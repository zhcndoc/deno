# Deno Documentation - Full Content

> This document contains the full content of the Deno documentation website.

# 压缩响应体

URL: https://docs.deno.com/deploy/api/compression


压缩响应体以节省带宽是一种常见做法。为了减轻您的负担，我们将此功能直接构建到 Deploy 中。

Deno Deploy 支持 brotli 和 gzip 压缩。当满足以下条件时，将应用压缩。

1. 对您的部署的请求具有 [`Accept-Encoding`][accept-encoding] 头，设置为 `br` (brotli) 或 `gzip`。
2. 您的部署的响应包含 [`Content-Type`][content-type] 头。
3. 提供的内容类型是可压缩的；我们使用 [这个数据库](https://github.com/jshttp/mime-db/blob/master/db.json) 来确定该内容类型是否可压缩。
4. 响应体大小大于 20 字节。

当 Deploy 压缩响应体时，它将根据所使用的压缩算法将 `Content-Encoding: gzip` 或 `Content-Encoding: br` 头设置到响应中。

### 何时跳过压缩？

Deno Deploy 在以下情况下跳过压缩：

- 响应具有 [`Content-Encoding`][content-encoding] 头。
- 响应具有 [`Content-Range`][content-range] 头。
- 响应的 [`Cache-Control`][cache-control] 头具有 [`no-transform`][no-transform] 值（例如，`cache-control: public, no-transform`）。

### 我的 `Etag` 头会发生什么？

当您设置响应的 Etag 头时，如果我们对您的响应体应用了压缩，我们会将头的值转换为弱 Etag。如果它已经是弱 Etag，我们不会修改该头。

[accept-encoding]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding
[cache-control]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control
[content-encoding]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Encoding
[content-type]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type
[no-transform]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#other
[content-range]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Range

---

# 动态导入

URL: https://docs.deno.com/deploy/api/dynamic-import


Deno Deploy 支持 [动态导入] ，但有一些限制。本文概述了这些限制。

### 规范符必须是静态确定的字符串字面量

在普通的动态导入中，规范符不需要在构建时确定。因此以下所有形式都是有效的：

```ts title="Deno CLI 中有效的动态导入"
// 1. 静态确定的字符串字面量
await import("jsr:@std/assert");

// 2. 静态确定，但通过变量
const specifier = "jsr:@std/assert";
await import(specifier);

// 3. 静态确定，但模板字面量
const stdModuleName = "path";
await import(`jsr:@std/${stdModuleName}`);

// 4. 动态确定
const rand = Math.random();
const mod = rand < 0.5 ? "npm:cowsay" : "npm:node-emoji";
await import(mod);
```

然而，在 Deno Deploy 中，规范符必须是没有字符串插值的字符串字面量。因此在上述三个例子中，只有第一个在 Deno Deploy 中有效。

```ts title="仅静态字符串字面量在 Deno Deploy 中有效"
// 1. ✅ 在 Deno Deploy 中正常工作
await import("jsr:@std/assert");

// 2. ❌ 在 Deno Deploy 中不工作
// 因为传递给 `import` 的是一个变量
const specifier = "jsr:@std/streams";
await import(specifier);

// 3. ❌ 在 Deno Deploy 中不工作
// 因为这有一个插值
const stdModuleName = "path";
await import(`jsr:@std/${stdModuleName}`);

// 4. ❌ 在 Deno Deploy 中不工作
// 因为这是动态的
const rand = Math.random();
const mod = rand < 0.5 ? "npm:cowsay" : "npm:node-emoji";
await import(mod);
```

### 一个例外 - 动态规范符适用于同项目文件

如果目标文件（模块）包含在同一个项目中，动态确定的规范符是支持的。

```ts title="动态规范符适用于同项目中的文件"
// ✅ 在 Deno Deploy 中正常工作
await import("./my_module1.ts");

// ✅ 在 Deno Deploy 中正常工作
const rand = Math.random();
const modPath = rand < 0.5 ? "dir1/moduleA.ts" : "dir2/dir3/moduleB.ts";
await import(`./${modPath}`);
```

请注意，以 `./` 开头的模板字面量告诉模块解析器目标模块在同一个项目中。相反，如果规范符不以 `./` 开头，可能的目标模块将不会包含在生成的 [eszip] 中，这将导致动态导入在运行时失败，即使最终评估的规范符以 `./` 开头。

```ts
// ❌ 不工作，因为分析器无法静态确定此情况下的规范符是否以 `./` 开头。
// 与之前的例子相比，唯一的区别是是否在模板字面量中或在变量中放置 `./`。
const rand = Math.random();
const modPath = rand < 0.5 ? "./dir1/moduleA.ts" : "./dir2/dir3/moduleB.ts";
await import(modPath);
```

我们将考虑是否可以在未来放宽这一约束。

:::tip 什么是 eszip？

当您在 Deno Deploy 上进行新部署时，系统会分析您的代码，通过递归遍历构建模块图，并将所有依赖项打包到一个单独的文件中。我们称之为 [eszip](https://github.com/denoland/eszip)。由于其创建是完全静态完成的，因此 Deno Deploy 上的动态导入功能受到限制。

:::

### 数据 URL

[数据 URL] 可以用作传递给动态导入的规范符。

```ts title="静态数据 URL"
// ✅ 在 Deno Deploy 中正常工作
const { val } = await import(
  "data:text/javascript,export const val = 42;"
);
console.log(val); // -> 42
```

对于数据 URL，完全动态的数据是支持的。

```ts title="动态数据 URL"
function generateDynamicDataUrl() {
  const moduleStr = `export const val = ${Math.random()};`;
  return `data:text/javascript,${moduleStr}`;
}

// ✅ 在 Deno Deploy 中正常工作
const { val } = await import(generateDynamicDataUrl());
console.log(val); // -> 打印随机值
```

将此技术应用于从网络获取的 JavaScript 代码，您甚至可以模拟真正的动态导入：

```js title="external.js"
export const name = "external.js";
```

```ts title="从获取的源生成的动态数据 URL"
import { assert } from "jsr:@std/assert/assert";
const res = await fetch(
  "https://gist.githubusercontent.com/magurotuna/1cacb136f9fd6b786eb8bbad92c8e6d6/raw/56a96fd0d246fd3feabbeecea6ea1155bdf5f50d/external.js",
);
assert(res.ok);
const src = await res.text();
const dataUrl = `data:application/javascript,${src}`;

// ✅ 在 Deno Deploy 中正常工作
const { name } = await import(dataUrl);
console.log(`来自 ${name} 的问候`); // -> "来自 external.js 的问候"
```

然而，请注意传递给 `import` 的数据 URL 必须是 JavaScript；如果传递 TypeScript，将在运行时抛出 [TypeError]。

[动态导入]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import
[eszip]: https://github.com/denoland/eszip
[数据 URL]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
[TypeError]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError

---

# API 参考

URL: https://docs.deno.com/deploy/api/


这是 Deno Deploy 上可用的运行时 API 的参考。此 API 与标准 [运行时 API](/runtime/manual/runtime) 非常相似，但由于 Deno Deploy 是一个无服务器环境，某些 API 并不以相同的方式提供。

请使用文档的这一部分来探索 Deno Deploy 上可用的 API。

### Web APIs

- [`console`](https://developer.mozilla.org/zh-CN/docs/Web/API/console)
- [`atob`](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/atob)
- [`btoa`](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/btoa)
- [Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)
  - `fetch`
  - `Request`
  - `Response`
  - `URL`
  - `File`
  - `Blob`
- [TextEncoder](https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder)
- [TextDecoder](https://developer.mozilla.org/zh-CN/docs/Web/API/TextDecoder)
- [TextEncoderStream](https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoderStream)
- [TextDecoderStream](https://developer.mozilla.org/zh-CN/docs/Web/API/TextDecoderStream)
- [Performance](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)
- [Web Crypto API](https://developer.mozilla.org/zh-CN/docs/Web/API/Crypto)
  - `randomUUID()`
  - `getRandomValues()`
  - [SubtleCrypto](https://developer.mozilla.org/zh-CN/docs/Web/API/SubtleCrypto)
- [WebSocket API](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)
- [Timers](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
  (`setTimeout`, `clearTimeout`, 和 `setInterval`)
- [Streams API](https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API)
  - `ReadableStream`
  - `WritableStream`
  - `TransformStream`
- [URLPattern API](https://developer.mozilla.org/zh-CN/docs/Web/API/URLPattern)
- [Import Maps](https://docs.deno.com/runtime/manual/basics/import_maps/)
  - 注意：`import maps` 目前仅可以通过
    [deployctl](https://github.com/denoland/deployctl) 或
    [deployctl GitHub Action](https://github.com/denoland/deployctl/blob/main/action/README.md)
    工作流使用。

### Deno APIs

> 注意：仅提供 Deno 的稳定 API 在 Deploy 中。

- [`Deno.env`](https://docs.deno.com/api/deno/~/Deno.env) - 与
  环境变量（机密）进行交互。
  - `get(key: string): string | undefined` - 获取环境变量的值。
  - `toObject(): { [key: string]: string }` - 将所有环境变量作为对象获取。
- [`Deno.connect`](https://docs.deno.com/api/deno/~/Deno.connect) - 连接到
  TCP 套接字。
- [`Deno.connectTls`](https://docs.deno.com/api/deno/~/Deno.connectTls) -
  使用 TLS 连接到 TCP 套接字。
- [`Deno.startTls`](https://docs.deno.com/api/deno/~/Deno.startTls) - 从现有的 TCP 连接开始 TLS
  握手。
- [`Deno.resolveDns`](https://docs.deno.com/api/deno/~/Deno.resolveDns) - 进行
  DNS 查询。
- 文件系统 API
  - [`Deno.cwd`](https://docs.deno.com/api/deno/~/Deno.cwd) - 获取当前
    工作目录。
  - [`Deno.readDir`](https://docs.deno.com/api/deno/~/Deno.readDir) - 获取
    目录列表。
  - [`Deno.readFile`](https://docs.deno.com/api/deno/~/Deno.readFile) - 读取一个
    文件到内存中。
  - [`Deno.readTextFile`](https://docs.deno.com/api/deno/~/Deno.readTextFile) -
    读取一个文本文件到内存中。
  - [`Deno.open`](https://docs.deno.com/api/deno/~/Deno.open) - 打开一个文件以
    进行流式读取。
  - [`Deno.stat`](https://docs.deno.com/api/deno/~/Deno.stat) - 获取文件系统
    条目信息。
  - [`Deno.lstat`](https://docs.deno.com/api/deno/~/Deno.lstat) - 不跟随符号链接，
    获取文件系统条目信息。
  - [`Deno.realPath`](https://docs.deno.com/api/deno/~/Deno.realPath) - 在解析符号链接后获取
    文件的真实路径。
  - [`Deno.readLink`](https://docs.deno.com/api/deno/~/Deno.readLink) - 获取给定符号链接的
    目标路径。

## 未来支持

在未来，这些 API 也将被添加：

- [Cache API](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache)
- UDP API：
  - `Deno.connectDatagram` 用于出站的 UDP 套接字。
- 使用 `Deno.createHttpClient` 来定制 `fetch` 选项。

## 限制

与 Deno CLI 一样，我们不按 ECMA Script 附录 B 中的规定实现 `__proto__` 对象字段。

---

# BroadcastChannel

URL: https://docs.deno.com/deploy/api/runtime-broadcast-channel


在 Deno Deploy 中，代码在全球不同的数据中心运行，以减少延迟，能够在离客户端最近的数据中心处理请求。在浏览器中，[`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API) API 允许相同源的不同标签页交换信息。在 Deno Deploy 中，BroadcastChannel API 提供了一个通信机制，用于不同实例之间的消息传递；这是一个简单的消息总线，连接全球各地的 Deploy 实例。

## 构造函数

`BroadcastChannel()` 构造函数创建一个新的 `BroadcastChannel` 实例，并连接到（或创建）提供的通道。

```ts
let channel = new BroadcastChannel(channelName);
```

#### 参数

| 名称        | 类型     | 描述                                                         |
| ----------- | -------- | ------------------------------------------------------------ |
| channelName | `string` | 用于基础广播通道连接的名称。                                |

构造函数的返回类型是一个 `BroadcastChannel` 实例。

## 属性

| 名称             | 类型                   | 描述                                                                                                  |
| ---------------- | ---------------------- | ----------------------------------------------------------------------------------------------------- |
| `name`           | `string`               | 基础广播通道的名称。                                                                                  |
| `onmessage`      | `function` (或 `null`) | 当通道接收到新消息时执行的函数 ([`MessageEvent`][messageevent])。                                   |
| `onmessageerror` | `function` (或 `null`) | 当到达的消息无法反序列化为 JavaScript 数据结构时执行的函数。                                       |

## 方法

| 名称                   | 描述                                                                                                                        |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `close()`              | 关闭与基础通道的连接。关闭后，您将无法再向通道发送消息。                                                              |
| `postMessage(message)` | 向基础通道发送消息。消息可以是字符串、对象字面量、数字或任何类型的 [`Object`][object]。                               |

`BroadcastChannel` 继承自 [`EventTarget`][eventtarget]，这使您可以在 `BroadcastChannel` 实例上使用 `EventTarget` 的方法，如 `addEventListener` 和 `removeEventListener`。

## 示例：跨实例更新内存缓存

像 `BroadcastChannel` 这样启用的消息总线的一个用例是，在跨网络不同数据中心运行的隔离体之间更新数据的内存缓存。在下面的示例中，我们展示了如何配置一个简单的服务器，使用 `BroadcastChannel` 在所有运行的服务器实例之间同步状态。

```ts
import { Hono } from "jsr:@hono/hono";

// 内存消息缓存
const messages = [];

// 所有隔离体使用的 BroadcastChannel
const channel = new BroadcastChannel("all_messages");

// 当其他实例发送新消息时，将其加入缓存
channel.onmessage = (event: MessageEvent) => {
  messages.push(event.data);
};

// 创建一个服务器以添加和获取消息
const app = new Hono();

// 将消息添加到列表中
app.get("/send", (c) => {
  // 新消息通过包含 "message" 查询参数添加
  const message = c.req.query("message");
  if (message) {
    messages.push(message);
    channel.postMessage(message);
  }
  return c.redirect("/");
});

// 获取消息列表
app.get("/", (c) => {
  // 返回当前消息列表
  return c.json(messages);
});

Deno.serve(app.fetch);
```

您可以使用 [这个游乐场](https://dash.deno.com/playground/broadcast-channel-example) 在 Deno Deploy 上自行测试此示例。

[eventtarget]: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
[messageevent]: https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
[object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object

---

# HTTP 请求 (fetch)

URL: https://docs.deno.com/deploy/api/runtime-fetch


[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 允许您在 Deno Deploy 中发起外部 HTTP 请求。它是一个网络标准，并具有以下接口：

- `fetch()` - 允许您发起外部 HTTP 请求的方法
- [`Request`](./runtime-request) - 表示 fetch() 的请求资源
- [`Response`](./runtime-response) - 表示 fetch() 的响应资源
- [`Headers`](./runtime-headers) - 表示请求和响应的 HTTP 头部。

本页面展示了 fetch() 方法的使用示例。您可以点击上面的其他接口以了解更多信息。

Fetch 还支持从文件 URL 获取静态文件。有关静态文件的更多信息，请参阅 [文件系统 API 文档](./runtime-fs)。

## `fetch()`

`fetch()` 方法初始化对提供资源的网络请求，并返回一个在响应可用后解析的 Promise。

```ts
function fetch(
  resource: Request | string,
  init?: RequestInit,
): Promise<Response>;
```

#### 参数

| 名称     | 类型                                                          | 可选 | 描述                                                               |
| -------- | ------------------------------------------------------------- | ---- | ------------------------------------------------------------------ |
| resource | [`Request`](./runtime-request) <br/> [`USVString`][usvstring] | `false`  | 资源可以是请求对象或 URL 字符串。                                   |
| init     | [`RequestInit`](./runtime-request#requestinit)                | `true`   | init 对象允许您为请求应用可选参数。                               |

`fetch()` 的返回类型是一个解析为 [`Response`](./runtime-response) 的 Promise。

## 示例

下面的 Deno Deploy 脚本对每个传入的请求发起对 GitHub API 的 `fetch()` 请求，然后从处理函数返回该响应。

```ts
async function handler(req: Request): Promise<Response> {
  const resp = await fetch("https://api.github.com/users/denoland", {
    // 这里的 init 对象包含一个 headers 对象，其中包含指示我们接受的响应类型的头部。
    // 我们没有指定 method 字段，因为默认情况下 fetch 发起的是 GET 请求。
    headers: {
      accept: "application/json",
    },
  });
  return new Response(resp.body, {
    status: resp.status,
    headers: {
      "content-type": "application/json",
    },
  });
}

Deno.serve(handler);
```

[usvstring]: https://developer.mozilla.org/en-US/docs/Web/API/USVString

---

# 文件系统 API

URL: https://docs.deno.com/deploy/api/runtime-fs


Deno Deploy 支持 Deno 中可用的有限文件系统 API 集。这些文件系统 API 可以访问您部署中的静态文件。静态文件例如：

- 如果您通过 GitHub 集成进行部署，则为您的 GitHub 存储库中的文件。
- 在 playground 部署中的入口文件。

可用的 API 有：

- [Deno.cwd](#deno.cwd)
- [Deno.readDir](#deno.readdir)
- [Deno.readFile](#deno.readfile)
- [Deno.readTextFile](#deno.readtextfile)
- [Deno.open](#deno.open)
- [Deno.stat](#deno.stat)
- [Deno.lstat](#deno.lstat)
- [Deno.realPath](#deno.realpath)
- [Deno.readLink](#deno.readlink)

## Deno.cwd

`Deno.cwd()` 返回您部署的当前工作目录。它位于您部署根目录的根部。例如，如果您通过 GitHub 集成进行部署，则当前工作目录是您 GitHub 存储库的根部。

## Deno.readDir

`Deno.readDir()` 允许您列出目录的内容。

该函数与 [Deno](https://docs.deno.com/api/deno/~/Deno.readDir) 完全兼容。

```ts
function Deno.readDir(path: string | URL): AsyncIterable<DirEntry>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例列出目录的内容，并将此列表作为 JSON 对象返回到响应正文中。

```js
async function handler(_req) {
  // 列出位于存储库根目录中的 `blog` 目录中的文章。
  const posts = [];
  for await (const post of Deno.readDir(`./blog`)) {
    posts.push(post);
  }

  // 返回 JSON。
  return new Response(JSON.stringify(posts, null, 2), {
    headers: {
      "content-type": "application/json",
    },
  });
}

Deno.serve(handler);
```

## Deno.readFile

`Deno.readFile()` 允许您将文件完全读入内存。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.readFile) 类似，但目前不支持 [`ReadFileOptions`](https://docs.deno.com/api/deno/~/Deno.ReadFileOptions)。未来将添加支持。

```ts
function Deno.readFile(path: string | URL): Promise<Uint8Array>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例将文件内容读入内存作为字节数组，然后将其作为响应正文返回。

```js
async function handler(_req) {
  // 让我们读取位于存储库根目录中的 README.md 文件，以探索可用的方法。

  // 相对路径是相对于存储库的根部
  const readmeRelative = await Deno.readFile("./README.md");
  // 绝对路径。
  // 存储库的内容可以在 Deno.cwd() 下获得。
  const readmeAbsolute = await Deno.readFile(`${Deno.cwd()}/README.md`);
  // 文件 URL 也受到支持。
  const readmeFileUrl = await Deno.readFile(
    new URL(`file://${Deno.cwd()}/README.md`),
  );

  // 将 Uint8Array 解码为字符串。
  const readme = new TextDecoder().decode(readmeRelative);
  return new Response(readme);
}

Deno.serve(handler);
```

> 注意：要使用此功能，您必须将 GitHub 存储库链接到您的项目。

Deno Deploy 支持 `Deno.readFile` API 从文件系统中读取静态资源。这对于提供图像、样式表和 JavaScript 文件等静态资源非常有用。本指南演示了如何使用此功能。

假设在 GitHub 存储库中有以下文件结构：

```console
├── mod.ts
└── style.css
```

`mod.ts` 的内容：

```ts
async function handleRequest(request: Request): Promise<Response> {
  const { pathname } = new URL(request.url);

  // 服务器的工作方式：
  // 1. 针对特定资产的请求到达。
  // 2. 我们从文件系统中读取该资产。
  // 3. 我们将资产发送回客户端。

  // 检查请求是否是针对 style.css。
  if (pathname.startsWith("/style.css")) {
    // 从文件系统中读取 style.css 文件。
    const file = await Deno.readFile("./style.css");
    // 用 style.css 文件响应请求。
    return new Response(file, {
      headers: {
        "content-type": "text/css",
      },
    });
  }

  return new Response(
    `<html>
      <head>
        <link rel="stylesheet" href="style.css" />
      </head>
      <body>
        <h1>示例</h1>
      </body>
    </html>`,
    {
      headers: {
        "content-type": "text/html; charset=utf-8",
      },
    },
  );
}

Deno.serve(handleRequest);
```

提供给 [`Deno.readFile`](https://docs.deno.com/api/deno/~/Deno.readFile) API 的路径是相对于存储库的根部。您也可以指定绝对路径，前提是它们位于 `Deno.cwd` 内部。

## Deno.readTextFile

此函数类似于 [Deno.readFile](#Deno.readFile)，不同之处在于它将文件内容解码为 UTF-8 字符串。

```ts
function Deno.readTextFile(path: string | URL): Promise<string>
```

### 示例

此示例将文本文件读入内存，并将内容作为响应正文返回。

```js
async function handler(_req) {
  const readme = await Deno.readTextFile("./README.md");
  return new Response(readme);
}

Deno.serve(handler);
```

## Deno.open

`Deno.open()` 允许您打开一个文件，返回一个文件句柄。该文件句柄随后可用于读取文件的内容。有关文件句柄上可用方法的信息，请参见 [`Deno.File`](#deno.file)。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.open) 类似，但目前不支持 [`OpenOptions`](https://docs.deno.com/api/deno/~/Deno.OpenOptions)。未来将添加支持。

```ts
function Deno.open(path: string | URL): Promise<Deno.File>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例打开一个文件，并将内容作为响应主体进行流式传输。

```js
async function handler(_req) {
  // 打开位于存储库根部的 README.md 文件。
  const file = await Deno.open("./README.md");

  // 使用 `readable` 属性，这是一个 `ReadableStream`。这将在响应完成发送时自动关闭文件句柄。
  return new Response(file.readable);
}

Deno.serve(handler);
```

:::note

当您按如下所示迭代文件流时，文件描述符将在迭代结束时自动关闭。无需手动关闭文件描述符：`const iterator = fd.readable[Symbol.asyncIterator]();`

:::

## Deno.File

`Deno.File` 是通过 [`Deno.open()`](#deno.open) 返回的文件句柄。它可以用于使用 `read()` 方法读取文件的块。可以使用 `close()` 方法关闭文件句柄。

该接口与 [Deno](https://docs.deno.com/api/deno/~/Deno.File) 类似，但不支持写入文件或寻址。对后者的支持将在未来添加。

```ts
class File {
  readonly rid: number;

  close(): void;
  read(p: Uint8Array): Promise<number | null>;
}
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

## Deno.File#read()

read 方法用于读取文件的一块。它应传递一个缓冲区以读取数据。它返回读取的字节数或 `null`（如果已到达文件末尾）。

```ts
function read(p: Uint8Array): Promise<number | null>;
```

### Deno.File#close()

close 方法用于关闭文件句柄。关闭句柄将中断所有正在进行的读取。

```ts
function close(): void;
```

## Deno.stat

`Deno.stat()` 读取文件系统条目的元数据。它返回一个 [`Deno.FileInfo`](#fileinfo) 对象。符号链接会被跟随。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.stat) 相同。它不返回修改时间、访问时间或创建时间值。

```ts
function Deno.stat(path: string | URL): Promise<Deno.FileInfo>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例获取文件的大小，并将结果作为响应主体返回。

```js
async function handler(_req) {
  // 获取位于存储库根部的 README.md 的文件信息。
  const info = await Deno.stat("./README.md");

  // 获取文件的字节大小。
  const size = info.size;

  return new Response(`README.md 的大小为 ${size} 字节`);
}

Deno.serve(handler);
```

## Deno.lstat

`Deno.lstat()` 类似于 `Deno.stat()`，但它不跟随符号链接。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.lstat) 相同。它不返回修改时间、访问时间或创建时间值。

```ts
function Deno.lstat(path: string | URL): Promise<Deno.FileInfo>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

## Deno.FileInfo

`Deno.FileInfo` 接口用于表示文件系统条目的元数据。它是由 [`Deno.stat()`](#deno.stat) 和 [`Deno.lstat()`](#deno.lstat) 函数返回的。它可以表示文件、目录或符号链接。

在 Deno Deploy 中，仅有文件类型和大小属性可用。大小属性的行为与 Linux 上相同。

```ts
interface FileInfo {
  isDirectory: boolean;
  isFile: boolean;
  isSymlink: boolean;
  size: number;
}
```

## Deno.realPath

`Deno.realPath()` 返回解析后的绝对路径，经过符号链接的跟随。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.realPath) 相同。

```ts
function Deno.realPath(path: string | URL): Promise<string>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例调用 `Deno.realPath()` 获取存储库根部文件的绝对路径。结果作为响应正文返回。

```js
async function handler(_req) {
  const path = await Deno.realPath("./README.md");

  return new Response(`./README.md 的完全解析路径为 ${path}`);
}

Deno.serve(handler);
```

## Deno.readLink

`Deno.readLink()` 返回符号链接的目标路径。

该函数的定义与 [Deno](https://docs.deno.com/api/deno/~/Deno.readLink) 相同。

```ts
function Deno.readLink(path: string | URL): Promise<string>
```

路径可以是相对路径或绝对路径。它也可以是 `file:` URL。

### 示例

此示例调用 `Deno.readLink()` 获取存储库根部文件的绝对路径。结果作为响应正文返回。

```js
async function handler(_req) {
  const path = await Deno.readLink("./my_symlink");

  return new Response(`./my_symlink 的目标路径为 ${path}`);
}

Deno.serve(handler);
```

---

# HTTP 头

URL: https://docs.deno.com/deploy/api/runtime-headers


[Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) 接口是 Fetch API 的一部分。它允许你创建和操作 fetch() 请求和响应资源的 HTTP 头。

- [构造函数](#构造函数)
  - [参数](#参数)
- [方法](#方法)
- [示例](#示例)

## 构造函数

Header() 构造函数创建一个新的 `Header` 实例。

```ts
let headers = new Headers(init);
```

#### 参数

| 名称  | 类型                                    | 可选    | 描述                                                                                                 |
| ----- | --------------------------------------- | ------- | ---------------------------------------------------------------------------------------------------- |
| init  | `Headers` / `{ [key: string]: string }` | `true`  | init 选项允许你使用现有的 `Headers` 或对象字面量初始化头对象。                                      |

构造函数的返回类型是 `Headers` 实例。

## 方法

| 名称                                    | 描述                                                               |
| --------------------------------------- | ------------------------------------------------------------------ |
| `append(name: string, value: string)`  | 向 Headers 对象追加一个头部（覆盖现有的）。                         |
| `delete(name: string)`                  | 从 Headers 对象删除一个头部。                                     |
| `set(name: string, value: string)`      | 在 Headers 对象中创建一个新的头部。                               |
| `get(name: string)`                     | 获取 Headers 对象中头部的值。                                    |
| `has(name: string)`                     | 检查头部是否存在于 Headers 对象中。                               |
| `entries()`                             | 以键值对的形式获取头部。结果是可迭代的。                          |
| `keys()`                                | 获取 Headers 对象的所有键。结果是可迭代的。                       |

## 示例

```ts
// 从对象字面量创建一个新的头部对象。
const myHeaders = new Headers({
  accept: "application/json",
});

// 向头部对象添加一个头部。
myHeaders.append("user-agent", "Deno Deploy");

// 打印头部对象的头部。
for (const [key, value] of myHeaders.entries()) {
  console.log(key, value);
}

// 你可以将头部实例传递给 Response 或 Request 构造函数。
const request = new Request("https://api.github.com/users/denoland", {
  method: "POST",
  headers: myHeaders,
});
```

---

# Node.js 内置 API

URL: https://docs.deno.com/deploy/api/runtime-node


Deno Deploy 原生支持使用 `node:` 前缀导入内置的 Node.js 模块，如 `fs`、`path` 和 `http`。这使得原本为 Node.js 编写的代码可以在 Deno Deploy 中无须修改地运行。

以下是一个在 Deno Deploy 上运行的 Node.js HTTP 服务器示例：

```js
import { createServer } from "node:http";
import process from "node:process";

const server = createServer((req, res) => {
  const message = `Hello from ${process.env.DENO_REGION} at ${new Date()}`;
  res.end(message);
});

server.listen(8080);
```

_您可以在这里实时查看此示例：
https://dash.deno.com/playground/node-specifiers_

使用 `node:` 前缀时，Deno Deploy 的所有其他功能仍然可用。例如，您可以使用 `Deno.env` 访问环境变量，即使是在使用 Node.js 模块的情况下。您还可以像往常一样从外部 URL 导入其他 ESM 模块。

以下 Node.js 模块可用：

- `assert`
- `assert/strict`
- `async_hooks`
- `buffer`
- `child_process`
- `cluster`
- `console`
- `constants`
- `crypto`
- `dgram`
- `diagnostics_channel`
- `dns`
- `dns/promises`
- `domain`
- `events`
- `fs`
- `fs/promises`
- `http`
- `http2`
- `https`
- `module`
- `net`
- `os`
- `path`
- `path/posix`
- `path/win32`
- `perf_hooks`
- `process`
- `punycode`
- `querystring`
- `readline`
- `stream`
- `stream/consumers`
- `stream/promises`
- `stream/web`
- `string_decoder`
- `sys`
- `timers`
- `timers/promises`
- `tls`
- `tty`
- `url`
- `util`
- `util/types`
- `v8`
- `vm`
- `worker_threads`
- `zlib`

这些模块的行为在大多数情况下应与 Node.js 一致。由于 Deno Deploy 的沙箱行为，一些功能不可用：

- 使用 `child_process` 执行二进制文件
- 使用 `worker_threads` 生成工作线程
- 使用 `vm` 创建上下文并评估代码

> 注：Node.js 模块的仿真对于大多数用例来说是足够的，但
> 仍然不完美。如果您遇到任何问题，请
> [提出问题](https://github.com/denoland/deno)。

---

# HTTP 请求

URL: https://docs.deno.com/deploy/api/runtime-request


[请求](https://developer.mozilla.org/en-US/docs/Web/API/Request)接口是 Fetch API 的一部分，表示 fetch() 的请求。

- [构造函数](#constructor)
  - [参数](#parameters)
- [属性](#properties)
- [方法](#methods)
- [示例](#example)

## 构造函数

Request() 构造函数创建一个新的 Request 实例。

```ts
let request = new Request(resource, init);
```

#### 参数

| 名称     | 类型                          | 可选     | 描述                                                                     |
| -------- | ----------------------------- | -------- | ----------------------------------------------------------------------- |
| resource | `Request` 或 `USVString`      | `false`  | 资源可以是请求对象或 URL 字符串。                                        |
| init     | [`RequestInit`](#requestinit) | `true`   | init 对象允许您设置应用于请求的可选参数。                                  |

返回类型是一个 `Request` 实例。

##### `RequestInit`

| 名称                         | 类型                                                                                    | 默认值          | 描述                                                        |
| ---------------------------- | --------------------------------------------------------------------------------------- | -------------- | ----------------------------------------------------------- |
| [`method`][method]           | `string`                                                                                | `GET`          | 请求的方法。                                              |
| [`headers`][headers]         | `Headers` 或 `{ [key: string]: string }`                                                | 无             | 请求的头部。                                              |
| [`body`][body]               | `Blob`、`BufferSource`、`FormData`、`URLSearchParams`、`USVString` 或 `ReadableStream` | 无             | 请求的主体。                                              |
| [`cache`][cache]             | `string`                                                                                | 无             | 请求的缓存模式。                                          |
| [`credentials`][credentials] | `string`                                                                                | `same-origin`  | 请求的凭据模式。                                          |
| [`integrity`][integrity]     | `string`                                                                                | 无             | 请求主体的加密哈希。                                      |
| [`mode`][mode]               | `string`                                                                                | `cors`         | 您想使用的请求模式。                                      |
| [`redirect`][redirect]       | `string`                                                                                | `follow`       | 处理重定向的模式。                                        |
| [`referrer`][referrer]       | `string`                                                                                | `about:client` | 一个 `USVString`，指定 `no-referrer`、`client` 或一个 URL。 |

## 属性

| 名称                               | 类型                                       | 描述                                                                                                                        |
| ---------------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| [`cache`][cache]                   | `string`                                   | 缓存模式指示浏览器如何缓存请求（`default`、`no-cache` 等）。                                                              |
| [`credentials`][credentials]       | `string`                                   | 凭据（`omit`、`same-origin` 等）指示用户代理是否在请求的 CORs 情况下发送 cookies。                                         |
| [`destination`][destination]       | [`RequestDestination`][requestdestination] | 字符串指示所请求内容的类型。                                                                                                |
| [`body`][body]                     | [`ReadableStream`][readablestream]         | getter 提供请求主体内容的 `ReadableStream`。                                                                                |
| [`bodyUsed`][bodyused]             | `boolean`                                  | 指示主体内容是否已被读取。                                                                                                  |
| [`url`][url]                       | `USVString`                                | 请求的 URL。                                                                                                                |
| [`headers`][headers]               | [`Headers`](runtime-headers)               | 与请求相关联的头部。                                                                                                        |
| [`integrity`][integrity]           | `string`                                   | 请求主体的加密哈希。                                                                                                        |
| [`method`][method]                 | `string`                                   | 请求的方法（`POST`、`GET` 等）。                                                                                             |
| [`mode`][mode]                     | `string`                                   | 指示请求的模式（例如 `cors`）。                                                                                            |
| [`redirect`][redirect]             | `string`                                   | 处理重定向的模式。                                                                                                          |
| [`referrer`][referrer]             | `string`                                   | 请求的引荐来源。                                                                                                            |
| [`referrerPolicy`][referrerpolicy] | `string`                                   | 请求的引荐政策。                                                                                                            |

上述所有属性都是只读的。

## 方法

| 名称                           | 描述                                                                                     |
| ------------------------------ | ----------------------------------------------------------------------------------------- |
| [`arrayBuffer()`][arraybuffer] | 读取主体流直到完成并返回一个 `ArrayBuffer` 对象。                                        |
| [`blob()`][blob]               | 读取主体流直到完成并返回一个 `Blob` 对象。                                              |
| [`formData()`][formdata]       | 读取主体流直到完成并返回一个 `FormData` 对象。                                          |
| [`json()`][json]               | 读取主体流直到完成，将其解析为 JSON 并返回一个 JavaScript 对象。                       |
| [`text()`][text]               | 读取主体流直到完成并返回一个 USVString 对象（文本）。                                   |
| [`clone()`][clone]             | 克隆请求对象。                                                                          |

## 示例

```ts
function handler(_req) {
  // 创建一个 POST 请求
  const request = new Request("https://post.deno.dev", {
    method: "POST",
    body: JSON.stringify({
      message: "Hello world!",
    }),
    headers: {
      "content-type": "application/json",
    },
  });

  console.log(request.method); // POST
  console.log(request.headers.get("content-type")); // application/json

  return fetch(request);
}

Deno.serve(handler);
```

[cache]: https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
[credentials]: https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
[destination]: https://developer.mozilla.org/en-us/docs/web/api/request/destination
[requestdestination]: https://developer.mozilla.org/en-US/docs/Web/API/RequestDestination
[body]: https://developer.mozilla.org/en-US/docs/Web/API/Body/body
[bodyused]: https://developer.mozilla.org/en-US/docs/Web/API/Body/bodyUsed
[url]: https://developer.mozilla.org/en-US/docs/Web/API/Request/url
[headers]: https://developer.mozilla.org/en-US/docs/Web/API/Request/headers
[method]: https://developer.mozilla.org/en-US/docs/Web/API/Request/method
[integrity]: https://developer.mozilla.org/en-US/docs/Web/API/Request/integrity
[mode]: https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
[redirect]: https://developer.mozilla.org/en-US/docs/Web/API/Request/redirect
[referrer]: https://developer.mozilla.org/en-US/docs/Web/API/Request/referrer
[referrerpolicy]: https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerpolicy
[readablestream]: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
[arraybuffer]: https://developer.mozilla.org/en-US/docs/Web/API/Body/arrayBuffer
[blob]: https://developer.mozilla.org/en-US/docs/Web/API/Body/blob
[json]: https://developer.mozilla.org/en-US/docs/Web/API/Body/json
[text]: https://developer.mozilla.org/en-US/docs/Web/API/Body/text
[formdata]: https://developer.mozilla.org/en-US/docs/Web/API/Body/formdata
[clone]: https://developer.mozilla.org/en-US/docs/Web/API/Request/clone

---

# HTTP 响应

URL: https://docs.deno.com/deploy/api/runtime-response


[响应](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)
接口是 Fetch API 的一部分，表示 fetch() 的响应资源。

- [构造函数](#构造函数)
  - [参数](#参数)
- [属性](#属性)
- [方法](#方法)
- [示例](#示例)

## 构造函数

Response() 构造函数创建一个新的 Response 实例。

```ts
let response = new Response(body, init);
```

#### 参数

| 名称 | 类型                                                                                    | 可选 | 描述                                                                   |
| ---- | --------------------------------------------------------------------------------------- | ---- | ---------------------------------------------------------------------- |
| body | `Blob`，`BufferSource`，`FormData`，`ReadableStream`，`URLSearchParams` 或 `USVString` | `true` | 响应的主体。默认值为 `null`。                                           |
| init | `ResponseInit`                                                                          | `true` | 可选对象，允许设置响应的状态和头部信息。                             |

返回类型为一个 `Response` 实例。

##### `ResponseInit`

| 名称         | 类型                                                  | 可选 | 描述                                                      |
| ------------ | ----------------------------------------------------- | ---- | --------------------------------------------------------- |
| `status`     | `number`                                              | `true` | 响应的状态码。                                         |
| `statusText` | `string`                                              | `true` | 表示状态码的状态信息。                                    |
| `headers`    | `Headers` 或 `string[][]` 或 `Record<string, string>` | `false` | 响应的 HTTP 头信息。                                     |

## 属性

| 名称                       | 类型             | 只读 | 描述                                                        |
| -------------------------- | ---------------- | ---- | ----------------------------------------------------------- |
| [`body`][body]             | `ReadableStream` | `true` | getter 返回主体内容的 `ReadableStream`。                  |
| [`bodyUsed`][bodyused]     | `boolean`        | `true` | 表示主体内容是否已被读取。                                  |
| [`url`][url]               | `USVString`      | `true` | 响应的 URL。                                               |
| [`headers`][headers]       | `Headers`        | `true` | 与响应相关的头部信息。                                     |
| [`ok`][ok]                 | `boolean`        | `true` | 表示响应是否成功（状态码在 200-299 之间）。                |
| [`redirected`][redirected] | `boolean`        | `true` | 表示响应是否是重定向的结果。                                |
| [`status`][status]         | `number`         | `true` | 响应的状态码。                                            |
| [`statusText`][statustext] | `string`         | `true` | 响应的状态信息。                                          |
| [`type`][type]             | `string`         | `true` | 响应的类型。                                              |

## 方法

| 名称                                                 | 描述                                                                                    |
| ---------------------------------------------------- | --------------------------------------------------------------------------------------- |
| [`arrayBuffer()`][arraybuffer]                       | 读取主体流直到完成并返回一个 `ArrayBuffer` 对象。                                       |
| [`blob()`][blob]                                     | 读取主体流直到完成并返回一个 `Blob` 对象。                                             |
| [`formData()`][formdata]                             | 读取主体流直到完成并返回一个 `FormData` 对象。                                         |
| [`json()`][json]                                     | 读取主体流直到完成，将其解析为 JSON 并返回一个 JavaScript 对象。                       |
| [`text()`][text]                                     | 读取主体流直到完成并返回一个 USVString 对象（文本）。                                  |
| [`clone()`][clone]                                   | 克隆响应对象。                                                                         |
| [`error()`][error]                                   | 返回一个与网络错误相关的新响应对象。                                                  |
| [`redirect(url: string, status?: number)`][redirect] | 创建一个新的响应，重定向到提供的 URL。                                               |

## 示例

```ts
function handler(_req) {
  // 创建一个以 HTML 为主体的响应。
  const response = new Response("<html> Hello </html>", {
    status: 200,
    headers: {
      "content-type": "text/html",
    },
  });

  console.log(response.status); // 200
  console.log(response.headers.get("content-type")); // text/html

  return response;
}

Deno.serve(handler);
```

[clone]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/clone
[error]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/error
[redirect]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirect
[body]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/body
[bodyused]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/bodyUsed
[url]: https://developer.mozilla.org/zh-CN/docs/Web/API/Request/url
[headers]: https://developer.mozilla.org/zh-CN/docs/Web/API/Request/headers
[ok]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/ok
[redirected]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/redirected
[status]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/status
[statustext]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/statusText
[type]: https://developer.mozilla.org/zh-CN/docs/Web/API/Response/type
[method]: https://developer.mozilla.org/zh-CN/docs/Web/API/Request/method
[readablestream]: https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream
[arraybuffer]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/arrayBuffer
[blob]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/blob
[json]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json
[text]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/text
[formdata]: https://developer.mozilla.org/zh-CN/docs/Web/API/Body/formdata

---

# TCP 套接字和 TLS

URL: https://docs.deno.com/deploy/api/runtime-sockets


Deno Deploy 支持出站 TCP 和 TLS 连接。这些 API 允许您与 Deploy 一起使用如 PostgreSQL、SQLite、MongoDB 等数据库。

需要了解如何服务 TCP 的相关信息？请查阅 [`Deno.serve`](/api/deno/~/Deno.serve) 的文档，其中包括对 [TCP 选项](/api/deno/~/Deno.ServeTcpOptions) 的支持说明。

## `Deno.connect`

建立出站 TCP 连接。

函数定义与
[Deno](https://docs.deno.com/api/deno/~/Deno.connect) 相同，唯一的限制是
`transport` 选项只能为 `tcp`，并且 `hostname` 不能是 localhost 或为空。

```ts
function Deno.connect(options: ConnectOptions): Promise<Conn>
```

### 示例

```js
async function handler(_req) {
  // 与 example.com 建立 TCP 连接
  const connection = await Deno.connect({
    port: 80,
    hostname: "example.com",
  });

  // 发送原始 HTTP GET 请求。
  const request = new TextEncoder().encode(
    "GET / HTTP/1.1\nHost: example.com\r\n\r\n",
  );
  const _bytesWritten = await connection.write(request);

  // 从连接中读取 15 字节。
  const buffer = new Uint8Array(15);
  await connection.read(buffer);
  connection.close();

  // 将字节作为纯文本返回。
  return new Response(buffer, {
    headers: {
      "content-type": "text/plain;charset=utf-8",
    },
  });
}

Deno.serve(handler);
```

## `Deno.connectTls`

建立出站 TLS 连接。

函数定义与 
[Deno](https://docs.deno.com/api/deno/~/Deno.connectTls) 相同，唯一的限制是 `hostname` 不能是 localhost 或为空。

```ts
function Deno.connectTls(options: ConnectTlsOptions): Promise<Conn>
```

### 示例

```js
async function handler(_req) {
  // 与 example.com 建立 TLS 连接
  const connection = await Deno.connectTls({
    port: 443,
    hostname: "example.com",
  });

  // 发送原始 HTTP GET 请求。
  const request = new TextEncoder().encode(
    "GET / HTTP/1.1\nHost: example.com\r\n\r\n",
  );
  const _bytesWritten = await connection.write(request);

  // 从连接中读取 15 字节。
  const buffer = new Uint8Array(15);
  await connection.read(buffer);
  connection.close();

  // 将字节作为纯文本返回。
  return new Response(buffer, {
    headers: {
      "content-type": "text/plain;charset=utf-8",
    },
  });
}

Deno.serve(handler);
```

---

# Deno Deployᴱᴬ 更新日志

> 列出 Deno Deploy 早期访问版开发和演进中的显著进展

URL: https://docs.deno.com/deploy/early-access/changelog


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。正在寻找
Deploy Classic 文档？[请点击这里查看](/deploy/)。

:::

## 2025年8月27日

### 新功能

- 现在可以将 Deno KV 用于数据库集成：
  - 通过“数据库”标签页配置 Deno KV 数据库，并将其链接到应用或 playground。
  - 通过 `Deno.openKv()` 从代码访问 Deno KV 数据库。
  - 当前不支持 KV 队列、读复制、手动备份及选择主区域。
- playground 现在支持拖拽单个文件和文件夹。
- playground 文件浏览器现在支持文件的内联重命名和删除。
- 新增内置环境变量，用于检测 Deno Deploy EA、运行的应用和所属组织：
  `DENO_DEPLOY=1`、`DENO_DEPLOY_ORG_ID`、`DENO_DEPLOY_ORG_SLUG`、
  `DENO_DEPLOY_APP_ID`、`DENO_DEPLOY_APP_SLUG`、`DENO_DEPLOY_REVISION_ID`。
- 用户现在可以从账户页面创建个人访问令牌。
- Deno Deploy EA 仪表板已从 https://app.deno.com 迁移至 https://console.deno.com。所有现有 URL 会自动重定向至新地址。

### Bug 修复

- 在允许数据库实例链接到组织前，检查 Postgres 数据库实例是否支持数据库动态配置。
- 确保已删除的 Deno Deploy 应用在推送至之前关联的仓库时不会触发 GitHub 状态检查。
- playground HTTP 探索器在发送请求时正确带上设置的请求头。
- playground 不再因为顶层 `await` 报错。
- 现在可以向 Deno Deploy 应用添加名为 `GOOGLE_APPLICATION_CREDENTIALS` 的环境变量。
- 批量导入环境变量时，正确将它们导入到对应应用，而非错误地导入组织环境变量。
- 一些不支持 `using` 声明的 Next.js 版本现能正确构建。
- 构建步骤中的 `npm install` 现在更稳定，不会再因证书问题失败。

## 2025年7月23日

### 新功能

- 新增：Deno Deploy<sup>EA</sup> 应用支持数据库，允许您轻松连接和使用 Postgres 数据库。
  - 可在 AWS RDS、Neon、Supabase 或其他提供商上配置 Postgres 数据库实例，然后将其链接到您的 Deno Deploy<sup>EA</sup> 组织。
  - 将数据库实例分配给某个应用，使其在该应用环境中可用。
  - 每个时间线（生产环境、每个 git 分支及预览）拥有独立的数据库，使用单独的模式和数据，这样您可以在不影响生产数据的情况下测试迁移和更改。
  - 可以使用任何 Postgres 客户端库进行连接，包括 `npm:pg`、`npm:drizzle` 或 `npm:kysely`。
- 现在应用和 playground 支持重命名。注意，重命名后旧的 `deno.net` URLs 将不再可用，但自定义域名仍然可以使用。
- 现在应用和 playground 可以被删除。
- playground 新增 HTTP Explorer 标签页，允许您向 playground 服务的任意 URL 发起 HTTP 请求，这对于测试不提供网页的 API 或其他服务非常有用。
- 现在可通过点击文件夹名称旁的删除按钮删除 playground 文件浏览器中的整个文件夹。
- 现在支持将 zip 文件拖放至 playground 文件浏览器，自动上传 zip 文件中的所有文件。
- 可以在 playground 中启用保存时自动格式化，保存文件时自动格式化代码。

### Bug 修复

- 以 `DENO_` 前缀的环境变量如 `DENO_CONDITIONS`、`DENO_COMPAT` 和 `DENO_AUTH_TOKENS` 现在可以设置且不会出错。
- `DENO_REVISION_ID` 环境变量现已正确暴露给应用和 playground。
- 自定义域名分配抽屉中，已被其他应用或 playground 占用的自定义域名现显示为禁用状态。
- 监控页面上的网络使用图现在正确显示进出流量，之前显示的数据不正确。
- 新建组织时，首次构建会等待 `<org>.deno.net` 域名被配置完成后再进行路由步骤。
- 在 playground 中按 `Ctrl-S` / `Cmd-S` 会保存当前文件并触发构建，而不是打开浏览器保存对话框。
- 查看某些特定追踪时之前会导致追踪查看器卡死，现在能正确显示。

## 2025年7月9日

### 新功能

- 新增：Cloud Connect 允许您安全地连接 Deno Deploy<sup>EA</sup> 应用至 AWS 和 GCP，使您能够使用 AWS S3、Google Cloud Storage 等服务，无需管理凭据。
  - 这通过不存储任何长期有效的静态凭据实现，而是使用短期令牌和 OIDC（OpenID Connect）在 Deno Deploy<sup>EA</sup> 和云提供商之间建立信任关系。
  - 在应用设置页面或 playground 抽屉中提供设置流程，指引您将应用连接至 AWS 或 GCP。
  - 您可以使用标准的 AWS 和 GCP SDK 访问服务，无需重写代码以使用不同的 API。
  - [文档中了解更多。](https://docs.deno.com/deploy/early-access/reference/cloud-connections/)
- 应用的监控页面现在展示更多指标，包括 V8 内存指标（如堆大小和垃圾回收统计）以及进程级指标（如 CPU 使用率和整体内存使用）。
- 组织概览新增“监控”标签页，展示组织内所有应用的整体指标，包括请求数量、CPU 使用率和内存使用。
- 您现在可以通过编辑 playground 预览 iframe 上方显示的“地址栏”来修改预览的 URL。
- 当环境变量键名包含 `SECRET`、`KEY`、`TOKEN`、`PRIVATE` 或 `PASSWORD` 时，默认环境变量为机密，您仍可手动切换为纯文本。
- 环境变量值的最大长度限制由 1024 字符提升至 4096 字符。

### Bug 修复

- playground 不再在尝试部署空文件时卡死。
- playground 抽屉调整大小更可靠，尤其是在某些抽屉已折叠时。
- 构建时间显著缩短，尤其对大型项目。之前超过 10 秒的“预热”和“路由”步骤通常现在不到 1 秒。
- 构建过程中的“排队”和“路由”步骤可以取消。
- 组织创建页面现能正确显示组织别名是否已被占用，提交表单前即提示。
- `npm install` 现在可以正常安装 `esbuild`，之前会报通用错误。

## 2025年6月24日

### 新功能

- playground 现在支持实时日志和追踪面板
  - 显示当前修订在过去一小时内的日志和追踪
  - 日志和追踪可过滤，与专用观察页面类似
- 框架自动检测支持更多项目，包含许多基于 Vite 的项目
- 组织下拉菜单中，当前选中的组织高亮更明显

### Bug 修复

- 监控概览中的小面积图形现正常工作
- 错误率指标正常显示
- 由 GitHub 触发的构建不再重复运行
- Next.js 构建在较旧版本中更稳定

## 2025年6月12日

### 新功能

- Deno Deploy<sup>EA</sup> 现支持 playground！
  - playground 可在组织概览的 playgrounds 标签页中创建和访问
  - playground 支持多文件与构建步骤
  - playground 界面提供已部署应用的预览 iframe
  - 目前提供三种模板：hello world、Next.js 与 Hono
- 移动设备新增浮动导航栏，不会遮挡页面内容

## 2025年6月9日

### 新功能

- Deno Deploy<sup>EA</sup> 拥有了新徽标！
- 任何人均可在 [dash.deno.com](https://dash.deno.com/account#early-access) 注册加入早期访问计划
- 构建相关
  - 构建存储空间上限由 2 GB 提升至 8 GB
  - 构建可使用组织或应用设置中配置的环境变量和密钥（位于新“构建”上下文中）
  - 构建最大运行时间设定为 5 分钟
- 监控页面经过全面重构，图表渲染重新编写：
  - 拖拽图表可以缩放选中区域
  - 可显示更多数据，页面加载不卡顿
  - 工具提示跟随鼠标指针，并新增十字线以便精准分析
  - 字体大小和颜色改进，提升可读性

### Bug 修复

- 构建不再卡在待处理状态
- 仪表板页面加载速度显著提升
- 追踪中带有未导出父级的跨度可以正确显示
- 切换时间范围时监控页面正常刷新
- 遥测搜索栏的“清除搜索”按钮正常工作
- 旧版 Next.js 版本（如 Next.js 13）现在能正确构建
- 环境变量抽屉现已全局应用，修复了多个同名环境变量不同上下文冲突的问题
- 构建器中使用绝对路径运行 `node <path>` 不再失败
- 构建器中提供 `npx`
- Astro 构建不再偶发因 `--unstable-vsock` 错误失败
- Svelte 明确指定使用 `@deno/svelte-adapter` 时能正确部署

## 2025年5月26日

### 新功能

- 现在手动触发构建时可选择部署分支
- 支持部署 Astro 静态站点，无需手动安装 Deno 适配器
- 提供了[参考文档](https://docs.deno.com/deploy/early-access/)，方便查阅

### Bug 修复

- 使用 `npm` 作为包管理器时，SvelteKit 自动检测正常工作
- 预热阶段不再随机发送 POST 请求至您的应用
- 访问带尾部斜杠的页面不再导致 404
- 抽屉不会因点击内部、拖动背景并释放而关闭

## 2025年5月22日

### 新功能

- 现在可以在创建应用时通过粘贴 `.env` 文件批量导入环境变量，位于环境变量抽屉中
- SvelteKit 现可开箱即用，无需手动安装 Deno 适配器
- 新增针对 Lume 静态站点生成器的预设

### Bug 修复

- 环境变量在时间线页面现正确显示
- 生产时间线页面现在正确显示所有构建历史
- console.deno.com 在旧版 Firefox 上能正常使用
- console.deno.com 各页面标题现反映当前所在页面
- “申请证书”按钮在 DNS 验证失败后不会再卡死
- 曾申请证书或绑定过应用的域名现在可以删除

---

# 入门指南

> 逐步指南，帮助您创建和配置您的第一个 Deno Deploy 早期访问应用程序，包括组织设置、构建配置、环境变量和部署监控。

URL: https://docs.deno.com/deploy/early-access/getting_started


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 文档？[点击这里查看](/deploy/)。

:::

## 创建组织

Deno Deploy<sup>EA</sup> 终将取代 Deno Deploy Classic。在此之前，两个系统将同时可用。通过为 Deploy<sup>EA</sup> 创建组织，您可以在不干扰已经使用 Deploy Classic 的项目的情况下，探索 Deploy<sup>EA</sup>。

开始使用 Deno Deploy<sup>EA</sup>：

1. 访问 [console.deno.com](http://console.deno.com)
2. 创建组织：

![Deno Deploy<sup>EA</sup> 组织创建屏幕。](./images/create_org.png)

注意，您不能使用与 Deploy Classic 中已存在项目相同的 slug 来创建组织。组织名称和 slug 创建后不可更改。

## 创建应用

创建组织后，系统会跳转至组织应用页面，展示您所有的应用，并可访问组织设置及自定义域名。

要创建应用，请点击 `+ New App` 按钮：

![部署应用创建屏幕截图](./images/create_app.png)

应用是一个单一部署的 Web 服务，拥有构建配置、构建历史、环境变量、附加自定义域名、关联的 GitHub 仓库等。

## 选择仓库

1. 选择您的应用对应的 GitHub 仓库：

![部署组织选择屏幕截图](./images/select_org.png)

如果您的仓库未显示，点击 `Add another GitHub account` 或 `Configure GitHub App permissions` 按钮，授权 Deno Deploy GitHub 应用访问您的仓库。

> ⏳ 目前尚不支持 Mono-repos（应用位于仓库子目录中的多仓库结构）。

## 配置您的应用

Deno Deploy<sup>EA</sup> 会自动尝试检测您的应用类型并配置相应的构建设置。您可以在 `App Config` 框中查看检测到的配置：

![部署应用配置屏幕截图](./images/app_config.png)

要修改配置，请点击 `Edit build config`。

![部署构建配置屏幕截图](./images/build_config.png)

## 配置构建

在构建配置抽屉中，您可以自定义：

### 框架预设

选择您的框架，或者如果使用自定义配置，则选择 `No Preset`。

### 安装命令

安装依赖的命令（例如 `npm install`、`deno install`）。如果是没有 `package.json` 的 Deno 应用此项可留空。

### 构建命令

用于编译/打包应用的命令（例如 `next build`、`deno task build`）。如果您的应用不需要构建，可留空。

### 运行时配置

对于大多数框架，此处无需配置，Deno Deploy<sup>EA</sup> 会根据框架预设自动确定最优的运行时配置。若未配置框架，您可以在此选择应用是需要针对每个请求执行服务端代码的 `Dynamic` 应用（如 API 服务、服务端渲染应用等），还是仅由一组静态文件组成的 `Static` 应用。

### 动态入口文件

启动应用时应执行的 JavaScript 或 TypeScript 文件。这个路径应与您本地通过 `deno run` 或 `node` 启动应用时传入的路径相同，且相对于工作目录。

### 动态参数

启动时传递给应用的额外命令行参数（入口文件后），这些参数传递给应用而非 Deno 本身。

### 静态目录

工作目录中存放静态文件的目录，例如 `dist`、`_site` 或 `.output`。

### 单页应用模式

应用是否为单页应用（SPA），当静态目录中不存在路径对应文件时，是否应返回根目录 `index.html` 而非 404 页面。

关闭抽屉即保存设置。

### 环境变量

添加环境变量的方法：

1. 点击 `Add/Edit environment variables`
2. 点击抽屉中的 `+ Add variable`
3. 输入变量名称和数值
4. 选择其为普通变量还是密钥
5. 选择其可用的上下文环境：
   - **Production**：针对生产域名的请求
   - **Development**：针对预览/分支域名的请求
6. 点击 `Save` 以应用更改

![部署环境变量配置屏幕截图](./images/env_var.png)

## 构建并部署您的应用

1. 点击 `Create App` 创建应用并启动首次构建。
2. 通过实时日志查看构建进度：

![应用构建日志截图](./images/build_logs.png)

构建日志分为以下阶段：

- **Prepare（准备）**：克隆仓库并恢复缓存
- **Install（安装）**：执行安装命令和框架特定设置
- **Build（构建）**：执行构建命令并生成部署产物
- **Warm up（预热）**：测试部署，通过请求确认应用正常启动
- **Route（部署）**：将构建版本部署至全球节点

您可以通过界面左上角按钮取消构建，失败时也可从此处重新启动构建。

构建完成后，右上角显示预览 URL，下方列出构建所部署的所有时间线。

## 监控您的应用程序

部署完成后，您可以使用监控工具来观察您的应用：

### 日志

浏览应用日志，支持通过上下文、版本和文本内容筛选：

![日志页面截图](./images/logs.png)

使用搜索栏过滤日志（如 `context:production`、`revision:<id>`）。时间选择器调整日志显示区间。

当日志关联到追踪时，您会看到 “查看跟踪” 按钮，点击即可查看追踪详情。

### 跟踪

查看请求追踪及详细的时间信息：

![跟踪页面截图](./images/traces.png)

点击任意追踪打开带有瀑布流视图的追踪详情页，展示所有跨度信息：

![跟踪视图截图](./images/trace.png)

追踪视图包括：

- 跨度时间线及持续时长
- 跨度详情及属性
- 在跨度期间产生日志的信息

要保存环境变量，请点击保存按钮。您也可以重新打开抽屉编辑或删除已有环境变量。

您还可以在此页面编辑应用名称，选择应用服务的区域。

## 构建并部署您的应用（重复部分）

最后，您可以点击 `Create App` 按钮创建应用，系统将立即触发首次构建：

![应用构建日志截图](./images/build_logs.png)

构建页面实时显示多阶段的构建日志：

- **Prepare（准备）**：克隆 GitHub 仓库与恢复缓存
- **Install（安装）**：执行安装命令及框架预安装步骤
- **Build（构建）**：执行构建命令及框架预设操作，为部署生成产物
- **Warm up（预热）**：向部署预览 URL 发送请求，保证应用正常启动。此处显示的日志为运行时日志，不是构建日志。
- **Route（部署）**：Deno Deploy 将新版本推送到全球所有区域

左上角有取消构建按钮，失败时也可重新启动。

完成后右上角显示预览 URL，及构建版本所部署所有时间线（如 `Production` 或 `Git Branch`）。

您可查看构建触发方式：  
- `manual action` 表示手动触发  
- `GitHub repo` 表示通过 GitHub 集成触发

可通过预览 URL 或时间线列表中的其他 URL 访问您的应用。

## 监控您的应用程序（重复部分）

访问应用后，您可查看遥测信息，包括日志和追踪数据，通过左侧栏访问对应页面。

### 日志

![日志页面截图](./images/logs.png)

日志页面显示项目中的最近所有日志。默认显示生产和开发环境日志，可通过顶部筛选或搜索栏限制显示内容，例如输入 `context:production` 过滤生产环境日志，`revision:<id>` 过滤特定版本。

支持全文搜索，仅匹配日志中写入文本（不区分大小写）。

默认显示最近一小时日志，通过右上角时间选择器调整时间范围，时间戳显示按选择器时区。

日志行右侧出现“查看跟踪”按钮，点击后可查看该日志关联的追踪详情。

### 跟踪

![跟踪页面截图](./images/traces.png)

跟踪页面显示项目中的最新追踪，默认展示所有环境的追踪，通过顶部筛选和搜索限制显示范围，例如 `context:production` 仅显示生产环境追踪，`revision:<id>` 筛选特定版本。

列表包括所有传入 HTTP 请求追踪，显示请求路径和耗时（毫秒）。点击追踪项打开详情视图，显示包含的全部跨度和日志。

![跟踪视图截图](./images/trace.png)

每个跨度包括持续时间、名称、开始和结束时间，以及记录的属性。点击时间线上跨度即可在底部摘要面板查看详细信息。

对应跨度的日志内容显示在底部“日志”标签页，切换跨度时日志内容也会随之更新。

---

# 关于 Deno Deploy 早期访问

> Deno Deploy 早期访问功能指南、与 Deploy Classic 的比较及部署入门说明。

URL: https://docs.deno.com/deploy/early-access/


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 文档？[点击此处查看](/deploy/)。

:::

Deno Deploy 早期访问（Deno Deploy<sup>EA</sup>）是对原始 Deploy 的彻底重构，具有以下特点：

- 改进的 NPM 兼容性和 Web 框架支持
- 内置的 OpenTelemetry 集成
- 集成的构建系统
- 显著增强的基础设施

<a href="https://console.deno.com" class="docs-cta deploy-cta">前往 Deno
Deploy<sup>EA</sup> 控制面板</a>

Deno Deploy<sup>EA</sup> 配备了一个全新的控制面板，位于
[console.deno.com](https://console.deno.com)。在该控制面板中，您可以创建新的 Deno Deploy<sup>EA</sup> 组织，该组织包含 Deno Deploy<sup>EA</sup> 应用。

在同一组织内，您不能混合使用 Deno Deploy<sup>EA</sup> 应用和 Deploy Classic 项目。您可以通过控制面板左上角的组织选择器在不同组织间切换。

## 什么是 Deno Deploy<sup>EA</sup>？

Deno Deploy 是一个用于在云端（或自行托管的基础设施上）运行 JavaScript 和 TypeScript 应用的无服务器平台。它通过 GitHub 部署等集成方式，提供应用部署和运行的管理平面。

## 与 Deploy Classic 的比较

Deno Deploy<sup>EA</sup> 是对 Deploy Classic 的完全重新设计。它拥有全新的仪表板和执行环境，使用 Deno 2.0，功能远超 Deploy Classic。下表对比了两个版本的 Deno Deploy。

| 功能                            | Deno Deploy<sup>EA</sup>       | Deploy Classic                                                                                                                          |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| Web interface                   | console.deno.com               | dash.deno.com                                                                                                                           |
| Dark mode                       | ✅ 支持                       | ❌ 不支持                                                                                                                              |
| Builds                          | ✅ 完全集成                   | 🟠 运行于 GitHub Actions，无仪表盘实时日志，缓存需手动配置，修改配置需编辑 YAML 文件                                                     |
| Can run Deno apps               | ✅ 完全支持                   | 🟠 有限支持（无 FFI、子进程、写权限）                                                                                                  |
| Can run Node apps               | ✅ 完全支持                   | 🟠 有限支持（无 FFI、本地插件、子进程、写权限，且 NPM 兼容性较差）                                                                       |
| Can run Next.js/Astro/SvelteKit | ✅ 一流支持                   | 🟠 依赖框架，需手动配置                                                                                                                  |
| First class static sites        | ✅ 支持                       | ❌ 不支持                                                                                                                              |
| Environment Variables           | ✅ 不同的开发/生产环境变量    | 🟠 所有部署共用一套环境变量                                                                                                             |
| CDN caching                     | ✅ 支持                       | ❌ 不支持                                                                                                                              |
| Web Cache API                   | ✅ 支持                       | ✅ 支持                                                                                                                                |
| Databases                       | ✅ 支持                       | 🟠 仅 Deno KV                                                                                                                           |
| Queues                          | ❌ 不支持                    | ✅ 支持                                                                                                                                |
| Cron                            | ❌ 不支持                    | ✅ 支持                                                                                                                                |
| Deploy from GitHub              | ✅ 支持                       | ✅ 支持                                                                                                                                |
| Deploy from CLI                 | ✅ 支持                       | ✅ 支持                                                                                                                                |
| Instant Rollback                | ✅ 支持                       | ✅ 支持                                                                                                                                |
| Logs                            | ✅ 支持                       | ✅ 支持                                                                                                                                |
| Tracing                         | ✅ 支持                       | ❌ 不支持                                                                                                                              |
| Metrics                         | ✅ 支持                       | ❌ 不支持                                                                                                                              |
| OpenTelemetry export            | ⏳ 进行中                     | ❌ 不支持                                                                                                                              |
| Regions                         | 2                              | 6                                                                                                                                       |
| Self hostable regions           | ✅ 支持                       | ❌ 不支持                                                                                                                              |

## 如何访问 EA

要开始使用 Deno Deploy<sup>EA</sup>：

1. 访问 [console.deno.com](https://console.deno.com) 进入全新控制面板
2. 创建一个新的 Deno Deploy<sup>EA</sup> 组织
3. 在该组织中创建您的第一个应用
4. 从您的 GitHub 仓库或直接在控制面板中部署

有关详细的配置说明及框架专属指南，请参阅我们的参考文档。

---

# deploy/early-access/reference/accounts.md

> 关于用户账户、通过 GitHub 进行身份验证以及在 Deno Deploy 早期访问中管理您的个人资料的信息。

URL: https://docs.deno.com/deploy/early-access/reference/accounts


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想要查看 Deploy Classic 文档？[请点击这里](/deploy/)。

:::

Deno Deploy 账户与 GitHub 账户关联。您只能通过 GitHub 身份验证登录 Deno Deploy。

您的主要联系电子邮件地址和名称会从 GitHub 同步。您的用户名和电子邮件地址会在每次登录时更新。在 GitHub 上更改电子邮件、登录名或名称后，请重新登录以便在 Deno Deploy<sup>EA</sup> 控制面板中看到这些更改。

目前，只有注册早期访问计划的账户可以访问 Deno Deploy<sup>EA</sup>。要加入该计划，请访问
[Deploy Classic 中的账户设置](https://dash.deno.com/account#early-access) 并注册。要访问早期访问 Discord 频道，请通过同一早期访问设置将 Discord 账户连接到您的 Deno Deploy 账户。

---

# deploy/early-access/reference/apps.md

> Deno Deploy 早期访问中管理应用程序的指南，包括应用创建、配置、GitHub 集成和部署选项。

URL: https://docs.deno.com/deploy/early-access/reference/apps


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想查看 Deploy Classic 文档？[请点击这里](/deploy/)。

:::

应用程序是组织内提供流量服务的网络服务。每个应用程序包含一系列修订历史（之前的版本），通常对应于使用 GitHub 集成时的 Git 提交。

应用程序通过一个 slug 来标识，该 slug 必须在组织内唯一，并用于默认域名。

## 创建应用程序

创建应用程序步骤：

1. 在组织页面点击“+ 创建应用程序”按钮
2. 选择要部署的 GitHub 仓库
3. 配置应用程序 slug（名称）
4. 设置构建配置
5. 添加所需的环境变量

> ⚠️ 目前，应用程序必须在创建时关联一个 GitHub 仓库。

构建配置决定了应用在部署过程中的构建方式。每次向关联的仓库推送代码时，或手动点击“部署默认分支”时，都会自动触发构建。有关详细的构建配置信息，请参阅[构建文档](/deploy/early-access/reference/builds/)。

您可以在创建应用时通过点击“编辑环境变量”添加环境变量。更多关于环境变量的详情，请参见[环境变量与上下文](/deploy/early-access/reference/env-vars-and-contexts/)文档。

## 重命名应用程序

可以通过编辑应用设置页面上的应用 slug 来重命名应用程序。这将更新与应用关联的默认域名，因为它们基于应用 slug。新的 slug 必须在组织内唯一（即同一组织内的其他应用或游乐场中不能使用）。

:::warning

重命名后，之前指向该应用的所有 `deno.net` URL 将失效。

自定义域名将继续正常工作，因为它们不依赖于应用 slug。

:::

## 删除应用程序

可以在应用设置页面删除应用程序。此操作将从组织中删除该应用及其所有修订版本。所有现有部署将立即停止服务，且所有自定义域名关联将被移除。

删除后，该应用及其修订将不再可访问，也不再服务任何流量。通过 Deno Deploy UI 无法恢复已删除的应用。

:::info

误删应用？请在 30 天内联系 Deno 支持以恢复。

:::

## 限制

> ⚠️ 目前应用程序无法转移到其他组织。

## GitHub 集成

GitHub 集成支持从 GitHub 仓库自动部署应用。每次向仓库推送时，都会触发应用的新构建。根据提交的分支，构建将部署到不同的[时间线](/deploy/early-access/reference/timelines/)。

应用程序在创建时与 GitHub 仓库关联。但创建后也可以解除关联，并可选择关联新的 GitHub 仓库。此操作可以在应用设置页面完成。

GitHub 仓库下拉菜单仅显示已经通过 Deno Deploy GitHub 应用授权的账户。您可以通过点击用户或组织下拉菜单中的“+ 添加另一个 GitHub 账户”按钮，或在仓库下拉菜单中点击“配置 GitHub 应用权限”按钮，授权新的组织或仓库。此操作会重定向您到 GitHub，以授权 Deno Deploy GitHub 应用访问所选 GitHub 账户或组织。授权完成后，您将被重定向回应用设置页面，此时可以选择新授权的 GitHub 仓库。

---

# deploy/early-access/reference/builds.md

> Deno Deploy 早期访问版中的构建流程详细说明，涵盖构建触发方式、阶段、配置选项、缓存以及构建环境。

URL: https://docs.deno.com/deploy/early-access/reference/builds


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想查找 Deploy Classic 文档？[点击这里查看](/deploy/)。

:::

在 Deno Deploy<sup>EA</sup> 中，您应用程序代码的每个版本都被表示为一个修订（或构建）。当从 GitHub 部署时，修订通常与您仓库中的 git 提交一一对应。

## 构建触发

构建可以通过两种方式触发：

- **手动触发**：使用构建页面上的“部署默认分支”按钮，部署默认 git 分支（通常是 `main`）。下拉菜单允许您选择不同的分支。

- **自动触发**：当向与您的应用关联的 GitHub 仓库推送新的提交时。

## 构建阶段

一个修订在变为可用状态前会经历以下阶段：

1. **排队**：修订等待分配给构建器。
2. **准备**：构建器下载源代码并恢复可用的构建缓存。
3. **安装**：执行安装命令（如果指定），通常用来下载依赖。
4. **构建**：执行构建命令（如果指定），生成构建产物并上传到运行时基础设施。
5. **预热**：通过发起 `GET /` 请求测试应用是否能正确启动并处理 HTTP 请求。
6. **路由**：配置全局基础设施，将请求路由到基于时间线的新修订。

如果任何步骤失败，构建将进入“失败”状态并且不会接收流量。

构建日志会在构建过程中实时推送到仪表盘，构建完成后仍可在构建页面查看。

构建缓存通过重用在构建间未更改的文件来加快构建速度。对于框架预设和 `DENO_DIR` 依赖缓存，此过程是自动进行的。

您可以使用构建页面右上角的“取消”按钮取消正在运行的构建。构建会在运行 5 分钟后自动取消。

## 构建配置

构建配置定义了如何将源代码转换为可部署的产物。您可以在以下三处修改构建配置：

- 创建应用时点击“编辑构建配置”
- 在应用设置中点击构建配置部分的“编辑”
- 在失败构建页面的重试抽屉中

在创建应用时，如果您使用已识别的框架或常见构建配置，构建配置可能会自动从仓库中检测。

### 配置选项

- **框架预设**：针对支持的框架（如 Next.js 或 Fresh）做了优化的配置。[了解更多框架集成](./frameworks/)。
  
- **安装命令**：安装依赖的 shell 命令，如 `npm install` 或 `deno install`。

- **构建命令**：构建项目的 shell 命令，通常是 `package.json` 或 `deno.json` 中的任务，如 `deno task build` 或 `npm run build`。

- **运行时配置**：决定应用如何提供流量：
  - **动态**：用于通过服务器响应请求的应用（API 服务器、服务器渲染网站等）
    - **入口文件**：要执行的 JavaScript 或 TypeScript 文件
    - **参数**（可选）：传递给应用的命令行参数
  - **静态**：用于提供预渲染静态内容的静态网站
    - **目录**：包含静态资源的文件夹（如 `dist`、`.output`）
    - **单页应用模式**（可选）：对不匹配静态文件的路径返回 `index.html`，而不是 404 错误

## 构建环境

构建环境在 Linux 上运行，支持 x64 或 ARM64 架构。可用工具包括：

- `deno`（与运行时版本相同）
- `node`
- `npm`
- `npx`
- `yarn`（v1）
- `pnpm`
- `git`
- `tar`
- `gzip`

:::info

构建器内部所有 JavaScript 代码均使用 Deno 执行。

`node` 命令实际上是一个 shim，负责将 Node.js 的调用转换为 `deno run`。类似地，`npm`、`npx`、`yarn` 和 `pnpm` 也都是通过 Deno 而非 Node.js 运行。

:::

为“构建”上下文配置的环境变量在构建过程中可用，但来自“生产”或“开发”上下文的变量不可用。[了解更多关于环境变量](./env-vars-and-contexts/)。

构建器在构建期间可用的存储空间为 8 GB。

---

# deploy/early-access/reference/button.md

> 帮助用户快速轻松地克隆代码并通过点击按钮将其部署到 Deno Deploy

URL: https://docs.deno.com/deploy/early-access/reference/button


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 的文档？ [点击此处查看](/deploy/)。

:::

部署按钮为用户提供了一个快捷方式，基于托管在 Git 仓库中的现有代码，在 Deno Deploy 上创建并部署新应用程序。

它提供了一个直接进入 Deno Deploy 应用创建流程的链接，并根据提供的查询参数或指定源的 `deno.json` 文件中的值填充创建流程中的设置。

指定的仓库将被克隆到用户的 GitHub 账户，并设置为新项目的源。默认情况下，新仓库为公开，但如果需要也可以设置为私有。

## 示例

下面的部署按钮演示了基于一个简单入门项目创建新应用程序的过程

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/examples&path=hello-world)

## 创建并部署新应用程序

使用以下代码提供一个创建并部署新应用程序的按钮：

**Markdown**

```bash
[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=REPOSITORY_URL)
```

**HTML**

```bash
<a href="https://console.deno.com/new?clone=REPOSITORY_URL"><img src="https://deno.com/button" alt="Deploy on Deno"/></a>
```

**URL**

```bash
https://console.deno.com/new?clone=REPOSITORY_URL
```

### 参数

以下查询参数可用于配置部署按钮：

- `clone` — （必填）要克隆为新仓库并随后部署的源仓库 URL
- `path` — （可选）在源仓库中需要克隆的路径。提供此参数将创建一个以该目录为根的新仓库
- `install` — （可选）构建前执行的命令，用于安装依赖
- `build` — （可选）构建应用程序时执行的命令

---

# deploy/early-access/reference/caching.md

> Deno Deploy 早期访问中的 CDN 缓存功能概览，涵盖缓存配置、指令及最佳实践。

URL: https://docs.deno.com/deploy/early-access/reference/caching


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。正在寻找 Deploy Classic 的文档？[请点击这里查看](/deploy/)。

:::

Deno Deploy<sup>EA</sup> 内置了一个 CDN，可以缓存您应用程序的响应。这提升了以下内容的性能：

- 静态资源（图片、CSS、JavaScript 文件）
- 不频繁变化的 API 响应和服务器渲染页面

缓存默认对所有应用启用，但只有带有合适缓存头的响应才会被实际缓存。

Deno Deploy<sup>EA</sup> 与 Next.js 等流行框架集成，自动优化像增量静态再生（ISR）这样的功能的缓存。

CDN 缓存与版本和上下文绑定。当您部署新版本时，缓存会自动失效，确保用户始终看到最新版本的应用。注意，如果 `Cache-Control` 头允许，浏览器缓存仍可能提供较旧内容。

## 缓存资源

要缓存资源，请在响应中设置 `Cache-Control` 头。此标准 HTTP 头指示浏览器和 CDN 如何缓存您的内容。

### 支持的缓存指令

Deno Deploy<sup>EA</sup> 支持以下缓存指令：

| 指令                      | 描述                                                                                                                                                                   |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `max-age`                | 响应被 CDN 和浏览器认为是新鲜的最大时间（秒）。过期后，响应被视为陈旧，需要与服务器重新验证。                                                                             |
| `s-maxage`               | 响应被共享缓存（仅限 CDN，不包括浏览器）认为是新鲜的最大时间（秒）。过期后，响应需要与服务器重新验证。                                                                     |
| `stale-while-revalidate` | 在获取新鲜响应的后台过程中，可以提供陈旧响应的最大时间（秒）。                                                                                                         |
| `stale-if-error`         | 当服务器返回错误时，可以提供陈旧响应的最大时间（秒）。                                                                                                                 |
| `immutable`              | 表示响应永远不会改变，允许无限期缓存。适用于内容哈希的静态资源。                                                                                                         |
| `no-store`               | 禁止缓存响应。适用于绝不应缓存的动态内容。                                                                                                                           |
| `no-cache`               | 在从缓存提供响应前需重新向服务器进行验证。适用于频繁变化但可利用条件请求的内容。                                                                                         |

### 其他缓存头

- `Vary`：指定哪些请求头应当包含在缓存键中，基于这些请求头创建独立缓存版本。

- `Expires`：为响应设置绝对过期时间（作为 `max-age` 的替代）。适用于不会变化的文件，如图片或 CSS 文件。
- `no-store`：响应不应被缓存。适用于不应缓存的动态响应，如 API 响应或服务器渲染的页面。
- `no-cache`：响应在从缓存提供前应向服务器重新验证。适用于可能经常变化的动态响应。

`Vary` 头可用来指定哪些请求头应作为请求的缓存键的一部分。

`Expires` 头可用来指定响应的绝对过期时间。这是 `max-age` 指令的另一种选择。

---

# 为整个应用创建信任策略文件

URL: https://docs.deno.com/deploy/early-access/reference/cloud-connections


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找
部署经典版文档？[点此查看](/deploy/)。

:::

Deno Deploy<sup>EA</sup> 允许您连接到诸如 AWS 和 Google Cloud Platform（GCP）之类的云提供商，而无需手动管理静态凭据。这是通过使用 OpenID Connect (OIDC) 和身份联合来实现的。

## 工作原理

Deno Deploy<sup>EA</sup> 是一个 OIDC 提供者。每个运行中的 Deno Deploy<sup>EA</sup> 应用都可以被签发由 Deno Deploy<sup>EA</sup> 签名的短期有效 JWT 令牌。这些令牌包含关于该应用的信息，例如组织和应用的 ID 和别名、应用执行的上下文，以及运行的修订版本 ID。了解更多关于 [Deno Deploy<sup>EA</sup> 中的 OIDC](./oidc) 。

通过将这些令牌发送到 AWS 或 GCP，可以将它们兑换为短期有效的 AWS 或 GCP 凭据，从而访问云资源，例如 AWS S3 存储桶或 Google Cloud Spanner 实例。向 AWS 或 GCP 发送令牌时，云提供商会验证该令牌，检查它是否由 Deno Deploy<sup>EA</sup> 签发，且是否有效且允许特定应用和上下文访问云资源。

为了使 AWS 或 GCP 能够将 OIDC 令牌兑换为凭据，云提供商需要配置为信任 Deno Deploy<sup>EA</sup> 作为 OIDC 身份提供者，并需要创建 AWS IAM 角色或 GCP 服务账号，使其允许特定 Deno Deploy<sup>EA</sup> 应用将令牌兑换为凭据的操作。

## 设置 AWS

本指南包含三种设置 AWS 资源的指导。您可以使用任意一种方式完成 AWS 资源的设置。

- [在本地使用 `deno deploy setup-aws` 命令](#aws%3A-easy-setup-with-deno-deploy-setup-aws)
  （推荐）
- [使用 `aws` CLI](#setup-aws-cli)
- [使用 AWS 控制台](#setup-aws-console)
- [使用 Terraform](#setup-aws-terraform)

要在您的 AWS 账户中设置与 Deno Deploy<sup>EA</sup> 的 AWS 集成，需要创建以下资源：

- 一个
  [AWS IAM OIDC 身份提供者](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html)
  来信任 Deno Deploy<sup>EA</sup> 作为 OIDC 提供者。
  - OIDC 提供者 URL 为 `https://oidc.deno.com`。
  - 受众（客户端 ID）为 `sts.amazonaws.com`。
- 一个
  [AWS IAM 角色](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp_oidc.html)
  ，可使用 Deno Deploy<sup>EA</sup> 的 OIDC 令牌进行“切换”（登录）。
  - 角色的信任策略应允许 OIDC 提供者切换角色，例如：
    ```json
    {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Principal": {
            "Federated": "arn:aws:iam::<account-id>:oidc-provider/oidc.deno.com"
          },
          "Action": "sts:AssumeRoleWithWebIdentity",
          "Condition": {
            "StringEquals": {
              "oidc.deno.com:aud": "sts.amazonaws.com",
              "oidc.deno.com:sub": "deployment:<organization-slug>/<application-slug>/<context-name>"
            }
          }
        }
      ]
    }
    ```
  - 角色应拥有访问您想使用的 AWS 资源（如 S3 存储桶或 DynamoDB 表）的权限。

设置完 AWS 资源后，从应用设置中前往 AWS 云集成设置页面。在那里，您必须选择应可用云连接的上下文。

然后必须输入之前创建的 AWS IAM 角色的 ARN（亚马逊资源名称）。输入 ARN 后，可以点击“测试连接”按钮开始连接测试。连接测试会检查 AWS IAM 角色和 OIDC 提供者是否已正确配置，并且不会允许未授权的应用、组织或上下文访问。

测试连接成功后，即可保存云连接。

### 使用方法

在建立 AWS 与 Deno Deploy<sup>EA</sup> 之间的云连接后，您可以直接从应用代码访问 AWS 资源（如 S3），无需配置任何凭据。

AWS SDK v3 会自动按云连接配置使用凭据。以下是一个示例，展示如何从配置了 AWS 账户的 Deno Deploy<sup>EA</sup> 应用访问 S3 存储桶。

```ts
import { ListBucketsCommand, S3Client } from "@aws-sdk/client-s3";

const s3 = new S3Client({ region: "us-west-2" });

Deno.serve(() => {
  const { Buckets } = await s3.send(new ListBucketsCommand({}));
  return Response.json(Buckets);
});
```

## 设置 GCP

要在您的 GCP 账户中设置与 Deno Deploy<sup>EA</sup> 的集成，需要创建以下资源：

- 一个
  [工作负载身份池和工作负载身份提供者](https://cloud.google.com/iam/docs/workload-identity-federation-with-other-providers)
  ，信任 Deno Deploy<sup>EA</sup> 作为 OIDC 提供者。
  - OIDC 提供者 URL 为 `https://oidc.deno.com`。
  - 受众应为默认值（以 `https://iam.googleapis.com` 开头）。
  - 至少需设置以下属性映射：
    - `google.subject = assertion.sub`
    - `attribute.full_slug = assertion.org_slug + "/" + assertion.app_slug`
- 一个
  [服务账号](https://cloud.google.com/iam/docs/service-accounts-create)
  ，可用 OIDC 令牌“模拟”（登录）。
  - 来自工作负载身份池的主体或主体集合应拥有使用工作负载身份用户角色 (`roles/iam.workloadIdentityUser`) 访问该服务账号的权限。示例：
    - 应用中的特定上下文：
      `principal://iam.googleapis.com/projects/<PROJECT_NUMBER>/locations/global/workloadIdentityPools/oidc-deno-com/subject/deployment:<ORG_SLUG>/<APP_SLUG>/<CONTEXT_NAME>`
    - 应用中的所有上下文：
      `principalSet://iam.googleapis.com/projects/<PROJECT_NUMBER>/locations/global/workloadIdentityPools/oidc-deno-com/attribute.full_slug/<ORG_SLUG>/<APP_SLUG>`
  - 服务账号应拥有访问您想使用的 GCP 资源的权限，例如 Google Cloud Storage 存储桶。

本指南包含三种设置 GCP 资源的指导。您可以使用任意一种方式完成 GCP 资源的设置。

- [在本地使用 `deno deploy setup-gcp` 命令](#setup-gcp-easy)
  （推荐）
- [使用 `gcloud` CLI](#setup-gcp-cli)
- [使用 GCP 控制台](#setup-gcp-console)
- [使用 Terraform](#setup-gcp-terraform)

设置完 GCP 资源后，前往应用设置中的 GCP 云集成设置页面。在那里，您必须选择应可用云连接的上下文。

然后您必须输入工作负载身份提供者 ID，格式为
`projects/<PROJECT_NUMBER>/locations/global/workloadIdentityPools/oidc-deno-com/providers/oidc-deno-com`，
以及之前创建的 GCP 服务账号邮箱。输入邮箱后，点击“测试连接”按钮开始连接测试。连接测试会检查 GCP 服务账号和 OIDC 提供者是否已正确配置，并且不会允许未授权的应用、组织或上下文访问。

测试成功后，即可保存云连接。

### 使用方法

在建立 GCP 与 Deno Deploy<sup>EA</sup> 之间的云连接后，您可以直接从应用代码访问 GCP 资源（如 Cloud Storage），无需配置任何凭据。

Google Cloud SDK 会自动按云连接配置使用凭据。以下是一个示例，展示如何从配置了 GCP 账户的 Deno Deploy<sup>EA</sup> 应用访问 Cloud Storage 存储桶。

```ts
import { Storage } from "@google-cloud/storage";

const storage = new Storage();

Deno.serve(() => {
  const [buckets] = await storage.getBuckets();
  return Response.json(buckets);
});
```

## 删除云集成

您可以在云集成部分，点击特定云连接旁边的“删除”按钮来删除该云连接。

## 设置指南

### AWS：使用 `deno deploy setup-aws` 简单设置

有关如何使用 `deno deploy setup-aws` 命令设置 AWS 与 Deno Deploy<sup>EA</sup> 集成的说明，请参阅应用设置中的 AWS 云集成设置页面的说明。

### AWS：使用 `aws` CLI

您可以使用 AWS CLI 手动设置 AWS 资源。此方法要求已安装并配置 AWS CLI，且拥有创建 IAM 角色、OIDC 提供者和附加策略的权限。

#### 前提条件

- 已安装并配置 AWS CLI
- 拥有创建 IAM 角色、OIDC 提供者和附加策略的权限

#### 第 1 步：创建 OIDC 提供者

如果还未创建 OIDC 提供者，请运行：

```bash
aws iam create-open-id-connect-provider \
  --url https://oidc.deno.com \
  --client-id-list sts.amazonaws.com
```

#### 第 2 步：创建带信任策略的 IAM 角色

创建一个信任策略文件，允许您的 Deno Deploy<sup>EA</sup> 应用切换角色。您可以选择允许所有上下文访问，或者只允许特定上下文。

**针对应用中所有上下文：**

```bash
# 为整个应用创建信任策略文件
cat > trust-policy-all-contexts.json << EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::YOUR_ACCOUNT_ID:oidc-provider/oidc.deno.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringLike": {
          "oidc.deno.com:sub": "deployment:YOUR_ORG/YOUR_APP/*"
        }
      }
    }
  ]
}
EOF
```

**针对特定上下文：**

```bash
# 为特定上下文创建信任策略文件
cat > trust-policy-specific-contexts.json << EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::YOUR_ACCOUNT_ID:oidc-provider/oidc.deno.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "oidc.deno.com:sub": [
            "deployment:YOUR_ORG/YOUR_APP/production",
            "deployment:YOUR_ORG/YOUR_APP/staging"
          ]
        }
      }
    }
  ]
}
EOF
```

#### 第 3 步：创建 IAM 角色

使用相应的信任策略创建角色：

```bash
# 针对整个应用
aws iam create-role \
  --role-name DenoDeploy-YourOrg-YourApp \
  --assume-role-policy-document file://trust-policy-all-contexts.json

# 或针对特定上下文
aws iam create-role \
  --role-name DenoDeploy-YourOrg-YourApp \
  --assume-role-policy-document file://trust-policy-specific-contexts.json
```

#### 第 4 步：附加策略

附加所需策略，以授予应用访问 AWS 资源的权限：

```bash
aws iam attach-role-policy \
  --role-name DenoDeploy-YourOrg-YourApp \
  --policy-arn arn:aws:iam::aws:policy/POLICY_NAME
```

将 `POLICY_NAME` 替换为合适的 AWS 策略（例如 `AmazonS3ReadOnlyAccess`、`AmazonDynamoDBReadOnlyAccess` 等），根据您的需求选择。

完成上述步骤后，在 Deno Deploy<sup>EA</sup> 云连接配置中使用角色 ARN。

### AWS：使用 AWS 控制台

您也可以通过 AWS 管理控制台网页界面设置 AWS 资源，此方式提供了一个直观的配置方法。

#### 第 1 步：创建 OIDC 身份提供者

1. 进入 IAM 控制台 → 身份提供者
2. 点击“添加提供者”
3. 选择“OpenID Connect”
4. 填写提供者 URL：`https://oidc.deno.com`
5. 受众：`sts.amazonaws.com`
6. 点击“添加提供者”

#### 第 2 步：创建 IAM 角色

1. 进入 IAM 控制台 → 角色
2. 点击“创建角色”
3. 选择受信实体类型为 **Web 身份**
4. 选择刚才创建的 OIDC 提供者（`oidc.deno.com`）
5. 受众填写 `sts.amazonaws.com`

#### 第 3 步：配置信任策略条件

添加条件限制哪些 Deno Deploy<sup>EA</sup> 应用可切换此角色。选择一种方式：

**应用中所有上下文：**

- 条件键：`oidc.deno.com:sub`
- 操作符：`StringLike`
- 值：`deployment:YOUR_ORG/YOUR_APP/*`

**特定上下文：**

- 条件键：`oidc.deno.com:sub`
- 操作符：`StringEquals`
- 值：`deployment:YOUR_ORG/YOUR_APP/production`
- 对每个上下文（如 staging、development）添加额外条件

点击“下一步”继续。

#### 第 4 步：附加权限策略

1. 根据需求搜索并选择合适的策略：
   - S3 访问：`AmazonS3ReadOnlyAccess` 或 `AmazonS3FullAccess`
   - DynamoDB 访问：`AmazonDynamoDBReadOnlyAccess` 或 `AmazonDynamoDBFullAccess`
   - 其他服务：选择相应策略
2. 点击“下一步”

#### 第 5 步：命名并创建角色

1. 角色名：`DenoDeploy-YourOrg-YourApp`（替换为您的组织及应用名）
2. 说明：可选填写角色用途描述
3. 审核信任策略和权限
4. 点击“创建角色”

#### 第 6 步：复制角色 ARN

创建完成后：

1. 进入角色详情页
2. 复制角色 ARN（格式为 `arn:aws:iam::123456789012:role/DenoDeploy-YourOrg-YourApp`）
3. 在 Deno Deploy<sup>EA</sup> 云连接配置中使用该 ARN

### AWS：使用 Terraform

您可以使用 Terraform 编程方式创建所需的 AWS 资源。此方案适合基础设施即代码的工作流程。

#### Terraform 配置示例

创建一个 Terraform 配置文件，内容如下：

```hcl
# 变量定义
variable "org" {
  description = "Deno Deploy 组织名称"
  type        = string
}

variable "app" {
  description = "Deno Deploy 应用名称"
  type        = string
}

variable "contexts" {
  description = "允许的特定上下文列表（留空表示允许所有上下文）"
  type        = list(string)
  default     = []
}

# OIDC 提供者资源
resource "aws_iam_openid_connect_provider" "deno_deploy" {
  url = "https://oidc.deno.com"
  client_id_list = ["sts.amazonaws.com"]
}

# 根据上下文动态生成的 IAM 角色
resource "aws_iam_role" "deno_deploy_role" {
  name = "DenoDeploy-${var.org}-${var.app}"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = aws_iam_openid_connect_provider.deno_deploy.arn
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = length(var.contexts) > 0 ? {
          # 只允许特定上下文
          StringEquals = {
            "oidc.deno.com:sub" = [
              for context in var.contexts : "deployment:${var.org}/${var.app}/${context}"
            ]
          }
        } : {
          # 允许所有上下文（通配符）
          StringLike = {
            "oidc.deno.com:sub" = "deployment:${var.org}/${var.app}/*"
          }
        }
      }
    ]
  })
}

# 附加策略
resource "aws_iam_role_policy_attachment" "example" {
  role       = aws_iam_role.deno_deploy_role.name
  policy_arn = "arn:aws:iam::aws:policy/POLICY_NAME"
}

# 输出角色 ARN
output "role_arn" {
  value = aws_iam_role.deno_deploy_role.arn
}
```

#### 使用示例

**针对整个应用（所有上下文）访问：**

```hcl
module "deno_deploy_aws" {
  source = "./path-to-terraform-module"

  org      = "your-org"
  app      = "your-app"
  contexts = []  # 空表示所有上下文
}
```

**仅针对特定上下文：**

```hcl
module "deno_deploy_aws" {
  source = "./path-to-terraform-module"

  org      = "your-org"
  app      = "your-app"
  contexts = ["production", "staging"]
}
```

#### 应用配置

1. 初始化 Terraform：
   ```bash
   terraform init
   ```

2. 计划部署：
   ```bash
   terraform plan
   ```

3. 应用配置：
   ```bash
   terraform apply
   ```

应用完成后，Terraform 会输出角色 ARN，供您在 Deno Deploy<sup>EA</sup> 云连接配置中使用。

#### 自定义策略

将 `aws_iam_role_policy_attachment` 资源中的 `POLICY_NAME` 替换为适合您的 AWS 托管策略，或根据需求创建自定义策略。您可以通过创建多个策略附件资源添加多个策略。

### GCP：使用 `deno deploy setup-gcp` 简单设置

有关如何使用 `deno deploy setup-gcp` 命令设置 GCP 与 Deno Deploy<sup>EA</sup> 集成的说明，请参阅应用设置中的 Google 云集成设置页面的说明。

### GCP：使用 `gcloud` CLI

您可以使用 gcloud CLI 手动设置 GCP 资源。此方法需要安装并认证 gcloud CLI，且拥有创建工作负载身份池、服务账号和授予 IAM 角色的权限。

#### 前提条件

- 安装并认证 gcloud CLI
- 拥有创建工作负载身份池、服务账号和授予 IAM 角色权限
- 启用以下必需 API：
  - `iam.googleapis.com`
  - `iamcredentials.googleapis.com`
  - `sts.googleapis.com`

#### 第 1 步：启用必需 API

先为项目启用必需的 API：

```bash
gcloud services enable iam.googleapis.com
gcloud services enable iamcredentials.googleapis.com
gcloud services enable sts.googleapis.com
```

#### 第 2 步：创建工作负载身份池

创建工作负载身份池以管理外部身份：

```bash
gcloud iam workload-identity-pools create oidc-deno-com \
  --location=global \
  --display-name="Deno Deploy Workload Identity Pool"
```

#### 第 3 步：创建工作负载身份提供者

在工作负载身份池中配置 OIDC 提供者：

```bash
gcloud iam workload-identity-pools providers create-oidc oidc-deno-com \
  --workload-identity-pool=oidc-deno-com \
  --location=global \
  --issuer-uri=https://oidc.deno.com \
  --attribute-mapping="google.subject=assertion.sub,attribute.org_slug=assertion.org_slug,attribute.app_slug=assertion.app_slug,attribute.full_slug=assertion.org_slug+\"/\"+assertion.app_slug"
```

#### 第 4 步：创建服务账号

创建供您的 Deno Deploy<sup>EA</sup> 应用使用的服务账号：

```bash
gcloud iam service-accounts create deno-your-org-your-app \
  --display-name="Deno Deploy YourOrg/YourApp"
```

#### 第 5 步：配置工作负载身份绑定

获取项目编号，并配置工作负载身份绑定。可选择允许所有上下文访问或仅特定上下文访问。

```bash
# 获取项目编号
PROJECT_NUMBER=$(gcloud projects describe PROJECT_ID --format="value(projectNumber)")
```

**应用中所有上下文：**

```bash
gcloud iam service-accounts add-iam-policy-binding \
  deno-your-org-your-app@PROJECT_ID.iam.gserviceaccount.com \
  --role=roles/iam.workloadIdentityUser \
  --member="principalSet://iam.googleapis.com/projects/$PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/attribute.full_slug/YOUR_ORG/YOUR_APP"
```

**仅特定上下文：**

```bash
# 绑定到生产上下文
gcloud iam service-accounts add-iam-policy-binding \
  deno-your-org-your-app@PROJECT_ID.iam.gserviceaccount.com \
  --role=roles/iam.workloadIdentityUser \
  --member="principal://iam.googleapis.com/projects/$PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/subject/deployment:YOUR_ORG/YOUR_APP/production"

# 绑定到预发布上下文
gcloud iam service-accounts add-iam-policy-binding \
  deno-your-org-your-app@PROJECT_ID.iam.gserviceaccount.com \
  --role=roles/iam.workloadIdentityUser \
  --member="principal://iam.googleapis.com/projects/$PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/subject/deployment:YOUR_ORG/YOUR_APP/staging"

# 根据需要为每个特定上下文添加更多绑定
```

#### 第 6 步：授予服务账号角色

授予服务账号访问 GCP 资源所需的角色：

```bash
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:deno-your-org-your-app@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/ROLE_NAME"
```

将 `ROLE_NAME` 替换为适当的角色，例如：

- `roles/storage.objectViewer`（Cloud Storage 读取访问）
- `roles/storage.objectAdmin`（Cloud Storage 完全访问）
- `roles/cloudsql.client`（Cloud SQL 访问）
- 根据需求选择其他角色

#### 第 7 步：获取必要的值

设置完成后，您需获取两个值用于 Deno Deploy<sup>EA</sup> 配置：

1. **工作负载提供者 ID**：
   `projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/providers/oidc-deno-com`
2. **服务账号邮箱地址**：
   `deno-your-org-your-app@PROJECT_ID.iam.gserviceaccount.com`

将这些值用于 Deno Deploy<sup>EA</sup> 云连接配置。

### GCP：使用 GCP 控制台

您也可以通过 Google Cloud 控制台网页界面设置 GCP 资源，此方式提供工作负载身份联合和服务账号的可视化配置。

#### 第 1 步：启用必需 API

1. 进入 API 与服务 → 库
2. 搜索并启用以下 API：
   - “身份和访问管理 (IAM) API”
   - “IAM 服务账号凭证 API”
   - “安全令牌服务 API”

#### 第 2 步：创建工作负载身份池

1. 进入 IAM 与管理员 → 工作负载身份联合
2. 点击“创建池”
3. 填写：
   - 池名称：`Deno Deploy Workload Id Pool`
   - 池 ID：`oidc-deno-com`
4. 点击“继续”

#### 第 3 步：添加提供者到池中

1. 点击“添加提供者”
2. 选择提供者类型为 **OpenID Connect (OIDC)**
3. 填写：
   - 提供者名称：`Deno Deploy OIDC Provider`
   - 提供者 ID：`oidc-deno-com`
   - 签发者 URL：`https://oidc.deno.com`
4. 配置属性映射：
   - `google.subject` → `assertion.sub`
   - `attribute.org_slug` → `assertion.org_slug`
   - `attribute.app_slug` → `assertion.app_slug`
   - `attribute.full_slug` → `assertion.org_slug + "/" + assertion.app_slug`
5. 点击“保存”

#### 第 4 步：创建服务账号

1. 进入 IAM 与管理员 → 服务账号
2. 点击“创建服务账号”
3. 填写：
   - 服务账号名称：`deno-your-org-your-app`
   - 服务账号 ID：`deno-your-org-your-app`
   - 描述：`Deno Deploy 项目 your-org/your-app 的服务账号`
4. 点击“创建并继续”

#### 第 5 步：授予服务账号角色

1. 根据需要选择角色：
   - Cloud Storage：`Storage 对象查看者` 或 `Storage 管理员`
   - Cloud SQL：`Cloud SQL 客户端`
   - 其他服务：选择相关角色
2. 点击“继续”，然后“完成”

#### 第 6 步：配置工作负载身份绑定

1. 回到已创建的服务账号
2. 点击“有访问权限的主体”标签
3. 点击“授予访问权限”
4. 配置主体 - 选择一种方式：

   **应用中所有上下文：**
   - 新主体：
     `principalSet://iam.googleapis.com/projects/YOUR_PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/attribute.full_slug/YOUR_ORG/YOUR_APP`

   **仅特定上下文：**
   - 新主体：
     `principal://iam.googleapis.com/projects/YOUR_PROJECT_NUMBER/locations/global/workloadIdentityPools/oidc-deno-com/subject/deployment:YOUR_ORG/YOUR_APP/production`
   - 对每个上下文（如 staging 等）重复添加

5. 角色：**工作负载身份用户**
6. 点击“保存”

#### 第 7 步：获取必要的值

您需要两个值用于 Deno Deploy<sup>EA</sup> 配置：

1. **工作负载提供者 ID**：
   - 回到工作负载身份联合
   - 点击您的池，然后点击您的提供者
   - 复制提供者资源名称（完整路径，以 `projects/` 开头）
2. **服务账号邮箱**：在服务账号详情页复制

#### 第 8 步：验证配置

最终工作负载身份池概览应显示：

- 您的工作负载身份池与 OIDC 提供者
- 已连接的服务账号
- 已正确配置的绑定

在 Deno Deploy<sup>EA</sup> 云连接配置中使用服务账号邮箱和工作负载提供者 ID。

### GCP：使用 Terraform

您可以使用 Terraform 编程方式创建 GCP 所需的资源。此方案适合基础设施即代码的工作流程。

#### Terraform 配置示例

创建一个 Terraform 配置文件，内容如下：

```hcl
# 变量定义
variable "org" {
  description = "Deno Deploy 组织名称"
  type        = string
}

variable "app" {
  description = "Deno Deploy 应用名称"
  type        = string
}

variable "contexts" {
  description = "允许的特定上下文列表（留空表示允许所有上下文）"
  type        = list(string)
  default     = []
}

variable "project_id" {
  description = "GCP 项目 ID"
  type        = string
}

variable "roles" {
  description = "授予服务账号的 IAM 角色列表"
  type        = list(string)
  default     = []
}

# 项目信息数据源
data "google_project" "project" {
  project_id = var.project_id
}

# 工作负载身份池
resource "google_iam_workload_identity_pool" "deno_deploy" {
  workload_identity_pool_id = "oidc-deno-com"
  display_name              = "Deno Deploy Workload Id Pool"
}

# 工作负载身份提供者
resource "google_iam_workload_identity_pool_provider" "deno_deploy" {
  workload_identity_pool_id           = google_iam_workload_identity_pool.deno_deploy.workload_identity_pool_id
  workload_identity_pool_provider_id = "oidc-deno-com"
  display_name                       = "Deno Deploy OIDC Provider"

  attribute_mapping = {
    "google.subject"      = "assertion.sub"
    "attribute.org_slug"  = "assertion.org_slug"
    "attribute.app_slug"  = "assertion.app_slug"
    "attribute.full_slug" = "assertion.org_slug + \"/\" + assertion.app_slug"
  }

  oidc {
    issuer_uri = "https://oidc.deno.com"
  }
}

# 服务账号
resource "google_service_account" "deno_deploy" {
  account_id   = "deno-${var.org}-${var.app}"
  display_name = "Deno Deploy ${var.org}/${var.app}"
}

# 基于上下文动态配置的工作负载身份绑定
resource "google_service_account_iam_binding" "workload_identity" {
  service_account_id = google_service_account.deno_deploy.name
  role               = "roles/iam.workloadIdentityUser"

  members = length(var.contexts) > 0 ? [
    # 仅允许特定上下文
    for context in var.contexts :
    "principal://iam.googleapis.com/projects/${data.google_project.project.number}/locations/global/workloadIdentityPools/${google_iam_workload_identity_pool.deno_deploy.workload_identity_pool_id}/subject/deployment:${var.org}/${var.app}/${context}"
  ] : [
    # 允许所有上下文（使用属性映射）
    "principalSet://iam.googleapis.com/projects/${data.google_project.project.number}/locations/global/workloadIdentityPools/${google_iam_workload_identity_pool.deno_deploy.workload_identity_pool_id}/attribute.full_slug/${var.org}/${var.app}"
  ]
}

# 授予服务账号权限
resource "google_project_iam_member" "service_account_roles" {
  for_each = toset(var.roles)
  project  = var.project_id
  role     = each.value
  member   = "serviceAccount:${google_service_account.deno_deploy.email}"
}

# 输出工作负载提供者 ID
output "workload_provider_id" {
  value = "projects/${data.google_project.project.number}/locations/global/workloadIdentityPools/${google_iam_workload_identity_pool.deno_deploy.workload_identity_pool_id}/providers/${google_iam_workload_identity_pool_provider.deno_deploy.workload_identity_pool_provider_id}"
}

# 输出服务账号邮箱
output "service_account_email" {
  value = google_service_account.deno_deploy.email
}
```

#### 使用示例

**针对整个应用（所有上下文）访问：**

```hcl
module "deno_deploy_gcp" {
  source = "./path-to-terraform-module"

  org        = "your-org"
  app        = "your-app"
  project_id = "your-gcp-project-id"
  contexts   = []  # 空列表表示允许所有上下文
  roles      = [
    "roles/storage.objectViewer",
    "roles/cloudsql.client"
  ]
}
```

**仅针对特定上下文：**

```hcl
module "deno_deploy_gcp" {
  source = "./path-to-terraform-module"

  org        = "your-org"
  app        = "your-app"
  project_id = "your-gcp-project-id"
  contexts   = ["production", "staging"]
  roles      = [
    "roles/storage.objectAdmin",
    "roles/cloudsql.client"
  ]
}
```

#### 应用配置

1. 初始化 Terraform：
   ```bash
   terraform init
   ```

2. 计划部署：
   ```bash
   terraform plan
   ```

3. 应用配置：
   ```bash
   terraform apply
   ```

应用完成后，Terraform 会输出工作负载提供者 ID 和服务账号邮箱，供您在 Deno Deploy<sup>EA</sup> 云连接配置中使用。

#### 自定义角色

`roles` 变量接受一个 GCP IAM 角色列表。常见角色包括：

- `roles/storage.objectViewer` - Cloud Storage 读取权限
- `roles/storage.objectAdmin` - Cloud Storage 对象完全权限
- `roles/cloudsql.client` - Cloud SQL 访问权限
- `roles/secretmanager.secretAccessor` - Secret Manager 访问权限
- 也可指定自定义角色

---

# deploy/early-access/reference/databases.md

URL: https://docs.deno.com/deploy/early-access/reference/databases


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 文档？[请点击这里](/deploy/)。

:::

数据库功能允许您将应用程序连接到外部数据库服务器。当您为应用分配数据库时，Deno Deploy 会自动为每个部署环境（生产环境、Git 分支和预览时间线）配置独立的数据库。

您的代码会自动连接到每个环境对应的正确数据库，无需手动检测时间线或处理数据库名称。只需使用您喜爱的数据库驱动程序进行连接——Deno Deploy 会通过环境变量自动处理连接细节。

## 入门指南

### 添加数据库

导航到您的组织仪表板，然后点击导航栏中的“数据库”。点击“添加数据库”，选择您的数据库引擎——目前支持 Deno KV 和 PostgreSQL，未来将支持更多。

您可以手动输入连接详情，也可以粘贴连接字符串以自动填充表单。连接详情包括您的数据库服务器主机名、端口（PostgreSQL 通常为 5432）、用户名、密码，以及根据需要上传 SSL 证书。

保存前，使用“测试连接”按钮验证您的设置是否正确。解决任何连接问题，给您的数据库实例起一个易记的名称，然后点击“保存”创建它。

#### 使用连接字符串

您可以直接粘贴类似 `postgresql://username:password@hostname:port/database` 的连接字符串，自动填充表单字段，无需手动填写各项信息。

**常见格式：**

- PostgreSQL：`postgresql://user:pass@localhost:5432/dbname` 或 `postgres://user:pass@localhost:5432/dbname`

### 将应用连接到数据库

有了数据库实例后，您可以将其分配给您的应用。在数据库实例列表中，点击您数据库实例旁的“分配”，从下拉菜单选择应用。

Deno Deploy 会自动为每个时间线创建独立数据库：

- 生产部署使用 `{app-id}-production`
- Git 分支使用 `{app-id}--{branch-name}`
- 预览部署使用 `{app-id}-preview`

这确保您的生产数据在开发和测试期间保持安全。您可以监控配置过程，并观察状态变为“已连接”。如果出现错误，可以使用“修复”按钮重试。

## 在代码中使用数据库

### 零配置要求

为应用分配数据库后，从代码中连接数据库非常简单。您无需配置连接字符串、设置环境变量或管理凭证——Deno Deploy 自动处理所有这些。

只需照常使用您喜欢的数据库库，它会自动连接到对应您当前环境的正确数据库。

### 自动环境变量

Deno Deploy 会自动将标准数据库环境变量注入到您的应用运行时环境中。以 PostgreSQL 为例，包含 `PGHOST`、`PGPORT`、`PGDATABASE`（根据环境自动选择）、`PGUSER`、`PGPASSWORD` 和 `PGSSLMODE`。这些变量遵循标准规范，大多数数据库库都能自动检测并使用，无需额外配置。

### PostgreSQL 示例

以下是在 Deno Deploy 应用中连接 PostgreSQL 的示例：

```typescript
import { Pool } from "npm:pg";

// 无需配置——Deno Deploy 会自动处理
const pool = new Pool();

Deno.serve(() => {
  // 使用数据库
  const result = await pool.query("SELECT * FROM users WHERE id = $1", [123]);

  return new Response(JSON.stringify(result.rows), {
    headers: { "content-type": "application/json" },
  });
});
```

### 工作原理

Deno Deploy 会自动检测您的代码运行在哪个环境（生产、Git 分支或预览），然后选择对应的数据库。正确的连接详情被自动设置为环境变量，您的数据库库会读取这些标准环境变量。

您的代码在所有环境中以相同方式运行，但连接到不同数据库。相同的 `new Pool()` 代码会在生产环境连接到 `myappid-production`，在 Git 分支连接到 `myappid--branch-name`，在预览环境连接到 `myappid-preview`。

### 迁移和 schema 管理

每个环境拥有独立数据库，您可以在 Git 分支中安全测试迁移，而不会影响生产环境或其他分支的数据库。

```typescript
// 为当前环境的数据库运行迁移
import { Pool } from "npm:pg";

const pool = new Pool();

// 这会针对当前环境的正确数据库执行
await pool.query(`
  CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
  )
`);
```

### 本地开发

本地开发时，您可以使用本地 PostgreSQL 实例（通过包管理器安装 PostgreSQL 或从 postgresql.org 下载）或连接远程数据库服务器。

在项目根目录创建 `.env` 文件（如果不存在），并添加 PostgreSQL 连接详情：

```bash
PGHOST=localhost        # 或您的远程主机
PGPORT=5432
PGDATABASE=myapp_dev
PGUSER=myuser
PGPASSWORD=mypassword
PGSSLMODE=prefer        # 远程连接使用 `require`
```

然后使用 `--env` 标志运行应用，自动加载环境变量：

```bash
deno run --env --allow-all main.ts
```

您的应用代码保持不变——本地开发期间，它会自动使用这些环境变量连接到您选择的数据库。

## SSL 配置

所有数据库连接均使用 SSL 加密保障安全。差异主要来自于不同数据库提供商对证书的处理方式。

### 证书类型

**受信任的根 CA 证书：** 部分数据库提供商使用由受信任根证书颁发机构（如 Let's Encrypt 或 DigiCert）签发的证书，这类证书无需配置即可自动工作。

**私有根 CA 证书：** 部分提供商使用自签名证书或私有 CA，您需要上传用于签名数据库证书的 CA 证书。

### 证书配置

**受信任根 CA 的数据库：** 无需上传证书，SSL 连接自动工作。一些托管数据库服务属于此类。

**私有根 CA 的数据库：** AWS RDS 用户可点击“使用 AWS 证书包”自动配置证书，无需手动下载。其他提供商则需上传相应的 CA 证书。

### 常见提供商

**AWS RDS** 使用 AWS 自有的证书颁发机构（非公共信任）。点击“使用 AWS 证书包”即可自动配置，无需手动下载证书。

**Google Cloud SQL** 使用 Google 自有的证书颁发机构（非公共信任）。您需要上传 Google Cloud SQL CA 证书，可从 Google Cloud 控制台下载。

**自托管数据库** 如果使用自签名证书，需上传自定义 CA 证书；或者您可配置数据库使用受公共信任的 CA 证书。

## 数据库管理

### 查看数据库详情

点击任意数据库实例查看连接信息（主机名、端口、引擎类型）、已分配的应用、实例中创建的各个数据库，以及健康和连接状态。

### 数据库状态指示器

仪表板显示以下状态：

- **🟢 已连接** - 所有数据库均可用且正常
- **🟡 创建中** - 正在配置数据库
- **🔴 错误** - 某些数据库创建失败
- **⚪ 未分配** - 尚未有应用使用此数据库

### 管理应用分配

要将数据库分配给应用，点击数据库实例上的“分配”，从下拉列表选择应用并确认。要将应用从数据库中移除，进入数据库详情页，在“已分配应用”表格找到应用，点击旁边的“移除”。

### 编辑数据库设置

点击任意数据库实例旁的“编辑”来更新连接详情。保存前请测试连接确保正常。

## 支持的数据库引擎

**当前支持：** Deno KV 和 PostgreSQL 完全支持所有功能。

**即将支持：** MySQL、MongoDB、Redis 等将在未来版本中推出。

## 故障排除

### 连接问题

**“连接失败”错误** 通常表示：

- 主机名和端口错误
- 用户名或密码错误
- 数据库服务器未启动
- 网络连接问题

请确认所有连接详情且数据库服务器可访问。

**“权限被拒绝”错误** 表示数据库用户权限不足。确认用户具有所需权限，能创建数据库，并且可以从 Deno Deploy 服务器连接。

**SSL 连接问题** 可能因：

- 使用受信任根 CA，数据库未正确配置 SSL
- 使用私有根 CA，未上传正确的 CA 证书
- 数据库服务器不支持 SSL
- 证书已过期

请检查数据库服务器的 SSL 配置及证书有效性。

### 配置问题

**“数据库创建失败”** 通常表示：

- 用户缺少 CREATE 权限
- 磁盘空间不足
- 数据库名称冲突

请检查权限和服务器容量。

**“超时”错误** 可能是：

- Deno Deploy 与数据库服务器间网络连接问题
- 数据库服务响应缓慢

请检查服务器负载和性能。

**“错误”状态** 可通过：

- 点击“修复”按钮重试操作
- 查看数据库服务器日志获取详细信息

## 常见问题

**问：多个应用可以共享同一个数据库实例吗？**

答：可以！多个应用可分配到同一数据库实例，每个应用拥有独立的数据库隔离。

**问：移除应用分配会影响数据吗？**

答：不会。数据库仍然保留在您的服务器上，仅解除应用与数据库实例的连接。

**问：可以使用同一个数据库支持多个环境吗？**

答：默认情况下，每个环境（生产、分支、预览）有独立数据库以确保隔离及防止数据冲突。不过您可以通过数据库库的配置自定义连接数据库。

**问：如何直接访问我的数据库？**

答：您可以使用提供的连接信息直接连接至您的数据库服务器。数据库名称在 Deno Deploy 仪表板中可见。

**问：可以更改数据库连接信息吗？**

答：可以，点击数据库实例旁“编辑”更新连接信息。保存前请先测试确保连接正常。

**问：如何删除数据库实例？**

答：先移除所有应用分配，再点击数据库实例的“删除”。这只会从 Deno Deploy 移除连接，不会影响实际数据库服务器。

---

# deploy/early-access/reference/deno-kv.md

URL: https://docs.deno.com/deploy/early-access/reference/deno-kv


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 文档？[请点击这里查看](/deploy/)。

:::

[Deno KV] 在 Deno Deploy EA 中被支持作为 [databases] 功能的可能数据库引擎之一，除此之外还有 PostgreSQL 等。得益于 Deno Deploy EA 新增的 [timelines] 功能，您的应用现在可以完全控制所使用的 Deno KV 数据库（一个用于生产环境，每个 git 分支一个数据库等），确保数据在所有环境中的隔离与安全。

与其他数据库引擎一样，您的代码会自动连接到适用于每个环境的正确数据库，无需进行时间线检测或手动处理数据库名称。

## 入门指南

### 添加数据库

前往您的组织仪表板，点击导航栏中的“数据库”。点击“添加数据库”，选择 Deno KV 作为数据库引擎，提供一个便于识别的名称后保存。

### 将应用连接到数据库

与其他 [databases] 引擎一样，一旦有了数据库实例，您可以将其分配给应用。在数据库实例列表中，点击对应数据库实例旁的“分配”，然后从下拉菜单中选择应用。

Deno Deploy 会自动为每个时间线创建独立的数据库。这确保您的生产数据在开发和测试过程中保持安全。您可以监控配置过程，并观察状态变更为“已连接”。如果出现任何错误，可以使用“修复”按钮重试。

## 在代码中使用 Deno KV

### 零配置需求

将数据库分配给应用后，从代码中连接数据库非常简单。Deno Deploy 会根据查询的环境自动设置到正确数据库的连接。

### 示例

以下示例展示了如何在 Deno Deploy 应用中连接 Deno KV：

```typescript
const kv = await Deno.openKv();

Deno.serve(async () => {
  const res = await kv.get<number>(["requests"]);
  const requests = res.value + 1;
  await kv.set(["requests"], requests);
  return new Response(JSON.stringify(requests));
});
```

有关 Deno KV 及其功能的详细信息，请参阅 [Deno KV 文档][Deno KV]。

## 数据分布

Deno KV 数据库会在主要区域北弗吉尼亚（us-east4）的至少三个数据中心间进行复制。写操作一旦提交，其变更会在主要区域的多数数据中心中持久存储。目前尚不支持跨区域复制。

## 常见问题解答

**问：本地开发期间数据如何存储？**

在本地开发环境中，数据存储在内存中。使用 KV API 前无需创建或分配数据库，且您的 KV 代码可在不同环境中保持一致。

**问：移除应用分配后我的数据会怎样？**

数据库中的数据会保留在服务器上。若需恢复或删除这些数据库中的数据，请[联系 Deno 支持](../support)。

**问：我可以在多个环境中使用同一个数据库吗？**

目前不支持此功能。如果您对此用例感兴趣，请[联系 Deno 支持](../support)。

**问：如何删除数据库实例？**

在数据库实例列表中点击 Deno KV 记录旁的“删除”。不同于其他数据库引擎，此操作会删除所有现有的 Deno KV 数据库及其数据。请务必在操作前备份数据。

[Deno KV]: /kv/
[databases]: ./databases.md
[timelines]: ./timelines.md

---

# deploy/early-access/reference/domains.md

> Deno Deploy 早期访问中的域管理完整指南，包括组织域、自定义域、DNS 配置、TLS 证书和域分配。

URL: https://docs.deno.com/deploy/early-access/reference/domains


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想查看 Deploy Classic 的文档吗？[请点击这里](/deploy/)。

:::

每个组织都有一个默认域，用于该组织内部部署的所有应用。例如，一个标识为 `acme-inc` 的组织，其默认域为 `acme-inc.deno.net`。名为 `my-app` 的应用将自动获得生产域名 `my-app.acme-inc.deno.net`。

除了这些默认域之外，您还可以为应用添加自定义域。自定义域是您拥有并控制的域。要使用自定义域，您必须：

1. 拥有该域（已从域名注册商购买）
2. 能够编辑其 DNS 记录

自定义域属于某个组织，可以附加到该组织内的任何应用。

自定义域可以添加为：

- 基础域（例如，`example.com` 或特定子域）
- 通配符域（例如，`*.example.com`）

基础域仅适用于单一应用，而通配符域提供更灵活的使用方式。您可以：

- 将整个通配符域分配给一个应用（所有子域指向同一应用）
- 部分分配给多个应用（不同子域指向不同应用）

所有自定义域都需要有效的 TLS 证书。Deno Deploy<sup>EA</sup> 可以通过 Let's Encrypt 自动生成这些证书。

## 添加自定义域

1. 进入组织域页面（点击左上角的组织名称，然后切换到“域”标签）
2. 点击“添加域”
3. 输入您的域（例如 `example.com`）
4. 选择是仅添加该域还是同时包含通配符子域
5. 点击“添加域”

这将打开域配置抽屉。

### DNS 配置

域配置抽屉显示了所需的 DNS 记录，用于：

- 验证域所有权
- 生成 TLS 证书
- 将流量路由到 Deno Deploy<sup>EA</sup>

根据您的域名注册商支持的能力，有三种可能的配置方法：

#### ANAME/ALIAS 方法（首选）

如果您的注册商支持 `ANAME` 或 `ALIAS` 记录，这是最佳选择：

- 添加一个 `ANAME`/`ALIAS` 记录
- 添加一个用于验证的 `CNAME` 记录

#### CNAME 方法

适合子域，但不适用于根域（顶级域）：

- 添加两个 `CNAME` 记录
- 注意：此方法不允许在同一域上使用其他 DNS 记录（如 `MX` 记录）

#### A 记录方法

兼容性最强，但配置较复杂：

- 添加一个 `A` 记录
- 添加一个用于验证的 `CNAME` 记录

> 注意：当前 Deno Deploy<sup>EA</sup> 不支持 IPv6。使用 `ANAME/ALIAS` 或 `CNAME` 方法时，当支持 IPv6 时，您的域名将自动使用 IPv6。使用 `A` 方法时，将在需要添加 `AAAA` 记录时通过邮件通知您。

:::caution

当您使用 Cloudflare 作为 DNS 提供商时，**必须**禁用 `_acme-challenge` CNAME 记录的代理功能（即关闭橙色云图标），否则验证和证书发放会失败。

:::

### 验证

添加 DNS 记录后，Deno Deploy<sup>EA</sup> 将验证您的域所有权。此过程根据您的 DNS 提供商可能需要几分钟时间。您可以在验证期间保持域配置抽屉打开——验证完成后它会自动刷新。

您可以通过点击“生成证书”按钮手动触发验证。验证成功同时会启动 TLS 证书的生成。

### TLS 证书生成

域名验证后，点击“生成证书”按钮，通过 Let's Encrypt 生成 TLS 证书。这个过程最多需 90 秒钟。

生成后，您将看到证书的详细信息，包括到期时间和颁发时间。

证书会在接近到期时自动续签。您可以在域配置抽屉中查看当前证书状态。

## 将自定义域分配给应用

添加自定义域到组织后：

1. 进入组织域页面
2. 点击自定义域旁的“分配”按钮
3. 选择目标应用
4. 若使用通配符域，选择是附加基础域、通配符子域还是特定子域
5. 点击“分配域名”

## 从应用中撤销自定义域分配

1. 进入应用设置页面
2. 找到“自定义域”部分
3. 点击要撤销分配的域名旁的“移除”按钮

这将从该应用移除域名，但该域名仍在您的组织中保留，可用于其他应用。

## 删除自定义域

1. 进入组织域页面
2. 打开域配置抽屉
3. 点击“删除”并确认

这会将自定义域从您的组织中移除，并删除该域在所有应用中的所有分配。选择是附加基础域、通配符子域还是任何特定子域到应用。

选择好应用和域后，点击“分配域名”按钮以确认。

## 从应用中撤销自定义域分配（重复段落，删除此段）

去应用设置页面，在“自定义域”部分，点击“移除”按钮撤销自定义域分配。该域名仍保留在组织内，可供其他应用使用。

## 删除自定义域（重复段落，删除此段）

进入组织域页面，打开域配置抽屉，点击“删除”按钮并确认。该操作会将自定义域从组织中删除，并清除所有应用中的自定义域分配。

---

# deploy/early-access/reference/env-vars-and-contexts.md

> Deno Deploy 早期访问版中管理环境变量和上下文的指南，包括变量类型、创建、编辑以及在代码中访问它们的方式。

URL: https://docs.deno.com/deploy/early-access/reference/env-vars-and-contexts


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。正在寻找 Deploy Classic 的文档？[请点击这里查看](/deploy/)。

:::

Deno Deploy<sup>EA</sup> 中的环境变量允许您使用静态值配置应用程序，例如 API 密钥或数据库连接字符串。

## 环境变量类型

环境变量可以以以下形式存储：

- **纯文本**：在 UI 中可见，适用于非敏感值，如特征标志
- **密钥**：创建后在 UI 中不可见，仅能从应用代码中读取，适用于敏感值，如 API 密钥

变量可以设置在：

- **应用级别**：特定于单个应用
- **组织级别**：应用于组织中的所有应用，但可以被应用级变量覆盖

## 上下文

每个环境变量适用于一个或多个上下文。上下文代表代码运行的逻辑“环境”，每个环境拥有自己的一组变量和密钥。

默认情况下，有两个上下文：

- **生产**：用于生产时间线，服务生产流量
- **开发**：用于开发时间线，服务非生产流量（预览 URL 和分支 URL）

:::info

需要额外的上下文？请联系 [支持](../support)。

:::

此外，还有一个用于构建过程中的 **构建** 上下文。构建上下文中的环境变量仅在构建期间可用，在生产和开发上下文中不可访问（反之亦然）。这种分离使得构建时和运行时可以有不同的配置。

在单个应用或者组织内，同一上下文中不能存在多个同名的环境变量；但可以在不同且不重叠的上下文中存在同名变量。

## 添加、编辑和删除环境变量

您可以从多个位置管理环境变量：

- 在创建应用时的 “新建应用” 页面
- 在应用设置的 “环境变量” 部分
- 在组织设置的 “环境变量” 部分

在每个位置，点击相应的编辑按钮打开环境变量抽屉。更改仅在点击 “保存” 后生效。点击 “取消” 会放弃更改。

添加变量步骤：

1. 点击 “添加环境变量”
2. 输入名称和值
3. 指定是否为密钥
4. 选择适用的上下文

您也可以从 `.env` 文件批量导入变量：

1. 点击 “+ 从 .env 文件添加”
2. 粘贴 `.env` 文件内容
3. 点击 “导入变量”

注意以 `#` 开头的行会被视为注释。

删除变量，点击其旁边的 “删除” 按钮。

编辑变量，点击其旁边的 “编辑” 按钮，可修改名称、值、密钥状态或适用上下文。

## 在代码中使用环境变量

通过 `Deno.env.get` API 访问环境变量：

```ts
const myEnvVar = Deno.env.get("MY_ENV_VAR");
```

<!--
## 以文件形式暴露环境变量

环境变量可以通过切换“以文件形式暴露”选项，而不是作为普通环境变量暴露。

启用该选项后，环境变量的值会存储在应用文件系统的一个临时文件中。环境变量的值则变为该临时文件的路径。

要读取该值，可以结合使用 `Deno.readTextFile` 与 `Deno.env.get` API：

```ts
// 假设 MY_ENV_VAR 已设置为以文件形式暴露
const value = await Deno.readTextFile(Deno.env.get("MY_ENV_VAR"));
```

这对于值过大而不适合放入环境变量，或希望避免在环境变量列表中暴露敏感数据非常有用。

此外，对于预先存在的应用程序，期望某些环境变量指向文件（如 Postgres CA 证书的 `PGSSLROOTCERT`）也很有帮助。
-->

## 限制

环境变量有以下限制：

- 环境变量键最大长度为 128 字节。\
- 环境变量键不能以以下前缀开头：
  - `DENO_`，但允许以下除外：`DENO_AUTH_TOKENS`、`DENO_COMPAT`、`DENO_CONDITIONS`、
    `DENO_DEPLOY_ENDPOINT` 或 `DENO_DEPLOY_TOKEN`
  - `LD_`
  - `OTEL_`
- 环境变量值最大长度为 16 KB（16,384 字节）。
- 环境变量键不能为以下任一键。请改用
  [云连接](/deploy/early-access/reference/cloud-connections)
  - `AWS_ROLE_ARN`
  - `AWS_WEB_IDENTITY_TOKEN_FILE`
  - `GCP_WORKLOAD_PROVIDER_ID`
  - `GCP_SERVICE_ACCOUNT_EMAIL`
  - `GCP_PROJECT_ID`
  - `AZURE_CLIENT_ID`
  - `AZURE_TENANT_ID`
  - `AZURE_FEDERATED_TOKEN_FILE`

## 预定义环境变量

Deno Deploy<sup>EA</sup> 在所有上下文中提供以下预定义环境变量：

- `DENO_DEPLOY=1`：表示应用正在 Deno Deploy 环境中运行。

- `DENO_DEPLOYMENT_ID`：表示整个配置集（应用 ID、修订 ID、上下文和环境变量）的唯一标识符。当其中任何组件更改时此值也会变化。

- `DENO_DEPLOY_ORG_ID`：应用所属组织的 ID。

- `DENO_DEPLOY_ORG_SLUG`：应用所属组织的标识符。

- `DENO_DEPLOY_APP_ID`：应用的 ID。

- `DENO_DEPLOY_APP_SLUG`：应用的标识符。

- `DENO_DEPLOY_BUILD_ID`：当前运行的修订版本 ID。

构建期间，环境变量中还会额外设置 `CI=1`。

---

# 或 npm install @deno/astro-adapter

> Deno Deploy 早期访问中支持的 JavaScript 和 TypeScript 框架的详细指南，包括 Next.js、Astro、Nuxt、SvelteKit 等。

URL: https://docs.deno.com/deploy/early-access/reference/frameworks


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想要查看 Deploy Classic 文档？[点击这里查看](/deploy/)。

:::

Deno Deploy<sup>EA</sup> 开箱即支持多种 JavaScript 和 TypeScript 框架。这意味着您可以在无需额外配置或设置的情况下使用这些框架。

原生支持的框架已经过测试，能在 Deno Deploy<sup>EA</sup> 上正常运行，并且在创建新应用时会被自动检测。Deno Deploy<sup>EA</sup> 会自动优化这些框架的构建和运行时配置，以达到最佳状态。

未列出的框架仍很可能可用，但可能需要您手动配置安装和/或构建命令，以及构建设置中的运行时配置。

觉得有什么框架缺失？欢迎在[Deno Deploy Discord 频道](https://discord.gg/deno)告诉我们，或[联系 Deno 支持](../support)。

## 支持的框架

### Next.js

Next.js 是用于构建全栈 Web 应用的 React 框架。您使用 React 组件构建用户界面，同时使用 Next.js 提供的额外功能和优化。

页面路由和应用路由均开箱即支持。支持 ISR、SSG、SSR 和 PPR。缓存开箱即支持，包括使用新的 `"use cache"`。

`next/image` 开箱即用。

Deno Deploy<sup>EA</sup> 上的 Next.js 始终在独立模式下构建。

支持开箱即用的追踪功能，Next.js 会自动为传入请求、路由、渲染及其他操作发出一些跨度（spans）。

### Astro

Astro 是一个用于构建内容驱动网站（如博客、营销和电商）的 Web 框架。Astro 尽可能多地利用服务器渲染而非浏览器端渲染。

对于静态 Astro 网站，使用 Deno Deploy<sup>EA</sup> 无需额外配置。

在 Deno Deploy<sup>EA</sup> 上使用 Astro 的 SSR 时，您需要安装 [@deno/astro-adapter](https://github.com/denoland/deno-astro-adapter) 包，并将您的 `astro.config.mjs` 文件配置为使用该适配器：

```bash
$ deno add npm:@deno/astro-adapter
# 或 npm install @deno/astro-adapter
# 或 yarn add @deno/astro-adapter
# 或 pnpm add @deno/astro-adapter
```

```diff title="astro.config.mjs"
  import { defineConfig } from 'astro/config';
+ import deno from '@deno/astro-adapter';
  
  export default defineConfig({
+   output: 'server',
+   adapter: deno(),
  });
```

支持 Sharp 图像优化。

支持 `astro:env` API。

### Nuxt

使用 Nuxt 轻松创建高质量 Web 应用，Nuxt 是一个开源框架，使基于 Vue.js 的全栈开发变得直观。

Nuxt 无需额外设置。

### SolidStart

SolidStart 是一个开源元框架，旨在统一组成 Web 应用的组件。它建立于 Solid 之上。

SolidStart 无需额外设置。

### SvelteKit

SvelteKit 是一个使用 Svelte 快速开发健壮且高性能 Web 应用的框架。

SvelteKit 无需额外设置。

### Fresh

Fresh 是一个面向 JavaScript 和 TypeScript 开发者的全栈现代 Web 框架。Fresh 使用 Preact 作为 JSX 渲染引擎。

Fresh 无需额外设置。

### Lume

Lume 是一个用于利用 Deno 构建快速且现代网站的静态站点生成器。

Lume 无需额外设置。

### Remix

> ⚠️ **实验性质**：Remix 目前尚未完全支持。它正在被集成进 Deno Deploy<sup>EA</sup>，某些功能可能无法按预期工作。如遇任何问题，请向 Deno 团队反馈。

---

# deploy/early-access/reference/observability.md

> Deno Deploy 早期访问中监控功能的全面概述，包括日志、跟踪、指标和过滤选项。

URL: https://docs.deno.com/deploy/early-access/reference/observability


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想要查找 Deploy Classic 文档？[点击这里查看](/deploy/)。

:::

Deno Deploy<sup>EA</sup> 提供全面的可观测性功能，帮助您了解应用性能、调试错误和监控使用情况。这些功能利用了 OpenTelemetry 以及
[Deno 内置的 OpenTelemetry 集成](/runtime/fundamentals/open_telemetry/)。

Deno Deploy<sup>EA</sup> 中的三大主要可观测性功能是：

- **日志**：应用代码发出的非结构化调试信息
- **跟踪**：关于请求处理的结构化信息，包括每个步骤的执行时间及自动捕获的出站 I/O 操作
- **指标**：关于应用性能和使用情况的结构化高层数据，例如请求数、错误数和延迟

## 日志

Deno Deploy<sup>EA</sup> 中的日志通过标准的 `console` API 捕获，并可以在控制面板的日志页面中查询。

日志按应用组织。您可以使用搜索栏根据各种属性和消息内容过滤日志。

当日志在跟踪上下文中发出时，它们会与特定的跟踪和跨度关联。对于这类日志，日志界面会显示“查看跟踪”按钮，允许您在覆盖抽屉中打开相关跟踪，进行详细检查。

## 跟踪

Deno Deploy<sup>EA</sup> 中的跟踪通过三种方式捕获：

- **内置操作自动跟踪**：入站 HTTP 请求、出站 fetch 调用及其他系统操作会自动跟踪，且无法禁用。
- **支持框架自动跟踪**：如 Next.js、Fresh 和 Astro 等框架内置了自动监控。具体支持的框架和操作可能随时间变化。
- **手动自定义监控**：您的应用代码可以通过 OpenTelemetry API 创建新的跟踪或跨度。

跟踪按应用组织。搜索栏可让您根据各种属性和跨度名称过滤。

点击某个跟踪会打开跟踪覆盖抽屉，显示该跟踪中的所有跨度的瀑布视图。该视图展示每个跨度的开始时间、结束时间和持续时间，并按父跨度分组，根跨度位于最上方。

点击任一跨度，会在抽屉底部展示其详细信息，包括所有捕获的属性。例如，出站 HTTP 请求包含方法、URL 和状态码。

跨度详情部分还包括 “日志” 标签页，显示在该跨度上下文中发出的所有日志。

您可点击任意跟踪上的“查看日志”，在日志页打开该跟踪 ID 预填的搜索栏，显示与该跟踪相关的所有日志。

## 指标

Deno Deploy<sup>EA</sup> 中的指标自动捕获多种操作数据，如入站 HTTP 请求和出站 fetch 调用，且无法禁用。

指标按应用组织，并以时间序列图的形式展示其随时间变化的数值。您可通过搜索栏按各种属性过滤指标。

## 过滤

日志、跟踪和指标可使用以下通用属性进行过滤：

- **版本**：发出数据的应用版本 ID
- **上下文**：数据发出的上下文（“生产”或“开发”）

对日志和跟踪，额外提供以下过滤器：

- **跟踪**：包含该日志或跨度的跟踪 ID

仅对跟踪提供以下额外过滤器：

- **HTTP 方法**：触发跟踪的请求的 HTTP 方法
- **HTTP 路径**：触发跟踪的请求路径
- **HTTP 状态**：响应的 HTTP 状态码

### 时间范围过滤

默认情况下，可观测性页面显示过去一小时的数据。您可以通过页面右上角的时间范围过滤器更改此设置。

您可以选择预定义的时间范围，如“最近 1 小时”、“最近 24 小时”或“最近 7 天”，也可以点击“自定义”按钮设置自定义时间范围。

自定义时间范围可以是绝对时间段（具体的开始和结束时间），也可以是相对时间段（例如 3 天前、1 小时后等）。相对时间段使用与 Grafana 相同的语法：

- `now` - 当前时间
- `now-1h` - 1 小时前
- `now/h` - 当前小时的开始时间
- `now-1h/h` - 前一个小时的开始时间
- `now/d+3h` - 当天开始时间加 3 小时
- `now-1d/d` - 前一天的开始时间

---

# deploy/early-access/reference/oidc.md

URL: https://docs.deno.com/deploy/early-access/reference/oidc


Deno Deploy<sup>EA</sup> 是一个 OIDC 提供者。Deno Deploy<sup>EA</sup> 的每个正在运行的应用程序都可以获得由 Deno Deploy<sup>EA</sup> 签发的短期 JWT 令牌。这些令牌包含有关应用程序的信息，例如组织和应用的 ID 与 slug、应用程序执行的上下文以及正在运行的修订版本 ID。

这些令牌可以用来与支持 OIDC 认证的第三方服务进行身份验证，例如主要的云提供商，也包括 HashiCorp Vault、NPM 等。

:::tip

想要使用 OIDC 令牌进行 AWS 或 Google Cloud 的身份验证？请使用[云连接](./cloud-connections)功能，而不是手动配置 OIDC 认证。云连接会为您处理整个配置流程，包括建立信任关系和权限设置。底层依然使用的是 OIDC。

:::

## 签发令牌

要为当前正在运行的应用程序签发令牌，请使用来自 [`@deno/oidc` 模块（在 JSR 上）](http://jsr.io/@deno/oidc) 的 `getIdToken()` 函数。

首先，将 `@deno/oidc` 作为您的应用依赖安装：

```
deno add jsr:@deno/oidc
```

然后，引入 `getIdToken()` 函数，并使用所需的目标受众调用它：

```ts
import { getIdToken } from "jsr:@deno/oidc";

const token = await getIdToken("https://example.com/");
console.log(token);
```

`audience` 参数是一个字符串，用于标识令牌的预期接收方。通常是一个 URL 或表示将消费该令牌的服务或应用的标识符。受众值必须与您希望进行身份验证的第三方服务中配置的值相匹配。该值会放入签发的 JWT 令牌的 `aud` 声明中。

`getIdToken()` 函数返回一个 Promise，解析后为字符串形式的 JWT 令牌。

若要检查当前环境是否支持 OIDC（即您的应用是否运行在 Deno Deploy<sup>EA</sup> 上），可使用 `supportsIssuingIdTokens` 命名空间属性：

```ts
import { supportsIssuingIdTokens } from "jsr:@deno/oidc";

if (supportsIssuingIdTokens) {
  // 支持 OIDC
} else {
  // 不支持 OIDC
}
```

## 令牌结构

发放的令牌是采用 RS256 算法签名的 JWT 令牌。令牌包含以下声明：

| 声明名称       | 示例值                                 | 描述                                                                                                 |
| -------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `iss`          | `https://oidc.deno.com`              | 令牌的签发者，总是 `https://oidc.deno.com`。                                                      |
| `aud`          | `https://example.com/`               | 令牌的受众，即传入 `getIdToken()` 函数的值。                                                      |
| `iat`          | `1757924011`                         | 令牌签发时间，Unix 时间戳，表示令牌签发时刻。                                                    |
| `exp`          | `1757924311`                         | 令牌过期时间，Unix 时间戳，表示令牌失效时刻。                                                    |
| `nbf`          | `1757923951`                         | 令牌生效时间，Unix 时间戳，表示令牌开始有效时刻。                                                |
| `sub`          | `deployment:deno/astro-app/production` | 令牌主题，是字符串拼接的形式：`deployment:<org>/<app>/<context>`                                   |
| `org_id`       | `729adb8f-20d6-4b09-bb14-fac14cb260d1` | 拥有该应用的组织的唯一标识符。                                                                      |
| `org_slug`     | `deno`                              | 拥有该应用的组织的 slug。                                                                          |
| `app_id`       | `16ad21d8-7aeb-4155-8aa3-9f58df87cd3e` | 应用的唯一标识符。                                                                                  |
| `app_slug`     | `astro-app`                         | 应用的 slug。                                                                                      |
| `context_id`   | `1d685676-92d7-418d-b103-75b46f1a58b4` | 应用运行的上下文的唯一标识符。                                                                      |
| `context_name` | `production`                       | 应用运行的上下文。                                                                                  |
| `revision_id`  | `rh2r15rgy802`                     | 当前运行的应用修订版本的唯一标识符。                                                                |
| `deployment_id`| <随机字符串>                       | 包含整个部署元数据（包括应用、修订和上下文 ID）的唯一哈希。                                          |

令牌会在签发后 5 分钟过期。为考虑时钟偏差，令牌中的 `nbf` 声明设置为比 `iat` 提前 1 分钟。

## 验证令牌

要验证由 Deno Deploy<sup>EA</sup> 签发的令牌，您需要从 OIDC 提供者的 JWKS 端点获取公钥。Deno Deploy<sup>EA</sup> 的 JWKS 端点为：

```
https://oidc.deno.com/.well-known/jwks.json
```

使用 JWT 令牌头中的 `kid`（密钥 ID）选择 JWKS 响应中的正确密钥。

Deno Deploy<sup>EA</sup> 还提供了标准的 OIDC 发现文档：

```
https://oidc.deno.com/.well-known/openid-configuration
```

Deno Deploy<sup>EA</sup> 会定期更换其签名密钥，因此应动态从 JWKS 端点获取密钥，而不要将密钥硬编码。

当前，Deno Deploy<sup>EA</sup> 的签名密钥使用 `ES256` 算法。未来可能会根据安全需求、最佳实践及第三方服务支持情况进行更改。

验证令牌时，可以使用支持 OIDC 和 JWKS 的 JWT 库。在 TypeScript 中，您可以使用 [`jose`](https://jsr.io/@panva/jose) 库。

---

# deploy/early-access/reference/organizations.md

> 在 Deno Deploy 早期访问中创建和管理组织的指南，包括成员、权限和组织管理。

URL: https://docs.deno.com/deploy/early-access/reference/organizations


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。想找 Deploy Classic 文档？[点击此处查看](/deploy/)。

:::

组织是由一组用户组成的，他们共同拥有应用和域名。当注册 Deno Deploy<sup>EA</sup> 时，每个用户可以创建一个组织，或通过邀请加入现有组织。

所有用户必须属于某个组织才能使用 Deno Deploy<sup>EA</sup>，因为所有资源均归属于组织层级。

组织具有名称和 slug。名称仅对组织成员可见，并显示在 Deno Deploy<sup>EA</sup> 和 Deploy Classic 的组织下拉菜单中。slug 是该组织内所有应用默认域名的一部分。

:::caution

组织创建后，名称和 slug 均不可更改。

:::

每个组织都有默认域名，用于该组织中项目的生产环境、git 分支及预览 URL。例如，slug 为 `acme-inc` 的组织，其默认域名为 `acme-inc.deno.net`。

组织可包含多个成员。目前，所有成员在组织中均拥有所有者权限，意味着他们可以邀请其他成员、创建和删除应用以及管理域名。

## 创建组织

Deno Deploy<sup>EA</sup> 中的组织通过 Deno Deploy Classic 仪表盘创建：

1. 访问 [Deploy Classic 仪表盘](https://dash.deno.com)，使用您的 GitHub 账号登录。
2. 点击屏幕左上角组织下拉菜单中的“+”按钮。
3. 选择“尝试新的 Deno Deploy”选项。
4. 点击“创建早期访问组织”按钮。
5. 输入组织名称和 slug，然后点击“创建”。

:::info

组织 slug 必须在所有 Deno Deploy<sup>EA</sup> 组织中唯一，且不能与任何现有的 Deno Deploy Classic 项目名称相同。

:::

## 删除组织

目前无法通过仪表盘删除组织。如需删除组织，请[联系 Deno 支持](../support)。

## 邀请用户加入组织

邀请用户操作步骤：

1. 进入组织设置页面并点击“+ 邀请用户”。
2. 输入用户的 GitHub 账号用户名（例如 `ry`）。
3. 可选：输入一个电子邮件地址用于发送邀请。
4. 点击“邀请”。

如果未指定电子邮件，我们将尝试发送至用户公开 GitHub 资料中的邮箱，或我们已有的其他邮箱地址。

邀请用户后（若有邮箱地址），用户会收到含邀请链接的邮件。用户必须点击该链接并接受邀请才能加入组织。您也可以直接分享成员列表中显示的个性化邀请链接。

您可以在邀请被接受之前取消邀请，方法是在成员列表中点击被邀请用户旁的删除按钮，然后点击“保存”确认，这将使之前发送的邀请链接失效。

## 从组织中移除用户

要移除组织成员，请在组织设置的成员列表中找到该用户，点击移除按钮，然后点击“删除”确认。

---

# deploy/early-access/reference/playgrounds.md

> Write and deploy code completely from Deno Deploy, without the need for a git repository.

URL: https://docs.deno.com/deploy/early-access/reference/playgrounds


:::info

You are viewing the documentation for Deno Deploy<sup>EA</sup>. Looking for
Deploy Classic documentation? [View it here](/deploy/).

:::

Playground applications enable you to create, edit, and deploy applications
entirely from the Deno Deploy<sup>EA</sup> web dashboard, without needing to
create a GitHub repository.

Playgrounds contain one or more files (JavaScript, TypeScript, TSX, JSON, etc.)
that you can edit directly in the playground editor.

## Creating a playground

You can create playgrounds from the "Playgrounds" page in your organization.
Click the "New Playground" button to create a basic "Hello World" playground.
Using the dropdown on the "New Playground" button lets you create playgrounds
from other templates, such as Next.js or Hono.

## Editing a playground

To edit a playground, open it from the "Playgrounds" page in your organization.

The playground editor consists of five main sections:

- **Code editor**: The central area where you edit code for the currently
  selected file. Above the editor is a navbar showing the current file name,
  which you can click to edit.
- **File browser**: Located on the left of the code editor, this panel shows all
  files in the playground. Click any file to open it in the editor. Create new
  files by clicking the "New" icon at the top of the file browser. Delete files
  using the delete button next to each file name.
- **Top bar**: Located above the code editor, this contains action buttons for
  the playground. The "Deploy" button saves current changes and triggers a
  build. "Build Config" and "Env Variables" buttons open their respective
  configuration drawers. The left side of the top bar displays the playground
  URL (unless the playground hasn't been deployed yet).
- **Bottom drawer**: Located beneath the code editor, this contains debugging
  tools including "Build Logs" that show build progress during deployment, and
  tabs for viewing logs and traces.
- **Right drawer**: Located to the right of the code editor, this contains tools
  for inspecting application output. The "Preview" tab displays an iframe
  showing the deployed application, while "HTTP Explorer" lets you send
  individual HTTP requests to your deployment.

The playground content automatically saves when you click the "Deploy" button or
when the editor loses focus.

## Uploading files

You can upload a zip file containing files and directories to the playground by
dragging it into the file browser area. The contents of the zip file will be
extracted into the playground, preserving the directory structure.

> ⚠️ The playground editor does not support uploading individual files or
> directories.

## Using the HTTP explorer

The HTTP Explorer tab in the playground allows you to make arbitrary HTTP
requests to any URL served by the playground. This is useful for testing APIs or
other services that do not serve a web page.

To use the HTTP Explorer, enter the path and query parameters for the request
you want to make, select the HTTP method (GET, POST, etc.), and click on the
button labeled with the selected method.

Additional request headers can be added by clicking the "Set Headers" button.

After the response has been made, the HTTP Explorer will display the response
status, headers, and body.

To view the trace for the request, click on the "Trace" button in the response
section. This will open the request trace for the request in a drawer on top of
the playground editor. From there you can also view any `console.log` output
that was captured during the request.

## Renaming a playground

You can rename a playground by editing the playground slug on the playground
settings page. This will update the default domain names associated with the
playground since they are based on the playground slug. The new slug must be
unique within the organization (i.e. must not be in use by another app or
playground in the same organization).

:::warning

Any previous `deno.net` URLs pointing to the playground will no longer work
after renaming.

Custom domains will continue to work, as they are not tied to the playground
slug.

:::

## Deleting a playground

Playgrounds can be deleted from the playground settings page. This will remove
the playground and all its revisions from the organization. All existing
deployments will immediately stop serving traffic, and all custom domain
associations will be removed.

The playground and its revisions will no longer be accessible after deletion.
Deleted playgrounds cannot be restored through the Deno Deploy UI.

:::info

Deleted a playground by mistake? Contact Deno support within 30 days to restore
it.

:::

## Limitations

> ⚠️ Playgrounds cannot currently be transferred to another organization.


---

# deploy/early-access/reference/runtime.md

> 关于 Deno Deploy 早期访问运行时环境的详细信息，包括应用程序生命周期、启动、关闭和冷启动优化.

URL: https://docs.deno.com/deploy/early-access/reference/runtime


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。 查找 Deploy Classic 的文档？[点击这里查看](/deploy/)。

:::

在 Deno Deploy<sup>EA</sup> 中，所有应用程序都使用标准的 Deno 运行时在安全、隔离的 Linux 环境中执行。

Deno Deploy<sup>EA</sup> 使用的 Deno 运行时是标准的 Deno 运行时，完全支持 Deno CLI 的所有功能，包括 JSR 和 NPM 依赖、读写文件系统、发起网络请求、生成子进程，以及加载 FFI 和 node 原生插件。

Deno 运行时以 `--allow-all` 权限运行。

无法向 Deno 运行时传递自定义标志。

## 运行时环境

运行时环境是基于 Linux 的环境，运行在 x64 或 ARM64 架构上。运行时环境中可用的具体工具集可能会发生变化，因此无法依赖其稳定性。

目前 Deno Deploy<sup>EA</sup> 运行在 Deno 2.4.0 上。

## 生命周期

Deno Deploy<sup>EA</sup> 在无服务器环境中运行应用程序。 这意味着应用程序并不总是运行，只有在收到请求时才会启动。当长时间未收到任何流量时，应用程序将被停止。

应用程序可以随时启动和停止。它们应该快速启动，以便无延迟地响应传入请求。

同一个应用程序的多个实例可以同时运行。例如，一个实例可能运行在美国，另一个在欧洲。每个实例彼此完全隔离，不共享 CPU、内存或磁盘资源。必要时同一地区也可以启动多个实例，比如处理高流量或基础设施更新。

### 启动

当系统决定启动一个应用程序时，会为该应用程序预置一个新的沙箱环境。该环境与其他所有应用程序隔离。

然后使用配置的入口点启动应用程序，并等待 HTTP 服务器启动。如果应用程序在 HTTP 服务器启动之前崩溃，触发启动的请求将失败并返回 502 Bad Gateway 错误。

应用程序启动后，传入请求将被路由到该应用程序，并将响应发送回客户端。

### 关闭

应用程序会保持运行状态，直到一段时间内没有接收到新的传入请求或未发送响应（包括响应体字节）。具体超时时间介于 5 秒至 10 分钟之间。积极传输数据的 WebSocket 连接（包括 ping/pong 帧）也会保持应用程序存活。

当系统决定停止应用程序时，会向应用程序发送 `SIGINT` 信号，作为关闭的触发。此后，应用程序有 5 秒的时间优雅关闭，否则将被强制以 `SIGKILL` 信号终止。

### 驱逐

有时即使应用程序仍在接收流量，其 isolate 也可能被关闭。以下是一些可能的情况：

- 应用程序为了应对负载被扩展，但负载已减少回单实例可处理的水平。
- 执行该实例的底层服务器资源紧张，无法继续运行该应用实例。
- 底层基础设施正在更新或发生故障。

当系统决定驱逐一个应用程序时，会尽早尝试将流量从被驱逐的实例分流。有时这意味着请求会等待一个新实例启动，即便现有实例仍在运行。

当应用只处理快速完成的请求时，驱逐一般不易察觉。对于处理长时间请求或 WebSocket 的应用，驱逐可能更明显，因为可能需要在处理请求时驱逐应用。系统会尽力避免这种情况，但并不可避免。

在流量被重定向离开旧实例后，系统发送 `SIGINT` 信号触发优雅关闭。应用程序应快速完成剩余请求，并关闭 websockets 及其他长连接。发起长时间请求的客户端应准备好处理中断，并在断开时重新连接。

在发送 `SIGINT` 信号 5 秒后，如果旧实例尚未优雅关闭，将被强制以 `SIGKILL` 信号终止。

## 冷启动

由于应用程序并非一直运行，收到请求时可能需要启动。这称为冷启动。Deno Deploy<sup>EA</sup> 的冷启动经过高度优化，“Hello World” 应用可在 100 毫秒内启动，较大应用则在几百毫秒内启动完成。

Deno Deploy<sup>EA</sup> 使用多项优化来实现快速冷启动：

- 沙箱和 Deno 运行时预先准备，确保启动应用时无需从零创建。

- 应用在客户端发送首个 TCP 包以建立 TLS 连接时立即启动。对于启动迅速的应用，依据网络往返延迟，应用可能在客户端发送 HTTP 请求之前已运行。

- 文件系统访问针对常用启动文件进行了优化。Deno Deploy<sup>EA</sup> 在构建步骤的预热阶段分析文件访问模式，并优化文件系统以加快访问速度。

当冷启动缓慢时，会影响用户体验。为优化应用快速启动：

1. 减少应用依赖。

2. 使用动态 `import()` 延迟加载不常访问的代码和依赖。

3. 启动时尽量减少 I/O 操作，特别是顶层 `await` 和网络请求。

如果您的应用启动缓慢，请[联系 Deno 支持](../support) 获取帮助调查问题。

---

# deploy/early-access/reference/timelines.md

> 了解 Deno Deploy 早期访问中的部署时间线，包括生产和开发上下文、活动修订、回滚和时间线锁定。

URL: https://docs.deno.com/deploy/early-access/reference/timelines


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。正在寻找经典 Deploy 文档？[点此查看](/deploy/)。

:::

时间线是应用程序某个分支历史的表示。每个时间线由一组修订组成，这些修订是时间线上的各个项目。某个修订（通常是最近的一个）为“活动”修订，即当前正在处理流量的修订。活动修订接收分配给该时间线的所有 URL 的流量。

每个时间线都与一个[上下文](./env-vars-and-contexts.md)相关联，该上下文决定在该时间线上运行的代码可用哪些环境变量。

默认情况下，每个应用程序会设置多个时间线：

- **生产**：生产时间线包含默认 git 分支的所有修订。该时间线负责处理生产流量。此时间线关联至 `https://<app-name>.<org-name>.deno.net`，以及映射至该应用的任何自定义域名。它使用生产环境上下文。

- **Git 分支 / `<branch-name>`**：每个 Git 分支都有自己的时间线。该时间线包含该分支的所有修订。此时间线关联至 `https://<app-name>--<branch-name>.<org-name>.deno.net`。它使用开发环境上下文。

> 每个修订还有一个独立的时间线，该时间线仅包含该修订。这个时间线承载该修订的预览 URL。该时间线关联至 `https://<app-name>-<revision-id>.<org-name>.deno.net`，使用开发环境上下文。
>
> 预览时间线在 UI 的时间线页面中不可见。您可以在该修订的构建页面查看其预览 URL。

您可以在修订的构建页面查看该修订关联的时间线。也可以在时间线页面查看关联某个时间线的修订。

## 活动修订

每个时间线都有一个活动修订。活动修订是当前为该时间线提供流量的修订。您可以在时间线页面查看时间线的活动修订。

通常，活动修订是该时间线中最近构建的修订。但也可以手动锁定其他修订作为活动修订。这使得能够回滚和锁定时间线成为可能：

### 回滚

回滚是将活动修订恢复到之前某个修订的过程，通常是因为较新的修订存在某种错误或问题。通过回滚到已知的良好修订，可以在无需通过 Git 部署新代码、等待构建完成的情况下恢复应用的正常状态。

有关如何回滚时间线的更多信息，请参阅下面的“更改活动修订”。

### 时间线锁定

时间线锁定是将时间线锁定到特定修订，以确保新构建不会自动成为活动修订的过程。如果您处于功能冻结阶段，例如大型活动期间，想要降低风险而不允许新构建部署，这非常有用。当时间线锁定到特定修订时，您仍可通过 Git 推送创建新构建，但这些构建不会自动成为该时间线的活动修订。

有关如何锁定时间线至特定修订的更多信息，请参阅下面的“更改活动修订”。

### 更改活动修订

在时间线页面，您可以将该时间线上的任意修订锁定为活动修订。这样会锁定时间线至该修订，且新构建将不再自动成为该时间线的活动修订。随后，您可以解锁该修订，恢复最新修订为活动修订的默认行为，或锁定其他修订为活动修订。

---

# deploy/early-access/support/index.md

URL: https://docs.deno.com/deploy/early-access/support/


:::info

您正在查看 Deno Deploy<sup>EA</sup> 的文档。寻找 Deploy Classic 的文档？[点击这里查看](/deploy/)。

:::

If you have any questions or feedback about Deno Deploy<sup>EA</sup>, please
reach out to us on the [Deno Discord](https://discord.gg/deno) in the
`#deploy-ea` channel or [contact us](mailto:deploy@deno.com).

我们正在积极改进该平台，期待听到您的想法！

---

# Deno Deployᴱᴬ 使用指南

> Deno Deploy 早期访问计划的重要限制、服务级别期望及使用条款。

URL: https://docs.deno.com/deploy/early-access/usage


作为一款早期访问产品，Deno Deploy<sup>EA</sup> 目前存在一些您在使用前应了解的限制：

- Deno Deploy Pro 账户功能尚未扩展至 Deno Deploy<sup>EA</sup>
- Deno Deploy<sup>EA</sup> 中不提供队列和定时任务功能

:::info

Deno Deploy<sup>EA</sup> 是一个早期访问产品，因此目前不受我们的常规服务级别协议的保护。

:::

Deno 公司现已使用 Deno Deploy<sup>EA</sup> 托管我们自己的网站，并正投入大量努力以确保服务的可靠性。然而，由于这是一个新系统，偶尔可能会发生服务中断。

虽然 Deno Deploy<sup>EA</sup> 仍处于早期访问阶段，但[可接受使用政策](/deploy/manual/acceptable-use-policy/)和[条款与条件](/deploy/manual/terms-and-conditions/)依然适用，我们保留终止任何违反这些条款的用户、组织或应用的权利。

---

# deploy/index.md

URL: https://docs.deno.com/deploy/



---

# 备份

URL: https://docs.deno.com/deploy/kv/manual/backup


<deno-admonition></deno-admonition>

在 Deno Deploy 上托管的 KV 数据库可以持续备份到您自己的 S3 兼容存储桶。这是我们为所有存储在托管 Deno KV 数据库中的数据内部执行的复制和备份的补充，以确保高可用性和数据持久性。

此备份将持续进行，几乎没有延迟，支持 _[时间点恢复](https://en.wikipedia.org/wiki/Point-in-time_recovery)_ 和实时复制。为 KV 数据库启用备份可以解锁各种有趣的使用案例：

- 在过去的任何时间点检索数据的一致快照
- 独立于 Deno Deploy 运行只读数据副本
- 通过将变更管道到流媒体平台和分析数据库（如 Kafka、BigQuery 和 ClickHouse）来推送数据到您最喜欢的数据管道

## 配置备份到 Amazon S3

首先，您必须在 AWS 上创建一个存储桶：

<deno-tabs group-id="aws-tool">
<deno-tab value="console" label="AWS 控制台" default>

1. 访问 [AWS S3 控制台](https://s3.console.aws.amazon.com/s3/home)
2. 点击 “创建存储桶”
3. 输入存储桶名称并选择 AWS 区域，然后向下滚动并点击 “下一步”

</deno-tab>
<deno-tab value="cli" label="AWS CLI">

1. 安装 [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)
2. 运行
   `aws s3api create-bucket --bucket <bucket-name> --region <region> --create-bucket-configuration LocationConstraint=<region>`
   （将 `<bucket-name>` 和 `<region>` 替换为您的值）

</deno-tab>
</deno-tabs>

接下来，创建一个对存储桶具有 `PutObject` 访问权限的 IAM 策略，将其附加到 IAM 用户，并为该用户创建访问密钥：

<deno-tabs group-id="aws-tool">
<deno-tab value="console" label="AWS 控制台" default>

1. 访问 [AWS IAM 控制台](https://console.aws.amazon.com/iam/home)
2. 在左侧边栏点击 “策略”
3. 点击 “创建策略”
4. 选择 “JSON” 策略编辑器并粘贴以下策略：
   ```json
   {
     "Version": "2012-10-17",
     "Statement": [
       {
         "Sid": "KVBackup",
         "Effect": "Allow",
         "Action": "s3:PutObject",
         "Resource": "arn:aws:s3:::<bucket-name>/*"
       }
     ]
   }
   ```
   将 `<bucket-name>` 替换为您之前创建的存储桶名称。
5. 点击 “审核策略”
6. 输入策略名称并点击 “创建策略”
7. 在左侧边栏点击 “用户”
8. 点击 “添加用户”
9. 输入用户名称并点击 “下一步”
10. 点击 “直接附加策略”
11. 搜索您之前创建的策略，并点击其旁边的复选框
12. 点击 “下一步”
13. 点击 “创建用户”
14. 点击您刚刚创建的用户
15. 点击 “安全凭证”，然后点击 “创建访问密钥”
16. 选择 “其他”，然后点击 “下一步”
17. 输入访问密钥描述并点击 “创建访问密钥”
18. 复制访问密钥 ID 和秘密访问密钥，并将其保存在安全的地方。
    您稍后会需要它们，并且将无法再检索它们。

</deno-tab>
<deno-tab value="cli" label="AWS CLI">

1. 复制以下命令到终端，将 `<bucket-name>` 替换为您之前创建的存储桶名称，然后运行：
   ```
   aws iam create-policy --policy-name <policy-name> --policy-document '{"Version":"2012-10-17","Statement":[{"Sid":"KVBackup","Effect":"Allow","Action":"s3:PutObject","Resource":"arn:aws:s3:::<bucket-name>/*"}]}'
   ```
2. 复制以下命令到终端，将 `<user-name>` 替换为您正在创建的用户的名称，然后运行：
   ```
   aws iam create-user --user-name <user-name>
   ```
3. 复制以下命令到终端，将 `<policy-arn>` 替换为您在步骤 1 中创建的策略的 ARN，并将 `<user-name>` 替换为您在上一步中创建的用户的名称，然后运行：
   ```
   aws iam attach-user-policy --policy-arn <policy-arn> --user-name <user-name>
   ```
4. 复制以下命令到终端，将 `<user-name>` 替换为您在步骤 2 中创建的用户的名称，然后运行：
   ```
   aws iam create-access-key --user-name <user-name>
   ```
5. 复制访问密钥 ID 和秘密访问密钥，并将其保存在安全的地方。
   您稍后会需要它们，并且将无法再检索它们。

</deno-tab>
</deno-tabs>

现在访问 [Deno Deploy 控制台](https://dash.deno.com)，并在您的项目中点击 “KV” 选项卡。滚动到 “备份” 部分，点击 “AWS S3”。输入您之前创建的存储桶名称、访问密钥 ID 和秘密访问密钥，以及存储桶所在的区域。然后点击 “保存”。

<img
  src="./images/backup-add-bucket-to-dash.png"
  alt="将备份添加到仪表板"
  style="height: 500px;"
/>

备份将立即开始。一旦数据备份完成，并且连续备份处于活动状态，您将看到状态变为 “活跃”。

## 配置备份到 Google Cloud Storage

Google Cloud Storage (GCS) 兼容 S3 协议，也可以用作备份目标。

首先，您必须在 GCP 上创建一个存储桶：

<deno-tabs group-id="gcp-tool">
<deno-tab value="console" label="GCP 控制台" default>

1. 访问 [GCP Cloud Storage 控制台](https://console.cloud.google.com/storage/browser)
2. 点击顶部栏的 “创建”
3. 输入存储桶名称，选择位置，然后点击 “创建”

</deno-tab>
<deno-tab value="cli" label="gcloud CLI">

1. 安装 [gcloud CLI](https://cloud.google.com/sdk/docs/install)
2. 运行 `gcloud storage buckets create <bucket-name> --location <location>`
   （将 `<bucket-name>` 和 `<location>` 替换为您的值）

</deno-tab>
</deno-tabs>

接下来，创建一个对存储桶具有 `Storage Object Admin` 访问权限的服务账号，并为该服务账号创建 HMAC 访问密钥：

<deno-tabs group-id="gcp-tool">
<deno-tab value="console" label="GCP 控制台" default>

1. 访问 [GCP IAM 控制台](https://console.cloud.google.com/iam-admin/iam)
2. 在左侧边栏点击 “服务账户”
3. 点击 “创建服务账户”
4. 输入服务账户名称并点击 “完成”
5. 复制您刚刚创建的服务账户的电子邮件。您稍后会需要它。
6. 访问 [GCP Cloud Storage 控制台](https://console.cloud.google.com/storage/browser)
7. 点击您之前创建的存储桶
8. 点击工具栏上的 “权限”
9. 点击 “授予访问权限”
10. 将您之前复制的服务账户的电子邮件粘贴到 “新主体” 字段中
11. 从 “选择角色” 下拉菜单中选择 “Storage Object Admin”
12. 点击 “保存”
13. 在左侧边栏点击 “设置”（仍然在 Cloud Storage 控制台中）
14. 点击 “互操作性” 标签
15. 点击 “为服务帐号创建密钥”
16. 选择您之前创建的服务帐号
17. 点击 “创建密钥”
18. 复制访问密钥和秘密访问密钥，并将其保存在安全的地方。您稍后会需要它们，并且将无法再检索它们。

</deno-tab>
<deno-tab value="cli" label="gcloud CLI">

1. 运行以下命令，将 `<service-account-name>` 替换为您正在创建的服务帐号的名称：
   ```
   gcloud iam service-accounts create <service-account-name>
   ```
2. 运行以下命令，将 `<bucket-name>` 替换为您之前创建的存储桶名称，并将 `<service-account-email>` 替换为您在上一步创建的服务帐户的电子邮件：
   ```
   gsutil iam ch serviceAccount:<service-account-email>:objectAdmin gs://<bucket-name>
   ```
3. 运行以下命令，将 `<service-account-email>` 替换为您在上一步创建的服务帐户的电子邮件：
   ```
   gcloud storage hmac create <service-account-email>
   ```
4. 复制 `accessId` 和 `secret` 并将其保存在安全的地方。您稍后会需要它们，并且将无法再检索它们。

</deno-tab>
</deno-tabs>

现在访问 [Deno Deploy 控制台](https://dash.deno.com)，并在您的项目中点击 “KV” 选项卡。滚动到 “备份” 部分，点击 “Google Cloud Storage”。输入您之前创建的存储桶名称、访问密钥 ID 和秘密访问密钥，以及存储桶所在的区域。然后点击 “保存”。

备份将立即开始。一旦数据备份完成，并且连续备份处于活动状态，您将看到状态变为 “活跃”。

## 使用备份

S3 备份可以与 `denokv` 工具一起使用。有关更多详细信息，请参阅 [文档](https://github.com/denoland/denokv)。

---

# 调度 cron 任务

URL: https://docs.deno.com/deploy/kv/manual/cron


<deno-admonition></deno-admonition>

[`Deno.cron`](https://docs.deno.com/api/deno/~/Deno.cron) 接口使您能够配置以可配置的时间表执行的 JavaScript 或 TypeScript 代码，使用 [cron 语法](https://en.wikipedia.org/wiki/Cron)。在下面的示例中，我们配置一段每分钟执行一次的 JavaScript 代码。

```ts
Deno.cron("记录消息", "* * * * *", () => {
  console.log("每分钟打印一次。");
});
```

也可以使用 JavaScript 对象来定义 cron 调度。在下面的示例中，我们配置一段每小时执行一次的 JavaScript 代码。

```ts
Deno.cron("记录消息", { hour: { every: 1 } }, () => {
  console.log("每小时打印一次。");
});
```

`Deno.cron` 接受三个参数：

- 一个可读的人类名称，描述 cron 任务
- 一个 cron 调度字符串或定义调度的 JavaScript 对象，指定 cron 任务的运行时间
- 一个在给定调度上执行的函数

如果您是 cron 语法的新手，有一些第三方模块可帮助您生成 cron 调度字符串 [像这个](https://www.npmjs.com/package/cron-time-generator)。

## 重试失败的运行

失败的 cron 调用会自动按照默认重试策略进行重试。如果您想指定自定义重试策略，可以使用 `backoffSchedule` 属性来指定一个等待时间数组（以毫秒为单位），该数组用于在再次重试函数调用之前等待。在以下示例中，我们将尝试重试失败的回调三次——第一次等待一秒，第二次等待五秒，然后等待十秒。

```ts
Deno.cron("重试示例", "* * * * *", {
  backoffSchedule: [1000, 5000, 10000],
}, () => {
  throw new Error("Deno.cron 将重试这三次，但没有成功！");
});
```

## 设计和限制

在使用 `Deno.cron` 时，请注意以下一些设计细节和限制。

### 任务必须在顶层模块作用域中定义

[`Deno.cron`](https://docs.deno.com/api/deno/~/Deno.cron) 接口旨在支持基于预定义调度的静态 cron 任务定义。所有 `Deno.cron` 任务必须在模块的顶层定义。任何嵌套的 `Deno.cron` 定义（例如在 [`Deno.serve`](https://docs.deno.com/api/deno/~/Deno.serve) 处理程序内）将导致错误或被忽略。

如果您需要在 Deno 程序执行期间动态调度任务，您可以使用 [Deno Queues](./queue_overview) API。

### 时区

`Deno.cron` 调度使用 UTC 时区指定。这有助于避免因观察夏令时而造成的时区问题。

### 重叠执行

下一个计划的 cron 任务调用可能会与先前的调用重叠。如果发生这种情况，`Deno.cron` 将跳过下一个计划调用，以避免重叠执行。

### 星期几数字表示

`Deno.cron` 不使用基于 0 的星期几数字表示。相反，它使用 1-7（或 SUN-SAT）来表示从星期日到星期六。这可能与其他使用 0-6 表示法的 cron 引擎不同。

## 在 Deno Deploy 上的使用

通过 [Deno Deploy](https://deno.com/deploy)，您可以在云中的 V8 隔离环境中运行您的后台任务。在这样做时，有一些注意事项要考虑。

### 与 Deno CLI 的不同

像其他 Deno 运行时内置功能（如队列和 Deno KV）一样，`Deno.cron` 的实现在线上 Deno Deploy 中稍有不同。

#### 默认情况下 cron 的工作原理

Deno 运行时中的 `Deno.cron` 实现将执行状态保存在内存中。如果您运行多个使用 `Deno.cron` 的 Deno 程序，每个程序将有自己独立的 cron 任务集。

#### Deno Deploy 上的cron工作原理

Deno Deploy 提供了一个无服务器实现的 `Deno.cron`，旨在实现高可用性和扩展性。Deno Deploy 会在部署时自动提取您的 `Deno.cron` 定义，并使用按需隔离进行任务调度。您最新的生产部署定义了安排执行的活动 cron 任务集。要添加、删除或修改 cron 任务，只需修改代码并创建一个新的生产部署。

Deno Deploy 保证您的 cron 任务在每个计划的时间间隔内至少执行一次。这通常意味着您的 cron 处理程序每次按照计划的时间调用一次。在某些故障场景下，处理程序可能会因同一调度时间被多次调用。

### Cron 仪表板

当您进行包含 cron 任务的生产部署时，可以在您项目的 [Deploy 仪表板](https://dash.deno.com/projects) 中的 `Cron` 选项卡下查看所有 cron 任务的列表。

![Deno 仪表板中 cron 任务的列表](./images/cron-tasks.png)

### 定价

`Deno.cron` 调用的收费与针对您的部署的入站 HTTP 请求相同。有关定价的更多信息，请访问 [这里](https://deno.com/deploy/pricing)。

### 特定于部署的限制

- `Deno.cron` 仅适用于生产部署（不适用于预览部署）
- 您的 `Deno.cron` 处理程序的确切调用时间可能与计划时间相差最多一分钟

## Cron 配置示例

以下是一些常见的 cron 配置，供您参考。

```ts title="每分钟运行一次"
Deno.cron("每分钟运行一次", "* * * * *", () => {
  console.log("你好，cron！");
});
```

```ts title="每十五分钟运行一次"
Deno.cron("每十五分钟运行一次", "*/15 * * * *", () => {
  console.log("你好，cron！");
});
```

```ts title="每小时整点运行一次"
Deno.cron("每小时整点运行一次", "0 * * * *", () => {
  console.log("你好，cron！");
});
```

```ts title="每三小时运行一次"
Deno.cron("每三小时运行一次", "0 */3 * * *", () => {
  console.log("你好，cron！");
});
```

```ts title="每天凌晨 1 点运行一次"
Deno.cron("每天凌晨 1 点运行一次", "0 1 * * *", () => {
  console.log("你好，cron！");
});
```

```ts title="每周三午夜运行一次"
Deno.cron("每周三午夜运行一次", "0 0 * * WED", () => {
  console.log("你好，cron！");
});
```

```ts title="每月第一天午夜运行一次"
Deno.cron("每月第一天午夜运行一次", "0 0 1 * *", () => {
  console.log("你好，cron！");
});
```

---

# 在 TypeScript 中的数据建模

URL: https://docs.deno.com/deploy/kv/manual/data_modeling_typescript


<deno-admonition></deno-admonition>

在 TypeScript 应用程序中，通常希望创建强类型、良好文档化的对象，以包含应用程序操作的数据。使用 [接口](https://www.typescriptlang.org/docs/handbook/2/objects.html) 或 [类](https://www.typescriptlang.org/docs/handbook/2/classes.html)，您可以描述程序中对象的形状和行为。

然而，如果您使用的是 Deno KV，则需要进行一些额外的工作来持久化和检索强类型对象。在本指南中，我们将讨论在 Deno KV 中处理强类型对象的策略。

## 使用接口和类型断言

在 Deno KV 中存储和检索应用数据时，您可能想要首先使用 TypeScript 接口描述数据的形状。以下是一个对象模型，它描述了博客系统的一些关键组件：

```ts title="model.ts"
export interface Author {
  username: string;
  fullName: string;
}

export interface Post {
  slug: string;
  title: string;
  body: string;
  author: Author;
  createdAt: Date;
  updatedAt: Date;
}
```

这个对象模型描述了一篇博客帖子及其相关的作者。

使用 Deno KV，您可以将这些 TypeScript 接口用作 [数据传输对象 (DTO)](https://martinfowler.com/bliki/LocalDTO.html)——对您可能发送到 Deno KV 或从中接收的非类型对象的强类型封装。

无需任何额外工作，您可以愉快地将这些 DTO 的内容存储在 Deno KV 中。

```ts
import { Author } from "./model.ts";

const kv = await Deno.openKv();

const a: Author = {
  username: "acdoyle",
  fullName: "Arthur Conan Doyle",
};

await kv.set(["authors", a.username], a);
```

然而，从 Deno KV 检索这个对象时，它默认不会具有与之关联的类型信息。如果您知道存储了哪个键的对象形状，您可以使用 [类型断言](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions) 通知 TypeScript 编译器对象的形状。

```ts
import { Author } from "./model.ts";

const kv = await Deno.openKv();

const r = await kv.get(["authors", "acdoyle"]);
const ac = r.value as Author;

console.log(ac.fullName);
```

您还可以为 `get` 指定一个可选的 [类型参数](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.get)：

```ts
import { Author } from "./model.ts";

const kv = await Deno.openKv();

const r = await kv.get<Author>(["authors", "acdoyle"]);

console.log(r.value.fullName);
```

对于更简单的数据结构，这个技术可能足够了。但通常，您希望或需要在创建或访问您的领域对象时应用一些业务逻辑。当这种需要出现时，您可以开发一组纯函数来操作您的 DTO。

## 使用服务层封装业务逻辑

当您应用程序的持久化需求变得更加复杂时——例如，当您需要创建 [二级索引](./secondary_indexes) 以通过不同的键查询数据，或维护对象之间的关系——您将希望创建一组函数来位于 DTO 之上，以确保传递的数据是有效的（而不仅仅是正确类型的）。

从我们上述的业务对象来看，`Post` 对象足够复杂，因此可能需要一小层代码来保存和检索对象的实例。以下是两个包裹底层 Deno KV API 的函数示例，同时返回强类型的 `Post` 接口实例。

值得注意的是，我们需要存储一个 `Author` 对象的标识符，以便稍后从 KV 检索作者信息。

```ts
import { Author, Post } from "./model.ts";

const kv = await Deno.openKv();

interface RawPost extends Post {
  authorUsername: string;
}

export async function savePost(p: Post): Promise<Post> {
  const postData: RawPost = Object.assign({}, p, {
    authorUsername: p.author.username,
  });

  await kv.set(["posts", p.slug], postData);
  return p;
}

export async function getPost(slug: string): Promise<Post> {
  const postResponse = await kv.get(["posts", slug]);
  const rawPost = postResponse.value as RawPost;
  const authorResponse = await kv.get(["authors", rawPost.authorUsername]);

  const author = authorResponse.value as Author;
  const post = Object.assign({}, postResponse.value, {
    author,
  }) as Post;

  return post;
}
```

这个薄层使用 `RawPost` 接口，扩展了实际的 `Post` 接口，以包括一些用于引用另一索引（相关的 `Author` 对象）的附加数据。

`savePost` 和 `getPost` 函数取代了直接的 Deno KV `get` 或 `set` 操作，从而可以正确地序列化和“注入”带有适当类型和关联的模型对象。

---

# Deno KV 快速入门

URL: https://docs.deno.com/deploy/kv/manual/


**Deno KV** 是一个
[键值数据库](https://en.wikipedia.org/wiki/Key%E2%80%93value_database)
直接构建在 Deno 运行时中，提供在
[`Deno.Kv` 命名空间](https://docs.deno.com/api/deno/~/Deno.Kv) 中可用。它可以用于许多类型的数据存储用例，但在存储简单数据结构时表现出色，这些数据结构受益于非常快速的读取和写入。Deno KV 可在 Deno CLI 和 [Deno Deploy](./on_deploy) 上使用。

:::caution

Deno KV is still in development and may change. To use it, you must pass the
`--unstable-kv` flag to Deno.

:::

让我们来了解 Deno KV 的关键特性。

## 打开数据库

在你的 Deno 程序中，可以使用
[`Deno.openKv()`](https://docs.deno.com/api/deno/~/Deno.openKv) 获取对 KV 数据库的引用。你可以传入一个可选的文件系统路径，以确定你希望存储数据库的位置，否则将根据你的脚本的当前工作目录为你创建一个。

```ts
const kv = await Deno.openKv();
```

## 创建、更新和读取键值对

Deno KV 中的数据以键值对的形式存储，类似于 JavaScript 对象字面量的属性或
[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)。
[键](./key_space) 由 JavaScript 类型的数组表示，如 `string`、`number`、`bigint` 或 `boolean`。值可以是任意 JavaScript 对象。在这个例子中，我们创建了一个表示用户 UI 偏好的键值对，并使用
[`kv.set()`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.set) 保存它。

```ts
const kv = await Deno.openKv();

const prefs = {
  username: "ada",
  theme: "dark",
  language: "en-US",
};

const result = await kv.set(["preferences", "ada"], prefs);
```

一旦设置了键值对，你可以使用 [`kv.get()`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.get) 从数据库中读取它：

```ts
const entry = await kv.get(["preferences", "ada"]);
console.log(entry.key);
console.log(entry.value);
console.log(entry.versionstamp);
```

`get` 和 `list` [操作](./operations) 都返回一个
[KvEntry](https://docs.deno.com/api/deno/~/Deno.KvEntry) 对象，具有以下属性：

- `key` - 用于设置值的数组键
- `value` - 为此键设置的 JavaScript 对象
- `versionstamp` - 用于确定键是否已更新的生成值。

`set` 操作也用于更新已存在的对象。当键的值被更新时，它的 `versionstamp` 将更改为一个新的生成值。

## 列出多个键值对

为了获取有限数量的键的值，您可以使用
[`kv.getMany()`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.getMany)。传入多个键作为参数，您将收到一个每个键的值数组。请注意，**如果给定的键没有值，值和版本戳可以是 `null`**。

```ts
const kv = await Deno.openKv();
const result = await kv.getMany([
  ["preferences", "ada"],
  ["preferences", "grace"],
]);
result[0].key; // ["preferences", "ada"]
result[0].value; // { ... }
result[0].versionstamp; // "00000000000000010000"
result[1].key; // ["preferences", "grace"]
result[1].value; // null
result[1].versionstamp; // null
```

通常，从所有具有给定前缀的键中检索键值对列表是很有用的。这种操作可以使用
[`kv.list()`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.list) 完成。在这个例子中，我们获取了共享 `"preferences"` 前缀的键值对列表。

```ts
const kv = await Deno.openKv();
const entries = kv.list({ prefix: ["preferences"] });
for await (const entry of entries) {
  console.log(entry.key); // ["preferences", "ada"]
  console.log(entry.value); // { ... }
  console.log(entry.versionstamp); // "00000000000000010000"
}
```

返回的键按键前缀后下一个组件的字典顺序排序。因此，具有以下键的 KV 对将按此顺序通过 `kv.list()` 返回：

- `["preferences", "ada"]`
- `["preferences", "bob"]`
- `["preferences", "cassie"]`

读取操作可以在
[**强一致性或最终一致性模式**](./operations) 下执行。强一致性模式保证读取操作将返回最近写入的值。最终一致性模式可能返回过时的值，但速度较快。相比之下，写入始终在强一致性模式下执行。

## 删除键值对

你可以使用
[`kv.delete()`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.delete) 从数据库中删除一个键。如果未找到给定键的值，则不执行任何操作。

```ts
const kv = await Deno.openKv();
await kv.delete(["preferences", "alan"]);
```

## 原子事务

Deno KV 能够执行 [原子事务](./transactions)，这使你能够有条件地同时执行一个或多个数据操作。在下面的示例中，我们只有在尚未创建喜好对象的情况下才会创建一个新的喜好对象。

```ts
const kv = await Deno.openKv();

const key = ["preferences", "alan"];
const value = {
  username: "alan",
  theme: "light",
  language: "en-GB",
};

const res = await kv.atomic()
  .check({ key, versionstamp: null }) // `null` 版本戳表示 '没有值'
  .set(key, value)
  .commit();
if (res.ok) {
  console.log("喜好尚不存在。已插入!");
} else {
  console.error("喜好已存在。");
}
```

在 Deno KV 中了解更多关于事务的信息 [这里](./transactions)。

## 通过二级索引改进查询

[二级索引](./secondary_indexes) 通过多个键存储相同的数据，允许更简单地查询所需的数据。假设我们需要能够通过用户名和电子邮件访问用户偏好。为此，你可以提供一个函数，该函数包装保存偏好的逻辑以创建两个索引。

```ts
const kv = await Deno.openKv();

async function savePreferences(prefs) {
  const key = ["preferences", prefs.username];

  // 设置主键
  const r = await kv.set(key, prefs);

  // 将二级键的值设置为主键
  await kv.set(["preferencesByEmail", prefs.email], key);

  return r;
}

async function getByUsername(username) {
  // 和之前一样使用...
  const r = await kv.get(["preferences", username]);
  return r;
}

async function getByEmail(email) {
  // 先通过电子邮件查找键，再进行第二次查找以获取实际数据
  const r1 = await kv.get(["preferencesByEmail", email]);
  const r2 = await kv.get(r1.value);
  return r2;
}
```

了解更多关于 [二级索引的手册信息](./secondary_indexes)。

## 监听 Deno KV 的更新

你也可以使用 `kv.watch()` 监听 Deno KV 的更新，它将会发出你提供的键的新的值或多个值。在下面的聊天示例中，我们监听键 `["last_message_id", roomId]` 的更新。我们检索 `messageId`，然后使用 `kv.list()` 从 `seen` 和 `messageId` 中获取所有的新消息。

```ts
let seen = "";
for await (const [messageId] of kv.watch([["last_message_id", roomId]])) {
  const newMessages = await Array.fromAsync(kv.list({
    start: ["messages", roomId, seen, ""],
    end: ["messages", roomId, messageId, ""],
  }));
  await websocket.write(JSON.stringify(newMessages));
  seen = messageId;
}
```

了解更多关于 [使用 Deno KV 监听的内容](./operations#watch)。

## 生产使用

Deno KV 可在 [Deno Deploy](./on_deploy) 上用于实时应用程序。在生产环境中，Deno KV 由
[FoundationDB](https://www.foundationdb.org/) 支持，后者是苹果创建的开源键值存储。

**运行使用 KV 的 Deno 程序在 Deploy 上无须额外配置** - 当你的代码需要时，会为你提供新的 Deploy 数据库。了解更多关于 Deno KV 在 Deno Deploy 上的信息 [这里](./on_deploy)。

## 测试

默认情况下，[`Deno.openKv()`](https://docs.deno.com/api/deno/~/Deno.openKv)
根据运行调用它的脚本的路径创建或打开一个持久存储。这通常不适合测试，因为测试需要在多次连续运行时产生相同的行为。

要测试使用 Deno KV 的代码，可以使用特殊参数 `":memory:"` 创建一个短暂的 Deno KV 数据存储。

```ts
async function setDisplayName(
  kv: Deno.Kv,
  username: string,
  displayname: string,
) {
  await kv.set(["preferences", username, "displayname"], displayname);
}

async function getDisplayName(
  kv: Deno.Kv,
  username: string,
): Promise<string | null> {
  return (await kv.get(["preferences", username, "displayname"]))
    .value as string;
}

Deno.test("Preferences", async (t) => {
  const kv = await Deno.openKv(":memory:");

  await t.step("可以设置 displayname", async () => {
    const displayName = await getDisplayName(kv, "example");
    assertEquals(displayName, null);

    await setDisplayName(kv, "example", "Exemplary User");

    const displayName = await getDisplayName(kv, "example");
    assertEquals(displayName, "Exemplary User");
  });
});
```

这可行是因为 Deno KV 在本地开发时由 SQLite 支持。就像内存 SQLite 数据库一样，多个短暂的 Deno KV 存储可以同时存在而互不干扰。有关特殊数据库寻址模式的更多信息，请参见
[SQLite 文档中的相关主题](https://www.sqlite.org/inmemorydb.html)。

## 下一步

到这里，你刚刚开始接触 Deno KV。确保查看我们关于 [Deno KV 键空间](./key_space) 的指南，以及 [这里](../tutorials/index.md) 的一系列 [教程和示例应用程序]。

---

# 键过期（键的 TTL）

URL: https://docs.deno.com/deploy/kv/manual/key_expiration


<deno-admonition></deno-admonition>

自版本 1.36.2 起，Deno KV 支持键过期，允许开发者控制 KV 数据库中键的生存时间（TTL）。这允许与一个键关联一个过期时间戳，在该时间戳之后，键将自动从数据库中删除：

```ts
const kv = await Deno.openKv();

// `expireIn` 是键过期的毫秒数。
function addSession(session: Session, expireIn: number) {
  await kv.set(["sessions", session.id], session, { expireIn });
}
```

键过期在 Deno CLI 和 Deno Deploy 上均得到支持。

## 原子性过期多个键

如果在同一原子操作中设置多个键并具有相同的 `expireIn` 值，则这些键的过期将具有原子性。例如：

```ts
const kv = await Deno.openKv();

function addUnverifiedUser(
  user: User,
  verificationToken: string,
  expireIn: number,
) {
  await kv.atomic()
    .set(["users", user.id], user, { expireIn })
    .set(["verificationTokens", verificationToken], user.id, { expireIn })
    .commit();
}
```

## 注意事项

过期时间戳指定了 _最早_ 可以从数据库中删除的时间。实现允许在指定时间戳之后的任何时间删除键，但不得在之前。如果您需要严格执行过期时间（例如出于安全目的），请将其作为值的一个字段添加，并在从数据库中检索到值后进行检查。

---

# 关键空间

URL: https://docs.deno.com/deploy/kv/manual/key_space


<deno-admonition></deno-admonition>

Deno KV 是一个键值存储。关键空间是一个扁平的命名空间，由键+值+版本戳对组成。键是键部分的序列，允许对分层数据进行建模。值是任意的 JavaScript 对象。版本戳表示值插入/修改的时间。

## 键

Deno KV 中的键是键部分的序列，这些部分可以是 `string`、`number`、`boolean`、`Uint8Array` 或 `bigint`。

使用一系列部分，而不是一个单一的字符串可以消除分隔符注入攻击的可能性，因为没有可见的分隔符。

> 键注入攻击发生在攻击者通过将键编码方案中使用的分隔符注入到用户控制的变量中，操纵键值存储的结构，导致意外行为或未经授权的访问。例如，考虑到一个使用斜杠 (/) 作为分隔符的键值存储，键如 "users/alice/settings" 和 "users/bob/settings"。攻击者可以创建一个名为 "alice/settings/hacked" 的新用户，从而形成键 "users/alice/settings/hacked/settings"，注入分隔符并操纵键结构。在 Deno KV 中，这种注入将导致键 `["users", "alice/settings/hacked", "settings"]`，这并不有害。

在键部分之间，使用不可见的分隔符来分隔这些部分。这些分隔符永远是不可见的，但确保一个部分不会与另一个部分混淆。例如，键部分 `["abc", "def"]`、`["ab", "cdef"]`、`["abc", "", "def"]` 都是不同的键。

键是区分大小写的，并按其部分以字典序排列。第一部分是最重要的，最后一部分是最不重要的。部分的顺序由部分的类型和数值共同决定。

### 键部分排序

键部分按类型的字典序排序，在给定类型内，按其值排序。类型的排序如下：

1. `Uint8Array`
1. `string`
1. `number`
1. `bigint`
1. `boolean`

在给定类型内，排序为：

- `Uint8Array`: 数组的字节排序
- `string`: 字符串的 UTF-8 编码的字节排序
- `number`: -Infinity < -1.0 < -0.5 < -0.0 < 0.0 < 0.5 < 1.0 < Infinity < NaN
- `bigint`: 数学排序，最大负数在前，最大正数在后
- `boolean`: false < true

这意味着部分 `1.0`（一个数字）的排序在部分 `2.0`（也是一个数字）之前，但大于部分 `0n`（一个 bigint），因为 `1.0` 是一个数字，而 `0n` 是一个 bigint，类型排序优先于在类型内的值排序。

### 键示例

```js
["users", 42, "profile"]; // ID 为 42 的用户的个人资料
["posts", "2023-04-23", "comments"]; // 2023-04-23 所有帖子评论
["products", "electronics", "smartphones", "apple"]; // 电子类别中的苹果智能手机
["orders", 1001, "shipping", "tracking"]; // 订单 ID 1001 的追踪信息
["files", new Uint8Array([1, 2, 3]), "metadata"]; // 带有 Uint8Array 标识符的文件元数据
["projects", "openai", "tasks", 5]; // OpenAI 项目中 ID 为 5 的任务
["events", "2023-03-31", "location", "san_francisco"]; // 2023-03-31 在旧金山的事件
["invoices", 2023, "Q1", "summary"]; // 2023 年 Q1 发票的摘要
["teams", "engineering", "members", 1n]; // 工程团队中 ID 为 1n 的成员
```

### 通用唯一字典序可排序标识符 (ULID)

键部分排序允许时间戳和 ID 部分组成的键按时间顺序列出。通常，你可以使用以下方式生成一个键：
[`Date.now()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now) 和
[`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID):

```js
async function setUser(user) {
  await kv.set(["users", Date.now(), crypto.randomUUID()], user);
}
```

连续运行多次，这将生成以下键：

```js
["users", 1691377037923, "8c72fa25-40ad-42ce-80b0-44f79bc7a09e"]; // 第一个用户
["users", 1691377037924, "8063f20c-8c2e-425e-a5ab-d61e7a717765"]; // 第二个用户
["users", 1691377037925, "35310cea-58ba-4101-b09a-86232bf230b2"]; // 第三个用户
```

然而，在某些情况下，将时间戳和 ID 表示在一个键部分中可能更直接。你可以使用一个
[通用唯一字典序可排序标识符 (ULID)](https://github.com/ulid/spec) 来做到这一点。这种标识符编码了 UTC 时间戳，字典序可排序，并且默认情况下是加密随机的：

```js
import { ulid } from "jsr:@std/ulid";

const kv = await Deno.openKv();

async function setUser(user) {
  await kv.set(["users", ulid()], user);
}
```

```js
["users", "01H76YTWK3YBV020S6MP69TBEQ"]; // 第一个用户
["users", "01H76YTWK4V82VFET9YTYDQ0NY"]; // 第二个用户
["users", "01H76YTWK5DM1G9TFR0Y5SCZQV"]; // 第三个用户
```

此外，你还可以使用 `monotonicUlid` 函数生成单调递增的 ULID：

```js
import { monotonicUlid } from "jsr:@std/ulid";

async function setUser(user) {
  await kv.set(["users", monotonicUlid()], user);
}
```

```js
// 对于同一时间戳进行严格排序，通过将最低有效随机位递增 1
["users", "01H76YTWK3YBV020S6MP69TBEQ"]; // 第一个用户
["users", "01H76YTWK3YBV020S6MP69TBER"]; // 第二个用户
["users", "01H76YTWK3YBV020S6MP69TBES"]; // 第三个用户
```

## 值

Deno KV 中的值可以是与 [结构化克隆算法][structured clone algorithm] 兼容的任意 JavaScript 值。这包括：

- `undefined`
- `null`
- `boolean`
- `number`
- `string`
- `bigint`
- `Uint8Array`
- `Array`
- `Object`
- `Map`
- `Set`
- `Date`
- `RegExp`

对象和数组可以包含上述任何类型，包括其他对象和数组。`Map` 和 `Set` 可以包含上述任何类型，包括其他 `Map` 和 `Set`。

值中的循环引用是支持的。

不支持具有非原始原型的对象（例如类实例或 Web API 对象）。函数和符号也不能被序列化。

### `Deno.KvU64` 类型

除了结构化可序列化值外，特殊值 `Deno.KvU64` 也被支持。这个对象表示一个 64 位无符号整数，以 bigint 形式表示。它可以与 `sum`、`min` 和 `max` KV 操作一起使用。它不能存储在对象或数组中。它必须作为顶级值存储。

可以通过 `Deno.KvU64` 构造函数创建：

```js
const u64 = new Deno.KvU64(42n);
```

### 值示例

```js,ignore
undefined;
null;
true;
false;
42;
-42.5;
42n;
"hello";
new Uint8Array([1, 2, 3]);
[1, 2, 3];
{ a: 1, b: 2, c: 3 };
new Map([["a", 1], ["b", 2], ["c", 3]]);
new Set([1, 2, 3]);
new Date("2023-04-23");
/abc/;

// 循环引用是支持的
const a = {};
const b = { a };
a.b = b;

// Deno.KvU64 是支持的
new Deno.KvU64(42n);
```

## 版本戳

Deno KV 键空间中的所有数据都是有版本的。每次插入或修改一个值时，会为其分配一个版本戳。版本戳是单调递增的、非顺序的、12 字节的值，表示值被修改的时间。版本戳并不表示实际时间，而是表示值被修改的顺序。

由于版本戳是单调递增的，因此可以用来判断某个值是否比另一个值更新。这可以通过比较两个值的版本戳来完成。如果版本戳 A 大于版本戳 B，则值 A 的修改时间比值 B 更新。

```js
versionstampA > versionstampB;
"000002fa526aaccb0000" > "000002fa526aacc90000"; // true
```

由单个事务修改的所有数据都被分配相同的版本戳。这意味着如果在同一原子操作中执行两个 `set` 操作，则新值的版本戳将是相同的。

版本戳用于实现乐观并发控制。原子操作可以包含检查，确保它们操作的数据的版本戳与传递给操作的版本戳匹配。如果数据的版本戳与传递给操作的版本戳不同，则事务将失败，操作将不被应用。

[结构化克隆算法]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm

---

# 在 Node.js 中使用 KV

URL: https://docs.deno.com/deploy/kv/manual/node


在 Node.js 中连接 Deno KV 数据库可以通过我们的
[官方客户端库在 npm 上](https://www.npmjs.com/package/@deno/kv)进行支持。您可以在下面找到此选项的使用说明。

## 安装和使用

使用您喜欢的 npm 客户端通过以下命令之一来安装 Node.js 的客户端库。

<deno-tabs group-id="npm-client">
<deno-tab value="npm" label="npm" default>

```sh
npm install @deno/kv
```

</deno-tab>
<deno-tab value="pnpm" label="pnpm">

```sh
pnpm add @deno/kv
```

</deno-tab>
<deno-tab value="yarn" label="yarn">

```sh
yarn add @deno/kv
```

</deno-tab>
</deno-tabs>

一旦您将包添加到 Node 项目中，就可以导入 `openKv` 函数（支持 ESM `import` 和 CJS `require` 基于的用法）：

```js
import { openKv } from "@deno/kv";

// 连接到一个 KV 实例
const kv = await openKv("<KV 连接 URL>");

// 写入一些数据
await kv.set(["users", "alice"], { name: "Alice" });

// 读取数据
const result = await kv.get(["users", "alice"]);
console.log(result.value); // { name: "Alice" }
```

默认情况下，用于身份验证的访问令牌来自 `DENO_KV_ACCESS_TOKEN` 环境变量。您也可以明确传递它：

```js
import { openKv } from "@deno/kv";

const kv = await openKv("<KV 连接 URL>", { accessToken: myToken });
```

一旦您的 Deno KV 客户端初始化，Deno 中可用的相同 API 也可以在 Node 中使用。

## KV 连接 URL

在 Deno 之外连接到 KV 数据库需要一个
[KV Connect](https://github.com/denoland/denokv/blob/main/proto/kv-connect.md)
URL。一个在 Deno Deploy 中托管的数据库的 KV 连接 URL 将是这种格式：`https://api.deno.com/databases/<database-id>/connect`。

您项目的 `database-id` 可以在
[Deno Deploy 仪表板](https://dash.deno.com/projects)中找到，在项目的 "KV" 标签下。

![Deploy 中连接字符串的位置](./images/kv-connect.png)

## 更多信息

有关如何在 Node 中使用 Deno KV 模块的更多信息可以在项目的 [README 页面](https://www.npmjs.com/package/@deno/kv)上找到。

---

# Deno Deploy 上的 KV

URL: https://docs.deno.com/deploy/kv/manual/on_deploy


<deno-admonition></deno-admonition>

Deno Deploy 现在提供一个内置的无服务器键值数据库，称为 Deno KV。

此外，Deno KV 也可以在 Deno 自身内部使用，利用 SQLite 作为其后端。自 Deno v1.32 起，这个功能在使用 `--unstable` 标志时可以访问。要了解更多关于 [Deno KV](/deploy/kv/manual) 的信息。

## 一致性

默认情况下，Deno KV 是一个强一致性的数据库。它提供了最严格的强一致性形式，称为 _外部一致性_，这意味着：

- **可序列化性**：这是事务的最高隔离级别。它确保多个事务的并发执行结果与这些事务按顺序逐个执行的系统状态相同。换句话说， 可序列化事务的最终结果相当于这些事务的某种顺序执行。
- **线性一致性**：这种一致性模型保证了操作（如读取和写入）看起来是瞬时的，并且实时发生。一旦写入操作完成，所有后续的读取操作将立即返回更新的值。线性一致性确保对操作的强实时排序，使得系统更可预测且更易于推理。

同时，您可以通过在单个读取操作上设置 `consistency: "eventual"` 选项来放宽一致性约束。此选项允许系统从全局副本和缓存中服务读取，以获取最小的延迟。

以下是我们主要区域的延迟数据：

| 区域                      | 延迟（最终一致性）  | 延迟（强一致性）         |
| ------------------------- | ------------------ | ------------------------ |
| 北弗吉尼亚 (us-east4)    | 7ms                | 7ms                      |
| 法兰克福 (europe-west3)  | 7ms                | 94ms                     |
| 荷兰 (europe-west4)      | 13ms               | 95ms                     |
| 加利福尼亚 (us-west2)    | 72ms               | 72ms                     |
| 香港 (asia-east2)        | 42ms               | 194ms                    |

## 分布式队列

无服务器的分布式队列在 Deno Deploy 上可用。有关更多详细信息，请参阅 [Deno Deploy 上的队列](/deploy/kv/manual/queue_overview#queues-on-deno-deploy)。

## 从 Deno Deploy 以外连接到托管数据库

您可以从 Deno Deploy 以外的 Deno 应用程序连接到您的 Deno Deploy KV 数据库。要打开一个托管数据库，请将 `DENO_KV_ACCESS_TOKEN` 环境变量设置为 Deno Deploy 个人访问令牌，并将数据库的 URL 提供给 `Deno.openKv`：

```ts
const kv = await Deno.openKv(
  "https://api.deno.com/databases/<database-id>/connect",
);
```

请查看
[文档](https://github.com/denoland/deno/tree/main/ext/kv#kv-connect)
了解远程 KV 数据库连接协议的规范。

## 数据分布

Deno KV 数据库在主要区域内的至少 3 个数据中心间进行复制。一旦写操作提交，其变更会持久存储在主要区域内的数据中心仲裁多数节点中。如果启用了跨区域复制，异步复制通常会在 5 秒内将变更传输到目标区域。

系统设计能够容忍大多数数据中心级别的故障，而不会出现停机或数据丢失。恢复点目标 (RPO) 与恢复时间目标 (RTO) 用于量化系统在不同故障模式下的弹性。RPO 表示可接受的数据最大丢失时间，RTO 表示在故障后恢复系统正常运行的最长时间。

- 主要区域内丢失一个数据中心：RPO=0（无数据丢失），RTO&lt;5秒（系统在 5 秒内恢复）
- 副本区域内丢失任意数量数据中心：RPO=0，RTO&lt;5秒
- 主要区域内丢失两个或更多数据中心：RPO&lt;60秒（数据丢失在 60 秒以内）

---

# 操作

URL: https://docs.deno.com/deploy/kv/manual/operations


<deno-admonition></deno-admonition>

Deno KV API 提供了一组可以在键空间上执行的操作。

有两个操作用于从存储中读取数据，还有五个操作用于将数据写入存储。

读取操作可以在强一致性模式或最终一致性模式下执行。强一致性模式保证读取操作会返回最近写入的值。最终一致性模式可能返回过期值，但速度更快。

写入操作始终在强一致性模式下执行。

## `get`

`get` 操作返回与给定键关联的值和版本戳。如果值不存在，get 将返回 `null` 值和版本戳。

可以使用两个 API 执行 `get` 操作。 [`Deno.Kv.prototype.get(key, options?)`][get] API，可以用来读取单个键，以及 [`Deno.Kv.prototype.getMany(keys, options?)`][getMany] API，可以用来一次读取多个键。

获取操作在所有一致性模式下都作为“快照读取”执行。这意味着在一次检索多个键时，返回的值将彼此一致。

```ts
const res = await kv.get<string>(["config"]);
console.log(res); // { key: ["config"], value: "value", versionstamp: "000002fa526aaccb0000" }

const res = await kv.get<string>(["config"], { consistency: "eventual" });
console.log(res); // { key: ["config"], value: "value", versionstamp: "000002fa526aaccb0000" }

const [res1, res2, res3] = await kv.getMany<[string, string, string]>([
  ["users", "sam"],
  ["users", "taylor"],
  ["users", "alex"],
]);
console.log(res1); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }
console.log(res2); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }
console.log(res3); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }
```

## `list`

`list` 操作返回与给定选择器匹配的键的列表。这些键关联的值和版本戳也会被返回。可以使用 2 个不同的选择器来过滤匹配的键。

`prefix` 选择器匹配所有以给定前缀键部分开头的键，但不包括精确匹配该键的情况。前缀选择器可以选择性地给定一个 `start` 或 `end` 键来限制返回的键的范围。`start` 键是包含的，`end` 键是不包含的。

`range` 选择器匹配所有在给定的 `start` 和 `end` 键之间的键。`start` 键是包含的，`end` 键是不包含的。

> 注意：在前缀选择器的情况下，`prefix` 键必须仅由完整（而非部分）键部分组成。例如，如果存储中存在键 `["foo", "bar"]`，则前缀选择器 `["foo"]` 将匹配它，但前缀选择器 `["f"]` 将不会。

list 操作可以选择性地给定一个 `limit` 来限制返回的键数量。

可以使用 [`Deno.Kv.prototype.list<string>(selector, options?)`][list] 方法执行列表操作。该方法返回一个 `Deno.KvListIterator`，可以用来遍历返回的键。这是一个异步迭代器，可以与 `for await` 循环一起使用。

```ts
// 返回所有用户
const iter = kv.list<string>({ prefix: ["users"] });
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }
console.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }
console.log(users[2]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }

// 返回前 2 个用户
const iter = kv.list<string>({ prefix: ["users"] }, { limit: 2 });
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }
console.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }

// 返回在 "taylor" 之后的所有用户
const iter = kv.list<string>({ prefix: ["users"], start: ["users", "taylor"] });
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }

// 返回在 "taylor" 之前的所有用户
const iter = kv.list<string>({ prefix: ["users"], end: ["users", "taylor"] });
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }
console.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }

// 返回 以 "a" 和 "n" 之间的字符开头的所有用户
const iter = kv.list<string>({ start: ["users", "a"], end: ["users", "n"] });
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }
```

list 操作从存储中批量读取数据。可以使用 `batchSize` 选项控制每批的大小。默认批大小是 500 个键。批内的数据在单个快照读取中读取，因此值彼此一致。一致性模式适用于每批读取的数据。在批次之间，数据是一致的。批次之间的边界从 API 中是不可见的，因为迭代器返回单个键。

list 操作可以通过将 `reverse` 选项设置为 `true` 来反向执行。这将返回以字母顺序降序排列的键。`start` 和 `end` 键仍然分别是包含和不包含的，并且仍然被解释为字母顺序升序。

```ts
// 以反向顺序返回所有用户，截止到 "sam"
const iter = kv.list<string>({ prefix: ["users"], start: ["users", "sam"] }, {
  reverse: true,
});
const users = [];
for await (const res of iter) users.push(res);
console.log(users[0]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }
console.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }
```

> 注意：在上述示例中，我们将 `start` 键设置为 `["users", "sam"]`，即使返回的第一个键是 `["users", "taylor"]`。这是因为 `start` 和 `end` 键始终以字母顺序升序评估，即使在以反向顺序执行列表操作时（返回的键按字母顺序降序）。

## `set`

`set` 操作在存储中设置键的值。如果键不存在，则创建该键。如果键已经存在，则其值将被覆盖。

可以使用 [`Deno.Kv.prototype.set(key, value)`][set] 方法执行 `set` 操作。该方法返回一个 `Promise`，解析为一个 `Deno.KvCommitResult` 对象，其中包含提交的 `versionstamp`。

set 操作始终在强一致性模式下执行。

```ts
const res = await kv.set(["users", "alex"], "alex");
console.log(res.versionstamp); // "00a44a3c3e53b9750000"
```

## `delete`

`delete` 操作从存储中删除一个键。如果该键不存在，则操作为无效操作。

可以使用 [`Deno.Kv.prototype.delete(key)`][delete] 方法执行 `delete` 操作。

删除操作始终在强一致性模式下执行。

```ts
await kv.delete(["users", "alex"]);
```

## `sum`

`sum` 操作原子地将一个值添加到存储中的一个键。如果该键不存在，则创建该键并设置为该值得和。如果该键已经存在，则其值将被添加到和中。

`sum` 操作只能作为原子操作的一部分执行。可以使用 [`Deno.AtomicOperation.prototype.mutate({ type: "sum", value })`][mutate] 方法将和变换添加到原子操作中。

sum 操作只能在类型为 `Deno.KvU64` 的值上执行。操作数和存储中的值必须都是类型为 `Deno.KvU64`。

如果键的新值大于 `2^64 - 1` 或小于 `0`，sum 操作将回绕。例如，如果存储中的值是 `2^64 - 1` 而操作数是 `1`，那么新值将为 `0`。

sum 操作始终在强一致性模式下执行。

```ts
await kv.atomic()
  .mutate({
    type: "sum",
    key: ["accounts", "alex"],
    value: new Deno.KvU64(100n),
  })
  .commit();
```

## `min`

`min` 操作原子地将键设置为其当前值和给定值中的最小值。如果该键不存在，则用给定值创建该键。如果该键已经存在，则其值将被设置为其当前值和给定值中的最小值。

`min` 操作只能作为原子操作的一部分执行。可以使用 [`Deno.AtomicOperation.prototype.mutate({ type: "min", value })`][mutate] 方法将最小值变换添加到原子操作中。

min 操作只能在类型为 `Deno.KvU64` 的值上执行。操作数和存储中的值必须都是类型为 `Deno.KvU64`。

min 操作始终在强一致性模式下执行。

```ts
await kv.atomic()
  .mutate({
    type: "min",
    key: ["accounts", "alex"],
    value: new Deno.KvU64(100n),
  })
  .commit();
```

## `max`

`max` 操作原子地将键设置为其当前值和给定值中的最大值。如果该键不存在，则用给定值创建该键。如果该键已经存在，则其值将被设置为其当前值和给定值中的最大值。

`max` 操作只能作为原子操作的一部分执行。可以使用 [`Deno.AtomicOperation.prototype.mutate({ type: "max", value })`][mutate] 方法将最大值变换添加到原子操作中。

max 操作只能在类型为 `Deno.KvU64` 的值上执行。操作数和存储中的值必须都是类型为 `Deno.KvU64`。

max 操作始终在强一致性模式下执行。

```ts
await kv.atomic()
  .mutate({
    type: "max",
    key: ["accounts", "alex"],
    value: new Deno.KvU64(100n),
  })
  .commit();
```

## `watch`

`watch` 操作接受一个键的数组，并返回一个 [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)，当任何被观察的键更改其 `versionstamp` 时，会发出一个新值。发出的值是一个
[Deno.KvEntryMaybe](https://docs.deno.com/api/deno/~/Deno.KvEntryMaybe) 对象的数组。

请注意，返回的流不会返回被观察的键的每个中间状态，而是让您与键的最新状态保持同步。这意味着如果一个键被快速多次修改，您可能不会收到每次变化的通知，而是会收到该键的最新状态。

```ts
const db = await Deno.openKv();

const stream = db.watch([["foo"], ["bar"]]);
for await (const entries of stream) {
  entries[0].key; // ["foo"]
  entries[0].value; // "bar"
  entries[0].versionstamp; // "00000000000000010000"
  entries[1].key; // ["bar"]
  entries[1].value; // null
  entries[1].versionstamp; // null
}
```

[get]: https://docs.deno.com/api/deno/~/Deno.Kv.prototype.get
[getMany]: https://docs.deno.com/api/deno/~/Deno.Kv.prototype.getMany
[list]: https://docs.deno.com/api/deno/~/Deno.Kv.prototype.list
[set]: https://docs.deno.com/api/deno/~/Deno.Kv.prototype.set
[delete]: https://docs.deno.com/api/deno/~/Deno.Kv.prototype.delete
[mutate]: https://docs.deno.com/api/deno/~/Deno.AtomicOperation.prototype.mutate

---

# 使用队列

URL: https://docs.deno.com/deploy/kv/manual/queue_overview


<deno-admonition></deno-admonition>

Deno 运行时包含一个队列 API，支持异步处理大型工作负载，并确保队列消息的至少一次投递。队列可以用于在 web 应用程序中卸载任务，或安排未来某个时间的工作单元。

您将使用的主要 API 在 `Deno.Kv` 命名空间中，分别是 [ `enqueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.enqueue) 和 [ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue)。

## 入队消息

要将消息入队以进行处理，请在一个 [`Deno.Kv`](https://docs.deno.com/api/deno/~/Deno.Kv) 实例上使用 `enqueue` 方法。在下面的示例中，我们展示了如何入队一个通知以便发送。

```ts title="queue_example.ts"
// 描述您的消息对象的形状（可选）
interface Notification {
  forUser: string;
  body: string;
}

// 获取 KV 实例的引用
const kv = await Deno.openKv();

// 创建一个通知对象
const message: Notification = {
  forUser: "alovelace",
  body: "您有邮件！",
};

// 将消息入队以进行立即投递
await kv.enqueue(message);
```

您可以通过指定一个延迟选项（以毫秒为单位）来将消息入队以便稍后投递。

```ts
// 将消息安排在 3 天后投递
const delay = 1000 * 60 * 60 * 24 * 3;
await kv.enqueue(message, { delay });
```

如果由于某种原因您的消息未被投递，您还可以指定一个 Deno KV 键，其中将存储您的消息值。

```ts
// 配置一个键以便发送未投递消息
const backupKey = ["failed_notifications", "alovelace", Date.now()];
await kv.enqueue(message, { keysIfUndelivered: [backupKey] });

// ... 灾难降临 ...

// 获取未发送的消息
const r = await kv.get<Notification>(backupKey);
// 这是未发送的消息：
console.log("找到未发送的通知给:", r.value?.forUser);
```

## 监听消息

您可以配置一个 JavaScript 函数，通过在一个 [`Deno.Kv`](https://docs.deno.com/api/deno/~/Deno.Kv) 实例上使用 `listenQueue` 方法来处理添加到队列中的项目。

```ts title="listen_example.ts"
// 定义我们期望的队列消息的对象形状
interface Notification {
  forUser: string;
  body: string;
}

// 创建一个类型保护来检查传入消息的类型
function isNotification(o: unknown): o is Notification {
  return (
    ((o as Notification)?.forUser !== undefined &&
      typeof (o as Notification).forUser === "string") &&
    ((o as Notification)?.body !== undefined &&
      typeof (o as Notification).body === "string")
  );
}

// 获取 KV 数据库的引用
const kv = await Deno.openKv();

// 注册一个处理函数以监听值 - 此示例展示
// 您如何发送通知
kv.listenQueue((msg: unknown) => {
  // 使用类型保护 - 然后 TypeScript 编译器知道 msg 是 Notification
  if (isNotification(msg)) {
    console.log("向用户发送通知:", msg.forUser);
    // ... 做一些实际发送通知的事情！
  } else {
    // 如果消息是未知类型，可能是一个错误
    console.error("收到未知消息:", msg);
  }
});
```

## 带有 KV 原子事务的队列 API

您可以将队列 API 与 [KV 原子事务](./transactions) 结合，以在同一事务中原子地入队消息和修改键。

```ts title="kv_transaction_example.ts"
const kv = await Deno.openKv();

kv.listenQueue(async (msg: unknown) => {
  const nonce = await kv.get(["nonces", msg.nonce]);
  if (nonce.value === null) {
    // 这条消息已经被处理
    return;
  }

  const change = msg.change;
  const bob = await kv.get(["balance", "bob"]);
  const liz = await kv.get(["balance", "liz"]);

  const success = await kv.atomic()
    // 确保这条消息尚未被处理
    .check({ key: nonce.key, versionstamp: nonce.versionstamp })
    .delete(nonce.key)
    .sum(["processed_count"], 1n)
    .check(bob, liz) // 余额没有变化
    .set(["balance", "bob"], bob.value - change)
    .set(["balance", "liz"], liz.value + change)
    .commit();
});

// 在同一 KV 事务中修改键并入队消息！
const nonce = crypto.randomUUID();
await kv
  .atomic()
  .check({ key: ["nonces", nonce], versionstamp: null })
  .enqueue({ nonce: nonce, change: 10 })
  .set(["nonces", nonce], true)
  .sum(["enqueued_count"], 1n)
  .commit();
```

## 队列行为

### 消息投递保证

运行时保证至少一次投递。这意味着对于大多数入队消息，[ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue) 处理程序将针对每条消息调用一次。在某些故障场景中，处理程序可能会多次调用同一消息以确保投递。重要的是要设计您的应用程序，以便能够正确处理重复消息。

您可以将队列与 [KV 原子事务](https://docs.deno.com/deploy/kv/manual/transactions) 原语结合使用，以确保您的队列处理程序 KV 更新仅针对每个消息执行一次。请参阅 [带有 KV 原子事务的队列 API](#queue-api-with-kv-atomic-transactions)。

### 自动重试

当队列消息准备投递时，`[listenQueue](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue)` 处理程序被调用以处理您的入队消息。如果您的处理程序抛出异常，运行时将自动重试调用处理程序，直到成功或达到最大重试次数。消息被认为已成功处理，一旦 [ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue) 处理程序调用成功完成。如果处理程序在重试时持续失败，消息将被丢弃。

### 消息投递顺序

运行时尽量按照入队顺序投递消息。但是，没有严格的顺序保证。偶尔，为了确保最大吞吐量，消息可能会被无序投递。

## Deno Deploy 中的队列

Deno Deploy 提供了全球范围内、无服务器、分布式的队列 API 实现，旨在提供高可用性和高吞吐量。您可以使用它构建能够处理大工作负载的应用程序。

### 按需快速启动孤立环境

在使用 Deno Deploy 的队列时，将根据需要自动快速启动孤立环境，以在消息可用于处理时调用您的 [ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue) 处理程序。定义 [ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue) 处理程序是启用队列处理的唯一要求，无需其他配置。

### 队列大小限制

未投递队列消息的最大数量限制为 100,000。当队列已满时， [ `enqueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.enqueue) 方法将失败并返回错误。

### 定价细节和限制

- [ `enqueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.enqueue) 与其他 [ `Deno.Kv`](https://docs.deno.com/api/deno/~/Deno.Kv) 写入操作一样对待。 入队的消息会占用 KV 存储和写入单位。
- 通过 [ `listenQueue`](https://docs.deno.com/api/deno/~/Deno.Kv.prototype.listenQueue) 发送的消息会消耗请求和 KV 写入单位。
- 有关更多信息，请参见 [定价细节](https://deno.com/deploy/pricing)。

## 用例 

队列在许多不同场景中都很有用，但在构建 web 应用程序时您可能会看到的一些用例有：

### 卸载异步进程

有时，客户发起的任务（例如发送通知或 API 请求）可能会花费较长时间，因此您不希望让客户在返回响应之前等待该任务完成。其他时候，客户其实根本不需要响应，例如，当客户向您的应用程序发送 [webhook 请求](https://en.wikipedia.org/wiki/Webhook) 时，因此没有必要在返回响应之前等待底层任务完成。

在这些情况下，您可以将工作卸载到队列中，以保持您的 web 应用程序响应并向客户发送即时反馈。要查看此用例的实际示例，请查看我们的 [webhook 处理示例](../tutorials/webhook_processor.md)。

### 为未来调度工作

队列的另一个有用应用（以及类似这种的队列 API）是安排在未来适当时间进行的工作。也许您想在新客户下单后的一天发送通知，以便向他们发送满意度调查。您可以安排一个队列消息在 24 小时后投递，并设置一个监听器在那个时候发送出通知。

要查看安排未来发送通知的示例，请查看我们的 [通知示例](../tutorials/schedule_notification.md)。

---

# 二级索引

URL: https://docs.deno.com/deploy/kv/manual/secondary_indexes


<deno-admonition></deno-admonition>

像 Deno KV 这样的键值存储将数据组织为键值对的集合，其中每个唯一的键都与单个值关联。这样的结构使得可以根据键轻松检索值，但不允许根据值本身进行查询。为了克服这一限制，您可以创建二级索引，它在包含（部分）该值的附加键下存储相同的值。

在使用二级索引时，保持主键与二级键之间的一致性至关重要。如果在主键处更新了一个值，但没有在二级键处更新，则通过针对二级键的查询返回的数据将是不正确的。为了确保主键和二级键始终表示相同的数据，在插入、更新或删除数据时使用原子操作。这种方法确保一组变更操作作为一个单元执行，或者全部成功或者全部失败，从而防止不一致。

## 唯一索引（一对一）

唯一索引将索引中的每个键与确切的一个主键关联。例如，当存储用户数据并通过唯一的 ID 和电子邮件地址查找用户时，可以将用户数据存储在两个单独的键下：一个用于主键（用户 ID），另一个用于二级索引（电子邮件）。这种设置允许根据用户的 ID 或电子邮件查询用户。二级索引还可以对存储中的值施加唯一性约束。在用户数据的例子中，使用该索引确保每个电子邮件地址只与一个用户关联——换句话说，确保电子邮件是唯一的。

要实现这个例子的唯一二级索引，请按照以下步骤操作：

1. 创建一个表示数据的 `User` 接口：

   ```ts
   interface User {
     id: string;
     name: string;
     email: string;
   }
   ```

2. 定义一个 `insertUser` 函数，在主键和二级键上存储用户数据：

   ```ts
   async function insertUser(user: User) {
     const primaryKey = ["users", user.id];
     const byEmailKey = ["users_by_email", user.email];
     const res = await kv.atomic()
       .check({ key: primaryKey, versionstamp: null })
       .check({ key: byEmailKey, versionstamp: null })
       .set(primaryKey, user)
       .set(byEmailKey, user)
       .commit();
     if (!res.ok) {
       throw new TypeError("ID 或电子邮件已存在的用户");
     }
   }
   ```

   > 该函数使用原子操作进行插入，检查没有具有相同 ID 或电子邮件的用户存在。如果违反其中任何一项约束，插入将失败且不会修改任何数据。

3. 定义一个 `getUser` 函数，根据用户 ID 检索用户：

   ```ts
   async function getUser(id: string): Promise<User | null> {
     const res = await kv.get<User>(["users", id]);
     return res.value;
   }
   ```

4. 定义一个 `getUserByEmail` 函数，通过电子邮件地址检索用户：

   ```ts
   async function getUserByEmail(email: string): Promise<User | null> {
     const res = await kv.get<User>(["users_by_email", email]);
     return res.value;
   }
   ```

   该函数使用二级键进行存储查询
   （`["users_by_email", email]`）。

5. 定义一个 `deleteUser` 函数，通过用户 ID 删除用户：

   ```ts
   async function deleteUser(id: string) {
     let res = { ok: false };
     while (!res.ok) {
       const getRes = await kv.get<User>(["users", id]);
       if (getRes.value === null) return;
       res = await kv.atomic()
         .check(getRes)
         .delete(["users", id])
         .delete(["users_by_email", getRes.value.email])
         .commit();
     }
   }
   ```

   > 该函数首先通过用户 ID 检索用户，以获取用户的电子邮件地址。这是获取用户地址的二级索引键所需的。然后执行原子操作，检查数据库中的用户未更改，并删除指向用户值的主键和二级键。如果此操作失败（用户在查询和删除之间被修改），则原子操作将中止。整个过程将重试直到删除成功。检查是必需的，以防止在检索和删除之间值被修改的竞争条件。如果更新更改了用户的电子邮件，则会发生这种竞争，因为在这种情况下二级索引发生变化。然后二级索引的删除将失败，因为删除的目标是旧的二级索引键。

## 非唯一索引（一对多）

非唯一索引是二级索引，其中单个键可以与多个主键关联，使您能够根据共享属性查询多个项目。例如，当根据用户的最爱颜色查询用户时，可以使用非唯一二级索引来实现。最爱颜色是一个非唯一属性，因为多个用户可以拥有相同的最爱颜色。

要为这个例子实现一个非唯一二级索引，请按照以下步骤操作：

1. 定义 `User` 接口：

   ```ts
   interface User {
     id: string;
     name: string;
     favoriteColor: string;
   }
   ```

2. 定义 `insertUser` 函数：

   ```ts
   async function insertUser(user: User) {
     const primaryKey = ["users", user.id];
     const byColorKey = [
       "users_by_favorite_color",
       user.favoriteColor,
       user.id,
     ];
     await kv.atomic()
       .check({ key: primaryKey, versionstamp: null })
       .set(primaryKey, user)
       .set(byColorKey, user)
       .commit();
   }
   ```

3. 定义一个函数，根据用户的最爱颜色检索用户：

   ```ts
   async function getUsersByFavoriteColor(color: string): Promise<User[]> {
     const iter = kv.list<User>({ prefix: ["users_by_favorite_color", color] });
     const users = [];
     for await (const { value } of iter) {
       users.push(value);
     }
     return users;
   }
   ```

这个例子演示了非唯一二级索引的使用，
`users_by_favorite_color`，该索引允许根据用户的最爱颜色进行查询。主键仍然是用户的 `id`。

唯一索引和非唯一索引的实现主要区别在于二级键的结构和组织。在唯一索引中，每个二级键与确切的一个主键关联，确保索引属性在所有记录中是唯一的。在非唯一索引的情况下，单个二级键可以与多个主键关联，因为索引属性可能在多个记录中共享。为了实现这一点，非唯一二级键通常以附加的唯一标识符（例如主键）作为键的一部分来构建，从而允许多个具有相同属性的记录共存，而不会发生冲突。

---

# 事务

URL: https://docs.deno.com/deploy/kv/manual/transactions


<deno-admonition></deno-admonition>

Deno KV 存储利用 _乐观并发控制事务_，而不是像 PostgreSQL 或 MySQL 等许多 SQL 系统那样使用 _交互式事务_。这种方法使用版本戳来表示给定键的值的当前版本，通过不使用锁的方式来管理对共享资源的并发访问。当发生读取操作时，系统除了返回相关键的值外，还会返回一个版本戳。

要执行事务，可以执行一个原子操作，该操作可以包含多个变更操作（例如设置或删除）。与这些操作一起，提供键+版本戳对作为事务成功的条件。乐观并发控制事务只有在指定的版本戳与数据库中对应键的值的当前版本匹配时才会提交。这种事务模型在允许 Deno KV 存储中的并发交互的同时，确保了数据的一致性和完整性。

由于 OCC 事务是乐观的，它们在提交时可能会失败，因为原子操作中指定的版本约束被违反。这发生在代理在读取和提交之间更新了事务中使用的键。当这种情况发生时，执行事务的代理必须重试事务。

为了说明如何在 Deno KV 中使用 OCC 事务，下面的例子展示了如何实现一个 `transferFunds(from: string, to: string, amount: number)` 函数用于账户分类账。账户分类账在键值存储中存储每个账户的余额。键前缀为 `"account"`，后跟账户标识符：`["account", "alice"]`。为每个键存储的值是一个表示账户余额的数字。

以下是实现 `transferFunds` 函数的逐步示例：

```ts
async function transferFunds(sender: string, receiver: string, amount: number) {
  if (amount <= 0) throw new Error("金额必须为正数");

  // 构造发送者和接收者账户的 KV 键。
  const senderKey = ["account", sender];
  const receiverKey = ["account", receiver];

  // 重试事务直到成功。
  let res = { ok: false };
  while (!res.ok) {
    // 读取两个账户的当前余额。
    const [senderRes, receiverRes] = await kv.getMany([senderKey, receiverKey]);
    if (senderRes.value === null) {
      throw new Error(`未找到账户 ${sender}`);
    }
    if (receiverRes.value === null) {
      throw new Error(`未找到账户 ${receiver}`);
    }

    const senderBalance = senderRes.value;
    const receiverBalance = receiverRes.value;

    // 确保发送者有足够的余额来完成转账。
    if (senderBalance < amount) {
      throw new Error(
        `账户 ${sender} 的余额不足以转账 ${amount}`,
      );
    }

    // 执行转账。
    const newSenderBalance = senderBalance - amount;
    const newReceiverBalance = receiverBalance + amount;

    // 尝试提交事务。如果事务由于检查失败而无法提交，`res` 返回一个对象，包含 `ok: false`
    // （即键的版本戳已更改）
    res = await kv.atomic()
      .check(senderRes) // 确保发送者的余额没有改变。
      .check(receiverRes) // 确保接收者的余额没有改变。
      .set(senderKey, newSenderBalance) // 更新发送者的余额。
      .set(receiverKey, newReceiverBalance) // 更新接收者的余额。
      .commit();
  }
}
```

在这个例子中，`transferFunds` 函数读取两个账户的余额和版本戳，计算转账后的新余额，并检查账户 A 是否有足够的资金。然后，它执行一个原子操作，使用版本戳约束设置新的余额。如果事务成功，循环退出。如果版本约束被违反，事务失败，循环重试事务直到成功。

## 限制

除了最大键大小为 2 KiB 和最大值大小为 64 KiB 外，Deno KV 事务 API 还有一些特定的限制：

- **每个 `kv.getMany()` 的最大键数**：10
- **每个 `kv.list()` 的最大批处理大小**：1000
- **原子操作中的最大检查数**：100
- **原子操作中的最大变更数**：1000
- **原子操作的最大总大小**：800 KiB。包括所有键和值的检查和变更，以及编码开销也算入此限制。
- **键的最大总大小**：90 KiB。包括所有键的检查和变更，以及编码开销也算入此限制。
- **每个 `kv.watch()` 的最大监视键数**：10

---

# Deno KV 教程与示例

URL: https://docs.deno.com/deploy/kv/tutorials/


查看这些展示 Deno KV 实际使用的示例。

## 使用队列处理传入的 Webhook

按照 [本教程](./webhook_processor.md) 学习如何使用队列将任务分配到后台进程，这样您的 Web 应用可以保持响应。这个示例展示了如何将处理来自 [GitHub](https://www.github.com) 的传入 Webhook 请求的任务加入队列。

## 使用队列安排未来的通知

按照 [本教程](./schedule_notification.md) 学习如何使用队列安排代码在未来某个时间执行。这个示例展示了如何使用 [Courier](https://www.courier.com/) 安排通知。

## Deno KV 中的 CRUD - TODO 列表

- Zod 模式验证
- 基于 Fresh 构建
- 使用 BroadcastChannel 进行实时协作
- [源代码](https://github.com/denoland/showcase_todo)
- [实时预览](https://showcase-todo.deno.dev/)

## Deno SaaSKit

- 基于 Fresh 构建的现代 SaaS 模板。
- 完全基于 KV 构建的类似于 [Product Hunt](https://www.producthunt.com/) 的模板。
- 使用 Deno KV OAuth 进行 GitHub OAuth 2.0 身份验证
- 用于更快地启动您的下一个应用项目
- [源代码](https://github.com/denoland/saaskit)
- [实时预览](https://hunt.deno.land/)

## 多人井字棋

- GitHub 身份验证
- 保存用户状态
- 使用 BroadcastChannel 进行实时同步
- [源代码](https://github.com/denoland/tic-tac-toe)
- [实时预览](https://tic-tac-toe-game.deno.dev/)

## 多用户像素艺术绘画

- 持久的画布状态
- 多用户协作
- 使用 BroadcastChannel 进行实时同步
- [源代码](https://github.com/denoland/pixelpage)
- [实时预览](https://pixelpage.deno.dev/)

## GitHub 身份验证与 KV

- 在 KV 中存储绘画
- GitHub 身份验证
- [源代码](https://github.com/hashrock/kv-sketchbook)
- [实时预览](https://hashrock-kv-sketchbook.deno.dev/)

## Deno KV oAuth 2

- 由 Deno KV 提供支持的高层次 OAuth 2.0
- [源代码](https://github.com/denoland/deno_kv_oauth)
- [实时预览](https://kv-oauth.deno.dev/)

---

# 为未来日期安排通知

URL: https://docs.deno.com/deploy/kv/tutorials/schedule_notification


一个常见的用例是使用 [队列](../manual/queue_overview.md) 来安排在未来某个时间完成的工作。为了帮助演示这一过程，我们提供了一个示例应用（在下面描述），该应用通过 [Courier API](https://www.courier.com/) 安排发送通知消息。该应用运行在 [Deno Deploy](https://deno.com/deploy) 上，利用那里的内置 KV 和队列 API 实现，配置为零。

## 下载和配置示例

⬇️
[**在这里下载或克隆完整的示例应用**](https://github.com/kwhinnery/deno_courier_example)。

您可以使用 GitHub 仓库中的
[`README` 文件](https://github.com/kwhinnery/deno_courier_example) 中的说明，自己运行和部署这个示例应用。

要运行上述示例应用，您还需要
[注册 Courier](https://app.courier.com/signup)。当然，您在应用中看到的技术同样适用于任何通知服务，从 [Amazon SNS](https://aws.amazon.com/sns/) 到
[Twilio](https://www.twilio.com)，但是 Courier 提供了一个易于使用的
通知 API，您可以用个人 GMail 账户进行测试（除了它可以做的所有其他有趣的事情）。

## 主要功能

在设置和运行项目后，我们希望您关注代码中的几个关键部分，这些部分实现了调度机制。

### 在应用启动时连接到 KV 并添加监听器

示例应用的大部分功能位于
[server.tsx](https://github.com/kwhinnery/deno_courier_example/blob/main/server.tsx)
的顶级目录中。当 Deno 应用进程启动时，它会创建一个与 Deno KV 实例的连接，并附加一个事件处理程序，该处理程序将处理从队列接收到的消息。

```ts title="server.tsx"
// 创建 Deno KV 数据库引用
const kv = await Deno.openKv();

// 创建一个队列监听器，用于处理入队消息
kv.listenQueue(async (message) => {
  /* ... 监听器的实现 ... */
});
```

### 创建和调度通知

在通过该演示应用中的表单提交新订单后，将调用 `enqueue` 函数，延迟五秒后发送通知邮件。

```ts title="server.tsx"
app.post("/order", async (c) => {
  const { email, order } = await c.req.parseBody();
  const n: Notification = {
    email: email as string,
    body: `收到订单："${order as string}"`,
  };

  // 选择未来的时间 - 目前只等待 5 秒
  const delay = 1000 * 5;

  // 将消息入队进行处理！
  kv.enqueue(n, { delay });

  // 用成功消息重定向回首页！
  setCookie(c, "flash_message", "订单创建成功！");
  return c.redirect("/");
});
```

### 在 TypeScript 中定义通知数据类型

在将数据推入或推出队列时，通常希望使用强类型对象。虽然队列消息最初是一个
[`unknown`](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
TypeScript 类型，但我们可以使用
[类型保护](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) 来告诉编译器我们期望的数据形状。

以下是
[通知模块的源代码](https://github.com/kwhinnery/deno_courier_example/blob/main/notification.ts)，
我们用它来描述我们系统中通知的属性。

```ts title="notification.ts"
// 通知对象的形状
export default interface Notification {
  email: string;
  body: string;
}

// 通知对象的类型保护
export function isNotification(o: unknown): o is Notification {
  return (
    ((o as Notification)?.email !== undefined &&
      typeof (o as Notification).email === "string") &&
    ((o as Notification)?.body !== undefined &&
      typeof (o as Notification).body === "string")
  );
}
```

在 `server.tsx` 中，我们使用导出的类型保护来确保我们响应正确的消息类型。

```ts title="server.tsx"
kv.listenQueue(async (message) => {
  // 使用类型保护在消息类型错误时提前中断
  if (!isNotification(message)) return;

  // 从消息中获取相关数据，TypeScript 现在知道
  // 这是一个 Notification 接口
  const { email, body } = message;

  // 使用 Courier 创建一条电子邮件通知
  // ...
});
```

### 发送 Courier API 请求

为了按计划发送电子邮件，我们使用 Courier REST API。有关 Courier REST API 的更多信息，请参见
[他们的参考文档](https://www.courier.com/docs/reference/send/message/)。

```ts title="server.tsx"
const response = await fetch("https://api.courier.com/send", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${COURIER_API_TOKEN}`,
  },
  body: JSON.stringify({
    message: {
      to: { email },
      content: {
        title: "新订单由 Deno 提交！",
        body: "通知内容在这里",
      },
    },
  }),
});
```

---

# 将 webhook 处理 offload 到队列

URL: https://docs.deno.com/deploy/kv/tutorials/webhook_processor


在网络应用中，通常希望将异步任务的处理（客户端不需要立即响应的任务）offload 到一个队列中。这样可以保持你的网络应用快速响应，而不是占用宝贵的资源等待长时间运行的进程完成。

一个你可能想要部署此技术的实例是[处理 webhooks](https://en.wikipedia.org/wiki/Webhook)。当收到来自不需要响应的非人类客户端的 webhook 请求时，您可以立即将该工作 offload 到一个队列中，在那里可以更有效地处理。

在本教程中，我们将向您展示如何在[处理 GitHub 仓库的 webhook 请求](https://docs.github.com/en/webhooks/about-webhooks-for-repositories)时执行此技术。

## 在 playground 中尝试

✏️
[**查看这个 playground，它实现了一个 GitHub 仓库的 webhook 处理程序**](https://dash.deno.com/playground/github-webhook-example)。

使用 Deno Deploy [playgrounds](/deploy/manual/playgrounds)，您可以立即部署自己的 GitHub webhook 处理程序，该处理程序同时使用队列和 Deno KV。我们将在稍后介绍这个代码的作用。

## 为一个仓库配置 GitHub webhooks

要尝试您刚刚在 playground 中启动的 webhook，请为您控制的 GitHub 仓库设置一个新的 webhook 配置。您可以在仓库的“设置”下找到 webhook 配置。

![配置 GitHub webhook](./images/github_webhook.png)

## 代码逐步讲解

我们的 webhook 处理程序函数相对简单——没有注释时，它总共有 23 行代码。它连接到一个 Deno KV 数据库，设置一个队列侦听器以处理传入的消息，并使用 [`Deno.serve`](https://docs.deno.com/api/deno/~/Deno.serve) 设置一个简单的服务器，该服务器响应传入的 webhook 请求。

请按照下面的注释逐步了解每个步骤在做什么。

```ts title="server.ts"
// 获取 Deno KV 数据库实例的句柄。KV 是内置于 Deno
// 运行时中的，可在本地和 Deno Deploy 上零配置访问
const kv = await Deno.openKv();

// 设置一个侦听器来处理从我们的服务器 offload 的工作。
// 在这个例子中，它只是将传入的 webhook 负载添加到 KV
// 数据库中，并带有时间戳。
kv.listenQueue(async (message) => {
  await kv.set(["github", Date.now()], message);
});

// 这是一个简单的 HTTP 服务器，将处理来自
// GitHub webhooks 的传入 POST 请求。
Deno.serve(async (req: Request) => {
  if (req.method === "POST") {
    // GitHub 将 webhook 请求作为 POST 请求发送到您的服务器。您可以
    // 配置 GitHub 以在 POST 正文中发送 JSON，您可以从
    // 请求对象解析。
    const payload = await req.json();
    await kv.enqueue(payload);
    return new Response("", { status: 200 });
  } else {
    // 如果服务器处理 GET 请求，这将列出所有记录的
    // webhook 事件，在我们的 KV 数据库中。
    const iter = kv.list<string>({ prefix: ["github"] });
    const github = [];
    for await (const res of iter) {
      github.push({
        timestamp: res.key[1],
        payload: res.value,
      });
    }
    return new Response(JSON.stringify(github, null, 2));
  }
});
```

---

# 可接受使用政策

URL: https://docs.deno.com/deploy/manual/acceptable-use-policy


Deno Deploy 服务包含资源（CPU 时间，请求次数），这些资源受此可接受使用政策的约束。本文档可以大致估算我们认为的“可接受使用”以及我们不接受的使用情况。

### 可接受使用的例子

- ✅ 服务器端渲染的网站
- ✅ Jamstack 网站和应用
- ✅ 单页面应用程序
- ✅ 查询数据库或外部 API 的 API
- ✅ 个人博客
- ✅ 公司网站
- ✅ 电子商务网站
- ✅ 反向代理

### 不可接受的使用

- ❌ 加密货币挖矿
- ❌ 高 CPU 密集型负载（例如机器学习）
- ❌ 外部网站的媒体托管
- ❌ 网络爬虫
- ❌ 正向代理
- ❌ 虚拟私人网络 (VPN)

## 指导方针

我们期望大多数项目能够很好地控制在使用限制范围内。如果您的项目使用情况明显偏离正常水平，我们将通知您。在采取任何措施解决我们基础设施上不合理负担之前，我们会在可能的情况下与您联系。

---

# CI 和 GitHub Actions

URL: https://docs.deno.com/deploy/manual/ci_github


Deno Deploy 的 Git 集成功能允许部署推送到 GitHub 仓库的代码更改。在生产分支上的提交将作为生产部署进行部署。所有其他分支上的提交将作为预览部署进行部署。

Git 集成有两种操作模式：

- **自动**：每次你推送时，Deno Deploy 会自动从你的仓库源拉取代码和资产，并进行部署。此模式非常快速，但不允许进行构建步骤。_这是大多数用户推荐的模式。_
- **GitHub Actions**：在此模式下，你可以从 GitHub Actions 工作流将代码和资产推送到 Deno Deploy。这允许你在部署之前执行构建步骤。

根据你的自定义部署配置，Deno Deploy 会选择合适的模式。下面，我们将更详细地介绍 **自动** 和 **GitHub Actions** 模式的不同配置。

## 自动

如果你的项目不需要任何额外的构建步骤，则系统会选择 **自动** 模式。入口文件仅仅是 Deno Deploy 将运行的文件。

## GitHub Actions

如果在 **项目配置** 的 **安装步骤** 和/或 **构建步骤** 中输入了命令，Deno Deploy 将创建一个必要的 GitHub Actions 工作流文件并推送到你的仓库。在这个工作流文件中，我们利用 `deployctl` [Github action][deploy-action] 来部署你的项目。在将其部署到 Deno Deploy 之前，你可以执行任何所需的操作，例如运行构建命令。

要配置你想要运行的预处理命令，点击选择你的 git 仓库后出现的 **显示高级选项** 按钮。然后根据需要在输入框中输入相应的值。

:::tip

例如，如果你想为 Fresh 项目启用 [提前构建]，你将在 **构建步骤** 框中输入 `deno task build`。

另请参阅 [Fresh 文档][Deploy to production]，了解如何将 Fresh 项目部署到 Deno Deploy。

:::

Deno Deploy 生成并推送到你的仓库的 GitHub Actions 工作流文件如下所示。

```yml title=".github/workflows/deploy.yml"
name: Deploy
on:
  push:
    branches: main
  pull_request:
    branches: main

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest

    permissions:
      id-token: write # Deno Deploy 认证所需
      contents: read # 克隆仓库所需

    steps:
      - name: Clone repository
        uses: actions/checkout@v4

      - name: Install Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Build step
        run: "deno task build"

      - name: Upload to Deno Deploy
        uses: denoland/deployctl@v1
        with:
          project: "<your-project-name>"
          entrypoint: "main.ts"
          root: "."
```

有关更多详细信息，请参见 [deployctl README](https://github.com/denoland/deployctl/blob/main/action/README.md)。

[fileserver]: https://jsr.io/@std/http#file-server
[ghapp]: https://github.com/apps/deno-deploy
[deploy-action]: https://github.com/denoland/deployctl/blob/main/action/README.md
[ahead-of-time builds]: https://fresh.deno.dev/docs/concepts/ahead-of-time-builds
[Deploy to production]: https://fresh.deno.dev/docs/getting-started/deploy-to-production

---

# 自定义域名

URL: https://docs.deno.com/deploy/manual/custom-domains


默认情况下，项目可以通过其预览URL访问，格式为 `$PROJECT_ID.deno.dev`，例如 `dead-clam-55.deno.dev`。您还可以按照下面的说明添加自定义域名。

## **步骤 1：** 在 Deno Deploy 控制面板中添加您的自定义域名

1. 在项目页面上点击 "设置" 按钮，然后从侧边栏选择 "域名"。
2. 输入您希望添加到项目中的域名，然后按 "添加"。请注意，您必须拥有要添加到该项目的域名。如果您尚未拥有域名，可以在 Google Domains、Namecheap 或 gandi.net 等域名注册商处注册一个。
   ![add_custom_domain](../docs-images/add_custom_domain.png)

3. 域名将被添加到域名列表中，并会显示 "设置" 标签。
4. 点击 "设置" 标签以访问域名设置页面，该页面将显示需要为您的域名创建/更新的 DNS 记录列表。
   ![dns_records_modal](../docs-images/dns_records_modal.png)

## **步骤 2：** 更新您的自定义域名的 DNS 记录

前往您的域名注册商的 DNS 配置面板（或您用于管理 DNS 的服务），并按照域名设置页面上的描述输入记录。

![change_dns_records](../docs-images/change_dns_records.png)

## **步骤 3：** 验证 DNS 记录是否已更新

返回 Deno Deploy 控制面板，点击域名设置页面上的 **验证** 按钮。它将检查 DNS 记录是否正确设置，如果是，将状态更新为 "已验证，等待证书配置。"

![get_certificates](../docs-images/get_certificates.png)

## **步骤 4：** 为您的自定义域名配置证书

此时，您有两个选择。99% 的情况下，您应该选择第一个选项。

1. 让我们自动配置一个证书，使用 Let's Encrypt。

   为此，请按 **获取自动证书** 按钮。配置 TLS 证书可能需要最多一分钟。如果您的域名指定了 CAA 记录，阻止 [Let's Encrypt](https://letsencrypt.org/) 配置证书，则可能会导致配置失败。证书将在过期前大约 30 天自动续期。当您成功颁发证书时，您将看到一个绿色复选标记，如下所示：

   ![green_check](../docs-images/green_check.png)

2. 手动上传证书和私钥。

   要手动上传证书链和私钥，请按 **上传您自己的证书** 按钮。系统将提示您上传证书链和私钥。证书链需要完整且有效，并且您的叶证书需要位于链的顶部。

---

# 在命令行中使用 deployctl

URL: https://docs.deno.com/deploy/manual/deployctl


`deployctl` 是一个命令行工具 (CLI)，允许你在不离开终端的情况下操作 Deno Deploy 平台。使用它，你可以部署代码、创建和管理项目及其部署，并监控使用情况和日志。

## 依赖项

`deployctl` 的唯一依赖是 Deno 运行时。你可以通过运行以下命令进行安装：

```sh
curl -fsSL https://deno.land/install.sh | sh
```

在部署你的第一个项目之前，你无需先设置 Deno Deploy 账户。账户将在你部署第一个项目的过程中自动创建。

## 安装 `deployctl`

安装 Deno 运行时后，你可以使用以下命令安装 `deployctl` 工具：

```sh
deno install -gArf jsr:@deno/deployctl
```

在 deno install 命令中，`-A` 选项赋予已安装脚本所有权限。你可以选择不使用它，在这种情况下，当工具执行时，会提示你授予必要的权限。

## 部署

要对你的代码进行新部署，请导航到项目的根目录并执行：

```shell
deployctl deploy
```

### 项目和入口点

如果这是项目的第一次部署，`deployctl` 将根据其所在的 Git 仓库或目录推测项目名称。同样，它会通过查找具有常见入口点名称的文件（如 `main.ts`、`src/main.ts` 等）来推测入口点。在首次部署之后，使用的设置将存储在配置文件中（默认是 deno.json）。

你可以分别使用 `--project` 和 `--entrypoint` 参数指定项目名称和/或入口点。如果项目不存在，将自动创建。默认情况下，它是在用户的个人组织中创建，但也可以通过指定 `--org` 参数在自定义组织中创建。如果组织尚不存在，也会自动创建。

```shell
deployctl deploy --project=helloworld --entrypoint=src/entrypoint.ts --org=my-team
```

### 包含和排除文件

默认情况下，deployctl 会递归部署当前目录下的所有文件（除了 `node_modules` 目录）。你可以使用 `--include` 和 `--exclude` 参数自定义此行为（这些参数在配置文件中也支持）。这些参数接受特定文件、整个目录和通配符。以下是一些示例：

- 仅包括源文件和静态文件：

  ```shell
  deployctl deploy --include=./src --include=./static
  ```

- 仅包括 Typescript 文件：

  ```shell
  deployctl deploy --include=**/*.ts
  ```

- 排除本地工具和工件

  ```shell
  deployctl deploy --exclude=./tools --exclude=./benches
  ```

一个常见的陷阱是未包括需要运行的源代码模块（入口点和依赖项）。以下示例将失败，因为未包括 `main.ts`：

```shell
deployctl deploy --include=./static --entrypoint=./main.ts
```

入口点也可以是远程脚本。一个常见的用例是使用 `std/http/file_server.ts` 部署一个静态网站（更多细节请参考 [静态网站教程](https://docs.deno.com/deploy/tutorials/static-site)）：

```shell
deployctl deploy --include=dist --entrypoint=jsr:@std/http/file-server
```

### 环境变量

你可以使用 `--env` 设置环境变量（设置单个环境变量）或使用 `--env-file` 加载一个或多个环境文件。可以组合这些选项并多次使用：

```shell
deployctl deploy --env-file --env-file=.other-env --env=DEPLOYMENT_TS=$(date +%s)
```

部署将通过 `Deno.env.get()` 获取这些变量。请注意，使用 `--env` 和 `--env-file` 设置的环境变量特定于正在创建的部署，不会添加到 [为项目配置的环境变量列表](./environment-variables.md)。

### 生产部署

你创建的每个部署都有一个唯一的 URL。此外，项目有一个“生产 URL”和指向其“生产”部署的自定义域名。部署可以随时晋升为生产，或者使用 `--prod` 标志直接创建为生产：

```shell
deployctl deploy --prod
```

在 [部署](./deployments) 文档中了解有关生产部署的更多信息。

## 部署

部署子命令将所有与部署相关的操作分组。

### 列出

你可以列出一个项目的部署：

```shell
deployctl deployments list
```

输出：

```
✔ 项目 'my-project' 的部署列表第 1 页已经准备好
┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  部署        │               日期               │   状态   │  数据库  │                       域                       │ 入口点   │  分支   │  提交   │
├───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ kcbxc4xwe4mc │ 2024年12月3日 13:21:40 CET (2天) │ 预览     │ 预览     │ https://my-project-kcbxc4xwe4mc.deno.dev │ main.ts   │ main    │ 4b6c506  │
│ c0ph5xa9exb3 │ 2024年12月3日 13:21:25 CET (2天) │ 生产     │ 生产     │ https://my-project-c0ph5xa9exb3.deno.dev │ main.ts   │ main    │ 4b6c506  │
│ kwkbev9er4h2 │ 2024年12月3日 13:21:12 CET (2天) │ 预览     │ 预览     │ https://my-project-kwkbev9er4h2.deno.dev │ main.ts   │ main    │ 4b6c506  │
│ dxseq0jc8402 │ 2024年6月3日 23:16:51 CET (8天)  │ 预览     │ 生产     │ https://my-project-dxseq0jc8402.deno.dev │ main.ts   │ main    │ 099359b  │
│ 7xr5thz8yjbz │ 2024年6月3日 22:58:32 CET (8天)  │ 预览     │ 预览     │ https://my-project-7xr5thz8yjbz.deno.dev │ main.ts   │ another  │ a4d2953  │
│ 4qr4h5ac3rfn │ 2024年6月3日 22:57:05 CET (8天)  │ 失败     │ 预览     │ n/a                                               │ main.ts   │ another  │ 56d2c88  │
│ 25wryhcqmb9q │ 2024年6月3日 22:56:41 CET (8天)  │ 预览     │ 预览     │ https://my-project-25wryhcqmb9q.deno.dev │ main.ts   │ another  │ 4b6c506  │
│ 64tbrn8jre9n │ 2024年6月3日 8:21:33 CET (8天)   │ 预览     │ 生产     │ https://my-project-64tbrn8jre9n.deno.dev │ main.ts   │ main    │ 4b6c506  │
│ hgqgccnmzg04 │ 2024年6月3日 8:17:40 CET (8天)   │ 失败     │ 生产     │ n/a                                               │ main.ts   │ main    │ 8071902  │
│ rxkh1w3g74e8 │ 2024年6月3日 8:17:28 CET (8天)   │ 失败     │ 生产     │ n/a                                               │ main.ts   │ main    │ b142a59  │
│ wx6cw9aya64c │ 2024年6月3日 8:02:29 CET (8天)   │ 预览     │ 生产     │ https://my-project-wx6cw9aya64c.deno.dev │ main.ts   │ main    │ b803784  │
│ a1qh5fmew2yf │ 2024年5月3日 16:25:29 CET (9天)  │ 预览     │ 生产     │ https://my-project-a1qh5fmew2yf.deno.dev │ main.ts   │ main    │ 4bb1f0f  │
│ w6pf4r0rrdkb │ 2024年5月3日 16:07:35 CET (9天)  │ 预览     │ 生产     │ https://my-project-w6pf4r0rrdkb.deno.dev │ main.ts   │ main    │ 6e487fc  │
│ nn700gexgdzq │ 2024年5月3日 13:37:11 CET (9天)  │ 预览     │ 生产     │ https://my-project-nn700gexgdzq.deno.dev │ main.ts   │ main    │ c5b1d1f  │
│ 98crfqxa6vvf │ 2024年5月3日 13:33:52 CET (9天)  │ 预览     │ 生产     │ https://my-project-98crfqxa6vvf.deno.dev │ main.ts   │ main    │ 090146e  │
│ xcdcs014yc5p │ 2024年5月3日 13:30:58 CET (9天)  │ 预览     │ 生产     │ https://my-project-xcdcs014yc5p.deno.dev │ main.ts   │ main    │ 5b78c0f  │
│ btw43kx89ws1 │ 2024年5月3日 13:27:31 CET (9天)  │ 预览     │ 生产     │ https://my-project-btw43kx89ws1.deno.dev │ main.ts   │ main    │ 663452a  │
│ 62tg1ketkjx7 │ 2024年5月3日 13:27:03 CET (9天)  │ 预览     │ 生产     │ https://my-project-62tg1ketkjx7.deno.dev │ main.ts   │ main    │ 24d1618  │
│ 07ag6pt6kjex │ 2024年5月3日 13:19:11 CET (9天)  │ 预览     │ 生产     │ https://my-project-07ag6pt6kjex.deno.dev │ main.ts   │ main    │ 4944545  │
│ 4msyne1rvwj1 │ 2024年5月3日 13:17:16 CET (9天)  │ 预览     │ 生产     │ https://my-project-4msyne1rvwj1.deno.dev │ main.ts   │ main    │ dda85e1  │
└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
按回车获取下一页 [Enter]
```

该命令默认输出每页 20 个部署。你可以使用回车键迭代查看页面，并使用 `--page` 和 `--limit` 选项查询特定页面和页面大小。

与其余命令一样，如果你不在项目目录中或想列出其他项目的部署，可以使用 `--project` 选项指定项目。

### 显示

使用以下命令获取特定部署的所有详细信息：

```shell
deployctl deployments show
```

输出：

```
✔ 项目 'my-project' 的生产部署为 'c0ph5xa9exb3'
✔ 部署 'c0ph5xa9exb3' 的详细信息已准备好：

c0ph5xa9exb3
------------
状态:         生产
日期:         2天前，12小时，29分钟，46秒 (2024年12月3日 13:21:25 CET)
项目:        my-project (e54f23b5-828d-4b7f-af12-706d4591062b)
组织:        my-team (d97822ac-ee20-4ce9-b942-5389330b57ee)
域名:        https://my-project.deno.dev
              https://my-project-c0ph5xa9exb3.deno.dev
数据库:      生产 (0efa985f-3793-48bc-8c05-f740ffab4ca0)
入口点:      main.ts
环境变量:    HOME
Git
  引用:      main [4b6c506]
  消息:      change name
  作者:      John Doe @johndoe [mailto:johndoe@deno.com]
  URL:       https://github.com/arnauorriols/my-project/commit/4b6c50629ceeeb86601347732d01dc7ed63bf34f
定时任务:    另一个定时任务 [*/10 * * * *] 于 2024年3月15日 1:50:00 CET 成功，耗时 2 秒 (下一个在 2024年3月15日 2:00:00 CET)
              最新定时任务 [*/10 * * * *] n/a
              又一个定时任务 [*/10 * * * *] 于 2024年3月15日 1:40:00 CET 失败，耗时 2 秒 (下一个在 2024年3月15日 1:51:54 CET)
```

如果未指定部署，命令将显示当前项目的生产部署的详细信息。要查看最后一次部署的详细信息，请使用 `--last`，要查看特定部署的详细信息，请使用 `--id`（或位置参数）。你还可以使用 `--next` 或 `--prev` 按时间顺序浏览部署。

例如，要查看倒数第二次部署的详细信息，你可以这样做：

```shell
deployctl deployments show --last --prev
```

要查看特定部署后 2 次部署的详细信息：

```shell
deployctl deployments show 64tbrn8jre9n --next=2
```

### 重新部署

重新部署命令创建一个新的部署，重用现有部署的构建，目的是更改与之关联的资源。这包括生产域、环境变量和 KV 数据库。

:::info

选择要重新部署的部署的语义与 [show 子命令](#show) 相同，包括 `--last`、`--id`、`--next` 和 `--prev`。

:::

#### 生产域

如果你想将项目的生产域路由到特定部署，可以使用 `--prod` 选项重新部署它：

```shell
deployctl deployments redeploy --prod 64tbrn8jre9n
```

这将创建一个新的部署，具有与指定部署相同的代码和环境变量，但项目的生产域名将指向它。对于具有预览/生产数据库的项目（即链接到 GitHub 的项目），这也将为新的部署设置生产数据库。

:::note

此功能类似于 Deno Deploy Web 应用程序中找到的“推广到生产”按钮，唯一的区别是“推广到生产”按钮不创建新的部署。相反，“推广到生产”按钮在原地更改域名路由，但仅限于已使用生产数据库的部署。

:::

#### KV 数据库

如果这是一个 GitHub 部署，它将拥有 2 个数据库，一个用于生产部署，一个用于预览部署。你可以通过使用 `--db` 选项重新部署来更改部署的数据库：

```shell
deployctl deployments redeploy --db=prod --id=64tbrn8jre9n
```

:::note

将部署重新部署到生产时，默认情况下，它将自动配置为使用生产数据库。你可以同时使用 `--prod` 和 `--db` 选项以选择不采用此行为。例如，以下命令将重新部署当前的生产部署（由于缺少位置参数，`--id` 或 `--last`）。新的部署将成为新的生产部署，但将使用预览数据库而不是生产数据库：

```shell
deployctl deployments redeploy --prod --db=preview
```

:::

如果你的组织有自定义数据库，你也可以通过 UUID 设置它们：

```shell
deployctl deployments redeploy --last --db=5261e096-f9aa-4b72-8440-1c2b5b553def
```

#### 环境变量

创建部署时，它会继承项目的环境变量。由于部署是不可变的，因此永远不能更改其环境变量。要在部署中设置新的环境变量，你需要使用 `--env`（设置单个变量）和 `--env-file`（加载一个或多个环境文件）重新部署它。

以下命令使用 `.env` 和 `.other-env` 文件中定义的环境变量重新部署当前的生产部署，并将 `DEPLOYMENT_TS` 变量设置为当前时间戳。生成的部署将是一个预览部署（即生产域将不路由流量到它，因为缺少 `--prod`）。

```shell
deployctl deployments redeploy --env-file --env-file=.other-env --env=DEPLOYMENT_TS=$(date +%s)
```

:::note

请注意，在更改环境变量时，仅在重新部署命令中设置的环境变量将被新部署使用。项目环境变量和正在重新部署的部署的环境变量将被忽略。如果这不符合你的需求，请在 https://github.com/denoland/deploy_feedback/issues/ 报告你的反馈。

:::

:::note

当你在 Deno Deploy Web 应用程序中更改项目环境变量时，当前的生产部署将使用新的环境变量重新部署，并且新部署将成为新的生产部署。

:::

### 删除

你可以使用 `delete` 子命令删除一个部署：

```shell
deployctl deployments delete 64tbrn8jre9n
```

与 `show` 和 `redeploy` 一样，`delete` 也可以使用 `--last`、`--next` 和 `--prev` 选择要删除的部署。以下是删除项目中所有部署（除了最后一个）的示例命令（使用时请谨慎！）：

```shell
while deployctl deployments delete --project=my-project --last --prev; do :; done
```

## 项目

`projects` 子命令将所有与项目整体相关的操作分组。这包括 `list`、`show`、`rename`、`create` 和 `delete`。

### 列出

`deployctl projects list` 输出你用户可以访问的所有项目，按组织分组：

```
个人组织:
    blog
    url-shortener

'my-team' 组织:
    admin-site
    main-site
    analytics
```

你可以使用 `--org` 通过组织进行过滤：

```shell
deployctl projects list --org=my-team
```

### 显示

要查看特定项目的详细信息，请使用 `projects show`。如果你在项目内，它将从配置文件中获取项目 ID。你也可以使用 `--project` 或位置参数指定项目：

```shell
deployctl projects show main-site
```

输出：

```
main-site
---------
组织:        my-team (5261e096-f9aa-4b72-8440-1c2b5b553def)
域名:       https://my-team.com
              https://main-site.deno.dev
仪表盘 URL:  https://dash.deno.com/projects/8422c515-f68f-49b2-89f3-157f4b144611
代码库:      https://github.com/my-team/main-site
数据库:      [main] dd28e63e-f495-416b-909a-183380e3a232
              [*] e061c76e-4445-409a-bc36-a1a9040c83b3
定时任务:    另一个定时任务 [*/10 * * * *] 于 2024年3月12日 14:40:00 CET 成功，耗时 2 秒 (下一个在 2024年3月12日 14:50:00 CET)
              最新定时任务 [*/10 * * * *] n/a
              又一个定时任务 [*/10 * * * *] 于 2024年3月12日 14:40:00 CET 失败，耗时 2 秒 (下一个在 2024年3月12日 14:50:00 CET)
部署:        kcbxc4xwe4mc c0ph5xa9exb3* kwkbev9er4h2 dxseq0jc8402 7xr5thz8yjbz
              4qr4h5ac3rfn 25wryhcqmb9q 64tbrn8jre9n hgqgccnmzg04 rxkh1w3g74e8
              wx6cw9aya64c a1qh5fmew2yf w6pf4r0rrdkb nn700gexgdzq 98crfqxa6vvf
              xcdcs014yc5p btw43kx89ws1 62tg1ketkjx7 07ag6pt6kjex 4msyne1rvwj1
```

### 重命名

项目可以通过 `rename` 子命令轻松重命名。与其他命令类似，如果你在项目的目录中运行命令，则无需指定项目的当前名称：

```shell
deployctl projects rename my-personal-blog
```

输出：

```
ℹ 使用配置文件 '/private/tmp/blog/deno.json'
✔ 找到项目 'blog' (8422c515-f68f-49b2-89f3-157f4b144611)
✔ 项目 'blog' 重命名为 'my-personal-blog'
```

:::note

请记住，项目名称是预览域名的一部分 (https://my-personal-blog-kcbxc4xwe4mc.deno.dev) 和默认生产域名 (https://my-personal-blog.deno.dev)。因此，在更改项目名称时，之前名称的 URL 将不再路由到项目的相应部署。

:::

### 创建

你可以创建一个空项目：

```shell
deployctl projects create my-new-project
```

### 删除

你可以删除一个项目：

```shell
deployctl projects delete my-new-project
```

## 监控资源使用情况

`top` 子命令用于实时监控项目的资源使用情况：

```shell
deployctl top
```

输出：

```
┌────────┬────────────────┬────────────────────────┬─────────┬───────┬─────────┬──────────┬─────────────┬────────────┬─────────┬─────────┬───────────┬───────────┐
│ (idx)  │ 部署           │ 区域                  │ 每分钟请求 │ CPU%  │ 每请求 CPU │ RSS/5分钟 │ 每分钟流入  │ 每分钟流出 │ KV 读/分钟 │ KV 写/分钟 │ 队列入队/分钟 │ 队列出队/分钟 │
├────────┼────────────────┼────────────────────────┼─────────┼───────┼─────────┼──────────┼─────────────┼────────────┼─────────┼─────────┼───────────┼───────────┤
│ 6b80e8 │ "kcbxc4xwe4mc" │ "亚洲-东北1"          │      80 │ 0.61  │ 4.56    │ 165.908  │ 11.657      │ 490.847    │       0 │       0 │         0 │         0 │
│ 08312f │ "kcbxc4xwe4mc" │ "亚洲-东北1"          │      76 │ 3.49  │ 27.58   │ 186.278  │ 19.041      │ 3195.288   │       0 │       0 │         0 │         0 │
│ 77c10b │ "kcbxc4xwe4mc" │ "亚洲-南部1"          │      28 │ 0.13  │ 2.86    │ 166.806  │ 7.354       │ 111.478    │       0 │       0 │         0 │         0 │
│ 15e356 │ "kcbxc4xwe4mc" │ "亚洲-南部1"          │      66 │ 0.97  │ 8.93    │ 162.288  │ 17.56       │ 4538.371   │       0 │       0 │         0 │         0 │
│ a06817 │ "kcbxc4xwe4mc" │ "亚洲-东南部1"        │     126 │ 0.44  │ 2.11    │ 140.087  │ 16.504      │ 968.794    │       0 │       0 │         0 │         0 │
│ d012b6 │ "kcbxc4xwe4mc" │ "亚洲-东南部1"        │     119 │ 2.32  │ 11.72   │ 193.704  │ 23.44       │ 8359.829   │       0 │       0 │         0 │         0 │
│ 7d9a3d │ "kcbxc4xwe4mc" │ "澳大利亚-东南部1"    │       8 │ 0.97  │ 75      │ 158.872  │ 10.538      │ 3.027      │       0 │       0 │         0 │         0 │
│ 3c21be │ "kcbxc4xwe4mc" │ "澳大利亚-东南部1"    │       1 │ 0.04  │ 90      │ 105.292  │ 0.08        │ 1.642      │       0 │       0 │         0 │         0 │
│ b75dc7 │ "kcbxc4xwe4mc" │ "欧洲-西部2"          │     461 │ 5.43  │ 7.08    │ 200.573  │ 63.842      │ 9832.936   │       0 │       0 │         0 │         0 │
│ 33607e │ "kcbxc4xwe4mc" │ "欧洲-西部2"          │      35 │ 0.21  │ 3.69    │ 141.98   │ 9.438       │ 275.788    │       0 │       0 │         0 │         0 │
│ 9be3d2 │ "kcbxc4xwe4mc" │ "欧洲-西部2"          │     132 │ 0.92  │ 4.19    │ 180.654  │ 15.959      │ 820.513    │       0 │       0 │         0 │         0 │
│ 33a859 │ "kcbxc4xwe4mc" │ "欧洲-西部3"          │    1335 │ 7.57  │ 3.4     │ 172.032  │ 178.064     │ 10967.918  │       0 │       0 │         0 │         0 │
│ 3f54ce │ "kcbxc4xwe4mc" │ "欧洲-西部4"          │     683 │ 4.76  │ 4.19    │ 187.802  │ 74.696      │ 7565.017   │       0 │       0 │         0 │         0 │
│ cf881c │ "kcbxc4xwe4mc" │ "欧洲-西部4"          │     743 │ 3.95  │ 3.19    │ 177.213  │ 86.974      │ 6087.454   │       0 │       0 │         0 │         0 │
│ b4565b │ "kcbxc4xwe4mc" │ "美洲-西部1"          │       3 │ 0.21  │ 55      │ 155.46   │ 2.181       │ 0.622      │       0 │       0 │         0 │         0 │
│ b97970 │ "kcbxc4xwe4mc" │ "南美-东部1"          │       3 │ 0.08  │ 25      │ 186.049  │ 1.938       │ 0.555      │       0 │       0 │         0 │         0 │
│ fd7a08 │ "kcbxc4xwe4mc" │ "美国-东部4"          │       3 │ 0.32  │ 80      │ 201.101  │ 0.975       │ 58.495     │       0 │       0 │         0 │         0 │
│ 95d68a │ "kcbxc4xwe4mc" │ "美国-东部4"          │     133 │ 1.05  │ 4.77    │ 166.052  │ 28.107      │ 651.737    │       0 │       0 │         0 │         0 │
│ c473e7 │ "kcbxc4xwe4mc" │ "美国-东部4"          │       0 │ 0     │ 0       │ 174.154  │ 0.021       │ 0          │       0 │       0 │         0 │         0 │
│ ebabfb │ "kcbxc4xwe4mc" │ "美国-东部4"          │      19 │ 0.15  │ 4.78    │ 115.732  │ 7.764       │ 67.054     │       0 │       0 │         0 │         0 │
│ eac700 │ "kcbxc4xwe4mc" │ "美国-南部1"          │     114 │ 2.37  │ 12.54   │ 183.001  │ 18.401      │ 22417.397  │       0 │       0 │         0 │         0 │
│ cd2194 │ "kcbxc4xwe4mc" │ "美国-南部1"          │      35 │ 0.33  │ 5.68    │ 145.871  │ 8.142       │ 91.236     │       0 │       0 │         0 │         0 │
│ 140fec │ "kcbxc4xwe4mc" │ "美国-西部2"          │     110 │ 1.43  │ 7.84    │ 115.298  │ 18.093      │ 977.993    │       0 │       0 │         0 │         0 │
│ 51689f │ "kcbxc4xwe4mc" │ "美国-西部2"          │    1105 │ 7.66  │ 4.16    │ 187.277  │ 154.876     │ 14648.383  │       0 │       0 │         0 │         0 │
│ c5806e │ "kcbxc4xwe4mc" │ "美国-西部2"          │     620 │ 4.38  │ 4.24    │ 192.291  │ 109.086     │ 9685.688   │       0 │       0 │         0 │         0 │
└────────┴────────────────┴────────────────────────┴─────────┴───────┴─────────┴──────────┴─────────────┴────────────┴─────────┴─────────┴───────────┴───────────┘
⠼ 正在流媒体...
```

列的定义如下：

| 列         | 描述                                                                                         |
| ----------- | ---------------------------------------------------------------------------------------------- |
| idx         | 实例区分符。用于区分在同一区域运行的不同执行的不透明 ID。                                        |
| 部署        | 正在执行的实例中运行的部署的 ID。                                                               |
| 每分钟请求  | 项目每分钟接收的请求数。                                                                        |
| CPU%        | 项目使用的 CPU 百分比。                                                                         |
| 每请求 CPU   | 每个请求的 CPU 时间，以毫秒为单位。                                                               |
| RSS/5分钟  | 项目在最近 5 分钟内使用的最大 RSS，单位为 MB。                                                  |
| 每分钟流入  | 项目每分钟接收的数据，单位为 KB。                                                                  |
| 每分钟流出  | 项目每分钟输出的数据，单位为 KB。                                                                  |
| KV 读/分钟  | 项目每分钟执行的 KV 读取。                                                                        |
| KV 写/分钟  | 项目每分钟执行的 KV 写入。                                                                        |
| 队列入队/分钟 | 项目每分钟执行的队列入队。                                                                      |
| 队列出队/分钟 | 项目每分钟执行的队列出队。                                                                      |

你可以使用 `--region` 按区域过滤，该选项接受子字符串并可以多次使用：

```shell
deployctl top --region=asia --region=southamerica
```

## 日志

你可以使用 `deployctl logs` 获取你的部署的日志。它支持实时日志（日志生成时流式传输到控制台）和查询已保存的日志（获取过去生成的日志）。

要显示项目当前生产部署的实时日志：

```shell
deployctl logs
```

:::note

与 Deno Deploy Web 应用程序不同，目前日志子命令在更改时不会自动切换到新的生产部署。

:::

要显示特定部署的实时日志：

```shell
deployctl logs --deployment=1234567890ab
```

日志可以使用 `--levels`、`--regions` 和 `--grep` 选项按级别、区域和文本过滤：

```shell
deployctl logs --levels=error,info --regions=region1,region2 --grep='unexpected'
```

要显示已保存的日志，可以使用 `--since` 和/或 `--until` 选项：

<deno-tabs groupId="operating-systems">
  <deno-tab value="mac" label="macOS" default>

```sh
deployctl logs --since=$(date -Iseconds -v-2H) --until=$(date -Iseconds -v-30M)
```

</deno-tab>
<deno-tab value="linux" label="Linux">

```sh
deployctl logs --since=$(date -Iseconds --date='2 hours ago') --until=$(date -Iseconds --date='30 minutes ago')
```

</deno-tab>
</deno-tabs>

## API

如果你使用 [子托管 API](../../subhosting/manual/index.md)，`deployctl api` 将帮助你与 API 交互，同时处理身份验证和头信息：

```shell
deployctl api /projects/my-personal-blog/deployments
```

使用 `--method` 和 `--body` 指定 HTTP 方法和请求体：

```shell
deployctl api --method=POST --body='{"name": "main-site"}' organizations/5261e096-f9aa-4b72-8440-1c2b5b553def/projects
```

## 本地开发

对于本地开发，你可以使用 `deno` CLI。要安装 `deno`，请遵循 [Deno 手册](https://deno.land/manual/getting_started/installation) 中的说明。

安装完成后，你可以在本地运行你的脚本：

```shell
$ deno run --allow-net=:8000 ./main.ts
Listening on http://localhost:8000
```

要监视文件更改，请添加 `--watch` 标志：

```shell
$ deno run --allow-net=:8000 --watch ./main.ts
Listening on http://localhost:8000
```

有关 Deno CLI 的更多信息，以及如何配置你的开发环境和 IDE，请访问 Deno 手册的 [入门][manual-gs] 部分。

[manual-gs]: https://deno.land/manual/getting_started

## JSON 输出

所有输出数据的命令都有一个 `--format=json` 选项，将数据以 JSON 对象的形式输出。当 stdout 不是 TTY 时，这种输出模式是默认的，尤其是当以管道输入到其他命令时。与 `jq` 一起使用时，这种模式使得对 `deployctl` 提供的所有数据进行编程使用：

获取当前生产部署的 ID：

```shell
deployctl deployments show | jq .build.deploymentId
```

获取每个区域每个隔离的 CPU 时间流的 csv：

```shell
deployctl top | jq -r '[.id,.region,.cpuTimePerRequest] | @csv'
```

---

# 部署

URL: https://docs.deno.com/deploy/manual/deployments


部署是运行应用程序所需的代码和环境变量的快照。可以通过
[使用 `deployctl`](./deployctl.md#deploy) 或者在配置后通过 Deploy 的 GitHub 集成自动创建新的部署。

部署在创建后是不可变的。要为应用程序部署新版本的代码，必须创建新的部署。一旦创建，部署将持续可访问。

所有可用的部署在您的项目页面的 `Deployments` 标签下列出，如下图所示。旧部署可以通过
[使用 `deployctl`](./deployctl.md#delete) 和
[通过 API](https://apidocs.deno.com/#delete-/deployments/-deploymentId-) 删除。

![显示项目仪表板中的部署标签](./images/project_deployments.png)

## 自定义域名

还可以有其他 URL 指向一个部署，比如
[自定义域名](custom-domains)。

## 分支域名

`<projectname--branchname>.deno.dev` 也受到支持。

## 生产部署与预览部署

所有部署都有一个预览 URL，可以用于查看该特定的部署。预览 URL 的格式为
`{project_name}-{deployment_id}.deno.dev`。

![图像](../docs-images/preview_deployment.png)

部署可以是生产部署或预览部署。这些部署在运行时功能上没有任何区别。唯一的区别是项目的生产部署将接收来自项目 URL（例如 `myproject.deno.dev`）和自定义域名的流量，以及指向部署的预览 URL 的流量。

## 通过 Deno Deploy UI 将预览部署提升为生产部署

可以通过 Deno Deploy UI 将预览部署“提升”为生产：

1. 导航到项目页面。
2. 点击 **Deployments** 标签。
3. 点击您想提升为生产的部署旁边的三个点，并选择 **Promote to Production**
   ![promote_to_production](../docs-images/promote_to_production.png)

将部署提升为生产是有限制的，仅限于已使用生产 KV 数据库的部署。这对于使用不同数据库进行预览和生产部署的 GitHub 部署尤其相关。部署（即使使用预览 KV 数据库的部署）始终可以使用
[the `deployctl deployments redeploy` 命令](./deployctl.md#production-domains) 重新部署到生产。

## 通过 `deployctl` 创建生产部署

如果您使用 `deployctl` 部署 Deno 代码，可以使用 `--prod` 标志直接部署到生产：

```sh
deployctl deploy --prod --project=helloworld main.ts
```

---

# 连接到 DynamoDB

URL: https://docs.deno.com/deploy/manual/dynamodb


亚马逊 DynamoDB 是一个完全托管的 NoSQL 数据库。要将数据持久化到 DynamoDB，请按照以下步骤操作：

本教程假设您拥有 AWS 和 Deno Deploy 帐户。

您可以在 [这里](../tutorials/tutorial-dynamodb) 找到一个更全面的教程，该教程在 DynamoDB 上构建了一个示例应用程序。

## 从 DynamoDB 收集凭证

该过程的第一步是生成 AWS 凭证，以便以编程方式访问 DynamoDB。

生成凭证：

1. 访问 https://console.aws.amazon.com/iam/ 并进入“用户”部分。
2. 点击 **添加用户** 按钮，填写 **用户名** 字段（可以使用 `denamo`），并选择 **编程访问** 类型。
3. 点击 **下一步：权限**，然后点击 **直接附加现有策略**，搜索 `AmazonDynamoDBFullAccess` 并选择它。
4. 点击 **下一步：标签**，然后点击 **下一步：审核**，最后点击 **创建用户**。
5. 点击 **下载 .csv** 按钮以下载凭证。

## 在 Deno Deploy 中创建项目

接下来，让我们在 Deno Deploy 中创建一个项目并设置所需的环境变量：

1. 访问 [https://dash.deno.com/new](https://dash.deno.com/new)（如果尚未登录，请用 GitHub 登录），然后在 **从命令行部署** 下点击 **+ 空项目**。
2. 现在点击项目页面上的 **设置** 按钮。
3. 导航到 **环境变量** 部分并添加以下密钥。

- `AWS_ACCESS_KEY_ID` - 使用下载的 CSV 中 **访问密钥 ID** 列下的值。
- `AWS_SECRET_ACCESS_KEY` - 使用下载的 CSV 中 **秘密访问密钥** 列下的值。

## 编写代码以连接到 DynamoDB

AWS 提供了一个
[官方 SDK](https://www.npmjs.com/package/@aws-sdk/client-dynamodb)，它可以在浏览器中使用。由于大多数 Deno Deploy 的 API 与浏览器类似，因此该 SDK 也可以在 Deno Deploy 中使用。要在 Deno 中使用该 SDK，可以从 CDN 导入，如下所示并创建一个客户端：

```js
import {
  DynamoDBClient,
  GetItemCommand,
  PutItemCommand,
} from "https://esm.sh/@aws-sdk/client-dynamodb?dts";

// 通过提供您的区域信息创建客户端实例。
// 凭证会从我们在 Deno Deploy 的项目创建步骤中设置的环境变量中自动获取，因此我们不需要在此手动传递它们。
const client = new ApiFactory().makeNew(DynamoDB);

serve({
  "/songs": handleRequest,
});

async function handleRequest(request) {
  // async/await。
  try {
    const data = await client.send(command);
    // 处理数据。
  } catch (error) {
    // 错误处理。
  } finally {
    // 最终处理。
  }
}
```

## 将应用程序部署到 Deno Deploy

一旦您完成了应用程序的编写，就可以在 Deno Deploy 上部署它。

为此，请返回到您的项目页面，地址为 `https://dash.deno.com/projects/<project-name>`。

您应该会看到几个部署选项：

- [Github 集成](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

除非您希望添加构建步骤，否则我们建议您选择 GitHub 集成。

有关在 Deno Deploy 上部署的不同方式和不同配置选项的更多详细信息，请阅读 [这里](how-to-deploy)。

---

# 边缘缓存

URL: https://docs.deno.com/deploy/manual/edge-cache


[Web Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) 在 Deno Deploy 上得到支持。此缓存旨在提供微秒级的读取延迟、多GB/s的写入吞吐量以及无限存储，尽管其在一致性和耐久性方面提供的是尽力而为的保障。

```ts
const cache = await caches.open("my-cache");

Deno.serve(async (req) => {
  const cached = await cache.match(req);
  if (cached) {
    return cached;
  }

  const res = new Response("cached at " + new Date().toISOString());
  await cache.put(req, res.clone());
  return res;
});
```

缓存的数据存储在运行您代码的同一 Deno Deploy 区域。通常，您的隔离进程会在同一区域内观察到读取后写入（RAW）和写入后写入（WAW）的一致性；但是，在极少数情况下，最近的写入可能会丢失、顺序错乱或暂时不可见。

## 过期

默认情况下，缓存的数据会无限期地保存。虽然我们定期扫描并删除不活跃的对象，但通常一个对象会在缓存中保持至少 30 天。

边缘缓存理解标准的 HTTP 响应头 `Expires` 和 `Cache-Control`。您可以使用它们为每个缓存对象指定过期时间，例如：

```
Expires: Thu, 22 Aug 2024 01:22:31 GMT
```

或：

```
Cache-Control: max-age=86400
```

## 限制

- 如果响应不是从 `Uint8Array` 或 `string` 主体构建的，`Content-Length` 头需要手动设置。
- 目前不支持删除。

---

# 环境变量

URL: https://docs.deno.com/deploy/manual/environment-variables


环境变量用于存储诸如web服务的访问令牌之类的值。每个部署在创建时都有一组环境变量，并且可以通过 `Deno.env` API 从代码中访问。定义部署的环境变量有两种方式：

## 项目环境变量

您可以在项目级别定义环境变量。当您创建一个部署时，它将获得在 _特定时刻_ 项目已定义的环境变量集。

为了方便起见，当您更改项目的环境变量时，当前的生产部署会 _重新部署_，创建一个新的生产部署，并附带一组新的环境变量。

:::note

部署是不可更改的，包括它们的环境变量。更改项目的环境变量不会更改现有部署的环境变量。

:::

要向您的项目添加环境变量，请点击项目页面上的 **设置** 按钮，然后从侧边栏中点击 **环境变量**。填写键/值字段，然后点击“添加”将环境变量添加到项目中。

![environment_variable](../docs-images/fauna2.png)

更新现有环境变量的操作方法相同。点击“添加变量”按钮，输入您希望更新的环境变量的相同名称，并输入新值。点击“保存”按钮以完成更新。

## 部署环境变量

在使用 `deployctl` 进行部署时，可以通过 [使用 `--env` 或 `--env-file` 标志](./deployctl.md#environment-variables) 来指定环境变量，补充已有的项目环境变量。您还可以传递多个 `--env-file` 参数（例如， `--env-file=.env.one --env-file=.env.two`）以包括来自多个文件的变量。

:::note

当在单个 `.env` 文件中存在相同环境变量的多个声明时，将应用第一个出现的值。但是，如果在多个 `.env` 文件中定义了相同的变量（使用多个 `--env-file` 参数），则最后指定的文件中的值将优先。即在最后列出的 `.env` 文件中的第一个出现的值将被应用。

:::

这些环境变量将特定于正在创建的部署。

### 默认环境变量

每个部署都有以下预设环境变量，您可以从代码中访问它们。

1. `DENO_REGION`

   它包含部署运行区域的区域代码。您可以使用此变量提供区域特定的内容。

   您可以在 [区域页面](regions) 中查找区域代码。

1. `DENO_DEPLOYMENT_ID`

   它保存部署的 ID。

---

# 连接到 FaunaDB

URL: https://docs.deno.com/deploy/manual/faunadb


FaunaDB 自称为“现代应用程序的数据 API”。它是一个具有 GraphQL 接口的数据库，使您能够使用 GraphQL 与其交互。由于您通过 HTTP 请求进行通信，因此您无需管理连接，这非常适合无服务器应用程序。

本教程介绍如何从部署在 Deno Deploy 上的应用程序连接到 Fauna 数据库。

您可以在 [这里](../tutorials/tutorial-faunadb) 找到一个更全面的教程，构建一个基于 Fauna 的示例应用程序。

## 从 Fauna 获取凭证

我们假设您已经在 https://dashboard.fauna.com 创建了一个 Fauna 实例。

要以编程方式访问您的 Fauna 数据库，您需要生成一个凭证：

1. 点击您特定数据库中的 **Security** 部分，然后点击 **New Key**。 ![fauna1](../docs-images/fauna1.png)

2. 选择 **Server** 角色，并点击 **Save**。复制密钥。您将在下一步中需要它。

## 在 Deno Deploy 中创建项目

接下来，让我们在 Deno Deploy 上创建一个项目，并设置所需的环境变量：

1. 前往 [https://dash.deno.com/new](https://dash.deno.com/new)（如果您还没有登录，请使用 GitHub 登录）并在 **从命令行部署** 下点击 **+ 空项目**。
2. 现在点击项目页面上的 **Settings** 按钮。
3. 导航到 **环境变量** 部分并添加以下密钥。

- `FAUNA_SECRET` - 该值应为我们在前一步创建的密钥。 ![fauna2](../docs-images/fauna2.png)

## 编写连接到 Fauna 的代码

虽然在 Node 中有一个 Fauna JavaScript 驱动程序，但在 Deno 中，您应该使用 graphql 端点。

Fauna 为其数据库提供了一个 graphql 端点，并生成基本的变更，如 `create`、`update` 和 `delete`，以便用于在模式中定义的数据类型。例如，Fauna 将生成一个名为 `createQuote` 的变更，以在数据库中为数据类型 `Quote` 创建一个新引用。

要与 Fauna 交互，我们需要向其 graphql 端点发送一个 POST 请求，并使用适当的查询和参数来获取数据。让我们构建一个处理这些事情的通用函数。

```javascript
import query from "https://esm.sh/faunadb@4.7.1";
import Client from "https://esm.sh/faunadb@4.7.1";

// 从环境中获取密钥。
const token = Deno.env.get("FAUNA_SECRET");
if (!token) {
  throw new Error("环境变量 FAUNA_SECRET 未设置");
}

var client = new Client.Client({
  secret: token,
  // 如果您使用的是区域组，请调整端点
  endpoint: "https://db.fauna.com/",
});
// HEAD
client.query(query.ToDate("2018-06-06"));
//
client
  .query(query.ToDate("2018-06-06"))
  //1e2f378 (添加更多页面)
  .then(function (res) {
    console.log("结果:", res);
  })
  .catch(function (err) {
    console.log("错误:", err);
  });
```

## 部署应用程序到 Deno Deploy

完成应用程序的编写后，您可以将其部署到 Deno Deploy。

为此，请返回到您的项目页面 `https://dash.deno.com/projects/<project-name>`。

您应该会看到几个部署选项：

- [Github 集成](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

除非您想添加构建步骤，否则我们建议您选择 Github 集成。

有关在 Deno Deploy 上以不同方式部署和不同配置选项的更多详细信息，请阅读 [这里](how-to-deploy)。

---

# 连接到 Firebase

URL: https://docs.deno.com/deploy/manual/firebase


Firebase 是 Google 开发的一个平台，用于创建移动和网络应用程序。它的功能包括用于登录的身份验证原语和一个 NoSQL 数据存储库 Firestore，您可以将数据持久化到其中。

本教程介绍了如何从部署在 Deno Deploy 上的应用程序连接到 Firebase。

您可以在 [这里](../tutorials/tutorial-firebase) 找到一个更全面的教程，该教程基于 Firebase 构建了一个示例应用程序。

## 从 Firebase 获取凭据

> 本教程假设您已经在 Firebase 中创建了一个项目并将网页应用程序添加到您的项目中。

1. 在 Firebase 中导航到您的项目，然后单击 **项目设置**
2. 向下滚动，直到您看到一张包含您的应用名称的卡片，以及一个包含 `firebaseConfig` 对象的代码示例。它应该看起来像下面的内容。请将其保留备用。我们稍后会用到它：

   ```js
   var firebaseConfig = {
     apiKey: "APIKEY",
     authDomain: "example-12345.firebaseapp.com",
     projectId: "example-12345",
     storageBucket: "example-12345.appspot.com",
     messagingSenderId: "1234567890",
     appId: "APPID",
   };
   ```

## 在 Deno Deploy 中创建项目

1. 访问 [https://dash.deno.com/new](https://dash.deno.com/new) （如果您尚未登录，请使用 GitHub 登录），然后在 **从命令行部署** 下单击 **+ 空项目**。
2. 现在单击项目页面上可用的 **设置** 按钮。
3. 导航至 **环境变量** 部分并添加以下内容：

   <dl>
    <dt><code>FIREBASE_USERNAME</code></dt>
    <dd>上述添加的 Firebase 用户（电子邮件地址）。</dd>
    <dt><code>FIREBASE_PASSWORD</code></dt>
    <dd>上述添加的 Firebase 用户密码。</dd>
    <dt><code>FIREBASE_CONFIG</code></dt>
    <dd>Firebase 应用程序的配置，格式为 JSON 字符串。</dd>
   </dl>

   配置需要是有效的 JSON 字符串，以便应用程序可以读取。如果在设置时给出的代码片段如下所示：

   ```js
   var firebaseConfig = {
     apiKey: "APIKEY",
     authDomain: "example-12345.firebaseapp.com",
     projectId: "example-12345",
     storageBucket: "example-12345.appspot.com",
     messagingSenderId: "1234567890",
     appId: "APPID",
   };
   ```

   您需要将字符串的值设置为如下（注意空格和换行不是必需的）：

   ```json
   {
     "apiKey": "APIKEY",
     "authDomain": "example-12345.firebaseapp.com",
     "projectId": "example-12345",
     "storageBucket": "example-12345.appspot.com",
     "messagingSenderId": "1234567890",
     "appId": "APPID"
   }
   ```

## 编写连接到 Firebase 的代码

我们要做的第一件事是导入 Firebase 在 Deploy 下运行所需的 `XMLHttpRequest` polyfill 以及一个用于 `localStorage` 的 polyfill，以允许 Firebase 身份验证保持登录用户：

```js
import "https://deno.land/x/xhr@0.1.1/mod.ts";
import { installGlobals } from "https://deno.land/x/virtualstorage@0.1.0/mod.ts";
installGlobals();
```

> ℹ️ 我们在撰写本教程时使用的是当前版本的包。它们可能不是最新的，您可能想要仔细检查当前版本。

由于 Deploy 具有许多网络标准 API，因此最好在 Deploy 下使用 Firebase 的 Web 库。目前 Firebase 的 v9 仍在测试阶段，所以我们将使用 v8：

```js
import firebase from "https://esm.sh/firebase@9.17.0/app";
import "https://esm.sh/firebase@9.17.0/auth";
import "https://esm.sh/firebase@9.17.0/firestore";
```

现在我们需要设置我们的 Firebase 应用程序。我们将从我们之前设置的环境变量中获取配置，并获取我们将要使用的 Firebase 部分的引用：

```js
const firebaseConfig = JSON.parse(Deno.env.get("FIREBASE_CONFIG"));
const firebaseApp = firebase.initializeApp(firebaseConfig, "example");
const auth = firebase.auth(firebaseApp);
const db = firebase.firestore(firebaseApp);
```

好的，我们快完成了。我们只需创建我们的中间件应用程序并添加我们导入的 `localStorage` 中间件：

```js
const app = new Application();
app.use(virtualStorage());
```

然后我们需要添加中间件来验证用户。在本教程中，我们只是从将要设置的环境变量中获取用户名和密码，但这很容易适应于将用户重定向到登录页面，如果他们没有登录：

```js
app.use(async (ctx, next) => {
  const signedInUid = ctx.cookies.get("LOGGED_IN_UID");
  const signedInUser = signedInUid != null ? users.get(signedInUid) : undefined;
  if (!signedInUid || !signedInUser || !auth.currentUser) {
    const creds = await auth.signInWithEmailAndPassword(
      Deno.env.get("FIREBASE_USERNAME"),
      Deno.env.get("FIREBASE_PASSWORD"),
    );
    const { user } = creds;
    if (user) {
      users.set(user.uid, user);
      ctx.cookies.set("LOGGED_IN_UID", user.uid);
    } else if (signedInUser && signedInUid.uid !== auth.currentUser?.uid) {
      await auth.updateCurrentUser(signedInUser);
    }
  }
  return next();
});
```

## 将应用程序部署到 Deno Deploy

完成编写应用程序后，您可以将其部署到 Deno Deploy。

为此，请返回到您的项目页面，网址为
`https://dash.deno.com/projects/<project-name>`。

您应该会看到几种部署选项：

- [Github 集成](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

除非您想添加构建步骤，否则我们建议您选择 Github 集成。

有关在 Deno Deploy 上部署的不同方式以及不同配置选项的更多详细信息，请阅读 [这里](how-to-deploy)。

---

# 兑现政策

URL: https://docs.deno.com/deploy/manual/fulfillment-policy


## 退款政策

在 Deno Deploy，我们努力提供卓越的服务。如果您对我们的服务不满意，您可以在以下条件下请求退款：

退款必须在初次购买或升级任何订阅计划后的 14 天内请求。如果服务未能正常运行，并且如果我们的支持团队在合理的时间内无法解决问题，则可以考虑退款。对于违反我们的服务条款所使用的服务或明显归因于用户错误或外部平台变化的问题，将不予退款。定期订阅可以取消，但仅在 14 天内请求时才有资格获得初始计费周期的退款。

## 取消政策

您可以在以下条款下随时取消您的 Deno Deploy 订阅：

订阅取消将立即生效，服务将继续运行至当前计费周期结束。要取消您的订阅，请导航到 Deno Deploy 仪表板上的帐户设置，并选择“取消订阅”。一旦订阅被取消，将不再产生进一步费用，但您仍需对取消生效日期之前的所有费用负责。如需了解我们履行政策的更多信息，或如果您需要帮助，请通过 [deploy@deno.com](mailto:deploy@deno.com) 联系我们的支持团队。

---

# 使用 GitHub 集成进行部署

URL: https://docs.deno.com/deploy/manual/how-to-deploy


部署更复杂项目的最简单方法是通过我们的 GitHub 集成。
这允许您将 Deno Deploy 项目链接到一个 GitHub 仓库。每当您推送到该仓库时，您的更改将会自动部署。

通过 GitHub 集成，您可以添加一个 GitHub Action，该动作在您的部署过程中定义一个构建步骤。

有关更多详细信息，请参见 [GitHub 集成页面](ci_github)。

### 使用 [`deployctl`](./deployctl.md) 从命令行进行部署

`deployctl` 是一个命令行工具，用于将您的代码部署到 Deno Deploy。使用 `deployctl` 可以控制比上述自动 GitHub 集成更多的部署细节。

有关更多详细信息，请参见 [deployctl 页面](./deployctl.md)。

### 使用 playground 进行部署

部署一些代码最简单的方法是通过 Deno Deploy playground。

有关更多详细信息，请参见 [playground 页面](playgrounds)。

---

# 快速开始部署

URL: https://docs.deno.com/deploy/manual/


Deno Deploy 是一个全球分布的平台，专为无服务器 JavaScript 应用程序而设计。您的 JavaScript、TypeScript 和 WebAssembly 代码在地理上靠近用户的管理服务器上运行，从而实现低延迟和更快的响应时间。部署的应用程序在快速、轻量级的 [V8 隔离环境](https://deno.com/blog/anatomy-isolate-cloud) 上运行，而不是虚拟机，支持 [Deno 运行时](/runtime/manual)。

让我们来部署您的第一个应用程序 - 这只需几分钟。

## 安装 Deno 和 `deployctl`

如果您还没有安装，可以使用以下命令之一来 [安装 Deno 运行时](/runtime/getting_started/installation)：

<deno-tabs group-id="operating-systems">
<deno-tab mac" label="macOS" default>

```sh
curl -fsSL https://deno.land/install.sh | sh
```

</deno-tab>
<deno-tab value="windows" label="Windows">

```powershell
irm https://deno.land/install.ps1 | iex
```

</deno-tab>
<deno-tab value="linux" label="Linux">

```sh
curl -fsSL https://deno.land/install.sh | sh
```

</deno-tab>
</deno-tabs>

安装 Deno 后，请安装 [`deployctl`](./deployctl.md) 工具：

```
deno install -A jsr:@deno/deployctl --global
```

您可以通过运行以下命令来确认 `deployctl` 已正确安装：

```console
deployctl --help
```

现在，您准备好从命令行部署 Deno 脚本了！

## 编写和测试 Deno 程序

首先，创建一个项目目录，并在其中创建一个名为 `main.ts` 的文件，内容如下所示的 "Hello World" 网络服务器：

```ts title="main.ts"
Deno.serve(() => new Response("Hello, world!"));
```

您可以通过运行以下命令来测试它是否有效：

```
deno run --allow-net main.ts
```

您的服务器应该可以在 [localhost:8000](http://localhost:8000) 上查看。现在让我们在边缘使用 Deno Deploy 运行这段代码！

## 部署您的项目

在您刚创建的 `main.ts` 文件的目录中，运行以下命令：

```sh
deployctl deploy
```

系统会提示您授权 Deno Deploy 在 GitHub 中注册 Deno Deploy 并/或为 `deployctl` 配置访问令牌。片刻之后，您的 Hello World 服务器将部署在 Deno Deploy 基础设施中，遍布全球，准备处理您预期的所有流量。

## 下一步

现在您已创建了第一个部署，您可以 [了解您可以在 Deno Deploy 上运行哪些类型的应用程序](./use-cases.md)，查看 [使用 deployctl 还可以做什么](./deployctl.md)，或者继续阅读以了解将代码部署到 Deno Deploy 的其他选项。我们非常期待看到您通过 Deno Deploy 交付的内容！

### 部署您现有的项目

导入一个项目并在边缘使用 Deno Deploy 运行它。

1. [从 Deno Deploy 仪表板](https://dash.deno.com) 点击 "新建项目" 按钮。

2. 连接到您的 GitHub 帐户并选择要部署的存储库。

3. 按照屏幕上的说明部署您的现有应用程序。

   如果您的项目需要构建步骤，请使用项目配置表单创建一个 GitHub 操作以部署您的项目。为您的项目命名并从可选框架预设中选择。如果您不使用框架，可以使用表单设置您的构建选项。

4. 确认您的构建选项正确，然后点击 "部署项目" 按钮以启动新的 GitHub 操作并部署您的项目。

片刻之后，您的项目将部署到全球约 12 个数据中心，准备处理大量流量。

一旦部署成功，您可以访问成功页面上提供的 URL 来查看您新部署的项目，或者在您的仪表板中管理它。

### 从游乐场开始

[游乐场](./playgrounds.md) 是一个基于浏览器的编辑器，使您能够立即编写和运行 JavaScript 或 TypeScript 代码。这是一个很好的选择，让您开始体验 Deno 和 Deno Deploy！

从 [Deno Deploy 仪表板](https://dash.deno.com) 点击 "新建游乐场" 按钮以创建一个游乐场。我们还提供了多种现成的教程，供您尝试 Deno Deploy，您可以通过点击 "学习游乐场" 或访问以下链接来尝试它们：\
[简单 HTTP 服务器游乐场](https://dash.deno.com/tutorial/tutorial-http)\
[使用 Deno KV 数据库游乐场](https://dash.deno.com/tutorial/tutorial-http-kv)\
[RESTful API 服务器游乐场](https://dash.deno.com/tutorial/tutorial-restful)\
[使用 WebSockets 的实时应用游乐场](https://dash.deno.com/tutorial/tutorial-websocket)\
[使用 Deno.cron 的定期任务游乐场](https://dash.deno.com/tutorial/tutorial-cron)

---

# 应用程序日志

URL: https://docs.deno.com/deploy/manual/logs


应用程序可以在运行时使用控制台 API 生成日志，方法包括 `console.log`、`console.error` 等。这些日志可以通过以下方式实时查看：

- 导航到项目或部署的 `日志` 面板。
- 使用 [deployctl](https://docs.deno.com/deploy/manual/deployctl) 中的 `logs` 子命令。

日志会直接从应用程序流式传输到日志面板，或显示在 `deployctl logs` 中。

除了实时日志，日志还会保留一段时间，具体取决于您所订阅的计划。要查看持久化日志，您可以：

- 如果您在浏览器中使用日志面板，请在搜索框旁的下拉菜单中，将其从 `实时` 切换到 `最近` 或 `自定义`。
- 如果您更喜欢命令行，可以在 `deployctl logs` 命令中添加 `--since=<DATETIME>` 和/或 `--until=<DATETIME>`。有关更多详细信息，请查阅 `deployctl logs --help`。

超出保留期限的日志会自动从系统中删除。

## 限制

日志消息的大小和在特定时间内生成的日志量都有所限制。

日志消息的最大大小为 2KB。超过此限制的消息会被裁剪为 2KB。

一个部署每秒最多允许生成 1000 条日志。如果超过此限度，我们可能会终止该部署。

---

# 反向代理中间件

URL: https://docs.deno.com/deploy/manual/middleware


本快速入门将介绍如何部署一个小型的中间件，它反向代理另一个服务器（在这个例子中是 example.com）。有关常见中间件功能的其他示例，请参见
[示例画廊](../tutorials/index.md)。

## **步骤 1：** 在 Deno Deploy 上创建一个新的 Playground 项目

导航到 https://dash.deno.com/projects 并点击 "新建 Playground" 按钮。

## **步骤 2：** 通过 Playground 部署中间件代码

在下一个页面，将以下代码复制并粘贴到编辑器中。这是一个将所有请求代理到 https://example.com 的 HTTP 服务器。

```ts
async function reqHandler(req: Request) {
  const reqPath = new URL(req.url).pathname;
  return await fetch("https://example.com" + reqPath, { headers: req.headers });
}

Deno.serve(reqHandler);
```

点击 **保存并部署**。

您应该看到类似以下内容的界面：

![image](../docs-images/proxy_to_example.png)

---

# 连接到 Neon Postgres

URL: https://docs.deno.com/deploy/manual/neon-postgres


本教程涵盖了如何从部署在 Deno Deploy 上的应用程序连接到 Neon Postgres 数据库。

你可以找到一个更全面的教程，该教程在 Postgres 之上构建了一个示例应用程序，[点击这里](../tutorials/tutorial-postgres)。

## 设置 Postgres

要开始，我们需要创建一个新的 Postgres 实例供我们连接。为了本教程，我们将使用 [Neon Postgres](https://neon.tech/)，因为他们提供免费的托管 Postgres 实例。如果你希望将数据库托管在其他地方，也可以这么做。

1. 访问 https://neon.tech/ 并点击 **注册**，通过电子邮件、Github、Google 或合作伙伴帐户进行注册。注册后，系统将引导你进入 Neon 控制台以创建你的第一个项目。
2. 输入项目的名称，选择 Postgres 版本，提供数据库名称，并选择区域。通常，你会选择离你的应用程序最近的区域。当你完成后，点击 **创建项目**。
3. 系统会向你展示新项目的连接字符串，你可以用来连接到数据库。保存连接字符串，通常看起来像这样：

   ```sh
   postgres://alex:AbC123dEf@ep-cool-darkness-123456.us-east-2.aws.neon.tech/dbname?sslmode=require
   ```

   你需要在下一步中使用连接字符串。

## 在 Deno Deploy 中创建项目

接下来，让我们在 Deno Deploy 中创建一个项目，并设置所需的环境变量：

1. 访问 [https://dash.deno.com/new](https://dash.deno.com/new)（如果你还没有登录，使用 GitHub 登录）并点击 **创建一个空项目**，在 **部署你自己的代码** 下。
2. 现在点击项目页面上的 **设置** 按钮。
3. 导航到 **环境变量** 部分并添加以下秘密。

- `DATABASE_URL` - 值应设置为你在上一步中保存的连接字符串。

![postgres_env_variable](../docs-images/neon_postgres_env_variable.png)

## 编写连接到 Postgres 的代码

要使用 [Neon 无服务器驱动程序](https://deno.com/blog/neon-on-jsr) 来读写 Postgres，首先使用 `deno add` 命令安装它：

```sh
deno add jsr:@neon/serverless
```

这将创建或更新你的 `deno.json` 文件，并添加依赖项：

```json
{
  "imports": {
    "@neon/serverless": "jsr:@neon/serverless@^0.10.1"
  }
}
```

现在你可以在代码中使用该驱动程序：

```ts
import { neon } from "@neon/serverless";

// 从环境变量 "DATABASE_URL" 获取连接字符串
const databaseUrl = Deno.env.get("DATABASE_URL")!;

// 创建 SQL 查询执行器
const sql = neon(databaseUrl);

try {
  // 创建表
  await sql`
    CREATE TABLE IF NOT EXISTS todos (
      id SERIAL PRIMARY KEY,
      title TEXT NOT NULL
    )
  `;
} catch (error) {
  console.error(error);
}
```

## 将应用程序部署到 Deno Deploy

一旦你完成了应用程序的编写，就可以在 Deno Deploy 上部署它。

为此，回到你的项目页面 `https://dash.deno.com/projects/<project-name>`。

你应该会看到几个部署选项：

- [Github 集成](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

除非你想添加构建步骤，否则我们建议你选择 GitHub 集成。

有关在 Deno Deploy 上以不同方式部署和不同配置选项的详细信息，请阅读 [这里](how-to-deploy)。

---

# 组织

URL: https://docs.deno.com/deploy/manual/organizations


**组织** 允许您与其他用户协作。在一个组织中创建的项目对该组织的所有成员都是可访问的。用户应首先注册 Deno Deploy，然后才能被添加到组织中。

目前，所有组织成员都拥有对组织的完全访问权限。他们可以添加/移除成员，并创建/删除/修改该组织中的所有项目。

### 创建组织

1. 在您的 Deploy 控制台上，点击屏幕左上角导航栏中的组织下拉菜单。
   ![organizations](../docs-images/organizations.png)
2. 选择 **组织 +**。
3. 输入您的组织名称，然后点击 **创建**。

### 添加成员

1. 在屏幕左上角导航栏中的组织下拉菜单中选择所需的组织。
2. 点击 **成员** 图标按钮。
3. 在 **成员** 面板下，点击 **+ 邀请成员**。
   > **注意：** 用户应首先使用
   > [这个链接](https://dash.deno.com/signin) 注册 Deno Deploy，然后您才能邀请他们。
4. 输入用户的 GitHub 用户名，然后点击 **邀请**。

Deploy 会向用户发送邀请电子邮件。然后他们可以选择接受或拒绝您的邀请。一旦他们接受邀请，他们将被添加到您的组织并显示在成员面板中。

待处理的邀请将在 **邀请** 面板中显示。您可以通过点击待处理邀请旁边的删除图标来撤销待处理的邀请。

### 移除成员

1. 在屏幕左上角导航栏中的组织下拉菜单中选择所需的组织。
2. 点击 **成员** 图标按钮。
3. 在 **成员** 面板中，点击要移除的用户旁边的删除按钮。

---

# 游乐场

URL: https://docs.deno.com/deploy/manual/playgrounds


**游乐场** 是一个简单的方式来玩转 Deno Deploy，并创建小项目。使用游乐场，您可以编写代码、运行代码，并在浏览器中完全看到输出。

游乐场拥有 Deno Deploy 的全部功能：它们支持与普通项目相同的所有功能，包括环境变量、自定义域名和日志。

游乐场的性能与 Deno Deploy 上的所有其他项目同样优秀：它们充分利用我们的全球网络，以尽可能接近用户的方式运行您的代码。

- [创建一个游乐场](#创建一个游乐场)
- [使用游乐场编辑器](#使用游乐场编辑器)
- [将游乐场设为公开](#将游乐场设为公开)
- [将游乐场导出到 GitHub](#将游乐场导出到-github)

## 创建一个游乐场

要创建一个新的游乐场，请点击 [项目概览页面](https://dash.deno.com/projects) 右上角的 **新建游乐场** 按钮。

这将创建一个随机生成名称的新游乐场。您可以稍后在项目设置中更改此名称。

## 使用游乐场编辑器

创建新游乐场时，游乐场编辑器会自动打开。您也可以通过导航到项目概览页面并点击 **编辑** 按钮来打开它。

编辑器主要分为两个区域：左侧是编辑器，右侧是预览面板。编辑器是您编写代码的地方，预览面板是您可以通过浏览器窗口查看代码输出的地方。

左侧的编辑器面板下方还有一个日志面板。此面板显示您的代码控制台输出，对调试代码很有帮助。

在编辑代码后，您需要保存并部署它，以便右侧的预览更新。您可以通过点击右上角的 **保存并部署** 按钮，按下 <kbd>Ctrl</kbd> + <kbd>S</kbd>，或按 <kbd>F1</kbd> 打开命令面板并选择 **部署：保存并部署** 来完成此操作。

在编辑器右上角的工具栏中，您可以在保存时查看项目的当前部署状态。

每次保存并部署代码时，右侧的预览面板会自动刷新。

编辑器右上角的语言下拉菜单允许您在 JavaScript、JSX、TypeScript 和 TSX 之间切换。默认选中的语言是 TSX，这在大多数情况下都能正常工作。

## 将游乐场设为公开

游乐场可以通过设为公开与其他用户共享。这意味着任何人都可以查看游乐场及其预览。公共游乐场不能被其他人编辑：它们只能由您编辑。日志也仅对您可见。用户可以选择分叉一个公共游乐场，以创建一个可以编辑的私有副本。

要将游乐场设为公开，请在编辑器顶部工具栏中点击 **共享** 按钮。您游乐场的 URL 将自动复制到剪贴板。

您还可以通过 Deno Deploy 仪表板中的游乐场设置页面更改游乐场的可见性。这可以用于将游乐场的可见性从公开更改为私有。

## 将游乐场导出到 GitHub

游乐场可以导出到 GitHub。这在您的项目开始超出游乐场编辑器的单文件限制时非常有用。

这样做将创建一个包含游乐场代码的新 GitHub 仓库。该项目将自动转换为一个与这个新 GitHub 仓库关联的 git 项目。环境变量和域名将被保留。

新创建的 GitHub 仓库将存储在您的个人账户中，并设置为私有。您可以在 GitHub 仓库设置中稍后更改这些设置。

导出游乐场后，您将无法再使用 Deno Deploy 游乐场编辑器来处理该项目。这是一个单向操作。

要导出游乐场，请访问 Deno Deploy 仪表板中的游乐场设置页面，或在命令面板中选择 **部署：导出到 GitHub**（在编辑器中按 <kbd>F1</kbd>）。

在这里，您可以输入新 GitHub 仓库的名称。该名称将用于在 GitHub 上创建仓库。仓库不能已经存在。

按下 **导出** 将游乐场导出到 GitHub。

---

# 连接到 Postgres

URL: https://docs.deno.com/deploy/manual/postgres


本教程介绍如何从部署在 Deno Deploy 上的应用程序连接到 Postgres 数据库。

您可以在 [这里](../tutorials/tutorial-postgres) 找到一个更全面的教程，该教程将在 Postgres 上构建一个示例应用程序。

## 设置 Postgres

> 本教程将完全集中于无加密连接到 Postgres。如果您希望使用自定义 CA 证书进行加密，请使用 [这里](https://deno-postgres.com/#/?id=ssltls-connection) 的文档。

要开始，我们需要为我们要连接的 Postgres 实例创建一个新的实例。对于本教程，我们将使用 [Supabase](https://supabase.com)，因为它们提供免费的托管 Postgres 实例。如果您希望将数据库托管在其他地方，您也可以这样做。

1. 访问 https://app.supabase.io/ 并单击 **新项目**。
2. 为您的数据库选择一个名称、密码和地区。确保保存密码，因为稍后您将需要它。
3. 单击 **创建新项目**。创建项目可能需要一些时间，请耐心等待。

## 从 Postgres 获取凭据

设置完 Postgres 数据库后，从您的 Postgres 实例中收集连接信息。

### Supabase

对于上述 Supabase 实例，要获取连接信息：

1. 导航到左侧的 **数据库** 选项卡。
2. 转到 **项目设置** >> **数据库**，并从 **连接字符串** >> **URI** 字段中复制连接字符串。这是您将用来连接数据库的连接字符串。将您之前保存的密码插入该字符串中，然后将其保存到某处 - 您稍后会需要它。

### psql

如果您使用 psql，通常可以通过运行以下命令找到连接信息：

```psql
test=# \conninfo
```

您的 Postgres 连接字符串将采用以下形式：

```sh
postgres://user:password@127.0.0.1:5432/deploy?sslmode=disable
```

## 在 Deno Deploy 中创建项目

接下来，让我们在 Deno Deploy 中创建一个项目，并设置所需的环境变量：

1. 转到 [https://dash.deno.com/new](https://dash.deno.com/new)（如果尚未登录，请用 GitHub 登录），然后在 **从命令行部署** 下点击 **+ 空项目**。
2. 现在点击项目页面上的 **设置** 按钮。
3. 导航到 **环境变量** 部分，并添加以下密钥。

- `DATABASE_URL` - 值应为您在上一步中获取的连接字符串。

![postgres_env_variable](../docs-images/postgres_env_variable.png)

## 编写连接到 Postgres 的代码

要读取/写入Postgres，请导入合适的Postgres模块，例如 [这个来自 JSR 的模块](https://jsr.io/@bartlomieju/postgres)，从环境变量中读取连接字符串，并创建一个连接池。

```ts
import { Pool } from "jsr:@bartlomieju/postgres";

// 从环境变量 "DATABASE_URL" 获取连接字符串
const databaseUrl = Deno.env.get("DATABASE_URL")!;

// 创建一个带有三个懒惰建立的连接的数据库连接池
const pool = new Pool(databaseUrl, 3, true);

// 连接到数据库
const connection = await pool.connect();

try {
  // 创建表
  await connection.queryObject`
    CREATE TABLE IF NOT EXISTS todos (
      id SERIAL PRIMARY KEY,
      title TEXT NOT NULL
    )
  `;
} finally {
  // 将连接释放回连接池
  connection.release();
}
```

## 将应用程序部署到 Deno Deploy

完成应用程序的编写后，您可以将其部署到 Deno Deploy。

为此，请返回到您的项目页面，网址为 `https://dash.deno.com/projects/<project-name>`。

您应该会看到几个部署选项：

- [Github 集成](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

除非您希望添加构建步骤，否则我们建议您选择 GitHub 集成。

有关在 Deno Deploy 上以不同方式部署和不同配置选项的更多详细信息，请阅读 [这里](how-to-deploy)。

---

# 定价和限制

URL: https://docs.deno.com/deploy/manual/pricing-and-limits


请参阅 [我们的定价页面](https://deno.com/deploy/pricing)，了解所有套餐中可用功能的概览。如果您的使用场景超出了这些限制，[请联系我们](mailto:deploy@deno.com)。

在 Deno Deploy的初始公开测试阶段不提供正常运行时间保证。对服务的访问将受到
[我们的可接受使用政策](/deploy/manual/acceptable-use-policy)的控制。任何被我们认为违反此政策的用户，都可能面临账号被终止的风险。

## 部署的最大大小

上传资产到部署时，所有文件（源文件和静态文件）的总大小
**不应超过1GB**。

## 内存分配

应用程序的最大内存分配为 512MB。

## 上传请求限制

只要您的应用程序符合
[我们的可接受使用政策](/deploy/manual/acceptable-use-policy)，
我们不限制您的应用程序可以处理的上传请求数量。

## TLS 代理

对于端口 443（HTTPS使用端口）的外发连接，需进行 TLS 终止。禁止使用 [Deno.connect](https://docs.deno.com/api/deno/~/Deno.connect) 连接这些端口。如果需要建立到 443 端口的 TLS 连接，请改用 [Deno.connectTls](https://docs.deno.com/api/deno/~/Deno.connectTls)。`fetch` 不受此限制。

此限制的原因是，未终止 TLS 直接连接到 443 端口的情况通常用于 TLS-over-TLS 代理，而根据 [我们的可接受使用政策](/deploy/manual/acceptable-use-policy)，在 Deno Deploy 中禁止使用此类代理形式。

---

# Connect to Prisma Postgres

URL: https://docs.deno.com/deploy/manual/prisma-postgres


This tutorial covers how to connect to a Prisma Postgres database from an
application deployed on Deno Deploy.

You can find a more comprehensive tutorial that builds a sample application on
top of Postgres [here](../tutorials/tutorial-postgres).

## Setup Postgres

There are several ways to set up a Prisma Postgre database for your Prisma
project. This guide covers the most common approaches.

### Method 1: Using Prisma CLI

Run the following command to initialize a new Prisma project with a database:

```bash
npx prisma init --db
```

This will prompt you to select your preferred region and database name. Once
completed, you'll find the `DATABASE_URL` connection string in your `.env` file.

### Method 2: Using `npx create-db`

Alternatively, you can use the dedicated database creation tool:

```bash
npx create-db@latest
```

This command will provide you with two connection strings tied to the same
database:

**Prisma ORM optimized connection string:**

```txt
prisma+postgres://accelerate.prisma-data.net/?api_key=<api_key>
```

**Standard Prisma Postgres connection string:**

```txt
postgresql://<username>:<password>@db.prisma.io:5432/postgres
```

In order to keep the database created with `npx create-db`, you must follow
through with the claim process. That can be done via the claim link provided in
the terminal.

The Prisma ORM optimized connection string (`prisma+postgres://`) only works
with the Prisma ORM, while the standard Prisma Postgre connection string can be
used with other database tools and libraries.

## Create a project in Deno Deploy

Next, let's create a project in Deno Deploy and set it up with the requisite
environment variables:

1. Go to [https://dash.deno.com/new](https://dash.deno.com/new) (Sign in with
   GitHub if you didn't already) and click on **Create an empty project** under
   **Deploy your own code**.
2. Now click on the **Settings** button available on the project page.
3. Navigate to **Environment Variables** Section and add the following secret.

- `DATABASE_URL` - The value should be set to the connection string you saved in
  the last step.

![postgres_env_variable](../docs-images/prisma_postgres_env_variable.png)

## Write code that connects to Postgres

Now that you have your database set up, let's create a simple application that
connects to the Prisma Postgres database using Prisma ORM.

### 1. Install dependencies

First, install the required dependencies:

```bash
deno install npm:@prisma/client
deno install npm:@prisma/extension-accelerate
deno install npm:dotenv-cli
```

:::note

The `dotenv-cli` package is needed because Prisma Client doesn't read `.env`
files by default on Deno.

:::

### 2. Create the database schema

With your database connection configured, you can now apply the data model to
your database:

```bash
deno run -A npm:prisma migrate dev --name init
```

This command creates a new SQL migration file and runs it against your database.

### 3. Update your Prisma schema

Edit your `prisma/schema.prisma` file to define a `Log` model and configure it
for Deno:

```ts
generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
  runtime  = "deno"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Log {
  id      Int    @id @default(autoincrement())
  level   Level
  message String
  meta    Json
}

enum Level {
  Info
  Warn
  Error
}
```

### 4. Create your application

Create `index.ts` in your project root with the following content:

```typescript
import { serve } from "https://deno.land/std@0.140.0/http/server.ts";
import { withAccelerate } from "npm:@prisma/extension-accelerate";
import { PrismaClient } from "./generated/prisma/client.ts";

const prisma = new PrismaClient().$extends(withAccelerate());

async function handler(request: Request) {
  // Ignore /favicon.ico requests:
  const url = new URL(request.url);
  if (url.pathname === "/favicon.ico") {
    return new Response(null, { status: 204 });
  }

  const log = await prisma.log.create({
    data: {
      level: "Info",
      message: `${request.method} ${request.url}`,
      meta: {
        headers: JSON.stringify(request.headers),
      },
    },
  });
  const body = JSON.stringify(log, null, 2);
  return new Response(body, {
    headers: { "content-type": "application/json; charset=utf-8" },
  });
}

serve(handler);
```

### 4. Test your application locally

Start your application locally to test the database connection:

```bash
npx dotenv -- deno run -A ./index.ts
```

Visit `http://localhost:8000` in your browser. Each request will create a new
log entry in your database and return the log data as JSON.

## Deploy application to Deno Deploy

Once you have finished writing your application, you can deploy it on Deno
Deploy.

To do this, go back to your project page at
`https://dash.deno.com/projects/<project-name>`.

You should see a couple of options to deploy:

- [Github integration](ci_github)
- [`deployctl`](./deployctl.md)
  ```sh
  deployctl deploy --project=<project-name> <application-file-name>
  ```

Unless you want to add a build step, we recommend that you select the GitHub
integration.

For more details on the different ways to deploy on Deno Deploy and the
different configuration options, read [here](how-to-deploy).


---

# Privacy Policy

URL: https://docs.deno.com/deploy/manual/privacy-policy


**DENO PRIVACY POLICY** 09 September 2024

Deno Land Inc. (“Deno,” “we,” “us,” or “our”) collects and uses personal
information in order to provide its products and services to you. This Privacy
Policy (the “Policy”) describes the personal information we collect, the
purposes for which we use it, the parties with whom we may share it, and your
choices with respect to such information. For purposes of this Privacy Policy,
“personal information” means any information that relates to you as an
individual and could reasonably be used to identify you. This Privacy Policy
applies to our collection and use of personal information through (i) our
website at [https://deno.com](https://deno.com) (the “Site”); (ii) any websites,
applications or other digital properties that link to this Privacy Policy; and
(iii) the products and services (the “Deno Offerings”) we offer to you on our
proprietary platform (the “Platform”) via the following websites:

- Deno Deploy ([https://deno.com/deploy](https://deno.com/deploy)); and
- Deno Subhosting ([https://deno.com/subhosting](https://deno.com/subhosting)).

By accessing or using the Site or any other digital property that links to this
Privacy Policy, you may learn about Deno and our technology platform, and
registered customers may also access the Deno Offerings (collectively, the
“Services”). To the extent permitted by applicable law, your use of Deno’
products and services constitutes your acknowledgment and/or consent to the
practices described in this Policy.

This Privacy Policy incorporates
[Deno’s Terms and Conditions](https://docs.deno.com/deploy/manual/terms-and-conditions/)
(the “Terms”). Capitalized terms that are not defined in the Privacy Policy have
the meaning given to them in the Terms.

**I. The Information We Collect, And How We Collect It**

We collect the following categories of information, which may include personal
information (collectively, the “**Information**”).

**1\. Information You Provide To Us**

We collect information from and about you directly when you provide it to us.
This information may be collected when you contact us, fill out a form, create
an account, subscribe to our blog, access or participate on our Sites, respond
to surveys, or otherwise interact with us. This information may include:

*Contact Information. *We collect your contact information when you voluntarily
provide it to us. For example, you may disclose contact information to us via
the “Contact” link on our Sites, submit information by mail, telephone, in
person or electronically, when signing up for our newsletters and other
marketing communications, or when you register to attend an event or program.
Contact Information typically includes first name, last name, e-mail address,
postal address, organization, telephone number and other information that
identifies you or can be used to identify or contact you.

_Account Credentials_. When you register to create an account with us, we will
collect certain additional personal information, including your name, email
address, and potentially other information such as your GitHub user name and
public GitHub profile.

In addition to Contact Information and Account Credentials, we may collect other
kinds of information, such as:

- Comments, questions, and requests you may make;

- Information about your preferences, such as your preferred methods of
  communication and the types of information in which you are interested;

- Event and service-related information (such as information required for
  registration, access to premises or online resources, dietary restrictions,
  and areas of interest);

- Audio and visual information, such as photographs, video and voice recordings
  (e.g., from events you attended with us), or security camera recordings if you
  visit our premises;

- Details of downloads from our Sites;

- Records and copies of your correspondence (including email addresses and phone
  numbers), if you contact us; and

- Any other information you voluntarily provide.

**2\. Information Obtained From Third Parties**

We may receive certain information about you from other sources, including
publicly available sources (such as public records and social media platforms),
as well as our service providers and marketing partners.

When we collect personal information from users and visitors of other sites on
which you have interacted with us, we will do so in accordance with the terms of
use and privacy policies of those sites and applicable law. We may also receive
personal information when you comment on our social media advertisements, post
comments about us, or tag us in a public-facing social media post. Personal
information may also be collected by the third-party social media sites that
host our social media pages. These sites may provide aggregate information and
analysis to us about visitors’ use of our social media pages. This allows us to
better understand and analyze our user growth, general demographic information
about the users of these pages, and interaction with the content that we post.
Overall, this information may be used to help us understand the types of
visitors and users of our social media pages and use of the content. This
Privacy Policy does not cover personal information collected by such third-party
social media sites. For more information on their privacy and security practices
please review the privacy policies and terms of use on their respective
websites.

**3\. Information Collected Automatically**

We and our service providers may automatically obtain certain information about
you, your electronic device, and your interactions with us, including the
following:

- _Device data_. We may collect data such as the type of device and its
  operating system and settings, browser type, mobile device carrier, country,
  IP address, and unique identifiers.

- _Internet and other or electronic activity data_. This includes information
  about your interaction with our Sites, emails, and other online content.

- _Tracking Data_. We may collect tracking data using first and third-party
  cookies, pixels, web server logs, web beacons, and similar data collection and
  tracking technologies on the Sites, third party websites, apps and online
  services, and across your devices (such as IP address, browser, type, ISP,
  platform type, device type). Third parties such as advertising networks and
  analytics providers may also collect information about your online activities
  over time and across different websites and devices when you access or use the
  Sites.

**II. How We Use And Share Your Information**

Deno uses the Information for the purpose for which it was collected and in a
manner that is consistent with this Privacy Policy. These functions include
operation, maintenance and improvements to the Sites, providing our products and
services, solicitation of your feedback, gaining a better understanding of our
customers and visitors of our Sites, responding to your requests and questions,
hosting events, and informing you about our organization, products, services,
events, and other areas of interest.

_Analytics Services_. We may use third-party web analytics services, such as
Google Analytics, to help us understand and analyze how Site visitors use our
services. For more information on how Google Analytics uses data collected
through our Sites, visit
[www.google.com/policies/privacy/partners](http://www.google.com/policies/privacy/partners).

_Aggregated Data_. We may analyze your personal information in aggregate form
which does not identify you personally (“**Aggregated Data**”). The Aggregated
Data may be used to operate, maintain, manage, and improve the Sites, shared
with our affiliates, agents, and business partners, and otherwise used and
disclosed for lawful business purposes. We do not re-identify de-identified or
aggregated information.

_Service Providers/Vendors_. Like many businesses, we hire other companies to
perform certain business-related services. We may disclose personal information
to certain types of third party companies but only to the extent needed to
enable them to provide such services, for example web hosting, disaster
recovery, client survey and marketing, and data storage.

_Reorganization_. If, in the future, Deno undergoes a corporate, partnership, or
business reorganization, we may transfer the Information, including personal
information, to the new or surviving entity. 

_Protection of Rights and Compliance_. We may use your Information to protect
the rights, privacy or safety of you, us or others; to ensure our compliance
with legal and contractual requirements; and to prevent and investigate illegal,
unethical, or unauthorized activities (including cyberattacks and identity
theft).

If Deno intends on using or disclosing your personal information in any manner
that is not consistent with this Privacy Policy, you will be informed of such
anticipated use prior to or at the time at which the personal information is
collected.

**III. How We Protect Your Information**

We take commercially reasonable steps to protect your personal information from
loss, misuse, and unauthorized access, disclosure, alteration, or destruction.
Please understand, however, that no security system is impenetrable. We cannot
guarantee the security of our databases, nor can we guarantee that the personal
information that you supply will not be intercepted while being transmitted to
and from us over the Internet.

**IV. Data Retention**

Deno determines the retention period for all Information based on the purposes
for which we collect and/or receive the Information and/or tax, legal and
regulatory requirements. In addition to this, we may consider other factors,
such as the nature and sensitivity of the data, and whether we can achieve the
purpose for which we collected the data through other means.

**V. Your Privacy Choices**

**1\. Your Information**

You may request access to, correction of, or deletion of the personal
information we maintain about you, and we will endeavor to respond promptly to
your request. In order to make such a request, please contact us as indicated
below.

**2\. Marketing Communications**

You may opt-out of marketing-related emails by clicking on the “unsubscribe”
link located on the bottom of any marketing email or emailing us at
[support@deno.com](mailto:support@deno.com). We will use commercially reasonable
efforts to process such requests in a timely manner. Please note that even if
you opt-out of marketing-related emails, you will continue to receive
service-related and other non-marketing emails.

**3\. Tracking Technology**

You can choose not to permit tracking technologies, such as cookies and web
beacons, when you use our services, but blocking some types of these tracking
technologies may interfere with your experience.

_Browser-Based Opt-Outs_. You may be able to disable tracking technologies using
your web browser settings. Please review your browser’s instructions or visit
[All About Cookies](https://allaboutcookies.org/) for general information. Note
that your web browser may have settings that allow you to transmit a “Do Not
Track” signal when you use online services. Like many websites, our Sites are
not currently designed to respond to “Do Not Track” signals received from
browsers.

_Self-Regulatory Program Opt-Outs_. Two self-regulatory programs are available
to help you control the use of tracking technologies on your browsers — the
[Digital Advertising Alliance](https://digitaladvertisingalliance.org/) and the
[Network Advertising Initiative](https://thenai.org/). Both programs help to
regulate vendors in the digital advertising space. One function of their
self-regulatory programs is to give you the ability to opt out of targeted (or
interest-based) advertising, including the use of tracking technologies, from
their member companies. You can visit the Digital Advertising Alliance’s Your Ad
Choices website to opt out of targeted advertising for participating vendors.
The Network Advertising Initiative similarly assists with opt outs through their
Opt Out of Interest-Based Advertising webpage.

_Google Analytics Opt-Out._ To opt out of Google Analytics cookies, visit
Google’s [My Ad Center](https://myadcenter.google.com/personalizationoff) and/or
download the Google Analytics Opt-Out Browser Add-On.

**VI. Children**

We do not knowingly collect personal information from children under the age of
18 through the Sites. If you are under 18, please do not give us any personal
information. We encourage parents and legal guardians to monitor their
children’s Internet usage and to help enforce our Privacy Policy by instructing
their children never to provide personal information through the Sites without
their permission. If you have reason to believe that a child under the age of 18
has provided personal information to us, please contact us, at
[support@deno.com](mailto:support@deno.com) and we will endeavor to delete that
information from our databases.

**VII. External Websites**

The Sites may contain links to third-party websites. These third-party sites may
collect information about you if you click on a link. We have no control over
the privacy practices or the content of these websites. As such, we are not
responsible for the content or the privacy policies of those third-party
websites. You should check the applicable third-party privacy policy and terms
of use when visiting any other websites.

**VIII. Important Notice To Non-U.S. Residents**

The Sites are hosted in and provided from the United States and other countries.
If you are located outside of the United States, please be aware that any
information you provide to us may be transferred to the United States or other
countries where the privacy laws may not be as protective as those in your
country of origin. If you are located outside the United States and choose to
use the Sites, you consent to any transfer and processing of your personal
information in accordance with this Privacy Policy, and you do so at your own
risk.

**IX. Notice To California Residents**

Pursuant to Section 1798.83 of the California Civil Code, residents of
California have the right to obtain certain information about the types of
personal information that companies with whom they have an established business
relationship (and that are not otherwise exempt) have shared with third parties
for direct marketing purposes during the preceding calendar year, including the
names and addresses of those third parties, and examples of the types of
services or products marketed by those third parties. In order to submit such a
request, please contact us using the contact information provided at the end of
this document. Please note, however, that we do not share, nor have we shared in
the past, personal information with third parties for direct marketing purposes.

**X. Notice To Nevada Residents**

If you are a resident of Nevada, you have the right to opt-out of the sale of
personal information to third parties. You can exercise this right by contacting
us at [support@deno.com](mailto:support@deno.com) with the subject line “Nevada
Do Not Sell Request” and providing us with your name and the email address.
Please note, however, that we do not sell any personal information to third
parties.

**XI. Changes To This Privacy Policy**

This Privacy Policy is effective as of the date stated at the top of this
Privacy Policy. We may change this Privacy Policy from time to time. Any such
changes will be posted on the Sites. By accessing the Sites after we make any
such changes to this Privacy Policy, you are deemed to have accepted such
changes. Please be aware that, to the extent permitted by applicable law, our
use of the Information is governed by the Privacy Policy in effect at the time
we collect the Information. Please refer back to this Privacy Policy on a
regular basis.

**XII. How To Contact Us**

Please reach out to [support@deno.com](mailto:support@deno.com) for any
questions, complaints, or requests regarding this Privacy Policy, and include in
the subject line “Privacy Policy", or contact us by mail at:

Deno Land Inc.\
1111 6th Ave Ste 550\
PMB 702973\
San Diego CA, 92101\
USA

**© 2024 Deno Land Inc. All rights reserved.**


---

# 区域

URL: https://docs.deno.com/deploy/manual/regions


Deno Deploy 将您的代码部署到全球各地。每个新请求都从离用户最近的区域提供服务。目前，部署位于以下区域：

- 新加坡（`asia-southeast1`）
- 伦敦（`europe-west2`）
- 法兰克福（`europe-west3`）
- 圣保罗（`southamerica-east1`）
- 北弗吉尼亚（`us-east4`）
- 加利福尼亚（`us-west2`）

该列表将保持更新，以反映我们区域的最新概况。

代码被部署到所有区域，并从离最终用户最近的区域提供服务，以最小化延迟。目前无法限制您的代码部署的区域。

---

# 本地开发

URL: https://docs.deno.com/deploy/manual/running-scripts-locally


要进行本地开发，您可以使用 `deno` CLI。要安装 `deno`，请按照[Deno 手册](https://deno.land/manual/getting_started/installation)中的说明进行操作。

安装后，您可以在本地运行脚本：

```shell
$ deno run --allow-net=:8000 https://deno.com/examples/hello.js
正在监听 http://localhost:8000
```

要监视文件更改，请添加 `--watch` 标志：

```shell
$ deno run --allow-net=:8000 --watch ./main.js
正在监听 http://localhost:8000
```

有关 Deno CLI 的更多信息，以及如何配置您的开发环境和 IDE，请访问 Deno 手册的[开始使用][manual-gs]部分。

[manual-gs]: https://deno.land/manual/getting_started

---

# 安全与负责任的披露

URL: https://docs.deno.com/deploy/manual/security


我们将系统的安全性以及这些系统控制的所有数据视为重中之重。无论我们在系统安全上投入多大精力，仍然有可能存在安全漏洞。我们非常感谢那些出于善意、伦理的安全研究人员对系统安全进行的调查工作。如果您发现了一个漏洞，无论多小，我们都希望您能告知我们，以便我们能够尽快采取适当措施来解决此问题。此页面概述了我们与安全研究社区合作以解决系统安全问题的方法。

## 报告漏洞

请将您的发现通过电子邮件发送至 security@deno.com。我们努力尽快解决所有问题，并非常乐意在问题解决后积极参与撰写报告的发布。

## 请遵循以下事项：

- 不要利用您发现的漏洞或问题。例如，仅下载必要的数据以演示漏洞 - 不要下载更多。也不要删除、修改或查看他人的数据。
- 在问题解决之前，请不要发布或透露该问题。
- 不要进行物理安全攻击、社会工程、分布式拒绝服务、垃圾邮件或第三方应用程序的攻击。
- 请提供足够的信息以重现问题，以便我们能尽快解决。通常，受影响系统的IP地址或URL以及漏洞的描述就足够了，但复杂的漏洞可能需要进一步解释。

## 我们的承诺

- 如果您按照此政策行事，我们将不会对您的报告采取法律行动。
- 我们将对您的报告严格保密，并且在没有您许可的情况下不会将您的个人信息传递给第三方。

---

# 条款和条件

URL: https://docs.deno.com/deploy/manual/terms-and-conditions


**DENO 条款和条件** 2024年9月9日

本条款和条件（“条款”）是您与 Deno Land Inc.（“Deno”，“我们”，“我们公司”或“我们的”）之间的法律协议。它们规定了您可以访问和使用（i）我们的网站 [https://deno.com](https://deno.com) （“网站”）；（ii）任何链接到这些条款的网站、应用程序或其他数字属性；以及（iii）我们通过以下网站在我们的专有平台（“平台”）上向您提供的产品和服务（“Deno 产品”）：

- Deno Deploy ([https://deno.com/deploy](https://deno.com/deploy))；以及
- Deno Subhosting ([https://deno.com/subhosting](https://deno.com/subhosting))。

通过访问或使用网站或任何链接到这些条款的其他数字属性，您可以了解 Deno 及其技术平台，注册客户还可以访问 Deno 产品（统称为“服务”）。

请仔细阅读这些条款。通过访问和/或使用服务，您确认您已阅读、理解并同意受到这些条款、数据处理附录（“DPA”）和我们的隐私政策（“隐私政策”）的法律约束，这些政策通过引用并入本条款并构成协议的一部分（统称为“协议”）。如果您不同意本协议中的任何条款，请不要使用服务。

如果您代表公司或其他法律实体接受或同意本协议，您声明并保证您有权利使该公司或其他法律实体受本协议的约束，在这种情况下，“您”和“您的”将指代并适用于该公司或其他法律实体。

我们保留在自行决定的情况下，随时修改、停止或终止任何服务的可用性，或修改本协议，且不需提前通知。我们鼓励您在每次访问或使用服务时检查这些条款及上面的“最后更新”日期。在我们发布对这些条款的修改后，继续访问或使用服务，即表示您同意受修改后协议的约束。如果修改后的协议您无法接受，您唯有停止访问或使用服务。

Deno 还提供收费的产品和服务（包括不时的免费试用），这些产品和服务可能提供对某些数据产品和/或服务的访问（“付费产品”）。我们根据您在购买时做出的适用付费产品的商业协议（每个“商业协议”）提供对我们的付费产品的访问和使用。如果本条款与您购买的付费产品的适用商业协议的条款和条件之间存在冲突，以商业协议的条款和条件为准。

未在这些条款中定义的专有名词应具有我们隐私政策中规定的含义。

**以下标题为“具有约束力的仲裁”和“集体诉讼豁免”的部分包含具有约束力的仲裁协议和集体诉讼豁免。它们会影响您的法律权利。请仔细阅读。**

1. **服务的描述；访问和使用服务的权利**

**Deno Deploy** 和 **Deno Subhosting** 是全球分布的无服务器 JavaScript 应用程序平台。您的 JavaScript、TypeScript 和 WebAssembly 代码在地理位置接近用户的管理服务器上运行，提供低延迟和更快的响应时间。部署和子托管应用程序在快速、轻便的 V8 隔离环境中运行，而不是在虚拟机上，由 Deno 运行时提供支持。

在本协议的条款和条件的限制下，Deno 在本协议期间授予您有限的、非独占的、不可转让的、不可再许可的、可撤回的权利，仅为您的内部商业目的访问和使用服务。

Deno 保留在任何时候，且无须通知或对您承担责任的权利：

1. 阻止和禁用任何因某种原因使平台不稳定的部署；
2. 更改服务运行的区域；
3. 更改服务支持的功能；以及
4. 修改或停止其他与服务相关的任何功能、功能或内容的可用性。

您同意，我们不对您或任何第三方因服务或其任何部分的修改、暂停或中止而承担责任。您可以随时停止使用服务。

2. **账户凭证**

   为了使用 Deno 产品，您必须是“授权用户”。要成为授权用户，您需要在平台上创建一个账户，并通过 GitHub 进行身份验证（统称为“账户凭证”）。在创建账户时，每个授权用户必须提供真实、准确、当前和完整的信息。每个账户凭证只能由一个授权用户使用。每个授权用户对其账户凭证的保密性和使用负责，包括与其账户凭证相关联的所有活动。授权用户必须及时通知我们需要停用任何账户凭证。Deno 没有义务接受任何人作为授权用户，并可全权接受或拒绝任何注册。我们有权在任何时候出于任何原因禁用任何账户凭证，包括在我们自行决定的情况下认为您未能遵守这些条款的情况下。

3. **个人信息的使用**

您使用服务可能涉及将某些个人信息传输给我们。我们关于个人信息收集和使用的政策根据我们的隐私政策进行，这里通过引用予以完全纳入。

4. **知识产权**

服务可能包含材料，例如软件、文本、图形、图像、声音录音、视听作品以及由 Deno 或代表 Deno 提供的其他材料（统称为“内容”）。内容可能属于我们或第三方。内容受美国和外国法律的保护。未经授权使用内容可能违反版权、商标和其他法律。您对内容没有任何权利，且除非本协议许可，您不得使用内容。未经我们事先书面同意，您不得以任何其他方式使用内容。您必须在您制作的任何内容副本上保留原始内容中包含的所有版权和其他专有声明。您不得销售、转让、分配、许可、再许可或修改内容，或以任何方式复制、展示、公开执行、制作衍生版本、分发或以其他方式使用内容，用于任何公共或商业目的。将内容用于任何其他网站或在网络计算机环境中发布的任何目的都是明确禁止的。

如果您违反本协议的任何部分，您访问和/或使用内容及服务的权限将自动终止，并且您必须立即销毁您制作的所有内容副本。

Deno 的商标、服务标志和徽标（“Deno 商标”）在服务中使用和展示，属于 Deno 的注册或未注册商标或服务标志。其他公司、产品和服务名称可能属于其他人的商标或服务标志（“第三方商标”，与 Deno 商标统称为“商标”）。服务中的任何内容不应被解读为隐含、禁止或以其他方式授予任何使用商标的许可或权利，除非我们为每种使用事先明确书面许可。除非我们事先书面批准建立链接的目的，否则使用商标作为从任何网站的链接的一部分是被禁止的。由 Deno 商标的使用所产生的所有商誉均为我们的利益。

服务的元素受到商业外观、商标、不正当竞争和其他州和联邦法律的保护，任何人不得以任何方式（包括但不限于使用框架或镜像的方式）全部或部分复制或模仿。内容的任何部分不得在没有我们的明确书面同意下进行转播。

5. **用户数据；使用数据；汇总数据**

就本协议而言，“用户数据”是指（i）我们通过连接到授权用户的业务系统所获取的任何数据和信息，包括但不限于事件日志；以及（ii）授权用户通过服务提交的任何数据和信息；而“使用数据”是指 Deno 收集的关于服务性能和您使用服务的匿名分析数据，包括但不限于您访问服务的日期和时间、访问的服务部分、访问这些页面的频率和次数、在特定时间段内使用服务的次数以及其他使用和性能数据。

在双方之间，授权用户拥有对用户数据的所有权、所有权利、标题和利益，包括对其所做的所有修改、改进、适应、增强或翻译以及其中的所有知识产权。授权用户特此授予 Deno 一项非独占的、全球性的、完全支付的、免版税的权利和许可，并有权授予再许可，以便在本协议的有效期内，复制、执行、使用、存储、归档、修改、执行、展示和分发用户数据；（i）在本协议的有效期内，为 Deno 在本协议下的义务服务；以及（ii）为 Deno 的内部商业目的，包括使用这些数据分析、更新和改进服务及 Deno 的分析能力以及进行基准测试。

尽管本协议另有规定，我们可能以匿名和汇总的形式（“汇总数据”）使用，并可能允许我们的第三方服务提供商访问和使用用户数据以及我们可能收集的任何使用数据，用于操作、维护、管理和改进我们的产品和服务，包括服务。汇总数据不会识别授权用户或任何个人。您特此同意，我们可以收集、使用、发布、传播、转让和以其他方式利用此类汇总数据。

6. **费用**

Deno 提供并且授权用户可以为服务购买月度或年度订阅（“订阅”），费用在我们网站上规定（“订阅费”）。Deno 可以自行决定在任何时候增加新费用和收费或修订费用和收费。订阅的付款应在购买时立即支付。通过购买，您同意通过我们的第三方支付处理器（“第三方支付处理器”）向 Deno 支付所有当时适用的订阅费用。您向第三方支付处理器提供的任何信息将根据该第三方支付处理器的隐私政策和使用条款进行处理。您必须为您的账户提供最新、完整和准确的信息，并及时更新所有信息以保持该账户信息的最新、完整和准确（例如，账单地址、信用卡号码或信用卡到期日期的变化）。此外，如果付款方式被取消（例如，因丢失或失窃）或您意识到可能的安全漏洞（例如，未经授权披露或使用您的用户名或密码），您必须尽快通知我们。有关此类信息的更改可以通过您的账户进行。

通过购买订阅，您承认您的订阅有初始和重复的付款费用，按当时的订阅费率收取，您同意 Deno 可以在未再征得您进一步授权的情况下，向您选择的付款方式提起每月收费，直到您通知我们希望取消订阅或更改付款方式。您还接受在取消之前的所有定期费用的责任，包括在您的付款卡过期后，Deno 根据适用情况处理的任何费用。

您可以通过向我们发送电子邮件至 [support@deno.com](mailto:support@deno.com) 更改或终止您的订阅。如果您终止您的订阅，您可以在当前计费周期结束之前使用您的订阅，并且订阅将在该期限到期后不再续订。Deno 不会退还任何预付款项。Deno 可以根据这些条款立即终止或暂停您的订阅，无论有无理由，包括未按时付款的情况下。如果我们终止或暂停您的订阅，您使用任何与订阅相关的软件或内容的权利也将终止或暂停（如适用）。

Deno 有时可能会提供服务的免费试用。Deno 保留自行决定随时停止提供服务的免费试用的权利，且不对您承担任何责任。

7. **社区规范**

通过访问和/或使用服务，您特此同意遵守以下指南：

- 您不会将服务用于任何非法目的；
- 您不会访问或使用服务收集任何市场研究以支持竞争业务；
- 您不会上传、发布、电子邮件、传输或以其他方式提供任何侵犯任何人或实体的版权、商标、公开权或其他专有权利的内容；
- 您不会冒充任何人或实体或虚假陈述或以其他方式歪曲与任何人或实体的关系；
- 您不会反编译、逆向工程、拆卸或以其他方式试图识别服务中任何软件或其他产品或过程的源代码或接口协议；
- 您不会删除或修改任何放置在服务上的专有标记或限制性说明；
- 您不会以任何可适用的法律违反情况下使用服务或其任何部分，以构建竞争产品或服务，或用于本条款中未明确允许的任何目的；
- 您不会遮盖、遮挡、屏蔽或以任何方式干扰服务中的任何广告和/或安全功能；
- 您不会规避、删除、修改、禁用、降级或阻碍服务中的任何保护措施；
- 您不会引入、发布或上传任何有害代码。这里所称的“有害代码”是指故意设计用来干扰、修改、访问、删除、损坏、禁用、伤害或以任何方式阻碍服务，或任何其他相关软件、固件、硬件、计算机系统或网络的计算机代码、程序或编程设备（包括但不限于“特洛伊木马”、“病毒”、“蠕虫”、“定时炸弹”、“定时锁”、“设备”、“陷阱”、“访问代码”或“死掉”或“陷阱门”设备）或任何其他有害、恶意或隐藏的程序、例程或机制，导致服务停止运行或损坏或破坏数据、存储介质、程序、设备或通信，或以其他方式干扰服务的操作；
- 您不会采取任何行动，施加或可能施加（由我们自行决定）不合理或不成比例的负担在我们的技术基础设施上；
- 您不会干扰或尝试中断服务的正常运行，使用任何病毒、设备、信息收集或传输机制、软件或例程，或通过黑客、密码或数据挖掘或其他方式访问或尝试获取与服务有关的任何数据、文件或密码。

虽然我们没有义务监控对服务的访问或使用，但我们有权这样做以便安全运行，确保遵守这些条款，并遵守适用法律或其他法律要求。我们有权调查这些条款的违规情况或影响服务的行为。我们还可能咨询和配合执法机构，对违反法律的用户进行起诉。

如果您发现任何违反我们用户指南的内容，请告知我们，我们将进行审查。

8. **链接和引用内容**

Deno 不反对第三方服务上指向我们主页的链接，只要它们处于适当的背景中。不过，“框架”或“镜像”服务或内容在没有 Deno 的事先书面同意的情况下是被禁止的。

9. **限制**

服务仅适用于年龄在18岁或以上的个人。如果您未满18岁，请不要访问和/或使用服务。通过签订本协议，您声明并保证您已满18岁。

10. **反馈**

我们欢迎并鼓励您提供对服务和我们服务的反馈、评论和改进建议（“反馈”）。尽管我们鼓励您通过电子邮件与我们联系，但我们不希望您向我们发送包含机密信息的任何内容。关于您提供的任何反馈，我们将可以自由使用和披露其中包含的任何想法、概念、知识、技术或其他材料，出于任何目的，包括但不限于处理、开发、生产和市场营销包含该信息的产品和服务，而无须向您支付补偿或给予署名。

11. **无保证；责任限制**

服务和内容是在“按现状”和“按可用性”基础上提供的，Deno 和 Deno 的供应商对其或与本协议相关的内容不作任何保证，并且 Deno 在此明确放弃所有明示、暗示或法定的保证，包括但不限于任何不侵权、适销性、特定用途适用性、可用性、无错误或无中断操作的保证，以及任何基于交易过程、执行过程或商业使用的保证。在适用法律不允许 Deno 和 Deno 的供应商放弃任何暗示保证的情况下，该保证的范围和持续时间将为适用法律允许的最低限度。

在不限制前述内容的情况下，我们不保证、也不作任何声明，亦不对以下事项负责：(A) 服务的正确性、准确性、可靠性、完整性或最新性；或(B) 您依赖服务或通过服务提供的内容或提示所取得的任何结果、采取的任何行动。您基于服务或通过服务提供的内容或提示所做的任何决定、行动或遗漏均由您自行承担风险。服务及通过服务提供的内容和提示仅作为方便，并不取代对其准确性、完整性和正确性的审查。

就任何保证、合同或普通法侵权索赔而言：(I) 我们不对因使用或无法访问和使用服务而造成的任何偶然或后果性损害、利润损失或因数据丢失或业务中断而造成的损失负责，即使我们已被告知可能会发生此类损害；以及(II) 您因使用服务所遭受的任何直接损害，应限于您在造成索赔时立即之前的十二（12）个月内支付给我们的费用或一百美元（$100）。

12. **外部网站**

服务可能包含指向第三方网站（“外部网站”）的链接。这些链接仅为您的方便提供，并不表示我们认可该外部网站的内容。此类外部网站的内容由其他人开发和提供。如果您对这些链接或该等外部网站上的任何内容有任何疑虑，应联系该外部网站的管理员或网站负责人。我们对任何链接的外部网站的内容不承担责任，也不就该等外部网站上的内容或材料的准确性作出任何声明。您在从所有网站下载文件时应采取预防措施，以保护您的计算机免受病毒和其他破坏性程序的侵害。如果您决定访问链接的外部网站，风险由您自行承担。

13. **声明和保证**

您声明并保证您拥有：（i）提供给我们或授予我们访问和使用用户数据所需的所有权利和权限；以及（ii）根据所有适用法律和法规，已获得关于所提供用户数据的所有必要和适当的同意、权限和授权。

14. **赔偿**

您将赔偿、辩护并使 Deno、其关联公司及我们的及其各自的股东、成员、官员、董事、员工、代理人和代表（统称为“Deno 赔偿方”）免受与您（i）违反本协议，包括但不限于您声明和保证的任何违反；（ii）滥用服务和/或内容；（iii）疏忽、重大疏忽、故意不当行为、欺诈、虚假陈述或违法行为；或（iv）违反任何第三方权利（包括但不限于任何版权、商标、财产权或隐私权）相关的任何损害、责任、损失、费用和开支，包括合理的律师费（统称为“损失”）。一旦发生索赔，您应及时通知我们；在此过程中，为您承担合理的合作费用，并在您赔偿的控制下，进行辩护和和解谈判。

15. **遵守适用法律**

服务的基础是在美国。我们不对根据国家法律的冲突条款主张服务可以在美国以外的地方查看或适用。如果您从美国以外访问服务，风险由您自行承担。无论是在美国境内还是境外，您均需自行负责确保遵守特定管辖区的法律法规。

16. **期限；终止**

本条款以及您访问和使用服务的权利将在您接受这些条款时开始，并持续至您订阅和/或使用服务的期限。

我们保留在自行决定的情况下，随时限制、暂停或终止这些条款以及您对服务的部分或全部访问的权利，无需提前通知或承担责任。我们保留在任何时候无须提前通知或承担责任，变更、暂停或终止服务的全部或任何部分的权利。“服务的描述；访问和使用服务的权利”，“个人信息使用”，“知识产权”，“反馈”，“无保证；责任限制”，“赔偿”，“遵守适用法律”，“期限；终止”，“具有约束力的仲裁”，“集体诉讼豁免”，“平等救济”，“适用法律；专属论坛”和“其他条款”部分应在这些条款终止后继续有效。

17. **具有约束力的仲裁**

如果因本协议和/或服务所引起的任何争议（“争议”）应通过由《联邦仲裁法》（“FAA”）管辖的具有约束力的仲裁最终、独家解决。任何一方均无权在法庭上诉讼该索赔或要求陪审团审判，除非任何一方可根据当地小额索赔法庭规则在小额索赔法庭提起索赔。仲裁与法庭不同，发现和上诉权利也可能在仲裁中受到限制。所有争议将由双方共同选择的中立仲裁人解决，其决定为最后决定，除非根据FAA的有限上诉权。仲裁应由 JAMS 根据当时适用的综合仲裁规则和程序进行，并根据这些规则中的加快程序进行，或在适用情况下，根据 JAMS 精简仲裁规则和程序进行。所有适用的 JAMS 规则和程序可在 JAMS 网站 [www.jamsadr.com](http://www.jamsadr.com) 上获得。每一方负责根据 JAMS 规则支付任何 JAMS 费用、管理费和仲裁人费用。仲裁人裁定的判决可在任何有管辖权的法院进行登记。此条款不妨碍双方在适当管辖权的法院寻求临时救济以支持仲裁。仲裁可以亲自进行，也可以通过提交文件、电话或在线方式进行。如果现场进行仲裁，仲裁应在您居住的美国县进行。双方可以在法院仲裁请求、暂停仲裁程序或确认、修改、撤销或对仲裁人做出的裁决进行判决。在仲裁开始后，双方应善意合作，自愿和非正式地交换与争议相关的所有非特权文件和其他信息（包括电子存储信息）。如下面第18节所述，本协议中的任何内容均不得妨碍我们向任何有管辖权的法院寻求禁令救济，以保护我们的专有权益。

18. **集体诉讼豁免**

您同意任何仲裁或程序应限于您与我们之间的争议。在法律允许的最大范围内，（i）不应将任何仲裁或程序与任何其他诉讼联合；（ii）没有权利或权限以集体诉讼的方式仲裁或解决任何争议或利用集体诉讼程序；（iii）没有权利或权限代表公众或任何其他人提起的所谓代理诉讼。您同意仅以个人身份对我们提起索赔，而不是作为任何假定的集体或代表性诉讼中的原告或集体成员。

19. **平等救济**

您承认并同意，如果您违反或威胁违反我们的知识产权和机密及专有信息，我们将遭受无法弥补的损害，因此有权寻求禁令救济以执行本协议。我们可不放弃其他在本协议下的救济，向任何有管辖权的法院请求任何临时、平等、临时或禁令救济，以保护我们的权利和财产，等待上述仲裁结果。您特此不可撤销地、自愿地同意纽约州联邦和州法院的个人和主题管辖权，以便我们提起任何行动。

20. **适用法律；专属论坛**

本协议及与之相关的任何行为应受纽约州法律管辖，而不考虑其法律冲突条款。各方特此同意将纽约州的州和联邦法院作为所有直接或间接因本协议引起或与之相关的诉讼、行动或程序的专属管辖法院，并放弃对此类法院的任何和所有异议，包括但不限于基于不当地点或不便论坛的异议，并各方特此不可撤销地向以上法院的专属管辖权提交任何因本协议引起或与之相关的诉讼、行动或程序。

21. **其他条款**

    尽管这些条款中有相反的规定，每一方可以在本协议有效期内出于市场营销和推广目的使用对方名称和/或标志，包括但不限于在 Deno 网站或其他地方将授权用户识别为 Deno 的客户。未经 Deno 书面同意，您不得将本条款下的任何权利、义务或责任转让给任何人或实体，无论是全部还是部分。我们未采取行动或执行本协议的任何条款不应被解释为对该条款或本协议中任何其他条款的放弃。任何放弃对我们无效，除非以书面形式作出，并且不应被解释为在其他或后续实例中放弃。除非我们和您以书面形式明示同意，该协议构成您和我们在主题方面的全部协议，并取代双方在主题方面的所有先前或同时存在的协议，无论是书面还是口头。各章节标题仅为方便而提供，不应被赋予任何法律意义。本协议将惠及我们的继承者、受让人、许可人和再许可人。

**版权所有 2024 Deno Land Inc. 保留所有权利。**

---

# Deno Deploy 用例

URL: https://docs.deno.com/deploy/manual/use-cases


Deno 当前一些热门的用例包括：

- [中间件](#中间件)
- [API 服务器](#api-服务器)
- [完整网站](#完整网站)

## 中间件

中间件指的是在请求到达应用服务器之前和之后执行的代码片段。如果您想在请求的早期快速执行一些 JavaScript 或其他代码，您将编写中间件。通过在边缘部署您的中间件代码，Deno Deploy 确保您的应用获得最佳性能。

一些示例包括：

- 设置 cookie
- 根据地理位置提供不同版本的网站
- 路径重写
- 重定向请求
- 在返回给用户之前动态更改从服务器返回的 HTML。

Deno Deploy 是您目前可能用于托管中间件的其他平台的良好替代方案，例如：

- Cloudflare Workers
- AWS Lambda@Edge
- 传统负载均衡器，如 nginx
- 自定义规则

## API 服务器

Deno 也是 API 服务器的理想选择。通过“边缘”部署这些服务器，更接近使用它们的客户端，Deno Deploy 能够提供比传统托管平台（如 Heroku）或甚至现代集中式托管服务（如 DigitalOcean）更低的延迟、更好的性能和更低的带宽成本。

## 完整网站

我们预见一个未来，您可以实际在边缘函数上编写整个网站。一些已经在这样做的网站示例包括：

- [博客](https://github.com/ry/tinyclouds)
- [聊天](https://github.com/denoland/showcase_chat)
- [Calendly 克隆](https://github.com/denoland/meet-me)

---

# Discord 斜杠命令

URL: https://docs.deno.com/deploy/tutorials/discord-slash


Discord 有一个新功能，称为 **斜杠命令**。它们允许你输入 `/` 后跟命令名称来执行某些操作。例如，你可以输入 `/giphy cats`（一个内置命令）来获取一些猫的 GIF。

Discord 斜杠命令的工作原理是在有人发出命令时向一个 URL 发送请求。你不需要时刻运行你的应用程序，以便斜杠命令能够工作，这使得 Deno Deploy 成为构建这些命令的完美解决方案。

在这篇文章中，让我们看看如何使用 Deno Deploy 创建一个 hello world 斜杠命令。

## **第一步：** 在 Discord 开发者门户创建应用程序

1. 前往 [https://discord.com/developers/applications](https://discord.com/developers/applications) （如有需要，请使用你的 Discord 账户登录）。
2. 点击你个人资料照片左侧的 **新建应用程序** 按钮。
3. 给你的应用程序命名，并点击 **创建**。
4. 转到 **机器人** 部分，点击 **添加机器人**，最后点击 **是的，执行！** 进行确认。

就是这样。一个新的应用程序被创建，它将保存我们的斜杠命令。请不要关闭这个选项卡，因为我们在开发过程中需要这个应用程序页面的信息。

## **第二步：** 在 Discord 应用中注册斜杠命令

在我们编写一些代码之前，我们需要向一个 Discord 端点发送请求以在我们的应用中注册一个斜杠命令。

将 `BOT_TOKEN` 填入 **机器人** 部分的令牌，将 `CLIENT_ID` 填入页面 **通用信息** 部分的 ID，并在终端运行以下命令。

```sh
BOT_TOKEN='replace_me_with_bot_token'
CLIENT_ID='replace_me_with_client_id'
curl -X POST \
-H 'Content-Type: application/json' \
-H "Authorization: Bot $BOT_TOKEN" \
-d '{"name":"hello","description":"问候一个人","options":[{"name":"name","description":"人的名字","type":3,"required":true}]}' \
"https://discord.com/api/v8/applications/$CLIENT_ID/commands"
```

这将注册一个名为 `hello` 的斜杠命令，它接受一个名为 `name` 的字符串类型参数。

## **第三步：** 创建并在 Deno Deploy 上部署 hello world 斜杠命令

接下来，我们需要创建一个服务器，以便在 Discord 发送 POST 请求并包含某人的斜杠命令时进行响应。

1. 前往 https://dash.deno.com/new 并在 **Playground** 卡片下点击 **Play**。
2. 在下一页的编辑器中，点击顶部菜单中的 **设置** 图标。在弹出的模态框中，选择 **+ 添加变量**。
3. 输入 `DISCORD_PUBLIC_KEY` 作为 KEY。VALUE 应该是 Discord 应用页面 **通用信息** 部分中可用的公钥。
4. 将以下代码复制并粘贴到编辑器中：

   ```ts
   // Sift 是一个小型路由库，它抽象了启动端口上的监听器等细节，
   // 提供了一个简单的函数 (serve)，具有调用特定路径函数的 API。
   import {
     json,
     serve,
     validateRequest,
   } from "https://deno.land/x/sift@0.6.0/mod.ts";
   // TweetNaCl 是一个我们用来验证来自 Discord 请求的加密库。
   import nacl from "https://esm.sh/tweetnacl@v1.0.3?dts";

   // 对于所有请求到 "/" 端点，我们希望调用 home() 处理程序。
   serve({
     "/": home,
   });

   // Discord 斜杠命令的主要逻辑在此函数中定义。
   async function home(request: Request) {
     // validateRequest() 确保请求的方法为 POST，并且具有以下头部。
     const { error } = await validateRequest(request, {
       POST: {
         headers: ["X-Signature-Ed25519", "X-Signature-Timestamp"],
       },
     });
     if (error) {
       return json({ error: error.message }, { status: error.status });
     }

     // verifySignature() 验证请求是否来自 Discord。
     // 当请求的签名无效时，我们返回 401，这一点很重要，因为 Discord 会发送无效的请求来测试我们的验证。
     const { valid, body } = await verifySignature(request);
     if (!valid) {
       return json(
         { error: "无效的请求" },
         {
           status: 401,
         },
       );
     }

     const { type = 0, data = { options: [] } } = JSON.parse(body);
     // Discord 进行 Ping 交互以测试我们的应用程序。
     // 请求中的类型 1 表示 Ping 交互。
     if (type === 1) {
       return json({
         type: 1, // 响应中的类型 1 是 Pong 交互响应类型。
       });
     }

     // 请求中的类型 2 是 ApplicationCommand 交互。
     // 这意味着用户已发出命令。
     if (type === 2) {
       const { value } = data.options.find((option) => option.name === "name");
       return json({
         // 类型 4 的响应包含以下消息，保留用户的输入在顶部。
         type: 4,
         data: {
           content: `你好，${value}!`,
         },
       });
     }

     // 我们将返回一个错误请求，因为有效的 Discord 请求不应该到达这里。
     return json({ error: "错误请求" }, { status: 400 });
   }

   /** 验证请求是否来自 Discord。 */
   async function verifySignature(
     request: Request,
   ): Promise<{ valid: boolean; body: string }> {
     const PUBLIC_KEY = Deno.env.get("DISCORD_PUBLIC_KEY")!;
     // Discord 在每个请求中都会发送这些头部。
     const signature = request.headers.get("X-Signature-Ed25519")!;
     const timestamp = request.headers.get("X-Signature-Timestamp")!;
     const body = await request.text();
     const valid = nacl.sign.detached.verify(
       new TextEncoder().encode(timestamp + body),
       hexToUint8Array(signature),
       hexToUint8Array(PUBLIC_KEY),
     );

     return { valid, body };
   }

   /** 将十六进制字符串转换为 Uint8Array。 */
   function hexToUint8Array(hex: string) {
     return new Uint8Array(
       hex.match(/.{1,2}/g)!.map((val) => parseInt(val, 16)),
     );
   }
   ```

5. 点击 **保存并部署** 来部署服务器。
6. 一旦文件被部署，请注意项目 URL。它将显示在编辑器的右上角，并以 `.deno.dev` 结尾。

## **第三步：** 配置 Discord 应用以使用我们的 URL 作为交互端点 URL

1. 返回到你的应用程序（Greeter）页面的 Discord 开发者门户。
2. 将 **交互端点 URL** 字段填入上面 Deno Deploy 项目的 URL，并点击 **保存更改**。

应用程序现在已准备就绪。让我们继续下一部分以安装它。

## **第四步：** 在你的 Discord 服务器上安装斜杠命令

要使用 `hello` 斜杠命令，我们需要在我们的 Discord 服务器上安装我们的 Greeter 应用。以下是步骤：

1. 前往 Discord 开发者门户上的 Discord 应用页面的 **OAuth2** 部分。
2. 选择 `applications.commands` 范围，并点击下面的 **复制** 按钮。
3. 现在将其粘贴并在浏览器中访问该 URL。选择你的服务器并点击 **授权**。

打开 Discord，输入 `/hello Deno Deploy` 并按 **Enter**。输出将类似于以下内容。

![Hello, Deno Deploy!](../docs-images/discord-slash-command.png)

恭喜你完成本教程！继续构建一些很棒的 Discord 斜杠命令！并请在 [Deno Discord 服务器](https://discord.gg/deno) 的 **deploy** 频道与我们分享它们。

---

# 基础 Fresh 站点

URL: https://docs.deno.com/deploy/tutorials/fresh


本教程将介绍如何在 Deno Deploy 上部署一个 Fresh 应用程序。

Fresh 是一个为 Deno 构建的Web框架，类似于 Node 的 Express。

## **步骤 1:** 创建 Fresh 应用程序

```sh
deno run -A -r https://fresh.deno.dev fresh-site
```

要在本地运行此应用程序：

```sh
deno task start
```

您可以编辑 `routes/index.js` 来修改应用程序。

## **步骤 2:** 创建一个新的 Github 仓库并链接您本地的 Fresh 应用程序。

1. 创建一个新的 Github 仓库并记录 git 仓库的远程 URL
2. 从您的本地 `fresh-site`，初始化 git 并推送到新的远程仓库：

   ```sh
   git init
   git add .
   git commit -m "第一次提交"
   git remote add origin <remote-url>
   git push origin main
   ```

## **步骤 3:** 部署到 Deno Deploy

1. 访问
   [https://dash.deno.com/new_project](https://dash.deno.com/new_project)。
2. 连接您的 GitHub 账户并选择您的仓库。
3. 在表单中填写各项值：
   - 为您的项目命名
   - 从“框架预设”选项中选择 `Fresh`
   - 将生产分支设置为 `main`
   - 选择 `main.ts` 作为入口文件
4. 点击“部署项目”以启动 Deno Deploy。
5. 部署完成后，您可以在项目仪表盘中提供的 URL 查看您的新项目。

---

# 教程

URL: https://docs.deno.com/deploy/tutorials/


在这里，您会找到 Deno Deploy 的教程和示例应用程序的集合。请在导航中查看我们不断扩展的教程列表，并探索 [examples.deno.land](https://examples.deno.land) 以获取更多示例。

## 代码示例

- [构建一个简单的 API 服务器](./simple-api.md)
- [提供静态资源](./static-site.md)

## 应用程序构建教程

- [构建一个 Fresh 应用](./fresh.md)
- [构建一个 Discord Slash 命令](./discord-slash.md)
- [使用 Vite 构建站点](./vite.md)

---

# 简单的 API 服务器

URL: https://docs.deno.com/deploy/tutorials/simple-api


Deno 非常适合创建简单、轻量的 API 服务器。在本教程中学习如何使用 Deno Deploy 创建和部署一个。

## 创建本地 API 服务器

在终端中，创建一个名为 `server.ts` 的文件。

```shell
touch server.ts
```

我们将实现一个简单的链接缩短服务，使用
[Deno KV 数据库](/deploy/kv/manual)。

```ts title="server.ts"
const kv = await Deno.openKv();

Deno.serve(async (request: Request) => {
  // 创建短链接
  if (request.method == "POST") {
    const body = await request.text();
    const { slug, url } = JSON.parse(body);
    const result = await kv.set(["links", slug], url);
    return new Response(JSON.stringify(result));
  }

  // 重定向短链接
  const slug = request.url.split("/").pop() || "";
  const url = (await kv.get(["links", slug])).value as string;
  if (url) {
    return Response.redirect(url, 301);
  } else {
    const m = !slug ? "请提供一个短链接标识符。" : `短链接标识符 "${slug}" 未找到`;
    return new Response(m, { status: 404 });
  }
});
```

您可以使用以下命令在您的机器上运行此服务器：

```shell
deno run -A --unstable-kv server.ts
```

该服务器将响应 HTTP `GET` 和 `POST` 请求。`POST` 处理程序期望在请求正文中接收一个包含 `slug` 和 `url` 属性的 JSON 文档。`slug` 是短 URL 组件，`url` 是您希望重定向到的完整 URL。

这是使用 cURL 访问此 API 端点的示例：

```shell
curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"url":"https://docs.deno.com/runtime/manual","slug":"denodocs"}' \
  http://localhost:8000/
```

作为响应，服务器应该向您发送 JSON，包含表示 `set` 操作结果的 KV 数据：

```json
{ "ok": true, "versionstamp": "00000000000000060000" }
```

对我们服务器的 `GET` 请求将把 URL 短链接作为路径参数并重定向到提供的 URL。您可以在浏览器中访问此 URL，或者发出另一个 cURL 请求查看其实际效果！

```shell
curl -v http://localhost:8000/denodocs
```

现在我们已经有了一个 API 服务器，让我们将其推送到一个 GitHub 存储库，稍后我们将链接到 Deno Deploy。

## 为您的应用创建一个 GitHub 存储库

登录到 [GitHub](https://github.com) 并
[创建一个新的存储库](https://docs.github.com/en/get-started/quickstart/create-a-repo)。
您可以暂时跳过添加 README 或其他文件 - 一个空存储库就足够我们的目的。

在您创建 API 服务器的文件夹中，按顺序运行以下命令初始化一个本地 git 存储库。请务必将 `your_username` 和 `your_repo_name` 替换为相应的值。

```sh
echo "# 我的 Deno 链接缩短器" >> README.md
git init
git add .
git commit -m "第一次提交"
git branch -M main
git remote add origin https://github.com/your_username/your_repo_name.git
git push -u origin main
```

您现在应该有一个包含 `server.ts` 文件的 GitHub 存储库，如
[这个示例存储库](https://github.com/kwhinnery/simple_api_server)所示。现在您准备好在 Deno Deploy 上导入并运行此应用程序。

## 导入并部署您的项目

接下来，在 [Deno Deploy](https://dash.deno.com) 上注册一个账户，并
[创建一个新项目](https://dash.deno.com/new_project)。连接您的 GitHub 账户，并选择我们刚才创建的存储库。

![Deno Deploy 项目选择](./images/simple_api_deploy.png)

配置应该如下所示：

![Deno Deploy 配置](./images/simple_api_deploy_settings.png)

点击“部署项目”按钮。部署完成后，您的链接缩短服务将在 Deno Deploy 上上线！

![Deno Deploy 仪表盘](./images/simple_api_dashboard.png)

## 测试您的新链接缩短器

在没有任何额外配置的情况下（Deno KV 在 Deploy 上正常工作），您的应用程序应该和在本地机器上一样运行。

您可以使用 `POST` 处理程序添加新的链接，如之前所做的那样。只需将 `localhost` URL 替换为您在 Deno Deploy 上的实际生产 URL：

```shell
curl --header "Content-Type: application/json" \
  --request POST \
  --data '{"url":"https://docs.deno.com/runtime/","slug":"denodocs"}' \
  https://your-deno-project-url-here.deno.dev/
```

同样，您可以在浏览器中访问您的缩短 URL，或者使用 cURL 命令查看重定向的返回：

```shell
curl -v https://your-deno-project-url-here.deno.dev/denodocs
```

如果您喜欢这个项目，接下来可以查看更高级的 Web 框架，如 [Fresh](https://fresh.deno.dev)，或者了解更多关于 [Deno KV 的内容](/deploy/kv/manual)。恭喜您成功部署了简单的 API 服务器！

---

# 部署静态网站

URL: https://docs.deno.com/deploy/tutorials/static-site


本教程将介绍如何在 Deno Deploy 上部署一个静态网站（不含 JavaScript）。

## 步骤 1：创建静态网站

```sh
mkdir static-site
cd static-site
touch index.html
```

在你的 `index.html` 中粘贴以下 HTML：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>你好</title>
  </head>
  <body>
    <h1>你好</h1>
    <img src="image.png" alt="image" />
  </body>
</html>
```

确保在 `static-site` 目录中有一个 `image.png` 文件。

现在你已经有了一个显示“你好”的 HTML 页面并包含一个徽标。

## 步骤 2：使用 `deployctl` 部署静态网站

要在 Deno Deploy 上部署这个库，在 `static-site` 目录中运行：

```console
deployctl deploy --project=<你选择的项目名称> --entrypoint=jsr:@std/http/file-server
```

关于这些命令的进一步解释：由于这是一个静态网站，不需要执行 JavaScript。你并不是给 Deno Deploy 提供一个特定的 JavaScript 或 TypeScript 文件作为入口文件，而是给它这个外部的 `file_server.ts` 程序，它简单地将 `static-site` 目录中的所有静态文件，包括图像和 HTML 页面，上传到 Deno Deploy。这些静态资源随后会被服务。

## 步骤 3：完成！

你的静态网站现在应该已经上线了！它的 URL 会在终端输出，或者你可以在你的 [Deno 控制面板](https://dash.deno.com/projects/) 中管理你新的静态网站项目。如果你点击进入你的新项目，你将能够查看网站，配置它的名称、环境变量、自定义域名等。

---

# 使用 Fresh 构建博客

URL: https://docs.deno.com/deploy/tutorials/tutorial-blog-fresh


教程 [在这里](https://deno.com/blog/build-a-blog-with-fresh)。

---

# 使用 DynamoDB 构建 API 服务器

URL: https://docs.deno.com/deploy/tutorials/tutorial-dynamodb


在本教程中，让我们看看如何使用 DynamoDB 来构建一个小型 API，该 API 具有插入和检索信息的端点。

本教程假设您拥有 AWS 和 Deno Deploy 账户。

- [概述](#overview)
- [设置 DynamoDB](#setup-dynamodb)
- [在 Deno Deploy 中创建项目](#create-a-project-in-deno-deploy)
- [编写应用程序](#write-the-application)
- [部署应用程序](#deploy-the-application)

## 概述

我们将构建一个具有单个端点的 API，该端点接受 GET/POST 请求并返回相应的信息。

```sh
# 对该端点的 GET 请求应返回基于歌曲标题的详细信息。
GET /songs?title=Song%20Title # '%20' == 空格
# 响应
{
  title: "Song Title"
  artist: "Someone"
  album: "Something",
  released: "1970",
  genres: "country rap",
}

# 对该端点的 POST 请求应插入歌曲详细信息。
POST /songs
# POST 请求体
{
  title: "A New Title"
  artist: "Someone New"
  album: "Something New",
  released: "2020",
  genres: "country rap",
}
```

## 设置 DynamoDB

我们过程中的第一步是生成 AWS 凭证，以便以编程方式访问 DynamoDB。

生成凭证：

1. 转到 https://console.aws.amazon.com/iam/ 并进入“用户”部分。
2. 点击 **创建用户** 按钮，填写 **用户名** 字段（可以使用 `denamo`），选择 **程序matic access** 类型。
3. 点击 **下一步**
4. 选择 **直接附加策略** 并搜索 `AmazonDynamoDBFullAccess`。勾选结果中此策略旁边的框。
5. 点击 **下一步** 和 **创建用户**
6. 在生成的 **用户** 页面中，点击您刚创建的用户
7. 点击 **创建访问密钥**
8. 选择 **在 AWS 外部运行的应用程序**
9. 点击 ***创建**
10. 点击 **下载 .csv 文件** 以下载您刚创建的凭证。

创建数据库表：

1. 转到 https://console.aws.amazon.com/dynamodb 并点击 **创建表** 按钮。
2. 在 **表名** 字段中填写 `songs`，在 **分区键** 中填写 `title`。
3. 向下滚动并点击 **创建表**。
4. 创建表后，点击表名并查看其 **基本信息**
5. 在 **Amazon 资源名称 (ARN)** 下，记下您新表的区域（例如 us-east-1）。

## 编写应用程序

创建一个名为 `index.js` 的文件，并插入以下内容：

```js
import {
  json,
  serve,
  validateRequest,
} from "https://deno.land/x/sift@0.6.0/mod.ts";
// AWS 有一个官方的 SDK 适用于浏览器。由于大多数 Deno Deploy 的 API
// 与浏览器类似，因此相同的 SDK 可与 Deno Deploy 一起使用。
// 因此我们导入 SDK 以及一些插入和
// 检索数据所需的类。
import {
  DynamoDBClient,
  GetItemCommand,
  PutItemCommand,
} from "https://esm.sh/@aws-sdk/client-dynamodb";

// 通过提供您的区域信息创建客户端实例。
// 凭证是从环境变量中获取的，
// 这些变量是在 Deno Deploy 的项目创建步骤中设置的。
const client = new DynamoDBClient({
  region: Deno.env.get("AWS_TABLE_REGION"),
  credentials: {
    accessKeyId: Deno.env.get("AWS_ACCESS_KEY_ID"),
    secretAccessKey: Deno.env.get("AWS_SECRET_ACCESS_KEY"),
  },
});

serve({
  "/songs": handleRequest,
});

async function handleRequest(request) {
  // 该端点允许 GET 和 POST 请求。GET 请求中需要一个名为“title”的参数。
  // 并且处理 POST 请求时，要求提供以下字段的体。
  // validateRequest 确保请求满足提供的条件。
  const { error, body } = await validateRequest(request, {
    GET: {
      params: ["title"],
    },
    POST: {
      body: ["title", "artist", "album", "released", "genres"],
    },
  });
  if (error) {
    return json({ error: error.message }, { status: error.status });
  }

  // 处理 POST 请求。
  if (request.method === "POST") {
    try {
      // 当我们想要与 DynamoDB 交互时，我们使用客户端实例发送命令。
      // 在这里，我们发送 PutItemCommand 来插入请求中的数据。
      const {
        $metadata: { httpStatusCode },
      } = await client.send(
        new PutItemCommand({
          TableName: "songs",
          Item: {
            // 这里 'S' 表示值类型为字符串
            // 而 'N' 表示数值。
            title: { S: body.title },
            artist: { S: body.artist },
            album: { S: body.album },
            released: { N: body.released },
            genres: { S: body.genres },
          },
        }),
      );

      // 在成功的插入项目请求中，dynamo 返回 200 状态码（很奇怪）。
      // 因此，我们测试状态码以验证数据是否已插入，并以请求提供的数据作为确认响应。
      if (httpStatusCode === 200) {
        return json({ ...body }, { status: 201 });
      }
    } catch (error) {
      // 如果在请求过程中发生错误，我们会记录该错误以供参考。
      console.log(error);
    }

    // 如果执行达到这里，意味着插入没有成功。
    return json({ error: "无法插入数据" }, { status: 500 });
  }

  // 处理 GET 请求。
  try {
    // 我们从请求中获取标题，并发送 GetItemCommand
    // 以检索有关歌曲的信息。
    const { searchParams } = new URL(request.url);
    const { Item } = await client.send(
      new GetItemCommand({
        TableName: "songs",
        Key: {
          title: { S: searchParams.get("title") },
        },
      }),
    );

    // Item 属性包含所有数据，因此如果它不是未定义的，
    // 我们继续返回有关该标题的信息
    if (Item) {
      return json({
        title: Item.title.S,
        artist: Item.artist.S,
        album: Item.album.S,
        released: Item.released.S,
        genres: Item.genres.S,
      });
    }
  } catch (error) {
    console.log(error);
  }

  // 如果在请求数据库时抛出错误，或者数据库中找不到 Item，
  // 我们可能会到达这里。
  // 我们用一条通用消息反映这两种情况。
  return json(
    {
      message: "找不到该标题",
    },
    { status: 404 },
  );
}
```

在您的新项目中初始化 git 并
[推送到 GitHub](https://docs.github.com/en/get-started/start-your-journey/hello-world#step-1-create-a-repository)。

## 部署应用程序

现在我们已准备好一切，让我们部署您的新应用程序！

1. 在浏览器中访问 [Deno Deploy](https://dash.deno.com/new_project) 并链接您的 GitHub 账户。
2. 选择包含您新应用程序的存储库。
3. 您可以给您的项目一个名称，或者允许 Deno 为您生成一个名称。
4. 在入口点下拉列表中选择 `index.js`
5. 点击 **部署项目**

为了使您的应用程序正常工作，我们需要配置其环境变量。

在您的项目成功页面或项目仪表板中，点击 **添加环境变量**。在环境变量下，点击 **+ 添加变量**。创建以下变量：

1. `AWS_ACCESS_KEY_ID` - 值来自您下载的 CSV
2. `AWS_SECRET_ACCESS_KEY` - 值来自您下载的 CSV。
3. `AWS_TABLE_REGION` - 选项为您的表的区域

点击保存变量。

让我们测试 API。

POST 一些数据。

```sh
curl --request POST --data \
'{"title": "Old Town Road", "artist": "Lil Nas X", "album": "7", "released": "2019", "genres": "Country rap, Pop"}' \
--dump-header - https://<project_name>.deno.dev/songs
```

获取关于标题的信息。

```sh
curl https://<project_name>.deno.dev/songs?title=Old%20Town%20Road
```

恭喜您学习了如何使用 DynamoDB 与 Deno Deploy！

---

# 使用 FaunaDB 的 API 服务器

URL: https://docs.deno.com/deploy/tutorials/tutorial-faunadb


FaunaDB 自称为 "现代应用程序的数据 API"。它是一个具有 GraphQL 接口的数据库，使您可以使用 GraphQL 与之进行交互。由于我们使用 HTTP 请求与其通信，因此不需要管理连接，这非常适合无服务器应用程序。

本教程假设您拥有 [FaunaDB](https://fauna.com) 和 Deno Deploy 账户，已安装 Deno Deploy CLI，并对 GraphQL 有一些基本了解。

- [概述](#概述)
- [构建 API 接口](#构建-api-接口)
- [使用 FaunaDB 进行持久化](#使用-faunadb-进行持久化)
- [部署 API](#部署-api)

## 概述

在本教程中，我们将构建一个小型的报价 API，提供插入和检索报价的接口。然后利用 FaunaDB 持久化这些报价。

让我们从定义 API 接口开始。

```sh
# 对端点的 POST 请求应将报价插入列表中。
POST /quotes/
# 请求的主体。
{
  "quote": "不要仅凭你收获的果实来评判每一天，而要凭你播种的种子。",
  "author": "罗伯特·路易斯·史蒂文森"
}

# 对端点的 GET 请求应返回数据库中的所有报价。
GET /quotes/
# 请求的响应。
{
  "quotes": [
    {
      "quote": "不要仅凭你收获的果实来评判每一天，而要凭你播种的种子。",
      "author": "罗伯特·路易斯·史蒂文森"
    }
  ]
}
```

现在我们了解了端点的行为，接下来就来构建它。

## 构建 API 接口

首先，创建一个名为 `quotes.ts` 的文件，并粘贴以下内容。

请阅读代码中的注释以了解发生了什么。

```ts
import {
  json,
  serve,
  validateRequest,
} from "https://deno.land/x/sift@0.6.0/mod.ts";

serve({
  "/quotes": handleQuotes,
});

// 为了开始，我们将使用一个全局的报价数组。
const quotes = [
  {
    quote: "能够想象任何事物的人，就能够创造不可能。",
    author: "艾伦·图灵",
  },
  {
    quote: "任何足够先进的技术都与魔法无异。",
    author: "阿瑟·克拉克",
  },
];

async function handleQuotes(request: Request) {
  // 确保请求是 GET 请求。
  const { error } = await validateRequest(request, {
    GET: {},
  });
  // validateRequest 会在请求不符合我们定义的模式时填充错误。
  if (error) {
    return json({ error: error.message }, { status: error.status });
  }

  // 返回所有报价。
  return json({ quotes });
}
```

使用 [Deno CLI](https://deno.land) 运行上述程序。

```sh
deno run --allow-net=:8000 ./path/to/quotes.ts
# 正在监听 http://0.0.0.0:8000/
```

然后使用 curl 访问端点查看一些报价。

```sh
curl http://127.0.0.1:8000/quotes
# {"quotes":[
# {"quote":"能够想象任何事物的人，就能够创造不可能。", "author":"艾伦·图灵"},
# {"quote":"任何足够先进的技术都与魔法无异。","author":"阿瑟·克拉克"}
# ]}
```

让我们继续处理 POST 请求。

更新 `validateRequest` 函数，确保 POST 请求遵循提供的主体模式。

```diff
-  const { error } = await validateRequest(request, {
+  const { error, body } = await validateRequest(request, {
    GET: {},
+   POST: {
+      body: ["quote", "author"]
+   }
  });
```

通过以下代码更新 `handleQuotes` 函数以处理 POST 请求。

```diff
async function handleQuotes(request: Request) {
  const { error, body } = await validateRequest(request, {
    GET: {},
    POST: {
      body: ["quote", "author"],
    },
  });
  if (error) {
    return json({ error: error.message }, { status: error.status });
  }

+  // 处理 POST 请求。
+  if (request.method === "POST") {
+    const { quote, author } = body as { quote: string; author: string };
+    quotes.push({ quote, author });
+    return json({ quote, author }, { status: 201 });
+  }

  return json({ quotes });
}
```

让我们通过插入一些数据进行测试。

```sh
curl --dump-header - --request POST --data '{"quote": "一个未经过测试的程序是无法工作的。", "author": "比扬·斯特劳斯特鲁普"}' http://127.0.0.1:8000/quotes
```

输出可能如下所示。

```console
HTTP/1.1 201 Created
transfer-encoding: chunked
content-type: application/json; charset=utf-8

{"quote":"一个未经过测试的程序是无法工作的。","author":"比扬·斯特劳斯特鲁普"}
```

太棒了！我们构建的 API 接口正在按预期工作。由于数据存储在内存中，重启后将会丢失。让我们使用 FaunaDB 来持久化我们的报价。

## 使用 FaunaDB 进行持久化

让我们使用 GraphQL Schema 定义我们的数据库模式。

```gql
# 我们创建一个名为 `Quote` 的新类型来表示报价及其作者。
type Quote {
  quote: String!
  author: String!
}

type Query {
  # Query 操作中的新字段，用于检索所有报价。
  allQuotes: [Quote!]
}
```

Fauna 为其数据库提供了一个 graphql 端点，并为模式中定义的数据类型生成必要的变更，例如创建、更新、删除。例如，Fauna 将生成一个名为 `createQuote` 的变更，用于在数据库中创建一个新的报价。此外，我们还定义了一个查询字段 `allQuotes`，用于返回数据库中的所有报价。

现在让我们开始编写与 Fauna 交互的代码，以便从 Deno Deploy 应用程序中访问。

要与 Fauna 交互，我们需要向它的 graphql 端点发送一个 POST 请求，带有适当的查询和参数以获取数据返回。所以让我们构建一个通用函数来处理这些事情。

```typescript
async function queryFauna(
  query: string,
  variables: { [key: string]: unknown },
): Promise<{
  data?: any;
  error?: any;
}> {
  // 从环境中获取密钥。
  const token = Deno.env.get("FAUNA_SECRET");
  if (!token) {
    throw new Error("环境变量 FAUNA_SECRET 未设置");
  }

  try {
    // 通过 POST 请求访问 Fauna 的 graphql 端点，主体为
    // 查询及其变量。
    const res = await fetch("https://graphql.fauna.com/graphql", {
      method: "POST",
      headers: {
        authorization: `Bearer ${token}`,
        "content-type": "application/json",
      },
      body: JSON.stringify({
        query,
        variables,
      }),
    });

    const { data, errors } = await res.json();
    if (errors) {
      // 如果有错误，返回第一个错误。
      return { data, error: errors[0] };
    }

    return { data };
  } catch (error) {
    return { error };
  }
}
```

将此代码添加到 `quotes.ts` 文件中。现在让我们更新端点以使用 Fauna。

```diff
async function handleQuotes(request: Request) {
  const { error, body } = await validateRequest(request, {
    GET: {},
    POST: {
      body: ["quote", "author"],
    },
  });
  if (error) {
    return json({ error: error.message }, { status: error.status });
  }

  if (request.method === "POST") {
+    const { quote, author, error } = await createQuote(
+      body as { quote: string; author: string }
+    );
+    if (error) {
+      return json({ error: "无法创建报价" }, { status: 500 });
+    }

    return json({ quote, author }, { status: 201 });
  }

  return json({ quotes });
}

+async function createQuote({
+  quote,
+  author,
+}: {
+  quote: string;
+  author: string;
+}): Promise<{ quote?: string; author?: string; error?: string }> {
+  const query = `
+    mutation($quote: String!, $author: String!) {
+      createQuote(data: { quote: $quote, author: $author }) {
+        quote
+        author
+      }
+    }
+  `;
+
+  const { data, error } = await queryFauna(query, { quote, author });
+  if (error) {
+    return { error };
+  }
+
+  return data;
+}
```

现在我们已经更新了代码以插入新的报价，让我们在继续测试代码之前设置一个 Fauna 数据库。

创建一个新数据库：

1. 访问 https://dashboard.fauna.com（如有需要登录），点击 **New Database**
2. 填写 **Database Name** 字段，然后点击 **Save**。
3. 点击左侧边栏可见的 **GraphQL** 部分。
4. 创建一个以 `.gql` 结尾的文件，内容为我们上述定义的模式。

生成一个秘密以访问数据库：

1. 点击 **Security** 部分，然后点击 **New Key**。
2. 选择 **Server** 角色并点击 **Save**。复制生成的密钥。

现在让我们使用这个密钥运行应用程序。

```sh
FAUNA_SECRET=<你刚才获得的秘密> deno run --allow-net=:8000 --watch quotes.ts
# 正在监听 http://0.0.0.0:8000
```

```sh
curl --dump-header - --request POST --data '{"quote": "一个未经过测试的程序是无法工作的。", "author": "比扬·斯特劳斯特鲁普"}' http://127.0.0.1:8000/quotes
```

请注意，报价已添加到 FaunaDB 中的集合中。

让我们编写一个新函数以获取所有报价。

```ts
async function getAllQuotes() {
  const query = `
    query {
      allQuotes {
        data {
          quote
          author
        }
      }
    }
  `;

  const {
    data: {
      allQuotes: { data: quotes },
    },
    error,
  } = await queryFauna(query, {});
  if (error) {
    return { error };
  }

  return { quotes };
}
```

并用以下代码更新 `handleQuotes` 函数。

```diff
-// 为了开始，我们将使用一个全局的报价数组。
-const quotes = [
-  {
-    quote: "能够想象任何事物的人，就能够创造不可能。",
-    author: "艾伦·图灵",
-  },
-  {
-    quote: "任何足够先进的技术都与魔法无异。",
-    author: "阿瑟·克拉克",
-  },
-];

async function handleQuotes(request: Request) {
  const { error, body } = await validateRequest(request, {
    GET: {},
    POST: {
      body: ["quote", "author"],
    },
  });
  if (error) {
    return json({ error: error.message }, { status: error.status });
  }

  if (request.method === "POST") {
    const { quote, author, error } = await createQuote(
      body as { quote: string; author: string },
    );
    if (error) {
      return json({ error: "无法创建报价" }, { status: 500 });
    }

    return json({ quote, author }, { status: 201 });
  }

+  // 假设请求方法为 "GET"。
+  {
+    const { quotes, error } = await getAllQuotes();
+    if (error) {
+      return json({ error: "无法获取报价" }, { status: 500 });
+    }
+
+    return json({ quotes });
+  }
}
```

```sh
curl http://127.0.0.1:8000/quotes
```

您应该会看到我们插入到数据库中的所有报价。API 的最终代码可以在 https://deno.com/examples/fauna.ts 找到。

## 部署 API

现在我们的一切都准备就绪，让我们部署您的新 API！

1. 在您的浏览器中访问 [Deno Deploy](https://dash.deno.com/new_project) 并链接您的 GitHub 账户。
2. 选择包含您新 API 的仓库。
3. 您可以为您的项目命名，或者允许 Deno 为您生成一个名称。
4. 在 Entrypoint 下拉菜单中选择 `index.ts`。
5. 点击 **Deploy Project** 。

为了让您的应用程序正常工作，我们需要配置其环境变量。

在您的项目成功页面或项目仪表板中，点击 **Add environmental variables**。在环境变量下，点击 **+ Add Variable**。创建一个名为 `FAUNA_SECRET` 的新变量 - 值应为我们之前创建的密钥。

点击保存变量。

在您的项目概览中，点击 **View** 以在浏览器中查看项目，并在 URL 末尾添加 `/quotes` 来查看您的 FaunaDB 中的内容。

---

# 用 Firestore (Firebase) 构建 API 服务器

URL: https://docs.deno.com/deploy/tutorials/tutorial-firebase


Firebase 是 Google 开发的平台，用于创建移动和 web 应用程序。您可以使用 Firestore 在该平台上持久化数据。在本教程中，让我们看看如何使用它构建一个小型 API，该 API 具有插入和检索信息的端点。

- [概述](#overview)
- [概念](#concepts)
- [设置 Firebase](#setup-firebase)
- [编写应用程序](#write-the-application)
- [部署应用程序](#deploy-the-application)

## 概述

我们将构建一个只有一个端点的 API，该端点接受 `GET` 和 `POST` 请求，并返回一个 JSON 有效负载的信息：

```sh
# 对没有任何子路径的端点进行 GET 请求应该返回商店中所有歌曲的详细信息：
GET /songs
# 响应
[
  {
    title: "歌曲标题",
    artist: "某人",
    album: "某事",
    released: "1970",
    genres: "乡村说唱",
  }
]

# 对带有子路径的标题的端点进行 GET 请求应该返回
# 基于其标题的歌曲的详细信息。
GET /songs/歌曲标题 # '%20' == 空格
# 响应
{
  title: "歌曲标题"
  artist: "某人"
  album: "某事",
  released: "1970",
  genres: "乡村说唱",
}

# 对端点发起 POST 请求应该插入歌曲的详细信息。
POST /songs
# POST 请求正文
{
  title: "新的标题"
  artist: "新某人"
  album: "新的某事",
  released: "2020",
  genres: "乡村说唱",
}
```

在本教程中，我们将：

- 创建并设置一个
  [Firebase 项目](https://console.firebase.google.com/)。
- 使用文本编辑器创建我们的应用程序。
- 创建一个 [gist](https://gist.github.com/) 来“托管”我们的应用程序。
- 在 [Deno Deploy](https://dash.deno.com/) 上部署我们的应用程序。
- 使用 [cURL](https://curl.se/) 测试我们的应用程序。

## 概念

有几个概念有助于理解我们在本教程其余部分采取特定方法的原因，也可以帮助扩展应用程序。如果您愿意，可以跳到 [设置 Firebase](#setup-firebase)。

### 部署类浏览器

尽管 Deploy 在云中运行，但它提供的 APIs 在许多方面都基于 Web 标准。因此，当使用 Firebase 时，Firebase APIs 与为服务器运行时设计的 APIs 更加兼容。这意味着我们将在本教程中使用 Firebase 的 Web 库。

### Firebase 使用 XHR

Firebase 使用一个封装器，围绕 Closure 的
[WebChannel](https://google.github.io/closure-library/api/goog.net.WebChannel.html)
构建，WebChannel 最初是围绕 [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) 构建的。
虽然 WebChannel 支持更现代的 `fetch()` API，但当前版本的 Firebase Web 并不统一使用支持 `fetch()` 的 WebChannel，而是使用 `XMLHttpRequest`。

虽然 Deploy 类似于浏览器，但不支持 `XMLHttpRequest`。
`XMLHttpRequest` 是一个“遗留”浏览器 API，存在多个限制，且在 Deploy 中实现某些特性将会很困难，这意味着 Deploy 不太可能实现该 API。

因此，在本教程中，我们将使用一个有限的 _polyfill_，该 polyfill 提供了足够的 `XMLHttpRequest` 功能集，以允许 Firebase/WebChannel 与服务器进行通信。

### Firebase 身份验证

Firebase 提供了相当多的 [选项](https://firebase.google.com/docs/auth) 进行身份验证。在本教程中，我们将使用电子邮件和密码身份验证。

当用户登录时，Firebase 可以持久化该身份验证。因为我们使用 Firebase 的 Web 库，持久化身份验证使得用户在离开页面后返回时无需重新登录。Firebase 允许在本地存储、会话存储中持久化身份验证，或者不进行持久化。

在 Deploy 上下文中，这略有不同。Deploy 部署将保持“活动”状态，这意味着某些请求将在请求之间保持内存状态，但在各种条件下可以启动或关闭新部署。目前，Deploy 没有提供任何持久性，除了内存分配。此外，它目前不提供全局的 `localStorage` 或 `sessionStorage`，这是 Firebase 用于存储身份验证信息的方式。

为了减少重新身份验证的需要，同时确保我们可以支持单一部署的多个用户，我们将使用一个 polyfill，允许我们提供一个 `localStorage` 接口给 Firebase，但将信息作为客户端的 cookie 存储。

## 设置 Firebase

[Firebase](https://firebase.google.com/) 是一个功能丰富的平台。Firebase 管理的所有详细信息超出了本教程的范围。我们将涵盖本教程所需的内容。

1. 在 [Firebase 控制台](https://console.firebase.google.com/) 中创建一个新项目。
2. 向您的项目添加一个 Web 应用程序。请记录在设置向导中提供的 `firebaseConfig`。它看起来应该类似于以下内容。我们稍后会使用这个：

   ```js title="firebase.js"
   var firebaseConfig = {
     apiKey: "APIKEY",
     authDomain: "example-12345.firebaseapp.com",
     projectId: "example-12345",
     storageBucket: "example-12345.appspot.com",
     messagingSenderId: "1234567890",
     appId: "APPID",
   };
   ```

3. 在管理控制台的 `身份验证` 下，您将想要启用 `电子邮件/密码` 登录方法。
4. 您将想要在 `身份验证` 下的 `用户` 部分添加用户和密码，并记录所用值，以备后用。
5. 向您的项目添加 `Firestore 数据库`。控制台将允许您设置 _生产模式_ 或 _测试模式_。您将根据配置的内容自行决定，但 _生产模式_ 将要求您设置进一步的安全规则。
6. 向数据库添加一个名为 `songs` 的集合。这将要求您至少添加一个文档。只需将文档设置为 _自动 ID_。

_注意_ 根据您的 Google 账户状态，可能需要进行其他设置和管理步骤。

## 编写应用程序

我们想将应用程序创建为我们喜欢的编辑器中的 JavaScript 文件。

我们要做的第一件事是导入 Firebase 在 Deploy 下工作所需的 `XMLHttpRequest` polyfill 以及一个 `localStorage` 的 polyfill，以允许 Firebase 身份验证持久化已登录用户：

```js title="firebase.js"
import "https://deno.land/x/xhr@0.1.1/mod.ts";
import { installGlobals } from "https://deno.land/x/virtualstorage@0.1.0/mod.ts";
installGlobals();
```

> ℹ️ 我们使用的是在编写本教程时当前版本的包。它们可能不是最新的，您可能想要双重检查当前版本。

因为 Deploy 具有大量 Web 标准 API，最好在部署下使用 Firebase 的 Web 库。目前 v9 仍处于 beta 阶段，所以我们在本教程中将使用 v8：

```js title="firebase.js"
import firebase from "https://esm.sh/firebase@8.7.0/app";
import "https://esm.sh/firebase@8.7.0/auth";
import "https://esm.sh/firebase@8.7.0/firestore";
```

我们还将使用 [oak](https://deno.land/x/oak) 作为创建 API 的中间件框架，包括用于将 `localStorage` 值设置为客户端 cookies 的中间件：

```js title="firebase.js"
import {
  Application,
  Router,
  Status,
} from "https://deno.land/x/oak@v7.7.0/mod.ts";
import { virtualStorage } from "https://deno.land/x/virtualstorage@0.1.0/middleware.ts";
```

现在我们需要设置我们的 Firebase 应用程序。我们将从稍后在 `FIREBASE_CONFIG` 关键字下设置的环境变量中获取配置，并获取我们将要使用的 Firebase 各部分的引用：

```js title="firebase.js"
const firebaseConfig = JSON.parse(Deno.env.get("FIREBASE_CONFIG"));
const firebaseApp = firebase.initializeApp(firebaseConfig, "example");
const auth = firebase.auth(firebaseApp);
const db = firebase.firestore(firebaseApp);
```

我们还将设置应用程序以处理每个请求的登录用户。所以我们将创建一个我们之前在此部署中登录过的用户的映射。虽然在本教程中，我们只会有一个登录用户，但代码可以很容易地适应允许客户端单独登录：

```js title="firebase.js"
const users = new Map();
```

让我们创建我们的中间件路由器，并创建三个不同的中间件处理程序，以支持 `/songs` 的 `GET` 和 `POST` 以及对 `/songs/{title}` 的 `GET`：

```js title="firebase.js"
const router = new Router();

// 返回集合中的任何歌曲
router.get("/songs", async (ctx) => {
  const querySnapshot = await db.collection("songs").get();
  ctx.response.body = querySnapshot.docs.map((doc) => doc.data());
  ctx.response.type = "json";
});

// 返回第一个与标题匹配的文档
router.get("/songs/:title", async (ctx) => {
  const { title } = ctx.params;
  const querySnapshot = await db.collection("songs").where("title", "==", title)
    .get();
  const song = querySnapshot.docs.map((doc) => doc.data())[0];
  if (!song) {
    ctx.response.status = 404;
    ctx.response.body = `未找到标题为 "${ctx.params.title}" 的歌曲。`;
    ctx.response.type = "text";
  } else {
    ctx.response.body = querySnapshot.docs.map((doc) => doc.data())[0];
    ctx.response.type = "json";
  }
});

function isSong(value) {
  return typeof value === "object" && value !== null && "title" in value;
}

// 移除任何具有相同标题的歌曲并添加新歌曲
router.post("/songs", async (ctx) => {
  const body = ctx.request.body();
  if (body.type !== "json") {
    ctx.throw(Status.BadRequest, "必须是 JSON 文档");
  }
  const song = await body.value;
  if (!isSong(song)) {
    ctx.throw(Status.BadRequest, "有效负载格式不正确");
  }
  const querySnapshot = await db
    .collection("songs")
    .where("title", "==", song.title)
    .get();
  await Promise.all(querySnapshot.docs.map((doc) => doc.ref.delete()));
  const songsRef = db.collection("songs");
  await songsRef.add(song);
  ctx.response.status = Status.NoContent;
});
```

好的，我们快要完成了。我们只需创建我们的中间件应用程序，并添加我们导入的 `localStorage` 中间件：

```js title="firebase.js"
const app = new Application();
app.use(virtualStorage());
```

然后我们需要添加中间件来验证用户。在本教程中，我们只是从我们将要设置的环境变量中获取用户名和密码，但如果用户未登录，这可以很容易地调整为将用户重定向到登录页面：

```js title="firebase.js"
app.use(async (ctx, next) => {
  const signedInUid = ctx.cookies.get("LOGGED_IN_UID");
  const signedInUser = signedInUid != null ? users.get(signedInUid) : undefined;
  if (!signedInUid || !signedInUser || !auth.currentUser) {
    const creds = await auth.signInWithEmailAndPassword(
      Deno.env.get("FIREBASE_USERNAME"),
      Deno.env.get("FIREBASE_PASSWORD"),
    );
    const { user } = creds;
    if (user) {
      users.set(user.uid, user);
      ctx.cookies.set("LOGGED_IN_UID", user.uid);
    } else if (signedInUser && signedInUid.uid !== auth.currentUser?.uid) {
      await auth.updateCurrentUser(signedInUser);
    }
  }
  return next();
});
```

现在让我们将路由器添加到中间件应用程序，并将应用程序设置为监听 8000 端口：

```js title="firebase.js"
app.use(router.routes());
app.use(router.allowedMethods());
await app.listen({ port: 8000 });
```

现在我们有一个应该提供我们 API 的应用程序。

## 部署应用程序

现在我们一切就绪，让我们部署您的新应用程序！

1. 在浏览器中访问 [Deno Deploy](https://dash.deno.com/new_project) 并将您的 GitHub 账户链接起来。
2. 选择包含您新应用程序的仓库。
3. 您可以为项目命名，或者让 Deno 为您生成一个名称
4. 在入口点下拉菜单中选择 `firebase.js`
5. 点击 **部署项目**

为了使您的应用程序正常工作，我们需要配置其环境变量。

在您项目的成功页面或项目仪表板中，点击 **添加环境变量**。在环境变量下，点击 **+ 添加变量**。创建以下变量：

1. `FIREBASE_USERNAME` - 上述添加的 Firebase 用户（电子邮件地址）
2. `FIREBASE_PASSWORD` - 上述添加的 Firebase 用户密码
3. `FIREBASE_CONFIG` - Firebase 应用程序的配置，作为 JSON 字符串

配置需要是有效的 JSON 字符串，以便应用程序可以读取。如果设置时给出的代码片段看起来是这样的：

```js
var firebaseConfig = {
  apiKey: "APIKEY",
  authDomain: "example-12345.firebaseapp.com",
  projectId: "example-12345",
  storageBucket: "example-12345.appspot.com",
  messagingSenderId: "1234567890",
  appId: "APPID",
};
```

您需要将字符串的值设置为这个（注意空格和换行不是必需的）：

```json
{
  "apiKey": "APIKEY",
  "authDomain": "example-12345.firebaseapp.com",
  "projectId": "example-12345",
  "storageBucket": "example-12345.appspot.com",
  "messagingSenderId": "1234567890",
  "appId": "APPID"
}
```

点击保存变量。

现在让我们来体验一下我们的 API。

我们可以创建一个新歌曲：

```sh
curl --request POST \
  --header "Content-Type: application/json" \
  --data '{"title": "Old Town Road", "artist": "Lil Nas X", "album": "7", "released": "2019", "genres": "乡村说唱, 流行"}' \
  --dump-header \
  - https://<project_name>.deno.dev/songs
```

我们可以获取我们集合中的所有歌曲：

```sh
curl https://<project_name>.deno.dev/songs
```

我们可以获取关于我们创建的标题的特定信息：

```sh
curl https://<project_name>.deno.dev/songs/Old%20Town%20Road
```

---

# 简单的 HTTP 服务器

URL: https://docs.deno.com/deploy/tutorials/tutorial-http-server


在本教程中，我们将构建一个 HTTP 服务器，响应所有传入的 HTTP 请求，返回 `Hello, world!` 和 `200 OK` HTTP 状态。我们将使用 Deno Deploy 实验室来部署和编辑这个脚本。

## 步骤 1：编写 HTTP 服务器脚本

一个简单的 HTTP 服务器可以通过以下一行代码在 Deno 中编写，使用 [`Deno.serve`](https://docs.deno.com/api/deno/~/Deno.serve):

```js title="一行代码的 HTTP 服务器"
Deno.serve(() => new Response("Hello, world!"));
```

虽然这种类型的服务器在入门时非常有用，但 `Deno.serve` 也支持更高级的用法
([API 参考文档](https://docs.deno.com/api/deno/~/Deno.serve))。下面是一个更复杂的服务器示例，利用了其他 API 特性。

```ts title="更复杂的 Hello World 服务器"
Deno.serve({
  onListen: ({ port }) => {
    console.log("Deno 服务器正在 *: ", port 监听);
  },
}, (req: Request, conn: Deno.ServeHandlerInfo) => {
  // 获取有关传入请求的信息
  const method = req.method;
  const ip = conn.remoteAddr.hostname;
  console.log(`${ip} 刚刚进行了 HTTP ${method} 请求.`);

  // 返回一个 web 标准的 Response 对象
  return new Response("Hello, world!");
});
```

## 步骤 2：将脚本部署到 Deno Deploy

1. 通过访问 [你的 Deno 仪表板](https://dash.deno.com/account/overview)，并点击 **新建实验室** 按钮来创建一个新的实验室项目。
2. 在下一屏幕上，将上面的代码（短示例或长示例）复制到屏幕左侧的编辑器中。
3. 点击顶部工具栏右侧的 **保存并部署** 按钮（或按 <kbd>Ctrl</kbd>+<kbd>S</kbd>）。

你可以在实验室编辑器右侧的预览窗格中预览结果。

你会看到，如果你更改脚本（例如 `Hello, World!` -> `Hello, Galaxy!`）然后重新部署，预览将自动更新。预览窗格顶部显示的 URL 可用于从任何地方访问已部署的页面。

即使在实验室编辑器中，脚本也会在我们的全球网络中部署。这样可以确保快速和可靠的性能，无论用户位于何处。

---

# 使用 Hugo 构建博客

URL: https://docs.deno.com/deploy/tutorials/tutorial-hugo-blog


教程 [在这里](https://deno.com/blog/hugo-blog-with-deno-deploy).


---

# 带 Postgres 的 API 服务器

URL: https://docs.deno.com/deploy/tutorials/tutorial-postgres


Postgres 是一个流行的数据库，因其灵活性和易用性而广受欢迎。本指南将向您展示如何将 Deno Deploy 与 Postgres 一起使用。

- [带 Postgres 的 API 服务器](#带-postgres-的-api-服务器)
  - [概述](#概述)
  - [设置 Postgres](#设置-postgres)
    - [Neon Postgres](#neon-postgres)
    - [Supabase](#supabase)
  - [编写并部署应用程序](#编写并部署应用程序)

## 概述

我们将构建一个简单待办列表应用程序的 API。它将有两个端点：

`GET /todos` 将返回所有待办事项的列表，`POST /todos` 将创建一个新的待办事项。

```
GET /todos
---
title: "返回所有待办事项的列表"
---
[
  {
    "id": 1,
    "title": "买面包"
  },
  {
    "id": 2,
    "title": "买大米"
  },
  {
    "id": 3,
    "title": "买香料"
  }
]

POST /todos
---
title: "创建一个新的待办事项"
---
"买牛奶"
---
title: "返回 201 状态码"
---
```

在本教程中，我们将：

- 在 [Neon Postgres](https://neon.tech/) 或 [Supabase](https://supabase.com) 上创建和设置一个 [Postgres](https://www.postgresql.org/) 实例。
- 使用 [Deno Deploy](../manual/deployctl.md) Playground 开发和部署应用程序。
- 使用 [cURL](https://curl.se/) 测试我们的应用程序。

## 设置 Postgres

> 本教程将完全专注于不加密地连接到 Postgres。如果您希望使用自定义 CA 证书进行加密，请使用 [此处](https://deno-postgres.com/#/?id=ssltls-connection) 的文档。

首先，我们需要创建一个新的 Postgres 实例以连接。对于本教程，您可以使用 [Neon Postgres](https://neon.tech/) 或 [Supabase](https://supabase.com)，因为它们都提供免费的托管 Postgres 实例。如果您希望将数据库托管在其他地方，也可以这样做。

### Neon Postgres

1. 访问 https://neon.tech/ 并点击 **注册** 通过电子邮件、Github、Google 或合作伙伴帐户注册。注册后，您将被引导到 Neon 控制台以创建第一个项目。
2. 输入项目名称，选择 Postgres 版本，提供数据库名称，并选择区域。一般来说，您会希望选择离您应用程序最近的区域。完成后，点击 **创建项目**。
3. 您将看到新项目的连接字符串，您可以用它连接到数据库。保存连接字符串，其格式类似于以下内容：

   ```sh
   postgres://alex:AbC123dEf@ep-cool-darkness-123456.us-east-2.aws.neon.tech/dbname?sslmode=require
   ```

### Supabase

1. 访问 https://app.supabase.io/ 并点击 "新项目"。
2. 为您的数据库选择名称、密码和区域。务必保存密码，因为您稍后将需要它。
3. 点击 "创建新项目"。创建项目可能需要一段时间，请耐心等待。
4. 一旦项目创建完成，导航到左侧的 "数据库" 选项卡。
5. 转到 "连接池" 设置，从 "连接字符串" 字段中复制连接字符串。这就是您将用于连接到数据库的连接字符串。在此字符串中插入您之前保存的密码，然后将其保存在某个地方 - 稍后您将需要它。

## 编写并部署应用程序

现在我们可以开始编写应用程序了。首先，我们将在控制面板中创建一个新的 Deno Deploy Playground：在 https://dash.deno.com/projects 上按下 "新 Playground" 按钮。

这将打开 Playground 编辑器。在我们真正开始编写代码之前，我们需要将 Postgres 连接字符串放入环境变量中。为此，点击编辑器左上角的项目名称。这将打开项目设置。

在这里，您可以通过左侧导航菜单导航到 "设置" -> "环境变量" 选项卡。在 "键" 字段中输入 "DATABASE_URL"，并将连接字符串粘贴到 "值" 字段中。现在，按 "添加"。您的环境变量现在已设置。

让我们返回编辑器：为此，您可以通过左侧导航菜单转到 "概述" 选项卡，然后按 "打开 Playground"。我们先使用 `Deno.serve()` 来处理 HTTP 请求：

```ts
Deno.serve(async (req) => {
  return new Response("未找到", { status: 404 });
});
```

您现在可以使用 <kbd>Ctrl</kbd>+<kbd>S</kbd> （或 Mac 上的 <kbd>Cmd</kbd>+<kbd>S</kbd>）保存此代码。您应该看到右侧的预览页面自动刷新：现在显示 "未找到"。

接下来，让我们导入 Postgres 模块，从环境变量中读取连接字符串，并创建一个连接池。

```ts
import * as postgres from "https://deno.land/x/postgres@v0.14.0/mod.ts";

// 从环境变量 "DATABASE_URL" 获取连接字符串
const databaseUrl = Deno.env.get("DATABASE_URL")!;

// 创建一个拥有三个连接的数据库池，这些连接会在使用时建立
const pool = new postgres.Pool(databaseUrl, 3, true);
```

同样，您现在可以保存此代码，但这次您应该不会看到任何变化。我们正在创建一个连接池，但实际上我们还没有对数据库执行任何查询。在此之前，我们需要设置表模式。

我们想要存储待办事项的列表。让我们创建一个名为 `todos` 的表，包含一个自增的 `id` 列和一个 `title` 列：

```ts
const pool = new postgres.Pool(databaseUrl, 3, true);

// 连接到数据库
const connection = await pool.connect();
try {
  // 创建表
  await connection.queryObject`
    CREATE TABLE IF NOT EXISTS todos (
      id SERIAL PRIMARY KEY,
      title TEXT NOT NULL
    )
  `;
} finally {
  // 将连接释放回连接池
  connection.release();
}
```

现在我们已经有了一个表，可以为 GET 和 POST 端点添加 HTTP 处理程序。

```ts
Deno.serve(async (req) => {
  // 解析 URL 并检查请求的端点是否为 /todos。如果不是，则返回 404 响应。
  const url = new URL(req.url);
  if (url.pathname !== "/todos") {
    return new Response("未找到", { status: 404 });
  }

  // 从数据库池中获取一个连接
  const connection = await pool.connect();

  try {
    switch (req.method) {
      case "GET": { // 这是一个 GET 请求。返回所有待办事项的列表。
        // 执行查询
        const result = await connection.queryObject`
          SELECT * FROM todos
        `;

        // 将结果编码为 JSON
        const body = JSON.stringify(result.rows, null, 2);

        // 以 JSON 格式返回结果
        return new Response(body, {
          headers: { "content-type": "application/json" },
        });
      }
      case "POST": { // 这是一个 POST 请求。创建一个新的待办事项。
        // 将请求体解析为 JSON。如果请求体解析失败、不是字符串或超过 256 个字符，返回 400 响应。
        const title = await req.json().catch(() => null);
        if (typeof title !== "string" || title.length > 256) {
          return new Response("请求错误", { status: 400 });
        }

        // 将新的待办事项插入数据库
        await connection.queryObject`
          INSERT INTO todos (title) VALUES (${title})
        `;

        // 返回 201 创建响应
        return new Response("", { status: 201 });
      }
      default: // 如果既不是 POST 也不是 GET，则返回 405 响应。
        return new Response("不允许的方法", { status: 405 });
    }
  } catch (err) {
    console.error(err);
    // 如果发生错误，返回 500 响应
    return new Response(`内部服务器错误\n\n${err.message}`, {
      status: 500,
    });
  } finally {
    // 将连接释放回连接池
    connection.release();
  }
});
```

就这样 - 应用程序完成了。通过保存编辑器来部署此代码。您现在可以向 `/todos` 端点发送 POST 请求以创建一个新的待办事项，可以通过向 `/todos` 发送 GET 请求来获取所有待办事项的列表：

```sh
$ curl -X GET https://tutorial-postgres.deno.dev/todos
[]⏎

$ curl -X POST -d '"买牛奶"' https://tutorial-postgres.deno.dev/todos

$ curl -X GET https://tutorial-postgres.deno.dev/todos
[
  {
    "id": 1,
    "title": "买牛奶"
  }
]⏎
```

一切正常 🎉

本教程的完整代码：

<iframe width="100%" height="600" src="https://embed.deno.com/playground/tutorial-postgres?layout=code-only&corp"></iframe>

作为额外的挑战，尝试添加一个 `DELETE /todos/:id` 端点来删除待办事项。[URLPattern][urlpattern] API 可以帮助您完成这个任务。

[urlpattern]: https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API

---

# 将 WordPress 用作无头 CMS

URL: https://docs.deno.com/deploy/tutorials/tutorial-wordpress-frontend


WordPress 是世界上最受欢迎的 CMS，但在 "无头" 形式下使用，即使用自定义前端，比较困难。

在本教程中，我们将展示如何使用 Fresh，这是一个基于 Deno 构建的现代网页框架，来为无头 WordPress 创建前端。

## 步骤 1：克隆 Fresh WordPress 主题

Fresh 提供了两个现成的主题，一个用于博客，另一个用于商店前端。

### 博客

```bash
git clone https://github.com/denoland/fresh-wordpress-themes.git
cd fresh-wordpress-themes/blog
deno task docker
```

### 商店

```bash
git clone https://github.com/denoland/fresh-wordpress-themes.git
cd fresh-wordpress-themes/corporate
deno task docker
```

请注意，博客和商店主题对 WordPress 服务器的设置是不同的。确保您在正确的目录中运行 `deno task docker` 命令。

## 步骤 2：在同一目录中打开另一个终端并运行：

```sh
deno task start
```

## 步骤 3：访问 http://localhost:8000/

您可以通过 WordPress 控制面板管理网站的内容，地址为 http://localhost/wp-admin（用户名: `user`，密码: `password`）。

## WordPress 托管选项

在互联网上有许多托管 WordPress 的选项。许多云服务提供商
[提供](https://aws.amazon.com/getting-started/hands-on/launch-a-wordpress-website/)
[专门](https://cloud.google.com/wordpress)
[指南](https://learn.microsoft.com/en-us/azure/app-service/quickstart-wordpress)
和
[模板](https://console.cloud.google.com/marketplace/product/click-to-deploy-images/wordpress)
专门用于 WordPress。还有一些专门的 WordPress 托管服务，如 [Bluehost](https://www.bluehost.com/),
[DreamHost](https://www.dreamhost.com/),
[SiteGround](https://www.siteground.com/) 等。您可以从这些选项中选择最适合您需求的。

互联网上还有许多资源关于如何扩展您的 WordPress 实例。

---

# 如何在 Deno 中使用 Apollo

> Step-by-step tutorial on integrating Apollo GraphQL with Deno. Learn how to set up an Apollo Server, define schemas, implement resolvers, and build a complete GraphQL API using TypeScript.

URL: https://docs.deno.com/examples/tutorials/apollo


[Apollo Server](https://www.apollographql.com/) 是一个 GraphQL 服务器，您可以在几分钟内设置并与现有数据源（或 REST API）一起使用。然后，您可以将任何 GraphQL 客户端连接到它，以接收数据并利用 GraphQL 的好处，例如类型检查和高效获取。

我们将启动一个简单的 Apollo 服务器，使我们能够查询一些本地数据。我们只需要三个文件：

1. `schema.ts` 用于设置我们的数据模型
2. `resolvers.ts` 用于设置我们如何填充模式中的数据字段
3. 我们的 `main.ts`，服务器将在此启动

我们将开始创建它们：

```shell
touch schema.ts resolvers.ts main.ts
```

让我们逐一设置。

[查看源代码。](https://github.com/denoland/examples/tree/main/with-apollo)

## schema.ts

我们的 `schema.ts` 文件描述了我们的数据。在这种情况下，我们的数据是一系列恐龙。我们希望用户能够获取每个恐龙的名称和简短描述。在 GraphQL 语言中，这意味着 `Dinosaur` 是我们的 **类型**，而 `name` 和 `description` 是我们的 **字段**。我们还可以为每个字段定义数据类型。在这种情况下，这两个字段均为字符串。

这里也是我们使用 GraphQL 特殊 **Query** 类型描述我们允许查询的数据的地方。我们有两个查询：

- `dinosaurs` 用于获取所有恐龙的列表
- `dinosaur` 需要传入恐龙的 `name` 作为参数，并返回关于该种类恐龙的信息。

我们将在 `typeDefs` 类型定义变量中导出所有这些内容：

```tsx
export const typeDefs = `
  type Dinosaur {
    name: String
    description: String
  }

  type Query {
    dinosaurs: [Dinosaur]
    dinosaur(name: String): Dinosaur
  }
`;
```

如果我们想要写入数据，这里也是我们描述 **Mutation** 的地方。Mutation 是使用 GraphQL 写入数据的方式。由于我们在这里使用的是静态数据集，因此我们不会写入任何内容。

## resolvers.ts

解析器负责填充每个查询的数据。在这里，我们有我们的恐龙列表，解析器要做的就是 a) 如果用户请求 `dinosaurs` 查询，则将整个列表传递给客户端，或者 b) 如果用户请求 `dinosaur` 查询，则仅传递一个。

```tsx
const dinosaurs = [
  {
    name: "Aardonyx",
    description: "爬行动物演化的早期阶段。",
  },
  {
    name: "Abelisaurus",
    description: '"阿贝尔的蜥蜴" 是从一具单一的头骨重建而来的。',
  },
];

export const resolvers = {
  Query: {
    dinosaurs: () => dinosaurs,
    dinosaur: (_: any, args: any) => {
      return dinosaurs.find((dinosaur) => dinosaur.name === args.name);
    },
  },
};
```

对于后者，我们将客户端的参数传递到一个函数中，以匹配名称和我们数据集中的名称。

## main.ts

在我们的 `main.ts` 中，我们将导入 `ApolloServer` 以及 `graphql` 和我们的模式中的 `typeDefs` 与解析器：

```tsx
import { ApolloServer } from "npm:@apollo/server@^4.1";
import { startStandaloneServer } from "npm:@apollo/server@4.1/standalone";
import { graphql } from "npm:graphql@16.6";
import { typeDefs } from "./schema.ts";
import { resolvers } from "./resolvers.ts";

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

const { url } = await startStandaloneServer(server, {
  listen: { port: 8000 },
});

console.log(`服务器运行在: ${url}`);
```

我们将 `typeDefs` 和 `resolvers` 传递给 `ApolloServer` 以启动一个新服务器。最后，`startStandaloneServer` 是一个帮助函数，用于快速启动服务器。

## 运行服务器

现在剩下的就是运行服务器：

```shell
deno run --allow-net --allow-read --allow-env main.ts
```

您应该在终端中看到 `服务器运行在: 127.0.0.1:8000`。如果您访问该地址，您将看到 Apollo 沙盒，在那里我们可以输入我们的 `dinosaurs` 查询：

```graphql
query {
  dinosaurs {
    name
    description
  }
}
```

这将返回我们的数据集：

```graphql
{
  "data": {
    "dinosaurs": [
      {
        "name": "Aardonyx",
        "description": "爬行动物演化的早期阶段。"
      },
      {
        "name": "Abelisaurus",
        "description": "\"阿贝尔的蜥蜴\" 是从一具单一的头骨重建而来的。"
      }
    ]
  }
}
```

或者如果我们想要只获取一个 `dinosaur`：

```graphql
query {
  dinosaur(name:"Aardonyx") {
    name
    description
  }
}
```

这将返回：

```graphql
{
  "data": {
    "dinosaur": {
      "name": "Aardonyx",
      "description": "爬行动物演化的早期阶段。"
    }
  }
}
```

太棒了！

[了解有关使用 Apollo 和 GraphQL 的更多信息，请查看他们的教程](https://www.apollographql.com/tutorials/)。

---

# 使用 Deno 构建 Astro

> 逐步教程：使用 Astro 和 Deno 构建 Web 应用程序。学习如何搭建项目、创建动态页面、实现服务器端渲染（SSR），以及使用 Deno 的 Node.js 兼容性部署你的 Astro 网站。

URL: https://docs.deno.com/examples/tutorials/astro


[Astro](https://astro.build/) 是一个专注于内容驱动型网站的现代 Web 框架，采用 Islands 架构，默认情况下不会向客户端发送任何 JavaScript。你可以查看[GitHub 上的完整应用](https://github.com/denoland/tutorial-with-astro)。

你可以在 [Deno Deploy](https://tutorial-with-astro.deno.deno.net/) 上看到该应用的在线版本。

:::info 部署你自己的应用

想跳过教程，立即部署完整的 Astro 恐龙应用？点击以下按钮，立即将完整的 Astro 恐龙应用副本部署到 Deno Deploy。你将获得一个可在线运行、可自定义并修改的应用，边学边用！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-astro)

:::

## 创建一个 Astro 项目

Astro 提供了一个 CLI 工具，可快速生成新的 Astro 项目。在你的终端运行以下命令，使用 Deno 创建一个新的 Astro 项目。

```sh
deno init --npm astro@latest
```

本教程中，我们选择“Empty”模板，方便从零开始搭建，然后安装依赖。

此操作将为我们搭建一个基础的 Astro 项目结构，包括一个 `package.json` 文件，以及存放应用代码的 `src` 目录。

## 启动 Astro 服务器

我们可以使用 `dev` 任务启动本地 Astro 开发服务器。在终端切换到新项目目录，运行：

```sh
deno task dev
```

这将启动 Astro 开发服务器，监视文件改动并自动刷新浏览器页面。你会看到服务器运行在 `http://localhost:4321` 的提示信息。

在浏览器访问该 URL，你应该看到一个非常基础的 Astro 欢迎页面。

## 构建应用架构

现在我们已搭建好基础 Astro 项目，接下来构建应用架构。我们将创建几个目录以组织代码，并设置基础路由。创建以下目录结构：

```text
src/
    ├── data/
    ├── lib/
    └── pages/
        └── index.astro
```

## 添加恐龙数据

在 `data` 目录下新建一个名为 `data.json` 的文件，用于存放硬编码的恐龙数据。

复制以下[这个 json 文件](https://raw.githubusercontent.com/denoland/tutorial-with-astro/refs/heads/main/src/data/data.json)内容，粘贴到 `data.json` 文件中。（如果是实际项目，你可能会从数据库或外部 API 拉取这些数据。）

## 设置业务逻辑

接着，我们创建一个 `lib` 目录，放置业务逻辑代码。在这里我们创建 `dinosaur-service.ts` 文件，包含用于获取恐龙数据的函数。新建 `src/lib/dinosaur-service.ts` 并写入如下代码：

```ts title="src/lib/dinosaur-service.ts"
// 简单的恐龙数据处理工具函数
import dinosaursData from "../data/data.json";

export interface Dinosaur {
  name?: string;
  description: string;
}

export class DinosaurService {
  private static dinosaurs: Dinosaur[] = dinosaursData;

  // 获取所有有名称的恐龙（过滤掉无名恐龙）
  static getNamedDinosaurs(): Dinosaur[] {
    return this.dinosaurs.filter((dino) => dino.name);
  }

  // 根据恐龙名称创建 URL 友好的 slug
  static createSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  // 根据 slug 获取恐龙数据
  static getDinosaurBySlug(slug: string): Dinosaur | undefined {
    return this.dinosaurs.find((dino) => {
      if (!dino.name) return false;
      return this.createSlug(dino.name) === slug;
    });
  }

  // 获取带 slug 的恐龙数据列表以用作链接
  static getDinosaursWithSlugs() {
    return this.getNamedDinosaurs().map((dino) => ({
      ...dino,
      slug: this.createSlug(dino.name!),
    }));
  }
}

export default DinosaurService;
```

该文件定义了一个 `DinosaurService` 类，包含获取所有恐龙、创建 URL 友好 slug 和根据 slug 获取恐龙数据的方法。

## 更新首页使用服务

现在可以更新 `index.astro` 页面，调用 `DinosaurService` 获取恐龙数据并渲染为链接列表。更新 `src/pages/index.astro` 文件内容如下：

```jsx title="src/pages/index.astro"
---
import DinosaurService from '../lib/dinosaur-service';
import '../../styles/index.css';

// 获取带 slug 的所有恐龙，用于创建链接
const dinosaursWithSlugs = DinosaurService.getDinosaursWithSlugs();
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>恐龙目录</title>
	</head>
	<body>
		<h1>🦕 恐龙目录</h1>
		<p>点击任意恐龙名称了解更多信息！</p>
		
		<div class="dinosaur-list">
			{dinosaursWithSlugs.map((dinosaur) => (
				<a href={`/dinosaur/${dinosaur.slug}`} class="dinosaur-link">
					{dinosaur.name}
				</a>
			))}
		</div>
	</body>
</html>
```

我们导入了 `DinosaurService`，然后遍历恐龙数据，创建指向单个恐龙页面的链接。

## 创建单个恐龙详情页

接下来为每只恐龙创建独立页面。在 `src/pages` 目录中创建一个 `dinosaurs` 文件夹，在该文件夹内创建名为 `[slug].astro` 的文件，内容如下：

```jsx title="src/pages/dinosaurs/[slug].astro"
---
import DinosaurService from '../../lib/dinosaur-service';
import '../../styles/index.css';

export async function getStaticPaths() {
    const dinosaursWithSlugs = DinosaurService.getDinosaursWithSlugs();
    
    return dinosaursWithSlugs.map((dinosaur) => ({
        params: { slug: dinosaur.slug },
        props: { dinosaur }
    }));
}

const { dinosaur } = Astro.props;
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width" />
        <meta name="generator" content={Astro.generator} />
        <title>{dinosaur.name} - 恐龙目录</title>
        <meta name="description" content={dinosaur.description} />
		<link rel="stylesheet" href="https://demo-styles.deno.deno.net/styles.css">
    </head>
    <body class="dinosaur">
        <main>
            <h1>🦕 {dinosaur.name}</h1>
            
            <div class="info-card">
                <p>{dinosaur.description}</p>
            </div>
            
            <a href="/" class="btn-secondary">返回目录</a>
        </main>
    </body>
</html>
```

该文件使用 `getStaticPaths` 生成所有恐龙的静态路由路径，`Astro.props` 会携带当前 slug 对应的恐龙数据，我们在页面中进行渲染。

## 添加样式

你可以在 `src/styles/index.css` 文件中为应用添加个性化样式。该文件在 `index.astro` 和 `[slug].astro` 文件中都被导入，因此所添加的样式会应用于这两个页面。

## 构建和部署

Astro 内置了用于生产构建的命令：

```sh
deno run build
```

此命令将：

- 在 `dist` 目录中生成每个页面对应的静态 HTML 文件。
- 优化你的资源文件（CSS、JavaScript、图片等），适配生产环境。

你可以将该应用部署到你喜欢的云提供商。我们推荐使用 [Deno Deploy](https://deno.com/deploy)，体验简单便捷。你可以直接从 GitHub 部署，只需新建一个 GitHub 仓库，推送代码后连接到 Deno Deploy 即可。

### 创建 GitHub 仓库

[创建一个新的 GitHub 仓库](https://github.com/new)，然后初始化并推送你的项目：

```sh
git init -b main
git remote add origin https://github.com/<你的_github_用户名>/<你的仓库名>.git
git add .
git commit -am 'initial commit'
git push -u origin main
```

### 部署到 Deno Deploy

代码托管至 GitHub 后，你可以在 [Deno Deploy<sup>EA</sup> 控制面板](https://console.deno.com/) 上进行部署。

如果想了解部署流程，请查看 [Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在，你可以使用 Deno 搭建并开发一个 Astro 应用！你可以继续扩展该应用，比如添加用户认证、数据库、甚至 CMS。我们期待看到你基于 Astro 和 Deno 创造的精彩项目！

---

# 如何将 Deno 部署到 AWS Lambda

> Step-by-step tutorial on deploying Deno applications to AWS Lambda. Learn about Docker containerization, ECR repositories, function configuration, and how to set up serverless Deno apps on AWS.

URL: https://docs.deno.com/examples/tutorials/aws_lambda


AWS Lambda 是由亚马逊网络服务提供的一种无服务器计算服务。它允许您在无需配置或管理服务器的情况下运行代码。

以下是将 Deno 应用程序部署到 AWS Lambda 的逐步指南，使用 Docker。

这需要的前提条件是：

- [`docker` CLI](https://docs.docker.com/reference/cli/docker/)
- 一个 [AWS 账户](https://aws.amazon.com)
- [`aws` CLI](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)

## 第一步：创建一个 Deno 应用

使用以下代码创建一个新的 Deno 应用：

```ts title="main.ts"
Deno.serve((req) => new Response("Hello World!"));
```

将此代码保存在名为 `main.ts` 的文件中。

## 第二步：创建一个 Dockerfile

创建一个名为 `Dockerfile` 的新文件，内容如下：

```Dockerfile
# 设置基础镜像
FROM public.ecr.aws/awsguru/aws-lambda-adapter:0.9.0 AS aws-lambda-adapter
FROM denoland/deno:bin-1.45.2 AS deno_bin
FROM debian:bookworm-20230703-slim AS deno_runtime
COPY --from=aws-lambda-adapter /lambda-adapter /opt/extensions/lambda-adapter
COPY --from=deno_bin /deno /usr/local/bin/deno
ENV PORT=8000
EXPOSE 8000
RUN mkdir /var/deno_dir
ENV DENO_DIR=/var/deno_dir

# 复制功能代码
WORKDIR "/var/task"
COPY . /var/task

# 预热缓存
RUN timeout 10s deno run -A main.ts || [ $? -eq 124 ] || exit 1

CMD ["deno", "run", "-A", "main.ts"]
```

此 Dockerfile 使用
[`aws-lambda-adapter`](https://github.com/awslabs/aws-lambda-web-adapter)
项目将常规 HTTP 服务器（如 Deno 的 `Deno.serve`）适配到 AWS
Lambda 运行时 API。

我们还使用 `denoland/deno:bin-1.45.2` 镜像获取 Deno 二进制文件，使用 `debian:bookworm-20230703-slim` 作为基础镜像。`debian:bookworm-20230703-slim` 镜像用于保持镜像大小较小。

将 `PORT` 环境变量设置为 `8000`，以通知 AWS Lambda 适配器我们正在监听端口 `8000`。

将 `DENO_DIR` 环境变量设置为 `/var/deno_dir`，以在 `/var/deno_dir` 目录中存储缓存的 Deno 源代码和转译模块。

预热缓存步骤用于在调用函数之前预热 Deno 缓存。这样做是为了减少函数的冷启动时间。这些缓存包含您函数代码的编译代码和依赖项。此步骤启动您的服务器 10 秒钟，然后退出。

在使用 package.json 时，请记得在预热缓存或运行函数之前运行 `deno install` 以从 `package.json` 文件中安装 `node_modules`。

## 第三步：构建 Docker 镜像

使用以下命令构建 Docker 镜像：

```bash
docker build -t hello-world .
```

## 第四步：创建 ECR Docker 存储库并推送镜像

使用 AWS CLI，创建一个 ECR 存储库并将 Docker 镜像推送到其中：

```bash
aws ecr create-repository --repository-name hello-world --region us-east-1 | grep repositoryUri
```

这应该会输出一个类似 `<account_id>.dkr.ecr.us-east-1.amazonaws.com/hello-world` 的存储库 URI。

使用上一步的存储库 URI 对 Docker 进行 ECR 身份验证：

```bash
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account_id>.dkr.ecr.us-east-1.amazonaws.com
```

使用存储库 URI 对 Docker 镜像进行标记，再次使用上一步的存储库 URI：

```bash
docker tag hello-world:latest <account_id>.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
```

最后，使用上一步的存储库 URI 将 Docker 镜像推送到 ECR 存储库：

```bash
docker push <account_id>.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
```

## 第五步：创建 AWS Lambda 函数

现在您可以通过 AWS 管理控制台创建一个新的 AWS Lambda 函数。

1. 转到 AWS 管理控制台并 
   [导航到 Lambda 服务](https://us-east-1.console.aws.amazon.com/lambda/home?region=us-east-1)。
2. 点击 "创建函数" 按钮。
3. 选择 "容器镜像"。
4. 输入函数的名称，例如 "hello-world"。
5. 点击 "浏览镜像" 按钮并选择您推送到 ECR 的镜像。
6. 点击 "创建函数" 按钮。
7. 等待函数创建完成。
8. 在 "配置" 选项卡中，转到 "函数 URL" 部分并点击 
   "创建函数 URL"。
9. 选择 "无" 作为身份验证类型（这将使 Lambda 函数公开可访问）。
10. 点击 "保存" 按钮。

## 第六步：测试 Lambda 函数

您现在可以访问 Lambda 函数的 URL，以查看来自 Deno 应用的响应。

🦕 您已成功使用 Docker 将 Deno 应用程序部署到 AWS Lambda。现在您可以使用此设置将更复杂的 Deno 应用程序部署到 AWS Lambda。

---

# examples/tutorials/aws_lightsail.md

> Step-by-step tutorial on deploying Deno applications to AWS Lightsail. Learn about Docker containers, GitHub Actions automation, continuous deployment, and how to set up cost-effective cloud hosting for Deno apps.

URL: https://docs.deno.com/examples/tutorials/aws_lightsail


[Amazon Lightsail](https://aws.amazon.com/lightsail/) 是开始使用 Amazon Web Services 最简单和最便宜的方式。它允许您托管虚拟机甚至整个容器服务。

本教程将向您展示如何使用 Docker、Docker Hub 和 GitHub Actions 将 Deno 应用部署到 Amazon Lightsail。

在继续之前，请确保您已经准备好：

- [`docker` CLI](https://docs.docker.com/engine/reference/commandline/cli/)
- 一个 [Docker Hub 帐户](https://hub.docker.com)
- 一个 [GitHub 帐户](https://github.com)
- 一个 [AWS 帐户](https://aws.amazon.com/)

## 创建 Dockerfile 和 docker-compose.yml

为了专注于部署，我们的应用程序将简单地是一个返回字符串作为 HTTP 响应的 `main.ts` 文件：

```ts
import { Application } from "jsr:@oak/oak";

const app = new Application();

app.use((ctx) => {
  ctx.response.body = "Hello from Deno and AWS Lightsail!";
});

await app.listen({ port: 8000 });
```

然后，我们将创建两个文件 -- `Dockerfile` 和 `docker-compose.yml` -- 来构建 Docker 镜像。

在我们的 `Dockerfile` 中，我们将添加：

```Dockerfile
FROM denoland/deno

EXPOSE 8000

WORKDIR /app

ADD . /app

RUN deno install --entrypoint main.ts

CMD ["run", "--allow-net", "main.ts"]
```

然后，在我们的 `docker-compose.yml` 中：

```yml
version: "3"

services:
  web:
    build: .
    container_name: deno-container
    image: deno-image
    ports:
      - "8000:8000"
```

让我们通过运行 `docker compose -f docker-compose.yml build` 来在本地测试，然后 `docker compose up`，并前往 `localhost:8000`。

![hello world from localhost](./images/how-to/aws-lightsail/hello-world-from-localhost.png)

它工作正常！

## 构建、标记并推送到 Docker Hub

首先，让我们登录到 [Docker Hub](https://hub.docker.com/repositories) 并创建一个仓库。我们将其命名为 `deno-on-aws-lightsail`。

然后，我们将标记并推送我们的新镜像，将 `username` 替换为您的用户名：

然后，让我们在本地构建镜像。请注意我们的 `docker-compose.yml` 文件将名称构建为 `deno-image`。

```shell
docker compose -f docker-compose.yml build
```

让我们 [标记](https://docs.docker.com/engine/reference/commandline/tag/) 本地镜像为 `{{ username }}/deno-on-aws-lightsail`：

```shell
docker tag deno-image {{ username }}/deno-on-aws-lightsail
```

现在我们可以将镜像推送到 Docker Hub：

```shell
docker push {{ username }}/deno-on-aws-lightsail
```

在成功之后，您应该能在您的 Docker Hub 仓库中看到新镜像：

![new image on docker hub](./images/how-to/aws-lightsail/new-image-on-docker-hub.png)

## 创建并部署到 Lightsail 容器

让我们前往 [Amazon Lightsail 控制台](https://lightsail.aws.amazon.com/ls/webapp/home/container-services)。

然后单击“容器”和“创建容器服务”。在页面中间，单击“设置您的第一次部署”，选择“指定自定义部署”。

您可以输入任何您想要的容器名称。

在 `Image` 中，请务必使用您在 Docker Hub 中设置的 `{{ username }}/{{ image }}`。在本例中，它是 `lambtron/deno-on-aws-lightsail`。

让我们单击 `添加开放端口` 并添加 `8000`。

最后，在 `公共端点` 下，选择您刚创建的容器名称。

完整的表单应如下所示：

![create container service interface](./images/how-to/aws-lightsail/create-container-service-on-aws.png)

当您准备好时，单击“创建容器服务”。

几秒钟后，您的新容器应该被部署。单击公共地址，您应该能够看到您的 Deno 应用：

![Hello world from Deno and AWS Lightsail](./images/how-to/aws-lightsail/hello-world-from-deno-and-aws-lightsail.png)

## 使用 GitHub Actions 进行自动化

为了自动化该过程，我们将使用 `aws` CLI 及其 [`lightsail` 子命令](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/lightsail/push-container-image.html)。

我们在 GitHub Actions 工作流中的步骤将是：

1. 检出仓库
2. 在本地构建我们的应用程序为 Docker 镜像
3. 安装并验证 AWS CLI
4. 通过 CLI 将本地 Docker 镜像推送到 AWS Lightsail 容器服务

让这个 GitHub Action 工作流正常工作的前提条件：

- 已创建 AWS Lightsail 容器实例（见上文）
- 设置了 IAM 用户和相关权限。
  ([了解有关为 IAM 用户管理 Amazon Lightsail 访问权限的更多信息。](https://docs.aws.amazon.com/lightsail/latest/userguide/amazon-lightsail-managing-access-for-an-iam-user.html))
- 为您的用户拥有权限的 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`。 (请按照 [此 AWS 指南](https://lightsail.aws.amazon.com/ls/docs/en_us/articles/lightsail-how-to-set-up-access-keys-to-use-sdk-api-cli) 来获取生成的 `AWS_ACCESS_KEY_ID` 和 `AWS_SUCCESS_ACCESS_KEY`。)

让我们创建一个新文件 `container.template.json`，其中包含关于如何进行服务容器部署的配置。请注意这些选项值与我们在上一节手动输入的值的相似性。

```json
{
  "containers": {
    "app": {
      "image": "",
      "environment": {
        "APP_ENV": "release"
      },
      "ports": {
        "8000": "HTTP"
      }
    }
  },
  "publicEndpoint": {
    "containerName": "app",
    "containerPort": 8000,
    "healthCheck": {
      "healthyThreshold": 2,
      "unhealthyThreshold": 2,
      "timeoutSeconds": 5,
      "intervalSeconds": 10,
      "path": "/",
      "successCodes": "200-499"
    }
  }
}
```

让我们将以下内容添加到 `.github/workflows/deploy.yml` 文件中：

```yml
name: Build and Deploy to AWS Lightsail

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-west-2
  AWS_LIGHTSAIL_SERVICE_NAME: container-service-2
jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4

      - name: Install Utilities
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip
      - name: Install AWS Client
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install || true
          aws --version
          curl "https://s3.us-west-2.amazonaws.com/lightsailctl/latest/linux-amd64/lightsailctl" -o "lightsailctl"
          sudo mv "lightsailctl" "/usr/local/bin/lightsailctl"
          sudo chmod +x /usr/local/bin/lightsailctl
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      - name: Build Docker Image
        run: docker build -t ${{ env.AWS_LIGHTSAIL_SERVICE_NAME }}:release .
      - name: Push and Deploy
        run: |
          service_name=${{ env.AWS_LIGHTSAIL_SERVICE_NAME }}
          aws lightsail push-container-image \
            --region ${{ env.AWS_REGION }} \
            --service-name ${service_name} \
            --label ${service_name} \
            --image ${service_name}:release
          aws lightsail get-container-images --service-name ${service_name} | jq --raw-output ".containerImages[0].image" > image.txt
          jq --arg image $(cat image.txt) '.containers.app.image = $image' container.template.json > container.json
          aws lightsail create-container-service-deployment --service-name ${service_name} --cli-input-json file://$(pwd)/container.json
```

哇，这里有很多内容！最后两个步骤是最重要的：
`Build Docker Image` 和 `Push and Deploy`。

```shell
docker build -t ${{ env.AWS_LIGHTSAIL_SERVICE_NAME }}:release .
```

此命令使用名称 `container-service-2` 构建我们的 Docker 镜像并标记为 `release`。

```shell
aws lightsail push-container-image ...
```

此命令将本地镜像推送到我们的 Lightsail 容器。

```shell
aws lightsail get-container-images --service-name ${service_name} | jq --raw-output ".containerImages[0].image" > image.txt
```

此命令检索镜像信息，并使用 [`jq`](https://stedolan.github.io/jq/) 进行解析，将镜像名称保存在本地文件 `image.txt` 中。

```shell
jq --arg image $(cat image.txt) '.containers.app.image = $image' container.template.json > container.json
```

此命令使用保存在 `image.txt` 中的镜像名称和 `container.template.json` 创建一个名为 `container.json` 的新选项文件。这个选项文件将被传递给 `aws lightsail` 进行下一步的最终部署。

```shell
aws lightsail create-container-service-deployment --service-name ${service_name} --cli-input-json file://$(pwd)/container.json
```

最后，此命令使用 `service_name` 创建一个新的部署，以及 `container.json` 中的配置设置。

当您将代码推送到 GitHub 并且 Action 成功后，您将能够在 AWS 上看到您的新 Deno 应用：

![deno on aws](./images/how-to/aws-lightsail/hello-world-from-deno-and-aws-lightsail.png)

🦕 现在您可以使用 Docker、Docker Hub 和 GitHub Actions 将 Deno 应用程序部署到 Amazon Lightsail。

---

# 在 Deno 中入门 OpenTelemetry

> 在 Deno 应用中设置基本的 OpenTelemetry 监测。本教程涵盖创建一个带有自定义指标和跟踪的简单 HTTP 服务器，以及查看遥测数据。

URL: https://docs.deno.com/examples/tutorials/basic_opentelemetry


OpenTelemetry 为您的应用提供强大的可观察性工具。借助 Deno 内置的 OpenTelemetry 支持，您可以轻松地对代码进行监测，收集指标、跟踪和日志。

本教程将指导您如何设置一个带有 OpenTelemetry 监测的简单 Deno 应用。

## 前提条件

- Deno 2.3 或更高版本

## 第一步：创建一个简单的 HTTP 服务器

让我们开始创建一个基础的 HTTP 服务器，模拟一个小型的网页应用：

```ts title="server.ts"
import { metrics, trace } from "npm:@opentelemetry/api@1";

// 为我们的应用创建 tracer 和 meter
const tracer = trace.getTracer("my-server", "1.0.0");
const meter = metrics.getMeter("my-server", "1.0.0");

// 创建一些指标
const requestCounter = meter.createCounter("http_requests_total", {
  description: "HTTP 请求总数",
});

const requestDuration = meter.createHistogram("http_request_duration_ms", {
  description: "HTTP 请求持续时间（毫秒）",
  unit: "ms",
});

// 启动服务器
Deno.serve({ port: 8000 }, (req) => {
  // 记录请求开始时间，以测量请求持续时间
  const startTime = performance.now();

  // 为该请求创建一个 span
  return tracer.startActiveSpan("handle_request", async (span) => {
    try {
      // 从 URL 中提取路径
      const url = new URL(req.url);
      const path = url.pathname;

      // 为 span 添加属性
      span.setAttribute("http.route", path);
      span.setAttribute("http.method", req.method);
      span.updateName(`${req.method} ${path}`);

      // 为 span 添加事件
      span.addEvent("request_started", {
        timestamp: startTime,
        request_path: path,
      });

      // 模拟一些处理时间
      const waitTime = Math.random() * 100;
      await new Promise((resolve) => setTimeout(resolve, waitTime));

      // 为 span 添加另一个事件
      span.addEvent("processing_completed");

      // 创建响应
      const response = new Response(`Hello from ${path}!`, {
        headers: { "Content-Type": "text/plain" },
      });

      // 记录指标
      requestCounter.add(1, {
        method: req.method,
        path,
        status: 200,
      });

      const duration = performance.now() - startTime;
      requestDuration.record(duration, {
        method: req.method,
        path,
      });

      span.setAttribute("request.duration_ms", duration);

      return response;
    } catch (error) {
      // 在 span 中记录错误
      if (error instanceof Error) {
        span.recordException(error);
        span.setStatus({
          code: trace.SpanStatusCode.ERROR,
          message: error.message,
        });
      }

      return new Response("内部服务器错误", { status: 500 });
    } finally {
      // 始终结束 span
      span.end();
    }
  });
});
```

该服务器功能：

1. 为应用创建 tracer 和 meter
2. 设置指标以统计请求数量并测量请求持续时间
3. 为每个请求创建带有属性和事件的 span
4. 模拟处理时间
5. 记录每个请求的指标

## 第二步：启用 OpenTelemetry 并运行服务器

使用以下命令行标志运行服务器以启用 OpenTelemetry：

```sh
OTEL_DENO=true OTEL_SERVICE_NAME=my-server deno run --allow-net server.ts
```

## 第三步：创建测试客户端

让我们创建一个简单客户端，向服务器发送请求：

```ts title="client.ts"
// 向不同路径发送 10 个请求
for (let i = 0; i < 10; i++) {
  const path = ["", "about", "users", "products", "contact"][i % 5];
  const url = `http://localhost:8000/${path}`;

  console.log(`正在向 ${url} 发送请求`);

  try {
    const response = await fetch(url);
    const text = await response.text();
    console.log(`来自 ${url} 的响应：${text}`);
  } catch (error) {
    console.error(`获取 ${url} 时出错：`, error);
  }
}
```

## 第四步：运行客户端

在另一个终端中运行客户端：

```sh
deno run --allow-net client.ts
```

## 第五步：查看遥测数据

默认情况下，Deno 会使用 OTLP 协议将遥测数据导出到 `http://localhost:4318`。您需要一个 OpenTelemetry collector 来接收并可视化这些数据。

### 安装本地 Collector

最快速的方式是使用 Docker 运行本地 LGTM 堆栈（Loki, Grafana, Tempo, Mimir）：

```sh
docker run --name lgtm -p 3000:3000 -p 4317:4317 -p 4318:4318 --rm -ti \
  -v "$PWD"/lgtm/grafana:/data/grafana \
  -v "$PWD"/lgtm/prometheus:/data/prometheus \
  -v "$PWD"/lgtm/loki:/data/loki \
  -e GF_PATHS_DATA=/data/grafana \
  docker.io/grafana/otel-lgtm:0.8.1
```

然后访问 http://localhost:3000 登录 Grafana（用户名：admin，密码：admin）。

在 Grafana 中，您可以：

1. 在 Tempo 中查看 **Traces（跟踪）**，查看每个请求的 span
2. 在 Mimir/Prometheus 中查看 **Metrics（指标）**，查看请求计数和持续时间
3. 在 Loki 中查看 **Logs（日志）**，查看应用的任何日志

## 理解你所看到的内容

### 跟踪（Traces）

在 Traces 视图中，您将看到：

- 服务器处理的每个 HTTP 请求的 span
- 客户端发出的每个 fetch 请求的 span
- 这些 span 之间的关联关系

点击任一 span 可查看详细信息，包括：

- 持续时间
- 属性（如 http.route、http.method 等）
- 事件（request_started、processing_completed）

### 指标（Metrics）

在 Metrics 视图中，您可以查询：

- `http_requests_total` — 统计 HTTP 请求数量的计数器
- `http_request_duration_ms` — 请求持续时间的直方图

您还可以看到内置的 Deno 指标，如：

- `http.server.request.duration`
- `http.server.active_requests`

### 日志（Logs）

在 Logs 视图中，您将看到应用程序的所有控制台日志，且带有正确的跟踪上下文。

## 故障排除

如果您在 Collector 中看不到数据：

1. 检查是否设置了 `OTEL_DENO=true`
2. 确认 Collector 正在运行且在默认端点可访问
3. 检查是否需要将 `OTEL_EXPORTER_OTLP_ENDPOINT` 设置为其他 URL
4. 查看 Deno 控制台输出中是否有错误信息

请记住，Deno 中的 OpenTelemetry 支持仍处于不稳定阶段，未来版本可能会有所变动。

🦕 本教程为希望在 Deno 中尝试 OpenTelemetry 的用户提供了一个简单的起点，无需立即深入复杂概念。

此基础示例可以通过多种方式扩展：

- 为业务逻辑添加更多自定义指标
- 为重要操作创建额外的 span
- 使用 baggage 在服务间传递上下文属性
- 基于指标阈值设置告警

欲了解更高级的用法，请参阅我们的
[分布式跟踪与上下文传播](/examples/otel_span_propagation_tutorial/)
教程。

---

# 行为驱动开发 (BDD)

> 使用 Deno 标准库的 BDD 模块实现行为驱动开发。创建可读性强、组织良好的测试，并进行有效的断言。

URL: https://docs.deno.com/examples/tutorials/bdd


行为驱动开发 (BDD) 是一种软件开发方法，鼓励开发人员、质量保证人员和非技术利益相关者之间的协作。BDD 关注通过用所有利益相关者都能理解的自然语言编写的示例来定义应用程序的行为。

Deno 的标准库提供了一个 BDD 风格的测试模块，使您能够以对非技术利益相关者友好且在实现上实用的方式构建测试。在本教程中，我们将探索如何使用 BDD 模块为您的应用程序创建描述性测试套件。

## BDD 简介

BDD 扩展了
[测试驱动开发](https://en.wikipedia.org/wiki/Test-driven_development)
(TDD)，通过使用易于阅读的自然语言编写测试。与其考虑“测试”，BDD 鼓励我们考虑“规范”或“规格”，这些规格描述软件应如何从用户的角度进行操作。这种方法有助于保持测试专注于代码应做什么，而不是它是如何实现的。

BDD 的基本元素包括：

- **Describe** 块，用于分组相关的规范
- **It** 语句，表达单一的行为
- **Before/After** 钩子，用于设置和拆解操作

## 使用 Deno 的 BDD 模块

要开始在 Deno 中进行 BDD 测试，我们将使用 [Deno 标准库](https://jsr.io/@std/testing/doc/bdd) 中的 `@std/testing/bdd` 模块。

首先，让我们导入所需的函数：

```ts
import {
  afterAll,
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  it,
} from "jsr:@std/testing/bdd";
import { assertEquals, assertThrows } from "jsr:@std/assert";
```

这些导入提供了核心的 BDD 函数：

- `describe` 创建一个块，分组相关的测试
- `it` 声明一个验证特定行为的测试用例
- `beforeEach`/`afterEach` 在每个测试用例前后运行
- `beforeAll`/`afterAll` 在描述块中的所有测试之前或之后运行一次

我们还将使用来自 [`@std/assert`](https://jsr.io/@std/assert) 的断言函数来验证我们的期望。

### 编写您的第一个 BDD 测试

让我们创建一个简单的计算器模块并使用 BDD 对其进行测试：

```ts title="calculator.ts"
export class Calculator {
  private value: number = 0;

  constructor(initialValue: number = 0) {
    this.value = initialValue;
  }

  add(number: number): Calculator {
    this.value += number;
    return this;
  }

  subtract(number: number): Calculator {
    this.value -= number;
    return this;
  }

  multiply(number: number): Calculator {
    this.value *= number;
    return this;
  }

  divide(number: number): Calculator {
    if (number === 0) {
      throw new Error("无法被零除");
    }
    this.value /= number;
    return this;
  }

  get result(): number {
    return this.value;
  }
}
```

现在，让我们使用 BDD 风格测试这个计算器：

```ts title="calculator_test.ts"
import { afterEach, beforeEach, describe, it } from "jsr:@std/testing/bdd";
import { assertEquals, assertThrows } from "jsr:@std/assert";
import { Calculator } from "./calculator.ts";

describe("计算器", () => {
  let calculator: Calculator;

  // 在每个测试之前创建一个新的 Calculator 实例
  beforeEach(() => {
    calculator = new Calculator();
  });

  it("应初始化为零", () => {
    assertEquals(calculator.result, 0);
  });

  it("应初始化为提供的值", () => {
    const initializedCalculator = new Calculator(10);
    assertEquals(initializedCalculator.result, 10);
  });

  describe("加法方法", () => {
    it("应正确地加一个正数", () => {
      calculator.add(5);
      assertEquals(calculator.result, 5);
    });

    it("应正确处理负数", () => {
      calculator.add(-5);
      assertEquals(calculator.result, -5);
    });

    it("应支持链式调用", () => {
      calculator.add(5).add(10);
      assertEquals(calculator.result, 15);
    });
  });

  describe("减法方法", () => {
    it("应正确地减去一个数", () => {
      calculator.subtract(5);
      assertEquals(calculator.result, -5);
    });

    it("应支持链式调用", () => {
      calculator.subtract(5).subtract(10);
      assertEquals(calculator.result, -15);
    });
  });

  describe("乘法方法", () => {
    beforeEach(() => {
      // 对于乘法测试，初始值为 10
      calculator = new Calculator(10);
    });

    it("应正确地乘以一个数", () => {
      calculator.multiply(5);
      assertEquals(calculator.result, 50);
    });

    it("应支持链式调用", () => {
      calculator.multiply(2).multiply(3);
      assertEquals(calculator.result, 60);
    });
  });

  describe("除法方法", () => {
    beforeEach(() => {
      // 对于除法测试，初始值为 10
      calculator = new Calculator(10);
    });

    it("应正确地除以一个数", () => {
      calculator.divide(2);
      assertEquals(calculator.result, 5);
    });

    it("应在除以零时抛出错误", () => {
      assertThrows(
        () => calculator.divide(0),
        Error,
        "无法被零除",
      );
    });
  });
});
```

要运行此测试，请使用 `deno test` 命令：

```sh
deno test calculator_test.ts
```

您将看到类似以下的输出：

```sh
running 1 test from file:///path/to/calculator_test.ts
计算器
  ✓ 应初始化为零 
  ✓ 应初始化为提供的值 
  加法方法
    ✓ 应正确地加一个正数 
    ✓ 应正确处理负数 
    ✓ 应支持链式调用 
  减法方法
    ✓ 应正确地减去一个数 
    ✓ 应支持链式调用 
  乘法方法
    ✓ 应正确地乘以一个数 
    ✓ 应支持链式调用 
  除法方法
    ✓ 应正确地除以一个数 
    ✓ 应在除以零时抛出错误 

ok | 11 passed | 0 failed (234ms)
```

## 使用嵌套的 describe 块组织测试

BDD 的一个强大特性是能够嵌套 `describe` 块，从而帮助以层次结构组织测试。在计算器示例中，我们在各自的 `describe` 块中分组了每个方法的测试。这不仅使测试更具可读性，而且在测试失败时更容易定位问题。

您可以嵌套 `describe` 块，但要注意不要嵌套得太深，因为过度嵌套可能使测试更难以理解。

## 钩子

BDD 模块提供了四个钩子：

- `beforeEach` 在当前 describe 块中的每个测试之前运行
- `afterEach` 在当前 describe 块中的每个测试之后运行
- `beforeAll` 在当前 describe 块中的所有测试之前运行一次
- `afterAll` 在当前 describe 块中的所有测试之后运行一次

### beforeEach/afterEach

这些钩子非常适合于：

- 为每个测试设置一个新的测试环境
- 在每个测试后清理资源
- 确保测试隔离

在计算器示例中，我们使用 `beforeEach` 在每个测试之前创建一个新的计算器实例，以确保每个测试都从干净的状态开始。

### beforeAll/afterAll

这些钩子适用于：

- 可以共享的昂贵设置操作
- 设置和拆除数据库连接
- 创建和清理共享资源

以下是如何使用 `beforeAll` 和 `afterAll` 的示例：

```ts
describe("数据库操作", () => {
  let db: Database;

  beforeAll(async () => {
    // 在所有测试之前一次连接到数据库
    db = await Database.connect(TEST_CONNECTION_STRING);
    await db.migrate();
  });

  afterAll(async () => {
    // 在所有测试完成后断开连接
    await db.close();
  });

  it("应插入一条记录", async () => {
    const result = await db.insert({ name: "测试" });
    assertEquals(result.success, true);
  });

  it("应检索一条记录", async () => {
    const record = await db.findById(1);
    assertEquals(record.name, "测试");
  });
});
```

## Gherkin 与 JavaScript 风格的 BDD

如果您熟悉 Cucumber 或其他 BDD 框架，您可能会期待使用 "Given-When-Then" 语句的 Gherkin 语法。

Deno 的 BDD 模块使用的是 JavaScript 风格的语法，而不是 Gherkin。这种方法类似于其他 JavaScript 测试框架，如 Mocha 或 Jasmine。然而，您仍然可以通过以下方式遵循 BDD 原则：

1. 编写清晰、以行为为中心的测试描述
2. 组织测试以反映用户故事
3. 在测试实现中遵循 "Arrange-Act-Assert" 模式

例如，您可以将您的 `it` 块构造为与 Given-When-Then 格式相对应：

```ts
describe("计算器", () => {
  it("应正确加法运算", () => {
    // Given
    const calculator = new Calculator();

    // When
    calculator.add(5);

    // Then
    assertEquals(calculator.result, 5);
  });
});
```

如果您需要完整的 Gherkin 支持和自然语言规范，请考虑使用与 Deno 兼容的专用 BDD 框架，例如
[cucumber-js](https://github.com/cucumber/cucumber-js)。

## Deno 的 BDD 最佳实践

### 编写易于阅读的测试

BDD 测试应像文档一样可读。在您的 `describe` 和 `it` 语句中使用清晰、描述性的语言：

```ts
// 好
describe("用户认证", () => {
  it("应拒绝不正确密码的登录", () => {
    // 测试代码
  });
});

// 不好
describe("auth", () => {
  it("bad pw fails", () => {
    // 测试代码
  });
});
```

### 保持测试专注

每个测试应验证单一行为。避免在单个 `it` 块中测试多个行为：

```ts
// 好
it("应将商品添加到购物车", () => {
  // 测试添加到购物车
});

it("应计算出正确的总数", () => {
  // 测试总数计算
});

// 不好
it("应添加商品并计算总数", () => {
  // 测试添加到购物车
  // 测试总数计算
});
```

### 使用上下文特定的设置

当一个描述块中的测试需要不同的设置时，使用嵌套的描述和它们自己的 `beforeEach` 钩子，而不是条件逻辑：

```ts
// 好
describe("用户操作", () => {
  describe("当用户已登录时", () => {
    beforeEach(() => {
      // 设置已登录用户
    });

    it("应显示仪表盘", () => {
      // 测试
    });
  });

  describe("当用户未登录时", () => {
    beforeEach(() => {
      // 设置未登录状态
    });

    it("应重定向到登录", () => {
      // 测试
    });
  });
});

// 避免
describe("用户操作", () => {
  beforeEach(() => {
    // 设置基本状态
    if (isLoggedInTest) {
      // 设置已登录状态
    } else {
      // 设置未登录状态
    }
  });

  it("应在已登录时显示仪表盘", () => {
    isLoggedInTest = true;
    // 测试
  });

  it("应在未登录时重定向到登录", () => {
    isLoggedInTest = false;
    // 测试
  });
});
```

### 正确处理异步测试

在测试异步代码时，请记住：

- 将您的测试函数标记为 `async`
- 对于 Promise 使用 `await`
- 正确处理错误

```ts
it("应异步获取用户数据", async () => {
  const user = await fetchUser(1);
  assertEquals(user.name, "约翰·多");
});
```

🦕 通过遵循本教程中概述的 BDD 原则和实践，您可以构建更可靠的软件，并加深对代码业务逻辑的理解。

请记住，BDD 不仅仅是关于语法或工具，而是共同定义和验证应用程序行为的方法。最成功的 BDD 实施将这些技术实践与开发人员、测试人员、产品与业务利益相关者之间的定期对话结合在一起。

要继续学习 Deno 中的测试，请探索标准库测试套件中的其他模块，例如 [模拟](/examples/mocking_tutorial/) 和 [快照测试](/examples/snapshot_tutorial/)。

---

# 使用 WebSockets 的聊天应用程序

> A tutorial on building a real-time chat app using Deno WebSockets. Learn how to create a WebSocket server with Oak, handle multiple client connections, manage state, and build an interactive chat interface with HTML, CSS, and JavaScript.

URL: https://docs.deno.com/examples/tutorials/chat_app


WebSockets 是构建实时应用程序的强大工具。它们允许客户端和服务器之间的双向通信，而无需不断轮询。WebSockets 的一个常见用例是聊天应用程序。

在本教程中，我们将使用 Deno 和内置的
[WebSockets API](/api/web/websockets) 创建一个简单的聊天应用程序。该聊天应用程序将允许多个聊天客户端连接到同一后端并发送群组消息。在客户端输入用户名后，他们可以开始向其他在线客户端发送消息。每个客户端还会显示当前活跃用户的列表。

您可以在
[GitHub 上查看完成的聊天应用程序](https://github.com/denoland/tutorial-with-websockets)。

![聊天应用程序 UI](./images/websockets.gif)

## 初始化新项目

首先，为您的项目创建一个新目录并导航到该目录。

```sh
deno init chat-app
cd deno-chat-app
```

## 构建后端

我们将首先构建处理 WebSocket 连接并向所有连接的客户端广播消息的后端服务器。我们将使用 [`oak`](https://jsr.io/@oak/oak) 中间件框架来设置我们的服务器，客户端可以连接到服务器，发送消息并接收有关其他连接用户的更新。此外，服务器将提供构成聊天客户端的静态 HTML、CSS 和 JavaScript 文件。

### 导入依赖项

首先，我们需要导入必要的依赖项。使用 `deno add` 命令将 Oak 添加到您的项目中：

```sh
deno add jsr:@oak/oak
```

### 设置服务器

在您的 `main.ts` 文件中，添加以下代码：

```ts title="main.ts"
import { Application, Context, Router } from "@oak/oak";
import ChatServer from "./ChatServer.ts";

const app = new Application();
const port = 8080;
const router = new Router();
const server = new ChatServer();

router.get("/start_web_socket", (ctx: Context) => server.handleConnection(ctx));

app.use(router.routes());
app.use(router.allowedMethods());
app.use(async (context) => {
  await context.send({
    root: Deno.cwd(),
    index: "public/index.html",
  });
});

console.log("Listening at http://localhost:" + port);
await app.listen({ port });
```

接下来，在与 `main.ts` 文件相同的目录中创建一个名为 `ChatServer.ts` 的新文件。在此文件中，我们将放置处理 WebSocket 连接的逻辑：

```ts title="ChatServer.ts"
import { Context } from "@oak/oak";

type WebSocketWithUsername = WebSocket & { username: string };
type AppEvent = { event: string; [key: string]: any };

export default class ChatServer {
  private connectedClients = new Map<string, WebSocketWithUsername>();

  public async handleConnection(ctx: Context) {
    const socket = await ctx.upgrade() as WebSocketWithUsername;
    const username = ctx.request.url.searchParams.get("username");

    if (this.connectedClients.has(username)) {
      socket.close(1008, `用户名 ${username} 已被占用`);
      return;
    }

    socket.username = username;
    socket.onopen = this.broadcastUsernames.bind(this);
    socket.onclose = () => {
      this.clientDisconnected(socket.username);
    };
    socket.onmessage = (m) => {
      this.send(socket.username, m);
    };
    this.connectedClients.set(username, socket);

    console.log(`新客户端连接：${username}`);
  }

  private send(username: string, message: any) {
    const data = JSON.parse(message.data);
    if (data.event !== "send-message") {
      return;
    }

    this.broadcast({
      event: "send-message",
      username: username,
      message: data.message,
    });
  }

  private clientDisconnected(username: string) {
    this.connectedClients.delete(username);
    this.broadcastUsernames();

    console.log(`客户端 ${username} 已断开连接`);
  }

  private broadcastUsernames() {
    const usernames = [...this.connectedClients.keys()];
    this.broadcast({ event: "update-users", usernames });

    console.log("发送用户名列表:", JSON.stringify(usernames));
  }

  private broadcast(message: AppEvent) {
    const messageString = JSON.stringify(message);
    for (const client of this.connectedClients.values()) {
      client.send(messageString);
    }
  }
}
```

这段代码设置了一个 `handleConnection` 方法，当建立新的 WebSocket 连接时会被调用。它从 Oak 框架接收一个 Context 对象，并将其升级为 WebSocket 连接。它从 URL 查询参数中提取用户名。如果用户名已经被占用（即存在于 connectedClients 中），它就用适当的消息关闭这个 socket。否则，它在 socket 上设置 username 属性，分配事件处理程序，并将 socket 添加到 `connectedClients`。

当 socket 打开时，它会触发 `broadcastUsernames` 方法，将连接的用户名列表发送给所有客户端。当 socket 关闭时，它会调用 `clientDisconnected` 方法，从连接的客户端列表中删除该客户端。

当收到类型为 `send-message` 的消息时，它将该消息广播给所有连接的客户端，包括发送者的用户名。

## 构建前端

我们将构建一个简单的用户界面，显示文本输入框和发送按钮，并显示发送的消息，以及聊天中的用户列表。

### HTML

在您的新项目目录中，创建一个 `public` 文件夹并添加一个 `index.html` 文件，并添加以下代码：

```html title="index.html"
<!DOCTYPE html>
<html>
  <head>
    <title>Deno 聊天应用程序</title>
    <link rel="stylesheet" href="/public/style.css" />
    <script defer type="module" src="/public/app.js"></script>
  </head>

  <body>
    <header>
      <h1>🦕 Deno 聊天应用程序</h1>
    </header>
    <aside>
      <h2>在线用户</h2>
      <ul id="users"></ul>
    </aside>
    <main id="content">
      <div id="conversation"></div>
      <form id="form">
        <input
          type="text"
          id="data"
          placeholder="发送消息"
          autocomplete="off"
        />
        <button type="submit" id="send">发送 ᯓ✉︎</button>
      </form>
    </main>
    <template id="user">
      <li></li>
    </template>
    <template id="message">
      <div>
        <span></span>
        <p></p>
      </div>
    </template>
  </body>
</html>
```

### CSS

如果您想要为聊天应用程序添加样式，请在 `public` 文件夹中创建一个 `style.css` 文件，并添加此
[预制的 CSS](https://raw.githubusercontent.com/denoland/tutorial-with-websockets/refs/heads/main/public/style.css)。

### JavaScript

我们将在 `app.js` 文件中设置客户端 JavaScript，您在刚刚编写的 HTML 文件中已经看到它的链接。在 `public` 文件夹中添加一个 `app.js` 文件，包含以下代码：

```js title="app.js"
const myUsername = prompt("请输入您的名字") || "匿名";
const url = new URL(`./start_web_socket?username=${myUsername}`, location.href);
url.protocol = url.protocol.replace("http", "ws");
const socket = new WebSocket(url);

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);

  switch (data.event) {
    case "update-users":
      updateUserList(data.usernames);
      break;

    case "send-message":
      addMessage(data.username, data.message);
      break;
  }
};

function updateUserList(usernames) {
  const userList = document.getElementById("users");
  userList.replaceChildren();

  for (const username of usernames) {
    const listItem = document.createElement("li");
    listItem.textContent = username;
    userList.appendChild(listItem);
  }
}

function addMessage(username, message) {
  const template = document.getElementById("message");
  const clone = template.content.cloneNode(true);

  clone.querySelector("span").textContent = username;
  clone.querySelector("p").textContent = message;
  document.getElementById("conversation").prepend(clone);
}

const inputElement = document.getElementById("data");
inputElement.focus();

const form = document.getElementById("form");

form.onsubmit = (e) => {
  e.preventDefault();
  const message = inputElement.value;
  inputElement.value = "";
  socket.send(JSON.stringify({ event: "send-message", message }));
};
```

这段代码提示用户输入用户名，然后使用该用户名作为查询参数创建与服务器的 WebSocket 连接。它监听来自服务器的消息，并根据需要更新连接用户列表或向聊天窗口添加新消息。当用户通过按下回车或点击发送按钮提交表单时，它还会将消息发送到服务器。我们使用
[HTML 模板](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) 来构建将在聊天窗口中显示的新消息。

## 运行服务器

要运行服务器，我们需要为 Deno 授予必要的权限。在您的 `deno.json` 文件中，更新 `dev` 任务以允许读取和网络访问：

```diff title="deno.json"
-"dev": "deno run --watch main.ts"
+"dev": "deno run --allow-net --allow-read --watch main.ts"
```

现在，如果您访问 [http://localhost:8080](http://localhost:8080/)，您将能够开始聊天会话。您可以同时打开 2 个标签页，尝试与自己聊天。

![聊天应用程序 UI](./images/websockets.gif)

🦕 现在您可以使用 Deno 的 WebSockets，您准备好构建各种实时应用程序了！WebSockets 可用于构建实时仪表板、游戏和协作编辑工具等等！如果您想扩展聊天应用程序，可以考虑向消息中添加数据，以便在消息是由您发送还是其他人发送时能够以不同的样式显示。无论您在构建什么，Deno 都将 WebSocket 传递给您！

---

# 从 CommonJS 更新到 ESM

> Step-by-step guide to migrating Node.js projects from CommonJS to ESM modules. Learn about import/export syntax changes, module resolution differences, and how to use modern JavaScript features in Deno.

URL: https://docs.deno.com/examples/tutorials/cjs_to_esm


如果您的 Node.js 项目使用 CommonJS 模块（例如，它使用 `require`），您将需要更新代码以使用
[ECMAScript 模块（ESM）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
以便在 Deno 中运行。本指南将帮助您更新代码以使用 ESM 语法。

## 模块导入和导出

Deno 独占支持 [ECMAScript 模块](/runtime/fundamentals/modules/)。
如果您的 Node.js 代码使用
[`require`](https://nodejs.org/api/modules.html#modules-commonjs-modules)，
您应该将其更新为使用 `import` 语句。如果您的内部代码使用 CommonJS 风格的导出，则也需要更新这些。

一个典型的 CommonJS 风格项目可能看起来像这样：

```js title="add_numbers.js"
module.exports = function addNumbers(num1, num2) {
  return num1 + num2;
};
```

```js title="index.js"
const addNumbers = require("./add_numbers");
console.log(addNumbers(2, 2));
```

要将它们转换为 [ECMAScript 模块](/runtime/fundamentals/modules/)，我们将进行一些小改动：

```js title="add_numbers.js"
export function addNumbers(num1, num2) {
  return num1 + num2;
}
```

```js title="index.js"
import { addNumbers } from "./add_numbers.js";
console.log(addNumbers(2, 2));
```

导出：

| CommonJS                             | ECMAScript 模块                  |
| ------------------------------------ | -------------------------------- |
| `module.exports = function add() {}` | `export default function add() {}` |
| `exports.add = function add() {}`    | `export function add() {}`         |

导入：

| CommonJS                                   | ECMAScript 模块                       |
| ------------------------------------------ | -------------------------------------- |
| `const add = require("./add_numbers");`    | `import add from "./add_numbers.js";`  |
| `const { add } = require("./add_numbers")` | `import { add } from "./add_numbers.js"` |

### 使用 VS Code 的快速修复

如果您使用 VS Code，可以利用其内置功能将 CommonJS 转换为 ES6 模块。右键单击 `require` 语句或灯泡图标，选择 `快速修复`，然后选择 `转换为 ES 模块`。

![快速修复](./images/quick-fix.png)

### CommonJS 与 ECMAScript 解析

这两种模块系统之间的重要区别是 ECMAScript 解析要求完整的标识符 **包括文件扩展名**。
省略文件扩展名和特殊处理 `index.js` 是 CommonJS 独有的特性。
ECMAScript 解析的好处在于，它在浏览器、Deno 和其他运行时中具有一致性。

| CommonJS             | ECMAScript 模块            |
| -------------------- | --------------------------- |
| `"./add_numbers"`    | `"./add_numbers.js"`        |
| `"./some/directory"` | `"./some/directory/index.js"` |

:::tip

Deno 可以通过运行 `deno lint --fix` 为您添加所有缺失的文件扩展名。
Deno 的 linter 具有 `no-sloppy-imports` 规则，当导入路径不包含文件扩展名时，将显示 linting 错误。

:::

🦕 现在您知道如何将 CJS 移植到 ESM，您可以利用 ESM 提供的现代功能，例如异步模块加载、与浏览器的互操作性、可读性更好、标准化和未来兼容性。

---

# 将 Deno 部署到 Cloudflare Workers

> Step-by-step tutorial on deploying Deno functions to Cloudflare Workers. Learn how to configure denoflare, create worker modules, test locally, and deploy your code to Cloudflare's global edge network.

URL: https://docs.deno.com/examples/tutorials/cloudflare_workers


Cloudflare Workers 允许您在 Cloudflare 的边缘网络上运行 JavaScript。

这是一个关于将 Deno 函数部署到 Cloudflare Workers 的简短指南。

注意：您只能部署
[模块 Worker](https://developers.cloudflare.com/workers/learning/migrating-to-module-workers/)
而不是网页服务器或应用程序。

## 设置 `denoflare`

为了将 Deno 部署到 Cloudflare，我们将使用这个社区创建的 CLI
[`denoflare`](https://denoflare.dev/)。

[安装它](https://denoflare.dev/cli/#installation):

```shell
deno install --unstable-worker-options --allow-read --allow-net --allow-env --allow-run --name denoflare --force \
https://raw.githubusercontent.com/skymethod/denoflare/v0.6.0/cli/cli.ts
```

## 创建您的函数

在一个新目录中，创建一个 `main.ts` 文件，里面将包含我们的模块 Worker 函数：

```ts
export default {
  fetch(request: Request): Response {
    return new Response("Hello, world!");
  },
};
```

最基本的模块 Worker 函数必须 `export default` 一个对象，该对象暴露一个 `fetch` 函数，返回一个 `Response` 对象。

您可以通过运行以下命令在本地测试它：

```shell
denoflare serve main.ts
```

如果您在浏览器中访问 `localhost:8080`，您将看到响应内容为：

```console
Hello, world!
```

## 配置 `.denoflare`

下一步是创建一个 `.denoflare` 配置文件。在其中，添加以下内容：

```json
{
  "$schema": "https://raw.githubusercontent.com/skymethod/denoflare/v0.5.11/common/config.schema.json",
  "scripts": {
    "main": {
      "path": "/absolute/path/to/main.ts",
      "localPort": 8000
    }
  },
  "profiles": {
    "myprofile": {
      "accountId": "abcxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      "apiToken": "abcxxxxxxxxx_-yyyyyyyyyyyy-11-dddddddd"
    }
  }
}
```

您可以通过访问您的
[Cloudflare 仪表板](https://dash.cloudflare.com/)，点击 "Workers"，并找到右侧的 "帐户 ID" 来查找您的 `accountId`。

您可以从您的
[Cloudflare API Token 设置](https://dash.cloudflare.com/profile/api-tokens)生成一个 `apiToken`。
创建 API 令牌时，请确保使用 "编辑 Cloudflare Workers" 模板。

在您将两者添加到 `.denoflare` 配置后，让我们尝试将其推送到 Cloudflare：

```console
denoflare push main
```

接下来，您可以在您的 Cloudflare 账户中查看您的新函数：

![Cloudflare Workers 上的新函数](./images/how-to/cloudflare-workers/main-on-cloudflare.png)

太好了！

---

# 连接到数据库

> Deno 中数据库连接的指南。学习如何使用 MySQL、PostgreSQL、MongoDB、SQLite、Firebase、Supabase 以及流行的 ORM 来构建基于 TypeScript 的数据驱动应用。

URL: https://docs.deno.com/examples/tutorials/connecting_to_databases


应用程序通常会从数据库中存储和检索数据。Deno
支持连接到多种数据库管理系统。

Deno 支持多种第三方模块，让你可以连接到 SQL 和
NoSQL 数据库，包括 MySQL、PostgreSQL、MongoDB、SQLite、Firebase 和
Supabase。

你可以在 [JSR](https://jsr.io/@db) 上找到实用的数据库连接模块，
并且 Deno 通过使用
[npm 标识符](/runtime/fundamentals/node/#using-npm-packages) 支持许多 npm 包。

## SQLite

SQLite 是一个自包含、无服务器、零配置且支持事务的
SQL 数据库引擎。它是应用程序本地存储的热门选择。

你可以使用多个模块在 Deno 中连接 SQLite，包括
内置的 [`node:sqlite` 模块](/api/node_sqlite/) 和
JSR 上的 [sqlite](https://jsr.io/@db/sqlite) 模块。

要在你的 Deno 应用中使用 [sqlite](https://jsr.io/@db/sqlite) 模块连接 SQLite：

```sh
deno add jsr:@db/sqlite
```

然后，从模块导入 `Database` 类并创建一个新的数据库实例。你就可以对数据库执行 SQL 查询：

```ts title="main.ts"
import { Database } from "@db/sqlite";

const db = new Database("test.db");

const [version] = db.prepare("select sqlite_version()").value<[string]>()!;
console.log(version);

db.close();
```

此模块依赖于 Deno FFI，因此你需要带上
`--allow-ffi` 标志运行你的脚本：

```sh
deno run --allow-ffi main.ts
```

## MySQL

你可以使用 [mysql npm 模块](https://www.npmjs.com/package/mysql) 连接到 MySQL 数据库。用 npm 标识符安装模块：

```sh
deno add npm:mysql
```

然后，导入 `mysql` 模块并创建与你的 MySQL 数据库的连接：

```ts
import mysql from "mysql";

// 最简连接配置（根据需要编辑或使用环境变量）
const connection = mysql.createConnection({
  host: Deno.env.get("MYSQL_HOST") || "localhost",
  port: Number(Deno.env.get("MYSQL_PORT") || "3306"),
  user: Deno.env.get("MYSQL_USER") || "root",
  password: Deno.env.get("MYSQL_PASSWORD") || "",
  database: Deno.env.get("MYSQL_DATABASE") || "test",
});

connection.connect((err) => {
  if (err) {
    console.error("连接错误:", err);
    return;
  }
  console.log("已连接！");
  connection.query("SELECT VERSION() AS version", (err, results) => {
    if (err) {
      console.error("查询错误:", err);
    } else {
      console.log("MySQL 版本:", results[0].version);
    }
    connection.end();
  });
});
```

## Postgres

PostgreSQL 是一个强大且开源的对象关系型数据库系统。你可以使用多个模块在 Deno 中连接 PostgreSQL，包括
[pg](https://www.npmjs.com/package/pg) 或
[postgresjs](https://www.npmjs.com/package/postgres)。

用 npm 标识符安装模块：

```sh
deno add npm:pg
```

首先，从 `pg` 模块导入 `Client` 类并创建一个新的客户端实例。然后通过传递连接详情的对象连接数据库：

```ts
import { Client } from "pg";

// 连接配置（编辑或使用环境变量）
const client = new Client({
  host: Deno.env.get("PGHOST") || "localhost",
  port: Number(Deno.env.get("PGPORT") || "5432"),
  user: Deno.env.get("PGUSER") || "postgres",
  password: Deno.env.get("PGPASSWORD") || "postgres",
  database: Deno.env.get("PGDATABASE") || "postgres",
});

async function main() {
  try {
    await client.connect();
    console.log("已连接！");
    const res = await client.query("SELECT version() AS version");
    console.log("Postgres 版本:", res.rows[0].version);
  } catch (err) {
    console.error("连接/查询错误:", err);
  } finally {
    await client.end();
  }
}

main();
```

## MongoDB

MongoDB 是一个流行的 NoSQL 数据库，以灵活的 JSON 类文档格式存储数据。你可以使用官方的
[MongoDB Node.js](https://www.npmjs.com/package/mongodb) 驱动连接 MongoDB，
或者使用来自 JSR 的 [Mongo db driver](https://jsr.io/@db/mongo)。

导入 MongoDB 驱动，设置连接配置，然后连接 MongoDB 实例：

```ts title="main.js"
import { MongoClient } from "mongodb";

const url = "mongodb://mongo:mongo@localhost:27017"; // 用户名:密码@主机:端口
const client = new MongoClient(url);
const dbName = "myProject";

await client.connect();
console.log("成功连接到服务器");

const db = client.db(dbName);
const collection = db.collection("documents");

const insertResult = await collection.insertMany([{ a: 1 }, { a: 2 }]);
console.log("插入的文档 =>", insertResult);

await client.close();
```

## Firebase

Firebase 是由 Google 开发的移动和网页应用平台。它提供多种服务，包括 NoSQL 数据库、认证和托管。

连接 Firebase，你可以使用 Firebase 提供的官方 npm 模块，需要更新你的 `deno.json` 告诉 Deno 使用 `node_modules` 目录，并在安装时允许脚本执行：

```json title="deno.json"
"nodeModulesDir": auto
```

```sh
deno add npm:firebase --allow-scripts
```

然后从 Firebase 模块导入所需函数，初始化你的应用和服务：

```js
import { initializeApp } from "firebase/app";
import { doc, getDoc, getFirestore, setDoc } from "firebase/firestore";

// 替换为你的 Firebase 配置（从 Firebase 控制台获取）
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_PROJECT_ID.appspot.com",
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
  appId: "YOUR_APP_ID",
};

// 初始化 Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// 示例：写入和读取文档
async function demo() {
  const ref = doc(db, "demo", "testdoc");
  await setDoc(ref, { hello: "world", time: Date.now() });
  const snap = await getDoc(ref);
  console.log("文档数据:", snap.data());
}

demo().catch(console.error);
```

## Supabase

Supabase 是一个开源的 Firebase 替代品，提供一套帮助你构建和扩展应用的工具和服务。它提供托管的 PostgreSQL 数据库、认证、实时订阅和存储。

连接 Supabase，你可以使用
[@supabase/supabase-js](https://www.npmjs.com/package/@supabase/supabase-js) npm 模块。

首先，用 npm 标识符安装模块：

```sh
deno add npm:@supabase/supabase-js --allow-scripts
```

然后，从模块导入 `createClient` 函数并创建一个新的 Supabase 客户端实例。你需要你的 Supabase 项目 URL 和 API 密钥，详见项目设置：

```ts
import { createClient } from "@supabase/supabase-js";

const url = Deno.env.get("SUPABASE_URL") ??
  "https://YOUR-PROJECT.ref.supabase.co";
const key = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

const supabase = createClient(url, key);

async function main() {
  const { data, error } = await supabase
    .from("demo")
    .insert({ message: `Hello @ ${new Date().toISOString()}` })
    .select()
    .maybeSingle();

  if (error) {
    console.error("插入失败:", error.message);
    console.error(
      "提示：如果这是 RLS 错误，要么禁用 'demo' 上的 RLS，要么添加允许匿名插入的策略。",
    );
    return;
  }

  console.log("插入的行:", data);
}

if (import.meta.main) main();
```

## ORM

对象关系映射 (ORM) 将你的数据模型定义为类，你可以将其实例持久化到数据库。你可以通过这些类的实例读取和写入数据库的数据。

Deno 支持多种 ORM，包括 Prisma、Drizzle 和 Kysely。

🦕 现在您可以将您的 Deno 项目连接到数据库，您将能够处理持久数据，执行 CRUD 操作并开始构建更复杂的应用程序。

---

# Better debugging with the console API

> An in-depth guide to advanced console debugging in Deno. Learn about console.table, timers, counters, tracers, and how to leverage the full console API beyond basic logging for better debugging workflows.

URL: https://docs.deno.com/examples/tutorials/debugging_with_console


Some of the console API is probably muscle memory for web developers, but there
is so much more than just `console.log()` for you to use. Deno has great support
for this API, so whether you’re writing JavaScript for the browser of for the
server it’s worth learning about these helpful utilities.

Let’s take a look at some of this API’s most useful methods. Your debugging is
going to get so much easier!

## `console.log()`

Hello, old friend! You’ll most likely be using this to output logging messages
to the console to help you debug.

```js
console.log("Hello, world!"); // "Hello, world!"
```

You can output multiple items by separated by commas like so:

```jsx
const person = { "name": "Jane", "city": "New York" };
console.log("Hello, ", person.name, "from ", person.city); // "Hello, Jane from New York"
```

Or you can use string literals:

```jsx
const person = { "name": "Jane", "city": "New York" };
console.log(`Hello ${person.name} from ${person.city}`); // "Hello, Jane from New York"
```

You can also [apply some styling using CSS](/examples/color_logging/) using the
`%c` directive:

```jsx
console.log("Wild %cblue", "color: blue", "yonder"); // Applies a blue text color to the word "blue"
```

…but there is much more you can do with the console API.

## `console.table()`

The `table` method is helpful for outputting structured data like objects for
easier inspection.

```jsx
const people = {
  "john": {
    "age": 30,
    "city": "New York",
  },
  "jane": {
    "age": 25,
    "city": "Los Angeles",
  },
};

console.table(people);

/*
┌───────┬─────┬───────────────┐
│ (idx) │ age │ city          │
├───────┼─────┼───────────────┤
│ john  │ 30  │ "New York"    │
│ jane  │ 25  │ "Los Angeles" │
└───────┴─────┴───────────────┘
*/
```

You can also specify the properties of your object that you’d like to include in
the table. Great for inspecting a summary of those detailed objects to see just
the part you are concerned with.

```jsx
console.table(people, ["city"]);

/* outputs
┌───────┬───────────────┐
│ (idx) │ city          │
├───────┼───────────────┤
│ john  │ "New York"    │
│ jane  │ "Los Angeles" │
└───────┴───────────────┘
*/
```

## Timer methods

Understanding how long specific parts of your application take is key to
removing performance bottlenecks and expensive operations. If you’ve ever
reached for JavaScript’s date method to make yourself a timer, you’ll wish you’d
know this one long ago. It’s more convenient and more accurate.

Try
using[`console.time()`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static),
[`console.timeLog()`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeLog_static),
and
[`console.timeEnd()`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeEnd_static)
instead.

```jsx
console.time("My timer"); // starts a timer with label "My timer"
// do some work...
console.timeLog("My timer"); // outputs the current timer value, e.g. "My timer: 9000ms"
// do more work...
console.timeEnd("My timer"); // stops "My timer" and reports its value, e.g. "My timer: 97338ms"
```

You can create multiple timers each with their own label. Very handy!

## Counting things with `console.count()`

It can be helpful to keep a count of how many times specific operations in your
code have been executed. Rather than doing this manually you can use
[`console.count()`](https://developer.mozilla.org/en-US/docs/Web/API/console/count_static)
which can maintain multiple counters for you based on the label you provide.

```jsx
// increment the default counter
console.count();
console.count();
console.count();

/*
"default: 1"
"default: 2"
"default: 3"
*/
```

This can be very handy inside a function and passing in a label, like so:

```jsx
function pat(animal) {
  console.count(animal);
  return `Patting the ${animal}`;
}

pat("cat");
pat("cat");
pat("dog");
pat("cat");

/*
"cat: 1"
"cat: 2"
"dog: 1"
"cat: 3"
*/
```

## Going deeper with `console.trace()`

For a detailed view of what is happening in your application, you can output a
stack trace to the console with
[`console.trace()`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace_static):

```jsx
// main.js
function foo() {
  function bar() {
    console.trace();
  }
  bar();
}

foo();

/*
Trace
    at bar (file:///PATH_TO/main.js:3:13)
    at foo (file:///PATH_TO/main.js:5:3)
    at file:///PATH_TO/main.js:8:1
*/
```

There’s more to explore, but these handy methods can give your JavaScript
debugging a boost and they are ready and waiting for you to use right in your
browser or in your Deno application.

Take a look at [console support](/api/web/~/Console) in the API Reference docs.
for more.


---

# 使用 Deno Deploy 部署应用

> 一步步指导你将第一个 Deno 应用部署到 Deno Deploy 早期访问。

URL: https://docs.deno.com/examples/tutorials/deno_deploy


Deno Deploy 允许你在全球边缘网络上托管 Deno 应用，内置遥测和 CI/CD 工具。

本教程将指导你使用 Deno Deploy<sup>EA</sup> 创建并部署一个简单的 Deno 应用。

## 先决条件

1. 一个 [GitHub](https://github.com) 账号
2. 在本地机器上 [安装 Deno](https://docs.deno.com/runtime/manual/getting_started/installation)
3. 访问
   [Deno Deploy 早期访问计划](https://dash.deno.com/account#early-access)

## 用 Vite 创建一个简单的 Deno 应用

首先，使用 Vite 创建一个基本应用，初始化一个新的
[Vite](https://vite.dev/guide/) 项目：

```sh
deno init --npm vite
```

为你的项目命名，选择框架和变体。本教程中，我们将创建一个原生 TypeScript 应用。

使用 `cd my-project-name` 进入新建的项目目录，然后运行：

```sh
deno install
deno run dev
```

你应该能在 [http://127.0.0.1:5173/](http://127.0.0.1:5173/) 看到一个基本运行的应用。

编辑 `main.ts` 文件即可在浏览器中查看修改效果。

## 创建 GitHub 仓库

1. 访问 [GitHub](https://github.com) 并新建一个仓库。

2. 将本地目录初始化为 Git 仓库：

```sh
git init
git add .
git commit -m "Initial commit"
```

3. 添加 GitHub 仓库为远程仓库并推送代码：

```sh
git remote add origin https://github.com/your-username/my-first-deno-app.git
git branch -M main
git push -u origin main
```

## 注册 Deno Deploy 早期访问

1. 访问
   [Deno Deploy 账户设置](https://dash.deno.com/account#early-access)
2. 点击“加入早期访问计划”
3. 审核通过后，你将收到含有访问说明的邮件

![早期访问加入截图](./images/join.png)

## 创建 Deno Deploy 组织

1. 访问 [console.deno.com](https://console.deno.com)
2. 点击“+ 新建组织”
3. 选择“标准部署”组织类型
4. 输入组织名称和标识（slug，后续不可更改）
5. 点击“创建标准部署组织”

## 创建并部署应用

1. 从组织仪表盘点击“尝试新 Deno Deploy 早期访问”
2. 点击“+ 新建应用”
3. 选择你之前创建的 GitHub 仓库
4. 应用配置会自动检测，你可以点击“编辑构建配置”按钮确认：
   - 框架预设：无预设
   - 运行时配置：静态站点
   - 安装命令：`deno install`
   - 构建命令：`deno task build`
   - 静态目录：`dist`

5. 点击“创建应用”开始部署流程

## 监控你的部署

1. 查看构建日志，了解应用部署进度
2. 部署完成后，你将看到预览链接（通常为
   `https://your-app-name.your-org-name.deno.net`）
3. 点击链接浏览已部署的应用！

## 修改并重新部署

现在我们更新应用，并查看变动如何部署：

本地修改你的 `main.ts` 文件：

```ts title="main.ts"
import './style.css'
import typescriptLogo from './typescript.svg'
import viteLogo from '/vite.svg'
import { setupCounter } from './counter.ts'

document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div>
    <a href="https://vite.dev" target="_blank">
      <img src="${viteLogo}" class="logo" alt="Vite logo" />
    </a>
    <a href="https://www.typescriptlang.org/" target="_blank">
      <img src="${typescriptLogo}" class="logo vanilla" alt="TypeScript logo" />
    </a>
    <h1>Hello from Deno Deploy!</h1>
    <div class="card">
      <button id="counter" type="button"></button>
    </div>
    <p class="read-the-docs">
      点击 Vite 和 TypeScript 标志了解更多
    </p>
  </div>

setupCounter(document.querySelector<HTMLButtonElement>('#counter')!)
```

2. 提交并推送更改：

```sh
git add .
git commit -m "Update application"
git push
```

返回 Deno Deploy 仪表盘，你将看到自动触发的新构建。构建完成后访问应用链接查看更新。

## 探索可观测性功能

Deno Deploy<sup>EA</sup> 提供完整的可观测性工具：

1. 在应用仪表盘点击侧边栏的“日志”
   - 查看应用输出的控制台日志
   - 通过搜索栏过滤日志（例如 `context:production`）

2. 点击“追踪”查看请求追踪
   - 选择某个追踪查看详细时间信息
   - 审查跨度以理解请求处理流程

3. 点击“指标”查看应用性能指标
   - 监控请求次数、错误率和响应时间

🦕 既然你已经部署了第一个应用，接下来你可能会想：

1. 为应用添加 [自定义域名](/deploy/early-access/reference/domains/)
2. 探索对 Next.js、Astro 等框架的 [支持](/deploy/early-access/reference/frameworks/)
3. 学习如何使用 [缓存策略](/deploy/early-access/reference/caching/) 提升性能
4. 为开发和生产环境设置不同的
   [环境变量和上下文](/deploy/early-access/reference/env-vars-and-contexts/)


---

# 使用 deno doc 生成文档

> 学习如何使用内置的 deno doc 命令为您的 Deno 项目生成专业文档。本教程涵盖 JSDoc 注释、HTML 输出、代码规范检查以及编写文档的最佳实践。

URL: https://docs.deno.com/examples/tutorials/deno_doc


良好的文档对任何软件项目都至关重要。它帮助其他开发者理解您的代码，简化维护，提高项目的整体质量。Deno 内置了一个名为 `deno doc` 的文档生成器，可以从您的 TypeScript 和 JavaScript 代码自动生成可搜索的文档。

`deno doc` 开箱即用，无需任何配置，可生成 HTML、JSON 或终端输出。它利用 JSDoc 注释进行文档编写，同时会自动提取代码中 TypeScript 类型注解的信息。

:::info 使用 JSR 自动生成文档

如果您将包发布到
[JSR（JavaScript 注册中心）](https://jsr.io)，则可以免费自动获得美观的文档生成！JSR 在底层使用相同的 `deno doc` 技术，为所有发布的包创建可搜索的网页文档。只需通过 `deno publish` 发布带有完善文档的代码，JSR 将为您完成剩余工作。

:::

## 创建示例项目

让我们创建一个示例库来演示 `deno doc` 的功能。我们将构建一个带有良好文档的简单数学工具库。

````ts title="math.ts"
/**
 * 一组数学工具函数集合。
 * @module
 */

/**
 * 将两个数字相加。
 *
 * @example
 * ```ts
 * import { add } from "./math.ts";
 *
 * const result = add(5, 3);
 * console.log(result); // 8
 * ```
 *
 * @param x 第一个数字
 * @param y 第二个数字
 * @returns x 和 y 之和
 */
export function add(x: number, y: number): number {
  return x + y;
}

/**
 * 将两个数字相乘。
 *
 * @example
 * ```ts
 * import { multiply } from "./math.ts";
 *
 * const result = multiply(4, 3);
 * console.log(result); // 12
 * ```
 *
 * @param x 第一个数字
 * @param y 第二个数字
 * @returns x 和 y 的乘积
 */
export function multiply(x: number, y: number): number {
  return x * y;
}

/**
 * 表示二维空间中的一个点。
 *
 * @example
 * ```ts
 * import { Point } from "./math.ts";
 *
 * const point = new Point(5, 10);
 * console.log(point.distance()); // 11.180339887498949
 * ```
 */
export class Point {
  /**
   * 创建一个新的 Point 实例。
   *
   * @param x x 坐标
   * @param y y 坐标
   */
  constructor(public x: number, public y: number) {}

  /**
   * 计算该点到原点 (0, 0) 的距离。
   *
   * @returns 到原点的距离
   */
  distance(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  /**
   * 计算该点到另一个点的距离。
   *
   * @param other 另一个点
   * @returns 两点之间的距离
   */
  distanceTo(other: Point): number {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}

/**
 * 数学操作的配置选项。
 */
export interface MathConfig {
  /** 浮点计算的精度 */
  precision?: number;
  /** 是否将结果四舍五入为整数 */
  roundToInt?: boolean;
}

/**
 * 在配置下执行高级数学运算。
 *
 * @example
 * ```ts
 * import { calculate } from "./math.ts";
 *
 * const result = calculate(10, 3, { precision: 2, roundToInt: false });
 * console.log(result); // 3.33
 * ```
 */
export function calculate(
  dividend: number,
  divisor: number,
  config: MathConfig = {},
): number {
  const { precision = 10, roundToInt = false } = config;

  let result = dividend / divisor;

  if (roundToInt) {
    result = Math.round(result);
  } else {
    result = Math.round(result * Math.pow(10, precision)) /
      Math.pow(10, precision);
  }

  return result;
}
````

## 基础文档生成

生成文档最简单的方式是对源文件运行 `deno doc`：

```bash
deno doc math.ts
```

这会在您的终端输出文档，显示所有导出的函数、类和接口及其 JSDoc 注释。

## 生成 HTML 格式文档

若要创建包含 HTML、CSS 和 JS 的文档网站，使用 `--html` 标志：

```bash
deno doc --html --name="数学工具" math.ts
```

这将在 `./docs/` 目录生成静态网站。该站点包括：

- 可搜索的界面
- 语法高亮
- 符号间的交叉引用
- 移动端友好的响应式设计

您还可以指定自定义输出目录：

```bash
deno doc --html --name="数学工具" --output=./documentation/ math.ts
```

## 文档规范检查

使用 `--lint` 标志检查文档问题：

```bash
deno doc --lint math.ts
```

它会报告多种问题：

1. 导出函数、类或接口缺少 JSDoc 注释
2. 函数缺少返回类型注释
3. 导出符号引用了未导出的类型

我们创建一个带有一些文档问题的文件，来查看 linter 的表现：

```ts title="bad_example.ts"
// 缺少 JSDoc 注释
export function badFunction(x) {
  return x * 2;
}

interface InternalType {
  value: string;
}

// 引用了未导出的类型
export function anotherFunction(param: InternalType) {
  return param.value;
}
```

运行 `deno doc --lint bad_example.ts` 会显示这些问题的错误。

## 同时处理多个文件

您可以同时文档多个文件：

```bash
deno doc --html --name="我的库" ./mod.ts ./utils.ts ./types.ts
```

对于较大项目，创建一个重新导出所有内容的主模块文件：

````ts title="mod.ts"
/**
 * 数学工具库
 *
 * 一个完整的数学函数和工具集合。
 *
 * @example
 * ```ts
 * import { add, multiply, Point } from "./mod.ts";
 *
 * const sum = add(5, 3);
 * const product = multiply(4, 2);
 * const point = new Point(3, 4);
 * ```
 *
 * @module
 */

export * from "./math.ts";
````

然后从主模块生成文档：

```bash
deno doc --html --name="数学工具" mod.ts
```

## 用于自动化的 JSON 输出

生成 JSON 格式的文档以便与其他工具配合使用：

```bash
deno doc --json math.ts > documentation.json
```

JSON 输出提供了代码结构的底层表示，包括符号定义和基本类型信息。此格式主要用于构建自定义文档工具或集成需要程序化访问代码 API 的系统。

## JSDoc 注释的最佳实践

使用 `deno doc` 时，请遵循以下 JSDoc 最佳实践：

### 1. 使用描述性的摘要

```ts
/**
 * 使用递归计算一个数字的阶乘。
 *
 * @param n 要计算阶乘的数字
 * @returns n 的阶乘
 */
export function factorial(n: number): number {
  // 实现...
}
```

### 2. 提供具体示例

````ts
/**
 * 将数字格式化为货币形式。
 *
 * @example
 * ```ts
 * formatCurrency(123.456); // "$123.46"
 * formatCurrency(1000); // "$1,000.00"
 * ```
 *
 * @param amount 要格式化的金额
 * @returns 格式化后的货币字符串
 */
export function formatCurrency(amount: number): string {
  // 实现...
}
````

### 3. 注明参数和返回值

```ts
/**
 * 验证邮箱地址格式。
 *
 * @param email 要验证的邮箱地址
 * @returns 若格式有效返回 true，否则返回 false
 * @throws {Error} 当邮箱为 null 或 undefined 时抛出
 */
export function validateEmail(email: string): boolean {
  // 实现...
}
```

### 4. 使用模块级文档

```ts
/**
 * 邮箱验证工具。
 *
 * 本模块提供根据 RFC 5322 标准验证和格式化邮箱地址的函数。
 *
 * @module
 */
```

### 5. 标记废弃或实验性功能

```ts
/**
 * 兼容旧版的遗留函数。
 *
 * @deprecated 请使用 `newFunction()` 替代
 * @param data 输入数据
 */
export function oldFunction(data: string): void {
  // 实现...
}

/**
 * 新的实验性功能。
 *
 * @experimental 此 API 未来版本可能发生变更
 * @param options 配置选项
 */
export function experimentalFunction(options: unknown): void {
  // 实现...
}
```

## 集成至 CI/CD 流程

您可以将文档生成集成到持续集成管道中：

```yaml title=".github/workflows/docs.yml"
name: 生成文档

on:
  push:
    branches: [main]

jobs:
  docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: 设置 Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: 生成文档
        run: deno doc --html --name="我的库" --output=./docs/ mod.ts

      - name: 部署到 GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
```

## 在 deno.json 中配置

您可以在 `deno.json` 文件中配置文档生成：

```json title="deno.json"
{
  "tasks": {
    "doc": "deno doc --html --name='数学工具' --output=./docs/ mod.ts",
    "doc:lint": "deno doc --lint mod.ts",
    "doc:json": "deno doc --json mod.ts > documentation.json"
  }
}
```

然后轻松运行文档相关任务：

```bash
deno task doc
deno task doc:lint
deno task doc:json
```

🦕 `deno doc` 命令是一个强大的工具，用于从您的 Deno 项目生成专业文档。

良好的文档让您的代码更易维护，帮助其他开发者有效理解和使用您的项目。使用 `deno doc`，全面的文档仅需一条命令！

---

# 使用 deno deploy 命令部署应用

> 使用 deno deploy CLI 命令创建并部署第一个应用到 Deno Deploy 早期访问的分步教程。

URL: https://docs.deno.com/examples/tutorials/deploy_command


`deno deploy` 命令为在 [Deno Deploy<sup>EA</sup>](https://deno.com/deploy) 上部署和管理应用提供了强大的 CLI 工具。

如果你已经有应用准备部署，可以跳转到[部署你的应用](#deploy-your-application)，或者继续阅读制作并部署一个简单应用。

## 前提条件

在使用 deploy 命令之前，你需要获得 Deno Deploy<sup>EA</sup> 的访问权限，并且需要一个 Deno Deploy<sup>EA</sup> 组织。

1. 访问
   [Deno Deploy 账号设置](https://dash.deno.com/account#early-access)
2. 开启“启用早期访问”开关
3. 在
   [Deno Deploy<sup>EA</sup> 控制台](https://console.deno.com/) 中创建一个 Deno Deploy<sup>EA</sup> 组织。

## 创建一个简单的 Web 应用

首先，我们来创建一个基本的 HTTP 服务器作为我们的应用。

新建一个项目目录并进入：

```bash
mkdir my-deploy-app
cd my-deploy-app
```

初始化一个新的 Deno 项目：

```bash
deno init
```

将 `main.ts` 的内容替换为一个简单的 HTTP 服务器：

```ts title="main.ts"
Deno.serve({ port: 8000 }, (req) => {
  const url = new URL(req.url);
  const userAgent = req.headers.get("user-agent") || "unknown";
  const timestamp = new Date().toISOString();

  // 记录每个请求
  console.log(
    `[${timestamp}] ${req.method} ${url.pathname} - User-Agent: ${userAgent}`,
  );

  // 简单路由
  if (url.pathname === "/") {
    console.log("Serving home page");
    return new Response(
      `
      <html>
        <head><title>My Deploy App</title></head>
        <body>
          <h1>欢迎使用 My Deploy App！</h1>
          <p>此应用使用 deno deploy 命令部署。</p>
          <nav>
            <a href="/about">关于</a> | 
            <a href="/api/status">API 状态</a> |
            <a href="/api/error">测试错误</a>
          </nav>
        </body>
      </html>
    `,
      {
        headers: { "content-type": "text/html" },
      },
    );
  }

  if (url.pathname === "/about") {
    console.log("Serving about page");
    return new Response(
      `
      <html>
        <head><title>关于 - My Deploy App</title></head>
        <body>
          <h1>关于此应用</h1>
          <p>这是一个使用 deno deploy CLI 部署的简单示例。</p>
          <p>查看日志以了解请求信息！</p>
          <a href="/">← 返回主页</a>
        </body>
      </html>
    `,
      {
        headers: { "content-type": "text/html" },
      },
    );
  }

  if (url.pathname === "/api/status") {
    const responseData = {
      status: "ok",
      timestamp: new Date().toISOString(),
      message: "API 正常运行",
      requestCount: Math.floor(Math.random() * 1000) + 1, // 模拟请求计数器
    };

    console.log("API 状态检查 - 全系统正常");
    console.log(`响应数据:`, responseData);

    return Response.json(responseData);
  }

  if (url.pathname === "/api/error") {
    // 此端点用于演示错误日志
    console.error("访问错误端点 - 演示错误日志");
    console.warn("这是将出现在日志中的警告信息");

    return Response.json({
      error: "这是用于演示的测试错误",
      timestamp: new Date().toISOString(),
      tip: "查看日志命令：deno deploy logs",
    }, { status: 500 });
  }

  // 其它路由返回 404
  console.warn(`404 - 未找到路由: ${url.pathname}`);
  return new Response("未找到", { status: 404 });
});
```

### 在本地测试应用

更新根目录下 `deno.json` 文件中的 `dev` 任务，允许网络访问：

```json
"dev": "deno run -N --watch main.ts"
```

然后运行 dev 命令：

```sh
deno run dev
```

访问 `http://localhost:8000` 查看运行中的应用。尝试访问不同路由（`/about`、`/api/status` 和 `/api/error`）以确认功能正常。你会看到每个请求都会被日志记录——这些日志在应用部署后也可以看到！

## 认证

`deno deploy` 命令自动处理认证。首次运行部署命令时会提示你进行认证。运行带有 `--help` 参数的部署命令查看所有可用选项：

```bash
deno deploy --help
```

:::note Deno Deploy 组织要求

`deno deploy` 命令需要一个 Deno Deploy 组织。如果你的账号还未设置组织，可以通过
[Deno Deploy Web 应用](https://console.deno.com) 创建一个。

:::

## 部署你的应用

现在让我们用 `deno deploy` 命令来部署应用！确保你在项目根目录，执行：

```bash
deno deploy
```

根据终端提示选择合适的选项。

部署过程将：

1. 打包你的应用代码为 tarball
2. 上传 tarball 到 Deno Deploy
3. 解包 tarball
4. 构建并部署到边缘网络
5. 返回一个可访问的在线 URL

你已经成功部署了应用！可以访问返回的 URL 查看应用效果。

如果需要修改应用，只需更新代码，然后再次运行 `deno deploy` 命令。

我们演示的应用内置了一些日志，可以通过 Deno Deploy 的日志功能监控应用。

## 监控你的应用

### 查看应用日志

部署后，可以实时获取日志流，了解应用具体情况：

```bash
deno deploy logs
```

访问你的应用 URL，浏览不同页面。你会看到类似的日志：

- 显示 HTTP 方法、路径和用户代理的请求日志
- 来自 `console.log()` 的信息日志
- 来自 `console.warn()` 的警告日志
- 来自 `console.error()` 的错误日志

在浏览器打开应用 URL，尝试访问 `/api/error` 端点，体验错误日志效果。

### 查看指定时间范围的日志

想查看特定时间范围的日志，可以使用 `--start` 和 `--end` 参数：

```bash
deno deploy logs \
  --start "2024-01-01T00:00:00Z" \
  --end "2024-01-01T23:59:59Z"
```

## 管理环境变量

你的应用可能需要环境变量进行配置。`deno deploy` 命令提供了完善的环境变量管理功能。

### 列出环境变量

查看应用的所有环境变量：

```bash
deno deploy env list
```

### 添加与更新环境变量

添加单个环境变量，使用 `deno deploy env add` 命令，例如：

```bash
deno deploy env add API_KEY "your-secret-key"
deno deploy env add DATABASE_URL "postgresql://..."
```

更新环境变量，使用 `deno deploy env update-value` 命令，例如：

```bash
deno deploy env update-value API_KEY "new-secret-key"
deno deploy env update-value DATABASE_URL "postgresql://new-user:new-pass@localhost/new-db"
```

### 删除环境变量

删除环境变量，使用 `deno deploy env delete` 命令，例如：

```bash
deno deploy env delete API_KEY
deno deploy env delete DATABASE_URL
```

### 从 .env 文件加载环境变量

你也可以使用 `.env` 文件将环境变量加载到部署的应用中：

```bash
deno deploy env load .env
```

🦕 你已成功使用 `deno deploy` 命令部署了第一个应用！更多命令和选项，请查阅 [`deno deploy` 文档](/runtime/reference/cli/deploy/)。

欲了解更多 Deno Deploy<sup>EA</sup> 相关信息，请参考 [Deno Deploy 早期访问文档](/deploy/early-access/)。

---

# 使用 OpenTelemetry 和 Deno Deploy 监控您的应用

> 添加自定义 OpenTelemetry 仪表到您的 Deno Deploy 应用的逐步教程。

URL: https://docs.deno.com/examples/tutorials/deploy_otel


Deno Deploy<sup>EA</sup> 内置了 OpenTelemetry 支持，能够自动捕获 HTTP 请求、数据库查询和其他操作的追踪信息。本教程展示如何为您的应用添加自定义 OpenTelemetry 仪表，以实现更详细的可观测性。

## 先决条件

1. 一个 [GitHub](https://github.com) 账号
2. 在本地机器上安装 [Deno](https://docs.deno.com/runtime/manual/getting_started/installation)
3. 访问 [Deno Deploy 早期体验计划](https://dash.deno.com/account#early-access)
4. 基本了解 [OpenTelemetry 概念](https://opentelemetry.io/docs/concepts/)

## 创建一个基础 API 应用

首先，让我们创建一个简单的 API 服务器，稍后将使用 OpenTelemetry 对其进行仪表：

```ts title="main.ts"
const dataStore: Record<string, string> = {};

async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);

  // 模拟随机延迟
  await new Promise((resolve) => setTimeout(resolve, Math.random() * 200));

  try {
    // 处理产品列表
    if (url.pathname === "/products" && req.method === "GET") {
      return new Response(JSON.stringify(Object.values(dataStore)), {
        headers: { "Content-Type": "application/json" },
      });
    }

    // 处理产品创建
    if (url.pathname === "/products" && req.method === "POST") {
      const data = await req.json();
      const id = crypto.randomUUID();
      dataStore[id] = data;
      return new Response(JSON.stringify({ id, ...data }), {
        status: 201,
        headers: { "Content-Type": "application/json" },
      });
    }

    // 按 ID 获取产品
    if (url.pathname.startsWith("/products/") && req.method === "GET") {
      const id = url.pathname.split("/")[2];
      const product = dataStore[id];

      if (!product) {
        return new Response("Product not found", { status: 404 });
      }

      return new Response(JSON.stringify(product), {
        headers: { "Content-Type": "application/json" },
      });
    }

    // 处理根路由
    if (url.pathname === "/") {
      return new Response("Product API - Try /products endpoint");
    }

    return new Response("Not Found", { status: 404 });
  } catch (error) {
    console.error("Error handling request:", error);
    return new Response("Internal Server Error", { status: 500 });
  }
}

console.log("Server running on http://localhost:8000");
Deno.serve(handler, { port: 8000 });
```

保存此文件并在本地运行：

```sh
deno run --allow-net main.ts
```

使用 curl 或浏览器测试 API，以确保其正常工作：

```sh
# 列出产品（初始为空）
curl http://localhost:8000/products

# 添加一个产品
curl -X POST http://localhost:8000/products \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Product", "price": 19.99}'
```

## 添加 OpenTelemetry 仪表

现在，给我们的应用添加自定义的 OpenTelemetry 仪表。创建一个新文件 `instrumented-main.ts`：

```ts title="instrumented-main.ts"
import { trace } from "npm:@opentelemetry/api@1";

// 获取 OpenTelemetry tracer
const tracer = trace.getTracer("product-api");

const dataStore: Record<string, string> = {};

// 模拟数据库操作并创建自定义 span
async function queryDatabase(
  operation: string,
  data?: unknown,
): Promise<unknown> {
  return await tracer.startActiveSpan(`database.${operation}`, async (span) => {
    try {
      // 为 span 添加属性以便提供更好的上下文
      span.setAttributes({
        "db.system": "memory-store",
        "db.operation": operation,
      });

      // 模拟数据库延迟
      const delay = Math.random() * 100;
      await new Promise((resolve) => setTimeout(resolve, delay));

      // 将延迟信息添加到 span 属性
      span.setAttributes({ "db.latency_ms": delay });

      if (operation === "list") {
        return Object.values(dataStore);
      } else if (operation === "get") {
        return dataStore[data as string];
      } else if (operation === "insert") {
        const id = crypto.randomUUID();
        dataStore[id] = data as string;
        return { id, data };
      }

      return null;
    } catch (error) {
      // 记录任何错误到 span
      span.recordException(error);
      span.setStatus({ code: trace.SpanStatusCode.ERROR });
      throw error;
    } finally {
      // 结束 span
      span.end();
    }
  });
}

async function handler(req: Request): Promise<Response> {
  // 为整个请求创建父 span
  return await tracer.startActiveSpan(
    `${req.method} ${new URL(req.url).pathname}`,
    async (parentSpan) => {
      const url = new URL(req.url);

      // 为 span 添加请求详情属性
      parentSpan.setAttributes({
        "http.method": req.method,
        "http.url": req.url,
        "http.route": url.pathname,
      });

      try {
        // 处理产品列表
        if (url.pathname === "/products" && req.method === "GET") {
          const products = await queryDatabase("list");
          return new Response(JSON.stringify(products), {
            headers: { "Content-Type": "application/json" },
          });
        }

        // 处理产品创建
        if (url.pathname === "/products" && req.method === "POST") {
          // 创建一个解析请求 JSON 的 span
          const data = await tracer.startActiveSpan(
            "parse.request.body",
            async (span) => {
              try {
                const result = await req.json();
                return result;
              } catch (error) {
                span.recordException(error);
                span.setStatus({ code: trace.SpanStatusCode.ERROR });
                throw error;
              } finally {
                span.end();
              }
            },
          );

          const result = await queryDatabase("insert", data);
          return new Response(JSON.stringify(result), {
            status: 201,
            headers: { "Content-Type": "application/json" },
          });
        }

        // 根据 ID 获取产品
        if (url.pathname.startsWith("/products/") && req.method === "GET") {
          const id = url.pathname.split("/")[2];
          parentSpan.setAttributes({ "product.id": id });

          const product = await queryDatabase("get", id);

          if (!product) {
            parentSpan.setAttributes({
              "error": true,
              "error.type": "not_found",
            });
            return new Response("Product not found", { status: 404 });
          }

          return new Response(JSON.stringify(product), {
            headers: { "Content-Type": "application/json" },
          });
        }

        // 处理根路由
        if (url.pathname === "/") {
          return new Response("Product API - Try /products endpoint");
        }

        parentSpan.setAttributes({ "error": true, "error.type": "not_found" });
        return new Response("Not Found", { status: 404 });
      } catch (error) {
        console.error("Error handling request:", error);
        // 在 span 中记录错误
        parentSpan.recordException(error);
        parentSpan.setAttributes({
          "error": true,
          "error.type": error.name,
          "error.message": error.message,
        });
        parentSpan.setStatus({ code: trace.SpanStatusCode.ERROR });

        return new Response("Internal Server Error", { status: 500 });
      } finally {
        // 结束父 span
        parentSpan.end();
      }
    },
  );
}

console.log(
  "Server running with OpenTelemetry instrumentation on http://localhost:8000",
);
Deno.serve(handler, { port: 8000 });
```

在本地运行带有仪表的版本：

```sh
deno run --allow-net instrumented-main.ts
```

再次使用 curl 测试 API 以生成一些追踪。

## 创建 GitHub 仓库

1. 访问 [GitHub](https://github.com) 并创建一个新仓库。

2. 初始化本地目录为 Git 仓库：

```sh
git init
git add .
git commit -m "Add OpenTelemetry instrumented API"
```

3. 添加 GitHub 仓库作为远程仓库并推送代码：

```sh
git remote add origin https://github.com/your-username/otel-demo-app.git
git branch -M main
git push -u origin main
```

## 部署到 Deno Deploy 早期体验

1. 访问 [console.deno.com](https://console.deno.com)
2. 选择您的组织，或根据需要新建一个
3. 点击 "+ New App"
4. 选择您之前创建的 GitHub 仓库
5. 配置构建设置：
   - 框架预设：无预设
   - 运行时配置：动态
   - 入口文件：`instrumented-main.ts`

6. 点击 "Create App" 开始部署过程

## 生成示例流量

为了生成示例追踪和指标，让我们向部署的应用发送一些流量：

1. 从 Deno Deploy 控制台复制您的部署 URL

2. 发送多个请求到不同的端点：

```sh
# 将应用 URL 存入变量
APP_URL=https://your-app-name.your-org-name.deno.net

# 访问根路由
curl $APP_URL/

# 列出产品（初始为空）
curl $APP_URL/products

# 添加一些产品
curl -X POST $APP_URL/products -H "Content-Type: application/json" -d '{"name": "Laptop", "price": 999.99}'
curl -X POST $APP_URL/products -H "Content-Type: application/json" -d '{"name": "Headphones", "price": 129.99}'
curl -X POST $APP_URL/products -H "Content-Type: application/json" -d '{"name": "Mouse", "price": 59.99}'

# 再次列出产品
curl $APP_URL/products

# 尝试访问一个不存在的产品（将生成错误 span）
curl $APP_URL/products/nonexistent-id
```

## 探索 OpenTelemetry 追踪和指标

现在，让我们探索 Deno Deploy 收集的可观测性数据：

1. 在应用仪表盘，点击侧边栏的 "Traces"
   - 您将看到针对每个请求的追踪列表
   - 可以使用搜索栏按 HTTP 方法或状态码过滤追踪

2. 选择一个 `/products` 的 POST 追踪以查看详细信息：
   - 整个请求的父 span
   - 数据库操作的子 span
   - 解析请求体的 span

   ![追踪瀑布图视图](./images/early-access/otel_trace.png)

3. 点击单个 span 查看详情：
   - 持续时间和时间信息
   - 您设置的属性，如 `db.operation` 和 `db.latency_ms`
   - 任何已记录的异常

4. 点击侧边栏的 "Logs" 查看带有追踪上下文的控制台输出：
   - 注意追踪期间发出的日志如何被自动关联到追踪
   - 点击日志行的 "View trace" 可查看关联的追踪

5. 点击 "Metrics" 查看应用性能指标：
   - 按端点的 HTTP 请求计数
   - 错误率
   - 响应时间分布

🦕 Deno Deploy<sup>EA</sup> 的自动仪表结合您的自定义仪表，为您的应用性能和行为提供了全面的可视化。

更多关于 Deno 中 OpenTelemetry 的信息，请参考以下资源：

- [Deno 中的 OpenTelemetry 文档](/runtime/fundamentals/open_telemetry/)
- [Deno Deploy<sup>EA</sup> 可观测性参考](/deploy/early-access/reference/observability/)
- [OpenTelemetry 官方文档](https://opentelemetry.io/docs/)

---

# 如何将 Deno 部署到 Digital Ocean

> A step-by-step guide to deploying Deno applications on Digital Ocean. Learn about Docker containerization, GitHub Actions automation, container registries, and how to set up continuous deployment workflows.

URL: https://docs.deno.com/examples/tutorials/digital_ocean


Digital Ocean 是一个受欢迎的云基础设施提供商，提供多种托管服务，从网络到计算再到存储。

以下是将 Deno 应用程序通过 Docker 和 GitHub Actions 部署到 Digital Ocean 的逐步指南。

此过程的先决条件包括：

- [`docker` CLI](https://docs.docker.com/engine/reference/commandline/cli/)
- 一个 [GitHub 帐户](https://github.com)
- 一个 [Digital Ocean 帐户](https://digitalocean.com)
- [`doctl` CLI](https://docs.digitalocean.com/reference/doctl/how-to/install/)

## 创建 Dockerfile 和 docker-compose.yml

为了专注于部署，我们的应用程序仅为一个返回 HTTP 响应字符串的 `main.ts` 文件：

```ts title="main.ts"
import { Application } from "jsr:@oak/oak";

const app = new Application();

app.use((ctx) => {
  ctx.response.body = "Hello from Deno and Digital Ocean!";
});

await app.listen({ port: 8000 });
```

接下来，我们将创建两个文件 -- `Dockerfile` 和 `docker-compose.yml` -- 来构建 Docker 镜像。

在我们的 `Dockerfile` 中，添加如下内容：

```Dockerfile title="Dockerfile"
FROM denoland/deno

EXPOSE 8000

WORKDIR /app

ADD . /app

RUN deno install --entrypoint main.ts

CMD ["run", "--allow-net", "main.ts"]
```

然后，在我们的 `docker-compose.yml` 中：

```yml
version: "3"

services:
  web:
    build: .
    container_name: deno-container
    image: deno-image
    ports:
      - "8000:8000"
```

让我们通过运行 `docker compose -f docker-compose.yml build`，然后 `docker compose up`，并访问 `localhost:8000` 来测试这个应用程序。

![Hello from localhost](./images/how-to/digital-ocean/hello-world-from-localhost.png)

它工作正常！

## 构建、标记并将 Docker 镜像推送到 Digital Ocean 容器注册表

Digital Ocean 有自己的私有容器注册表，我们可以在其中推送和拉取 Docker 镜像。为了使用该注册表，让我们
[在命令行中安装并认证 `doctl`](https://docs.digitalocean.com/reference/doctl/how-to/install/)。

之后，我们将创建一个名为 `deno-on-digital-ocean` 的新私有注册表：

```shell
doctl registry create deno-on-digital-ocean
```

使用我们的 Dockerfile 和 docker-compose.yml，我们将构建一个新镜像，标记它，并将其推送到注册表。请注意，`docker-compose.yml` 将在本地将构建命名为 `deno-image`。

```shell
docker compose -f docker-compose.yml build
```

让我们 [标记](https://docs.docker.com/engine/reference/commandline/tag/) 它为 `new`：

```shell
docker tag deno-image registry.digitalocean.com/deno-on-digital-ocean/deno-image:new
```

现在我们可以将其推送到注册表。

```shell
docker push registry.digitalocean.com/deno-on-digital-ocean/deno-image:new
```

你应该在你的 [Digital Ocean 容器注册表](https://cloud.digitalocean.com/registry) 中看到新的带有 `new` 标签的 `deno-image`：

![New deno image on Digital Ocean container registry](./images/how-to/digital-ocean/new-deno-image-on-digital-ocean-container-registry.png)

完美！

## 通过 SSH 部署到 Digital Ocean

一旦我们的 `deno-image` 在注册表中，我们可以使用 `docker run` 在任何地方运行它。在这种情况下，我们将在我们的
[Digital Ocean Droplet](https://www.digitalocean.com/products/droplets) 上运行，那里是他们托管的虚拟机。

在你的 [Droplet 页面](https://cloud.digitalocean.com/droplets) 上，点击你的 Droplet，然后点击 `console` 通过 SSH 进入虚拟机。（或者你可以从你的命令行 [直接 ssh](https://docs.digitalocean.com/products/droplets/how-to/connect-with-ssh/)）。

要拉取 `deno-image` 镜像并运行它，我们可以运行：

```shell
docker run -d --restart always -it -p 8000:8000 --name deno-image registry.digitalocean.com/deno-on-digital-ocean/deno-image:new
```

使用我们的浏览器访问 Digital Ocean 地址，我们现在看到：

![Hello from Deno and Digital Ocean](./images/how-to/digital-ocean/hello-from-deno-and-digital-ocean.png)

太棒了！

## 通过 GitHub Actions 自动化部署

让我们通过 GitHub Actions 自动化整个过程。

首先，让我们获取所有需要的环境变量，以便登录到 `doctl` 和 SSH 进入 Droplet：

- [DIGITALOCEAN_ACCESS_TOKEN](https://docs.digitalocean.com/reference/api/create-personal-access-token/)
- DIGITALOCEAN_HOST（你的 Droplet 的 IP 地址）
- DIGITALOCEAN_USERNAME（默认是 `root`）
- DIGITALOCEAN_SSHKEY（关于这一点，稍后会详细说明）

### 生成 `DIGITALOCEAN_SSHKEY`

`DIGITALOCEAN_SSHKEY` 是一个私钥，其公钥位于虚拟机的 `~/.ssh/authorized_keys` 文件中。

为此，首先在你的本地机器上运行 `ssh-keygen`：

```shell
ssh-keygen
```

当出现提醒输入电子邮件时，**确保使用你的 GitHub 电子邮件** 以便 GitHub Action 正确验证。最终输出应该类似于：

```console
Output
Your identification has been saved in /your_home/.ssh/id_rsa
Your public key has been saved in /your_home/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:/hk7MJ5n5aiqdfTVUZr+2Qt+qCiS7BIm5Iv0dxrc3ks user@host
The key's randomart image is:
+---[RSA 3072]----+
|                .|
|               + |
|              +  |
| .           o . |
|o       S   . o  |
| + o. .oo. ..  .o|
|o = oooooEo+ ...o|
|.. o *o+=.*+o....|
|    =+=ooB=o.... |
+----[SHA256]-----+
```

接下来，我们需要将新生成的公钥上传到你的 Droplet。你可以使用 [`ssh-copy-id`](https://www.ssh.com/academy/ssh/copy-id) 或手动复制它，SSH 进入你的 Droplet，并将其粘贴到 `~/.ssh/authorized_keys`。

使用 `ssh-copy-id`：

```shell
ssh-copy-id {{ username }}@{{ host }}
```

这个命令会提示你输入密码。请注意，这将自动从你的本地机器复制 `id_rsa.pub` 密钥并粘贴到你的 Droplet 的 `~/.ssh/authorized_keys` 文件中。如果你将密钥命名为其他名称，可以通过 `-i` 标志将其传递给命令：

```shell
ssh-copy-id -i ~/.ssh/mykey {{ username }}@{{ host }}
```

要测试是否成功执行：

```shell
ssh -i ~/.ssh/mykey {{ username }}@{{ host }}
```

太好了！

### 定义 yml 文件

最后一步是将这一切结合在一起。我们基本上是在手动部署的每一步中，将其添加到一个 GitHub Actions 工作流的 yml 文件中：

```yml
name: Deploy to Digital Ocean

on:
  push:
    branches:
      - main

env:
  REGISTRY: "registry.digitalocean.com/deno-on-digital-ocean"
  IMAGE_NAME: "deno-image"

jobs:
  build_and_push:
    name: Build, Push, and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4

      - name: Set $TAG from shortened sha
        run: echo "TAG=`echo ${GITHUB_SHA} | cut -c1-8`" >> $GITHUB_ENV

      - name: Build container image
        run: docker compose -f docker-compose.yml build

      - name: Tag container image
        run: docker tag ${{ env.IMAGE_NAME }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}

      - name: Install `doctl`
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Log in to Digital Ocean Container Registry
        run: doctl registry login --expiry-seconds 600

      - name: Push image to Digital Ocean Container Registry
        run: docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}

      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DIGITALOCEAN_HOST }}
          username: ${{ secrets.DIGITALOCEAN_USERNAME }}
          key: ${{ secrets.DIGITALOCEAN_SSHKEY }}
          script: |
            # 登录到 Digital Ocean 容器注册表
            docker login -u ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} -p ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} registry.digitalocean.com
            # 停止并删除正在运行的镜像
            docker stop ${{ env.IMAGE_NAME }}
            docker rm ${{ env.IMAGE_NAME }}
            # 从新镜像运行一个新容器
            docker run -d --restart always -it -p 8000:8000 --name ${{ env.IMAGE_NAME }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}
```

当你推送到 GitHub 时，这个 yml 文件会被自动检测，从而触发部署动作。

---

# 使用 Drizzle ORM 和 Deno 构建数据库应用

> Step-by-step guide to building database applications with Drizzle ORM and Deno. Learn about schema management, type-safe queries, PostgreSQL integration, migrations, and how to implement CRUD operations.

URL: https://docs.deno.com/examples/tutorials/drizzle


[Drizzle ORM](https://orm.drizzle.team/) 是一个 TypeScript ORM，提供了一种类型安全的方式与数据库进行交互。在本教程中，我们将设置 Drizzle ORM 与 Deno 和 PostgreSQL，以便创建、读取、更新和删除恐龙数据：

- [安装 Drizzle](#install-drizzle)
- [配置 Drizzle](#configure-drizzle)
- [定义模式](#define-schemas)
- [与数据库交互](#interact-with-the-database)
- [接下来做什么？](#whats-next)

您可以在[this GitHub repo](https://github.com/denoland/examples/tree/main/with-drizzle)中找到本教程的所有代码。

## 安装 Drizzle

首先，我们将使用 Deno 的 npm 兼容性安装所需的依赖项。我们将与 [Postgres](https://orm.drizzle.team/docs/get-started-postgresql) 一起使用 Drizzle，但您也可以使用 [MySQL](https://orm.drizzle.team/docs/get-started-mysql) 或 [SQLite](https://orm.drizzle.team/docs/get-started-sqlite) 。（如果您没有 PostgreSQL，可以在 [这里安装](https://www.postgresql.org/download/)。）

```bash
deno install npm:drizzle-orm npm:drizzle-kit npm:pg npm:@types/pg
```

这将安装 Drizzle ORM 及其相关工具——用于模式迁移的 [drizzle-kit](https://orm.drizzle.team/docs/kit-overview)，用于 PostgreSQL 连接的 [pg](https://www.npmjs.com/package/pg)，以及 PostgreSQL 的 [TypeScript 类型](https://www.npmjs.com/package/@types/pg)。这些包将允许我们以类型安全的方式与数据库交互，同时保持与 Deno 的运行环境的兼容性。

它还将在您的项目根目录中创建一个 `deno.json` 文件以管理 npm 依赖项：

```json
{
  "imports": {
    "@types/pg": "npm:@types/pg@^8.11.10",
    "drizzle-kit": "npm:drizzle-kit@^0.27.2",
    "drizzle-orm": "npm:drizzle-orm@^0.36.0",
    "pg": "npm:pg@^8.13.1"
  }
}
```

## 配置 Drizzle

接下来，让我们在项目根目录中创建一个 `drizzle.config.ts` 文件。此文件将配置 Drizzle 以与您的 PostgreSQL 数据库配合使用：

```tsx
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  schema: "./src/db/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: Deno.env.get("DATABASE_URL")!,
  },
});
```

这些配置设置决定：

- 迁移文件的输出位置（`./drizzle`）
- 查找模式定义的位置（`./src/db/schema.ts`）
- PostgreSQL 作为您的数据库方言，
- 如何使用存储在环境变量中的 URL 连接到您的数据库

`drizzle-kit` 将使用此配置管理您的数据库模式并自动生成 SQL 迁移。

我们还需要在项目根目录中添加一个 `.env` 文件，其中包含 `DATABASE_URL` 连接字符串：

```bash
DATABASE_URL=postgresql://[user[:password]@][host][:port]/[dbname]
```

确保将登录凭据替换为您自己的。

接下来，让我们连接到数据库，并使用 Drizzle 填充我们的表。

## 定义模式

使用 Drizzle 定义表模式有两种方法。如果您已经定义了 Postgres 表，您可以使用 `pull` 推断它们；否则，您可以在代码中定义它们，然后使用 Drizzle 创建新表。我们将在下面探讨这两种方法。

### 使用 `pull` 推断模式

如果您在添加 Drizzle 之前已经有 Postgres 表，则可以 introspect 您的数据库模式，以使用命令 [`npm:drizzle-kit pull`](https://orm.drizzle.team/docs/drizzle-kit-pull) 自动生成 TypeScript 类型和表定义。这在处理现有数据库时特别有用，或者当您希望确保代码与数据库结构保持同步时。

假设我们当前的数据库已经具有以下表模式：

![Postgres 中表模式的图示](./images/how-to/drizzle/table-diagram.png)

我们将运行以下命令以 introspect 数据库并在 `./drizzle` 目录下填充多个文件：

<figure>

```bash
deno --env -A --node-modules-dir npm:drizzle-kit pull

Failed to find Response internal state key
No config path provided, using default 'drizzle.config.ts'
Reading config file '/private/tmp/deno-drizzle-example/drizzle.config.ts'
Pulling from ['public'] list of schemas

Using 'pg' driver for database querying
[✓] 2 tables fetched
[✓] 8 columns fetched
[✓] 0 enums fetched
[✓] 0 indexes fetched
[✓] 1 foreign keys fetched
[✓] 0 policies fetched
[✓] 0 check constraints fetched
[✓] 0 views fetched

[i] No SQL generated, you already have migrations in project
[✓] Your schema file is ready ➜ drizzle/schema.ts 🚀
[✓] Your relations file is ready ➜ drizzle/relations.ts 🚀
```

<figcaption>
我们使用 <code>--env</code> 标志来读取包含我们数据库 URL 的 <code>.env</code> 文件，以及 <code>--node-modules-dir</code> 标志来创建一个 <code>node_modules</code> 文件夹，使我们能够正确使用 <code>drizzle-kit</code>。
</figcaption>
</figure>
</br>

上述命令将在 `./drizzle` 目录中创建一些文件，这些文件定义了模式、跟踪更改，并提供了进行数据库迁移所需的信息：

- `drizzle/schema.ts`：此文件使用 Drizzle ORM 的模式定义语法定义数据库模式。
- `drizzle/relations.ts`：此文件用于定义使用 Drizzle ORM 的关系 API 的表之间的关系。
- `drizzle/0000_long_veda.sql`：一个 SQL 迁移文件，其中包含创建数据库表的 SQL 代码。该代码被注释掉 — 如果要运行此迁移以在新环境中创建表，可以取消注释该代码。
- `drizzle/meta/0000_snapshot.json`：一个快照文件，表示您数据库模式的当前状态。
- `drizzle/meta/_journal.json`：此文件跟踪已应用于数据库的迁移。它帮助 Drizzle ORM 知道哪些迁移已运行，哪些仍需应用。

### 首先在 Drizzle 中定义模式

如果您还没有在 Postgres 中定义任何现有表（例如，您正在开始一个全新的项目），则可以在代码中定义表和类型，并让 Drizzle 创建它们。

让我们创建一个新的目录 `./src/db/`，并在其中创建一个 `schema.ts` 文件，填入以下内容：

<figure>

```ts
// schema.ts
import {
  boolean,
  foreignKey,
  integer,
  pgTable,
  serial,
  text,
  timestamp,
} from "drizzle-orm/pg-core";

export const dinosaurs = pgTable("dinosaurs", {
  id: serial().primaryKey().notNull(),
  name: text(),
  description: text(),
});

export const tasks = pgTable("tasks", {
  id: serial().primaryKey().notNull(),
  dinosaurId: integer("dinosaur_id"),
  description: text(),
  dateCreated: timestamp("date_created", { mode: "string" }).defaultNow(),
  isComplete: boolean("is_complete"),
}, (table) => {
  return {
    tasksDinosaurIdFkey: foreignKey({
      columns: [table.dinosaurId],
      foreignColumns: [dinosaurs.id],
      name: "tasks_dinosaur_id_fkey",
    }),
  };
});
```

<figcaption>
上述代码表示两个表 <code>dinosaurs</code> 和 <code>tasks</code> 及其关系。<a href="https://orm.drizzle.team/docs/schemas">了解有关使用 Drizzle 定义模式及其关系的更多信息</a>。
</figcaption>
</figure>
</br>

定义完 `./src/db/schema.ts` 后，我们可以通过创建迁移来创建表和指定的关系：

```bash
deno -A --node-modules-dir npm:drizzle-kit generate

Failed to find Response internal state key
No config path provided, using default 'drizzle.config.ts'
Reading config file '/private/tmp/drizzle/drizzle.config.ts'
2 tables
dinosaurs 3 columns 0 indexes 0 fks
tasks 5 columns 0 indexes 1 fks
```

上述命令将创建一个包含迁移脚本和日志的 `./drizzle/` 文件夹。

## 与数据库交互

现在我们已经设置了 Drizzle ORM，可以使用它来简化在 Postgres 数据库中管理数据。首先，Drizzle 建议将 `schema.ts` 和 `relations.ts` 复制到 `./src/db` 目录中，以便在应用程序中使用。

让我们创建一个 `./src/db/db.ts` 文件，导出一些助手函数，使我们更容易与数据库交互：

```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { dinosaurs as dinosaurSchema, tasks as taskSchema } from "./schema.ts";
import { dinosaursRelations, tasksRelations } from "./relations.ts";
import pg from "pg";
import { integer } from "drizzle-orm/sqlite-core";
import { eq } from "drizzle-orm/expressions";

// 使用 pg 驱动程序。
const { Pool } = pg;

// 使用 pg 驱动程序和模式实例化 Drizzle 客户端。
export const db = drizzle({
  client: new Pool({
    connectionString: Deno.env.get("DATABASE_URL"),
  }),
  schema: { dinosaurSchema, taskSchema, dinosaursRelations, tasksRelations },
});

// 插入恐龙。
export async function insertDinosaur(dinosaurObj: typeof dinosaurSchema) {
  return await db.insert(dinosaurSchema).values(dinosaurObj);
}

// 插入任务。
export async function insertTask(taskObj: typeof taskSchema) {
  return await db.insert(taskSchema).values(taskObj);
}

// 按 id 查找恐龙。
export async function findDinosaurById(dinosaurId: typeof integer) {
  return await db.select().from(dinosaurSchema).where(
    eq(dinosaurSchema.id, dinosaurId),
  );
}

// 按名称查找恐龙。
export async function findDinosaurByName(name: string) {
  return await db.select().from(dinosaurSchema).where(
    eq(dinosaurSchema.name, name),
  );
}

// 根据恐龙 id 查找任务。
export async function findDinosaurTasksByDinosaurId(
  dinosaurId: typeof integer,
) {
  return await db.select().from(taskSchema).where(
    eq(taskSchema.dinosaurId, dinosaurId),
  );
}

// 更新恐龙。
export async function updateDinosaur(dinosaurObj: typeof dinosaurSchema) {
  return await db.update(dinosaurSchema).set(dinosaurObj).where(
    eq(dinosaurSchema.id, dinosaurObj.id),
  );
}

// 更新任务。
export async function updateTask(taskObj: typeof taskSchema) {
  return await db.update(taskSchema).set(taskObj).where(
    eq(taskSchema.id, taskObj.id),
  );
}

// 按 id 删除恐龙。
export async function deleteDinosaurById(id: typeof integer) {
  return await db.delete(dinosaurSchema).where(
    eq(dinosaurSchema.id, id),
  );
}

// 按 id 删除任务。
export async function deleteTask(id: typeof integer) {
  return await db.delete(taskSchema).where(eq(taskSchema.id, id));
}
```

现在我们可以将其中一些助手函数导入到一个脚本中，在其中对我们的数据库执行一些简单的 CRUD 操作。让我们创建一个新文件 `./src/script.ts`：

```ts
import {
  deleteDinosaurById,
  findDinosaurByName,
  insertDinosaur,
  insertTask,
  updateDinosaur,
} from "./db/db.ts";

// 创建一个新的恐龙。
await insertDinosaur({
  name: "Denosaur",
  description: "Dinosaurs should be simple.",
});

// 按名称查找该恐龙。
const res = await findDinosaurByName("Denosaur");

// 根据该恐龙的 id 创建一个任务。
await insertTask({
  dinosaurId: res.id,
  description: "Remove unnecessary config.",
  isComplete: false,
});

// 使用新描述更新恐龙。
const newDeno = {
  id: res.id,
  name: "Denosaur",
  description: "The simplest dinosaur.",
};
await updateDinosaur(newDeno);

// 删除恐龙（及其可能存在的任何任务）。
await deleteDinosaurById(res.id);
```

我们可以运行它并在数据库上执行所有操作：

```ts
deno -A --env ./src/script.ts
```

## 接下来做什么？

Drizzle ORM 是一个流行的数据映射工具，简化了管理和维护数据模型以及与数据库的工作。希望本教程能为您如何在 Deno 项目中使用 Drizzle 提供一个起点。

现在您对如何在 Deno 中使用 Drizzle ORM 有了基本的了解，您可以：

1. 添加更复杂的数据库关系
2. [实现一个 REST API](https://docs.deno.com/examples/) 使用 [Hono](https://jsr.io/@hono/hono) 提供您的恐龙数据
3. 为您的数据库操作添加验证和错误处理
4. 为您的数据库交互编写测试
5. [将您的应用程序部署到云端](https://docs.deno.com/runtime/tutorials/#deploying-deno-projects)

🦕 祝您在 Deno 和 Drizzle ORM 上编码愉快！这种堆栈的类型安全性和简单性使其成为构建现代 Web 应用的绝佳选择。

---

# 如何在 Deno 中使用 Express

> Step-by-step guide to using Express.js with Deno. Learn how to set up an Express server, configure routes, handle middleware, and build REST APIs using Deno's Node.js compatibility features.

URL: https://docs.deno.com/examples/tutorials/express


[Express](https://expressjs.com/) 是一个流行的 web 框架，以简单和无特定意见著称，拥有庞大的中间件生态系统。

本指南将展示如何使用 Express 和 Deno 创建一个简单的 API。

[查看源代码。](https://github.com/denoland/tutorial-with-express)

## 初始化一个新的 Deno 项目

在命令行中运行以下命令以创建一个新的启动项目，然后导航到项目目录中：

```sh
deno init my-express-project
cd my-express-project
```

## 安装 Express

要安装 Express，我们将使用 `npm:` 模块说明符。这个说明符允许我们从 npm 导入模块：

```sh
deno add npm:express
```

这将把最新的 `express` 包添加到 `deno.json` 文件中的 `imports` 字段。现在你可以在代码中使用 `import express from "express";` 导入 `express`。

## 更新 `main.ts`

在 `main.ts` 中，让我们创建一个简单的服务器：

```ts
import express from "express";

const app = express();

app.get("/", (req, res) => {
  res.send("欢迎来到恐龙 API！");
});

app.listen(8000);
console.log(`服务器正在运行在 http://localhost:8000`);
```

你可能会注意到编辑器对 `req` 和 `res` 参数发出警告。这是因为 Deno 没有为 `express` 模块提供类型。为了解决这个问题，你可以直接从 npm 导入 Express 类型文件。在 `main.ts` 的顶部添加以下注释：

```ts
// @ts-types="npm:@types/express@4.17.15"
```

这个注释告诉 Deno 使用 `@types/express` 包中的类型。

## 运行服务器

当你初始化项目时，Deno 设置了一个任务来运行 `main.ts` 文件，你可以在 `deno.json` 文件中看到它。更新 `dev` 任务以包含 [`--allow-net`](/runtime/fundamentals/security/#network-access) 标志：

```jsonc
{
  "scripts": {
    "dev": "deno run --allow-net main.ts"
  }, 
  ...
}
```

这将允许项目进行网络请求。你可以 [阅读更多关于权限标志的信息](/runtime/fundamentals/security/)。

现在你可以使用以下命令运行服务器：

```sh
deno run dev
```

如果你在浏览器中访问 `localhost:8000`，你应该看到：

**欢迎来到恐龙 API！**

## 添加数据和路由

接下来的步骤是添加一些数据。我们将使用来自 [这篇文章](https://www.thoughtco.com/dinosaurs-a-to-z-1093748) 的恐龙数据。随意
[从这里复制它](https://raw.githubusercontent.com/denoland/tutorial-with-express/refs/heads/main/data.json)。

在项目根目录中创建一个 `data.json` 文件，并粘贴恐龙数据。

接下来，我们将把这些数据导入到 `main.ts` 中：

```ts
import data from "./data.json" with { type: "json" };
```

我们将创建访问这些数据的路由。

为了简单起见，我们只为 `/api/` 和 `/api/:dinosaur` 定义 `GET` 处理程序。在 `const app = express();` 这一行后添加以下代码：

```ts
app.get("/", (req, res) => {
  res.send("欢迎来到恐龙 API！");
});

app.get("/api", (req, res) => {
  res.send(data);
});

app.get("/api/:dinosaur", (req, res) => {
  if (req?.params?.dinosaur) {
    const found = data.find((item) =>
      item.name.toLowerCase() === req.params.dinosaur.toLowerCase()
    );
    if (found) {
      res.send(found);
    } else {
      res.send("未找到恐龙。");
    }
  }
});

app.listen(8000);
console.log(`服务器正在运行在 http://localhost:8000`);
```

让我们使用 `deno run dev` 运行服务器，并在浏览器中查看 `localhost:8000/api`。你应该会看到一列恐龙！

```jsonc
[
  {
    "name": "Aardonyx",
    "description": "长颈龙演化早期阶段。"
  },
  {
    "name": "Abelisaurus",
    "description": "\"阿贝尔的蜥蜴\" 是由单个头骨重建的。"
  },
  {
    "name": "Abrictosaurus",
    "description": "异齿龙的早期亲属。"
  },
...
```

你还可以通过访问 "/api/恐龙名称" 来获取特定恐龙的详细信息，例如 `localhost:8000/api/aardonyx` 将显示：

```json
{
  "name": "Aardonyx",
  "description": "长颈龙演化早期阶段。"
}
```

🦕 现在你已准备好在 Deno 中使用 Express。你可以考虑把这个示例扩展成一个恐龙网页应用。或者查看
[Deno 内置的 HTTP 服务器](https://docs.deno.com/runtime/fundamentals/http_server/)。

---

# 获取和流数据

> A tutorial on working with network requests in Deno. Learn how to use the fetch API for HTTP requests, handle responses, implement data streaming, and manage file uploads and downloads.

URL: https://docs.deno.com/examples/tutorials/fetch_data


Deno 将几个熟悉的 Web API 引入到服务器环境中。如果您曾经使用过浏览器，您可能会认识 [`fetch()`](/api/web/fetch) 方法和 [`streams`](/api/web/streams) API，它们用于进行网络请求和访问网络上的数据流。Deno 实现了这些 API，使您能够从网络中获取和流式传输数据。

## 获取数据

在构建 Web 应用程序时，开发人员通常需要从 Web 的其他地方检索资源。我们可以使用 `fetch` API 来实现。我们将看看如何从 URL 获取不同形状的数据，以及如果请求失败时如何处理错误。

创建一个名为 `fetch.js` 的新文件，并添加以下代码：

```ts title="fetch.js"
// 输出：JSON 数据
const jsonResponse = await fetch("https://api.github.com/users/denoland");
const jsonData = await jsonResponse.json();

console.log(jsonData, "\n");

// 输出：HTML 数据
const textResponse = await fetch("https://deno.land/");
const textData = await textResponse.text();

console.log(textData, "\n");

// 输出：错误信息
try {
  await fetch("https://does.not.exist/");
} catch (error) {
  console.log(error);
}
```

您可以使用 `deno run` 命令运行此代码。因为它正在跨网络获取数据，您需要授予 `--allow-net` 权限：

```sh
deno run --allow-net fetch.js
```

您应该在控制台看到 JSON 数据、作为文本的 HTML 数据以及一条错误信息。

## 流式传输数据

有时您可能希望通过网络发送或接收大文件。当您不知道文件的大小时，流式传输是处理数据的更有效方法。客户端可以从流中读取数据，直到它说它完成。

Deno 提供了一种使用 `Streams API` 进行数据流式传输的方法。我们将看看如何将文件转换为可读或可写的流，以及如何使用流来发送和接收文件。

创建一个名为 `stream.js` 的新文件。

我们将使用 `fetch` API 来检索一个文件。然后我们将使用 [`Deno.open`](/api/deno/Deno.open) 方法来创建和打开一个可写文件，并使用 Streams API 的 [`pipeTo`](/api/web/~/ReadableStream.pipeTo) 方法将字节流发送到创建的文件。

接下来，我们将使用 `readable` 属性在 `POST` 请求中将文件的字节流发送到服务器。

```ts title="stream.js"
// 接收文件
const fileResponse = await fetch("https://deno.land/logo.svg");

if (fileResponse.body) {
  const file = await Deno.open("./logo.svg", { write: true, create: true });

  await fileResponse.body.pipeTo(file.writable);
}

// 发送文件
const file = await Deno.open("./logo.svg", { read: true });

await fetch("https://example.com/", {
  method: "POST",
  body: file.readable,
});
```

您可以使用 `deno run` 命令运行此代码。因为它正在从网络获取数据并写入文件，所以您需要授予 `--allow-net`、`--allow-write` 和 `--allow-read` 权限：

```sh
deno run --allow-read --allow-write --allow-net stream.js
```

您应该会看到文件 `logo.svg` 在当前目录中创建并填充，而如果您拥有 example.com，您会看到文件被发送到服务器。

🦕 现在您知道如何在网络上获取和流式传输数据，以及如何将数据流式传输到文件和从文件中流式传输数据！无论您是提供静态文件、处理上传、生成动态内容还是流式传输大型数据集，Deno 的文件处理和流式传输能力都是您开发工具箱中的绝佳工具！

---

# examples/tutorials/file_based_routing.md

> Tutorial on implementing file-based routing in Deno. Learn how to create a dynamic routing system similar to Next.js, handle HTTP methods, manage nested routes, and build a flexible server architecture.

URL: https://docs.deno.com/examples/tutorials/file_based_routing


如果您使用过像 [Next.js](https://nextjs.org/) 这样的框架，您可能对基于文件的路由已不陌生 - 您在特定目录中添加一个文件，它会自动成为一个路由。本教程演示如何创建一个使用基于文件的路由的简单 HTTP 服务器。

## 路由请求

创建一个名为 `server.ts` 的新文件。这个文件将用于路由请求。
设置一个名为 `handler` 的异步函数，接受一个请求对象作为参数：

```ts title="server.ts"
async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const path = url.pathname;
  const method = req.method;
  let module;

  try {
    module = await import(`.${path}.ts`);
  } catch (_error) {
    return new Response("未找到", { status: 404 });
  }

  if (module[method]) {
    return module[method](req);
  }

  return new Response("未实现的方法", { status: 501 });
}

Deno.serve(handler);
```

`handler` 函数设置了一个路径变量，其中包含从请求 URL 中提取的路径，以及一个方法变量，包含请求方法。

接下来尝试根据路径导入一个模块。如果未找到模块，则返回404响应。

如果找到了模块，它会检查该模块是否有请求方法的处理程序。如果找到了方法处理程序，它将使用请求对象调用该方法处理程序。如果未找到方法处理程序，则返回501响应。

最后，它使用 `Deno.serve` 提供处理程序函数。

> 路径可以是任何有效的 URL 路径，例如 `/users`、`/posts` 等。对于像 `/users` 这样的路径，将导入 `./users.ts` 文件。然而，像 `/org/users` 这样的更深路径将需要 `./org/users.ts` 文件。您可以通过创建嵌套目录和文件来创建嵌套路由。

## 处理请求

在与 `server.ts` 相同的目录中创建一个名为 `users.ts` 的新文件。这个文件将用于处理对 `/users` 路径的请求。我们将使用 `GET` 请求作为示例。您可以添加更多的 HTTP 方法，如 `POST`、`PUT`、`DELETE` 等。

在 `users.ts` 中，设置一个名为 `GET` 的异步函数，接受一个请求对象作为参数：

```ts title="users.ts"
export function GET(_req: Request): Response {
  return new Response("来自 user.ts 的问候", { status: 200 });
}
```

## 启动服务器

要启动服务器，请运行以下命令：

```sh
deno run --allow-net --allow-read server.ts
```

这将在 `localhost:8080` 上启动服务器。您现在可以向 `localhost:8000/users` 发出 `GET` 请求，您应该会看到响应 `来自 user.ts 的问候`。

此命令需要 `--allow-net` 和 `--allow-read`
[权限标志](/runtime/fundamentals/security/)，以允许访问网络以启动服务器并从文件系统中读取 `users.ts` 文件。

🦕 现在您可以基于文件结构在您的应用程序中设置路由。您可以根据需要扩展此示例以添加更多路由和方法。

<small>感谢 [@naishe](https://github.com/naishe) 贡献此教程。</small>

---

# 编写一个文件服务器

> Tutorial on building a file server with Deno. Learn how to handle HTTP requests, serve static files, implement streaming responses, and use the standard library's file server module for production deployments.

URL: https://docs.deno.com/examples/tutorials/file_server


一个文件服务器监听传入的HTTP请求，并从本地文件系统提供文件。这个教程演示了如何使用Deno内置的 [文件系统API](/api/deno/file-system) 创建一个简单的文件服务器。

## 编写一个简单的文件服务器

首先，创建一个新的文件，命名为 `file-server.ts`。

我们将使用Deno内置的 [HTTP服务器](/api/deno/~/Deno.serve) 来监听传入的请求。在你的新 `file-server.ts` 文件中，添加以下代码：

```ts title="file-server.ts"
Deno.serve(
  { hostname: "localhost", port: 8080 },
  async (request) => {
    const url = new URL(request.url);
    const filepath = decodeURIComponent(url.pathname);
  },
);
```

> 如果你不熟悉 `URL` 对象，可以在 [URL API](https://developer.mozilla.org/en-US/docs/Web/API/URL) 文档中了解更多。 
> [decodeURIComponent函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) 用于解码URL编码的路径，以防字符被百分号编码。

### 打开文件并流式传输其内容

当接收到请求时，我们将尝试使用 [`Deno.open`](/api/deno/~/Deno.open) 打开请求URL中指定的文件。

如果请求的文件存在，我们将其转换为可读的数据流，使用 [ReadableStream API](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)，并将其内容流式传输到响应中。我们不知道请求的文件有多大，因此流式传输可以在服务大型文件或同时处理多个请求时防止内存问题。

如果文件不存在，我们将返回 "404 Not Found" 响应。

在请求处理程序的主体中，在这两个变量的下面，添加以下代码：

```ts
try {
  const file = await Deno.open("." + filepath, { read: true });
  return new Response(file.readable);
} catch {
  return new Response("404 Not Found", { status: 404 });
}
```

### 运行文件服务器

使用 `deno run` 命令运行你的新文件服务器，允许读取访问和网络访问：

```shell
deno run --allow-read=. --allow-net file-server.ts
```

## 使用Deno标准库提供的文件服务器

从头编写文件服务器是理解Deno的HTTP服务器如何工作的一个很好的练习。然而，从零开始编写生产级文件服务器可能会很复杂且容易出错。使用经过测试和可靠的解决方案更好。

Deno标准库为你提供了一个 [文件服务器](https://jsr.io/@std/http/doc/file-server/~)，这样你就不必自己编写。

要使用它，首先将远程脚本安装到本地文件系统：

```shell
# Deno 1.x
deno install --allow-net --allow-read jsr:@std/http/file-server
# Deno 2.x
deno install --global --allow-net --allow-read jsr:@std/http/file-server
```

> 这将把脚本安装到Deno安装根目录中，例如 `/home/user/.deno/bin/file-server`。

你现在可以使用简化的脚本名称运行该脚本：

```shell
$ file-server .
Listening on:
- Local: http://0.0.0.0:8000
```

要查看文件服务器可用的完整选项列表，请运行 `file-server --help`。

如果你在网页浏览器中访问 [http://0.0.0.0:8000/](http://0.0.0.0:8000/)，你将看到本地目录的内容。

### 在Deno项目中使用 @std/http 文件服务器

要在 [Deno项目](/runtime/getting_started/first_project) 中使用文件服务器，你可以在 `deno.json` 文件中添加它：

```sh
deno add jsr:@std/http
```

然后在你的项目中导入它：

```ts title="file-server.ts"
import { serveDir } from "@std/http/file-server";

Deno.serve((req) => {
  const pathname = new URL(req.url).pathname;
  if (pathname.startsWith("/static")) {
    return serveDir(req, {
      fsRoot: "path/to/static/files/dir",
    });
  }
  return new Response();
});
```

这段代码将使用 `Deno.serve` 设置一个HTTP服务器。当请求到来时，它会检查请求的路径是否以 “/static” 开头。如果是，则从指定目录服务文件。否则，它会返回一个空响应。

🦕 现在你知道如何编写自己的简单文件服务器，以及如何使用Deno标准库提供的文件服务器工具。你可以处理各种任务 - 无论是服务静态文件、处理上传、转换数据还是管理访问控制 - 你都准备好使用Deno服务文件了。

---

# 文件系统事件

> Tutorial on monitoring file system changes with Deno. Learn how to watch directories for file modifications, handle change events, and understand platform-specific behaviors across Linux, macOS, and Windows.

URL: https://docs.deno.com/examples/tutorials/file_system_events


## 概念

- 使用 [Deno.watchFs](https://docs.deno.com/api/deno/~/Deno.watchFs) 来监视文件系统事件。
- 结果可能会因操作系统而异。

## 示例

要在当前目录中轮询文件系统事件：

```ts title="watcher.ts"
const watcher = Deno.watchFs(".");
for await (const event of watcher) {
  console.log(">>>> event", event);
  // 示例事件: { kind: "create", paths: [ "/home/alice/deno/foo.txt" ] }
}
```

运行命令：

```shell
deno run --allow-read watcher.ts
```

现在尝试在与 `watcher.ts` 相同的目录中添加、删除和修改文件。

请注意，事件的具体顺序可能会因操作系统而异。此功能根据平台使用不同的系统调用：

- Linux: [inotify](https://man7.org/linux/man-pages/man7/inotify.7.html)
- macOS:
  [FSEvents](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html)
- Windows:
  [ReadDirectoryChangesW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readdirectorychangesw)

---

# 构建一个 Fresh 应用

> 使用 Fresh 和 Deno 构建全栈应用的完整指南。学习如何设置项目、使用岛屿架构实现服务器端渲染、添加 API 路由，以及部署你的 TypeScript 应用。

URL: https://docs.deno.com/examples/tutorials/fresh


[Fresh](https://fresh.deno.dev/) 是一个面向 Deno 的全栈 Web 框架，强调使用岛屿交互的服务器端渲染。它默认不向客户端发送任何 JavaScript，使其运行极其快速且高效。Fresh 采用基于文件的路由系统，并利用 Deno 现代运行时的能力。

在本教程中，我们将构建一个简单的恐龙目录应用，演示 Fresh 的关键特性。该应用将展示恐龙列表，允许你查看单个恐龙的详细信息，并使用 Fresh 的岛屿架构添加交互组件。

你可以查看
[GitHub 上的完整应用代码仓库](https://github.com/denoland/tutorial-with-fresh)
和
[Deno Deploy 上的应用演示](https://tutorial-with-fresh.deno.deno.net/)。

:::info 部署你自己的应用

想跳过教程，立即部署完成的应用吗？点击下面的按钮，即可将完整的 Fresh 恐龙应用即时部署到 Deno Deploy。你将获得一个可实时运行的应用，可以在学习过程中自定义和修改！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-fresh)

:::

## 创建 Fresh 项目

Fresh 提供了便捷的脚手架工具来创建新项目。在你的终端中运行以下命令：

```sh
deno run -Ar jsr:@fresh/init
```

此命令将会：

- 下载最新的 Fresh 脚手架脚本
- 创建一个名为 `my-fresh-app` 的新目录
- 设置基础的 Fresh 项目结构
- 安装所有必需的依赖

进入新项目目录：

```sh
cd my-fresh-app
```

启动开发服务器：

```sh
deno task dev
```

打开浏览器，访问 `http://localhost:5173`，即可看到你的 Fresh 应用运行起来了！

## 了解项目结构

项目包含以下关键目录和文件：

```text
my-fresh-app/
├── assets/           # 静态资源（图片、CSS 等）
├── components/       # 可重用的 UI 组件
├── islands/          # 交互式组件（岛屿）
├── routes/           # 基于文件的路由
│  └── api/           # API 路由
├── static/           # 静态资源（图片、CSS 等）
├── main.ts           # 应用入口文件
├── deno.json         # Deno 配置文件
└── README.md         # 项目文档
```

## 添加恐龙数据

为了给应用添加恐龙数据，我们将创建一个简单的数据文件，里面包含一些恐龙的 JSON 信息。在真实应用中，这些数据可能来自数据库或外部 API，但为了简单起见，我们使用静态文件。

在 `routes/api` 目录下创建一个新文件 `data.json`，并复制这里的内容：
[链接](https://github.com/denoland/tutorial-with-fresh/blob/main/routes/api/data.json)。

## 显示恐龙列表

主页将显示一个可点击的恐龙列表，用户点击后可查看详细信息。我们更新 `routes/index.tsx` 文件来获取并展示恐龙数据。

首先将文件头部的 `<title>` 改为 "Dinosaur Encyclopedia"。然后添加一些基本的 HTML 来介绍应用。

```tsx title="index.tsx"
<main>
  <h1>🦕 Welcome to the Dinosaur Encyclopedia</h1>
  <p>Click on a dinosaur below to learn more.</p>
  <div class="dinosaur-list">
    {/* Dinosaur list will go here */}
  </div>
</main>;
```

我们将创建一个新组件，用于展示列表中的每个恐龙。

## 创建组件

在 `components/LinkButton.tsx` 文件中创建以下代码：

```tsx title="LinkButton.tsx"
import type { ComponentChildren } from "preact";

export interface LinkButtonProps {
  href?: string;
  class?: string;
  children?: ComponentChildren;
}

export function LinkButton(props: LinkButtonProps) {
  return (
    <a
      {...props}
      class={"btn " +
        (props.class ?? "")}
    />
  );
}
```

该组件渲染一个看起来像按钮的样式化链接，接收 `href`、`class` 和 `children` 属性。

最后，更新 `routes/index.tsx`，导入并使用新建的 `LinkButton` 组件来显示恐龙列表。

```tsx title="index.tsx"
import { Head } from "fresh/runtime";
import { define } from "../utils.ts";
import data from "./api/data.json" with { type: "json" };
import { LinkButton } from "../components/LinkButton.tsx";

export default define.page(function Home() {
  return (
    <>
      <Head>
        <title>Dinosaur Encyclopedia</title>
      </Head>
      <main>
        <h1>🦕 Welcome to the Dinosaur Encyclopedia</h1>
        <p>Click on a dinosaur below to learn more.</p>
        <div class="dinosaur-list">
          {data.map((dinosaur: { name: string; description: string }) => (
            <LinkButton
              href={`/dinosaurs/${dinosaur.name.toLowerCase()}`}
              class="btn-primary"
            >
              {dinosaur.name}
            </LinkButton>
          ))}
        </div>
      </main>
    </>
  );
});
```

## 创建动态路由

Fresh 允许我们通过基于文件的路由创建动态路由。我们将创建一个新路由来显示单个恐龙的详细信息。

在 `routes/dinosaurs/[name].tsx` 文件中，根据参数名获取恐龙数据并展示。

```tsx title="[dinosaur].tsx"
import { PageProps } from "$fresh/server.ts";
import data from "../api/data.json" with { type: "json" };
import { LinkButton } from "../../components/LinkButton.tsx";

export default function DinosaurPage(props: PageProps) {
  const name = props.params.dinosaur;
  const dinosaur = data.find((d: { name: string }) =>
    d.name.toLowerCase() === name.toLowerCase()
  );

  if (!dinosaur) {
    return (
      <main>
        <h1>Dinosaur not found</h1>
      </main>
    );
  }

  return (
    <main>
      <h1>{dinosaur.name}</h1>
      <p>{dinosaur.description}</p>
      <LinkButton href="/" class="btn-secondary">← Back to list</LinkButton>
    </main>
  );
}
```

## 使用岛屿添加交互

Fresh 的岛屿架构允许我们给特定组件添加交互，而不向客户端发送多余的 JavaScript。我们来创建一个简单的交互组件，允许用户“收藏”某只恐龙。

在 `islands/FavoriteButton.tsx` 文件中添加以下代码：

```tsx title="FavoriteButton.tsx"
import { useState } from "preact/hooks";

export default function FavoriteButton() {
  const [favorited, setFavorited] = useState(false);

  return (
    <button
      type="button"
      className={`btn fav ${favorited ? "btn-favorited" : "btn-primary"}`}
      onClick={() => setFavorited((f) => !f)}
    >
      {favorited ? "★ Favorited!" : "☆ Add to Favorites"}
    </button>
  );
}
```

它是一个简单按钮，点击时切换收藏状态。你也可以扩展它，将收藏状态存储到数据库或本地存储，实现更完整的功能。

接着，在 `routes/dinosaurs/[dinosaur].tsx` 顶部导入该 `FavoriteButton` 岛屿：

```tsx title="[dinosaur].tsx"
import FavoriteButton from "../../islands/FavoriteButton.tsx";
```

然后在 JSX 中添加 `<FavoriteButton />` 组件，比如放在返回列表按钮前面：

```tsx title="[dinosaur].tsx"
<FavoriteButton />;
```

## 应用样式

我们已经为应用准备了一些基础样式，但你也可以在 `assets/styles.css` 文件中添加自定义 CSS。在 `routes/_app.tsx` 的 `<head>` 中添加链接引用我们的样式表：

```tsx title="_app.tsx"
<link rel="stylesheet" href="https://demo-styles.deno.deno.net/styles.css" />;
```

## 运行应用

确认你的开发服务器正在运行：

```sh
deno task dev
```

打开浏览器访问 `http://localhost:5173`，查看你的恐龙目录应用！你应该可以查看恐龙列表，点击任意一项查看细节，并能通过“收藏”按钮切换收藏状态。

## 构建与部署

默认的 Fresh 应用附带了一个使用 Vite 构建应用的 `build` 任务。你可以通过以下命令来构建生产版本：

```sh
deno run build
```

该命令会将优化后的文件输出到 `_fresh` 目录。

要运行已构建的应用，可以使用 `start` 任务，它会自动加载 `_fresh` 中的优化资源：

```sh
deno task start
```

打开浏览器，访问 `http://localhost:8000`，查看生产环境的应用。

你可以将此应用部署到你喜欢的云服务商。我们推荐使用 [Deno Deploy](https://deno.com/deploy) 进行简单快速的部署。你只需将代码推送到 GitHub，然后与 Deno Deploy 连接即可。

### 创建 GitHub 仓库

[创建一个新的 GitHub 仓库](https://github.com/new)，然后初始化并推送你的应用代码：

```sh
git init -b main
git remote add origin https://github.com/<your_github_username>/<your_repo_name>.git
git add .
git commit -am 'my fresh app'
git push -u origin main
```

### 部署到 Deno Deploy

代码在 GitHub 后，可以
[部署到 Deno Deploy<sup>EA</sup>](https://console.deno.com/)。

如果想要部署教程，可以参考
[Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在你拥有了一个基础的 Fresh 应用！这里有一些扩展恐龙目录的建议：

- 添加数据库（尝试 [Deno KV](https://docs.deno.com/runtime/fundamentals/kv/) 或连接到 [PostgreSQL](https://docs.deno.com/runtime/tutorials/connecting_to_databases/)）
- 实现用户身份验证
- 增加更多交互功能如收藏或评分
- 连接外部 API 获取更多恐龙数据

Fresh 架构让你轻松构建快速、可扩展的 Web 应用，同时保持良好的开发体验。默认的服务器端渲染结合可选的客户端交互，为你提供了两者的最佳结合。

---

# 如何部署到 Google Cloud Run

> Step-by-step guide to deploying Deno applications on Google Cloud Run. Learn about Docker containerization, Artifact Registry configuration, GitHub Actions automation, and how to set up continuous deployment to Google Cloud.

URL: https://docs.deno.com/examples/tutorials/google_cloud_run


[Google Cloud Run](https://cloud.google.com/run) 是一个托管计算平台，允许您在 Google 可扩展的基础设施上运行容器。

本如何做指南将向您展示如何使用 Docker 将您的 Deno 应用程序部署到 Google Cloud Run。

首先，我们将向您展示如何手动部署，然后我们将展示如何使用 GitHub Actions 自动化部署。

先决条件：

- [Google Cloud Platform 账户](https://cloud.google.com/gcp)
- 已安装 [`docker` CLI](https://docs.docker.com/engine/reference/commandline/cli/)
- 已安装 [`gcloud`](https://cloud.google.com/sdk/gcloud)

## 手动部署

### 创建 `Dockerfile` 和 `docker-compose.yml`

为了集中关注部署，我们的应用程序将简单地为一个返回字符串的 `main.ts` 文件作为 HTTP 响应：

```ts title="main.ts"
import { Application } from "jsr:@oak/oak";

const app = new Application();

app.use((ctx) => {
  ctx.response.body = "Hello from Deno and Google Cloud Run!";
});

await app.listen({ port: 8000 });
```

然后，我们将创建两个文件——`Dockerfile` 和 `docker-compose.yml`——用于构建 Docker 镜像。

在我们的 `Dockerfile` 中，添加：

```Dockerfile
FROM denoland/deno

EXPOSE 8000

WORKDIR /app

ADD . /app

RUN deno install --entrypoint main.ts

CMD ["run", "--allow-net", "main.ts"]
```

然后，在我们的 `docker-compose.yml` 中：

```yml
version: "3"

services:
  web:
    build: .
    container_name: deno-container
    image: deno-image
    ports:
      - "8000:8000"
```

我们通过运行 `docker compose -f docker-compose.yml build` 接着 `docker compose up`，并访问 `localhost:8000` 来进行本地测试。

![Hello from localhost](./images/how-to/google-cloud-run/hello-world-from-localhost.png)

它成功了！

### 设置 Artifact Registry

Artifact Registry 是 GCP 的 Docker 镜像私有注册中心。

在我们可以使用它之前，请访问 GCP 的 [Artifact Registry](https://console.cloud.google.com/artifacts) 并点击 "创建存储库"。您将被要求输入一个名称（`deno-repository`）和区域（`us-central1`）。然后点击 "创建"。

![New repository in Google Artifact Repository](./images/how-to/google-cloud-run/new-repository-in-google-artifact-repository.png)

### 构建、标记并推送到 Artifact Registry

一旦我们创建了一个存储库，我们就可以开始向其推送镜像。

首先，让我们将注册表地址添加到 `gcloud`：

```shell
gcloud auth configure-docker us-central1-docker.pkg.dev
```

然后，让我们构建您的 Docker 镜像。（请注意，镜像名称在我们的 `docker-compose.yml` 文件中定义。）

```shell
docker compose -f docker-compose.yml build
```

然后，用新的 Google Artifact Registry 地址、存储库和名称标记它。镜像名称应遵循以下结构：
`{{ location }}-docker.pkg.dev/{{ google_cloudrun_project_name }}/{{ repository }}/{{ image }}`。

```shell
docker tag deno-image us-central1-docker.pkg.dev/deno-app-368305/deno-repository/deno-cloudrun-image
```

如果不指定标签，它将默认使用 `:latest`。

接下来，推送镜像：

```shell
docker push us-central1-docker.pkg.dev/deno-app-368305/deno-repository/deno-cloudrun-image
```

_[有关如何推送和拉取镜像到 Google Artifact Registry 的更多信息](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling)。_

您的镜像现在应该出现在您的 Google Artifact Registry 中！

![Image in Google Artifact Registry](./images/how-to/google-cloud-run/image-in-google-artifact-registry.png)

### 创建 Google Cloud Run 服务

我们需要一个实例来构建这些镜像，因此让我们访问 [Google Cloud Run](https://console.cloud.google.com/run) 并点击 "创建服务"。

让我们将其命名为 "hello-from-deno"。

选择 "从现有容器镜像部署一个修订版本"。使用下拉菜单选择来自 `deno-repository` Artifact Registry 的镜像。

选择 "允许未经身份验证的请求"，然后点击 "创建服务"。确保端口为 `8000`。

完成后，您的应用程序现在应该是在线的：

![Hello from Google Cloud Run](./images/how-to/google-cloud-run/hello-from-google-cloud-run.png)

太棒了！

### 使用 `gcloud` 部署

现在它已经创建，我们将能够从 `gcloud` CLI 部署到此服务。命令的结构如下：
`gcloud run deploy {{ service_name }} --image={{ image }} --region={{ region }} --allow-unauthenticated`。
请注意，`image` 名称遵循上面的结构。

在本示例中，命令为：

```shell
gcloud run deploy hello-from-deno --image=us-central1-docker.pkg.dev/deno-app-368305/deno-repository/deno-cloudrun-image --region=us-central1 --allow-unauthenticated
```

![Hello from Google Cloud Run](./images/how-to/google-cloud-run/hello-from-google-cloud-run.png)

成功！

## 使用 GitHub Actions 自动化部署

为了使自动化工作，我们首先需要确保这两个已经创建：

- Google Artifact Registry
- Google Cloud Run 服务实例

（如果您还没有做到这一点，请参见之前的部分。）

现在我们完成了，可以通过 GitHub 工作流自动化部署。以下是 yaml 文件：

```yml
name: Build and Deploy to Cloud Run

on:
  push:
    branches:
      - main

env:
  PROJECT_ID: { { PROJECT_ID } }
  GAR_LOCATION: { { GAR_LOCATION } }
  REPOSITORY: { { GAR_REPOSITORY } }
  SERVICE: { { SERVICE } }
  REGION: { { REGION } }

jobs:
  deploy:
    name: Deploy
    permissions:
      contents: "read"
      id-token: "write"

    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Google Auth
        id: auth
        uses: "google-github-actions/auth@v0"
        with:
          credentials_json: "${{ secrets.GCP_CREDENTIALS }}"

      - name: Login to GAR
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ env.GAR_LOCATION }}-docker.pkg.dev
          username: _json_key
          password: ${{ secrets.GCP_CREDENTIALS }}

      - name: Build and Push Container
        run: |-
          docker build -t "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.SERVICE }}:${{ github.sha }}" ./
          docker push "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.SERVICE }}:${{ github.sha }}"

      - name: Deploy to Cloud Run
        id: deploy
        uses: google-github-actions/deploy-cloudrun@v0
        with:
          service: ${{ env.SERVICE }}
          region: ${{ env.REGION }}
          image: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.SERVICE }}:${{ github.sha }}

      - name: Show Output
        run: echo ${{ steps.deploy.outputs.url }}
```

我们需要设置的环境变量是（括号中的示例是本存储库的）：

- `PROJECT_ID`: 您的项目 ID（`deno-app-368305`）
- `GAR_LOCATION`: 您的 Google Artifact Registry 的位置（`us-central1`）
- `GAR_REPOSITORY`: 您为 Google Artifact Registry 指定的名称（`deno-repository`）
- `SERVICE`: Google Cloud Run 服务的名称（`hello-from-deno`）
- `REGION`: 您的 Google Cloud Run 服务的区域（`us-central1`）

我们需要设置的秘密变量是：

- `GCP_CREDENTIALS`: 这是 [服务账户](https://cloud.google.com/iam/docs/service-accounts) 的 json 密钥。创建服务账户时，请确保 [包括必要的角色和权限](https://cloud.google.com/iam/docs/granting-changing-revoking-access#granting_access_to_a_user_for_a_service_account) 以便用于 Artifact Registry 和 Google Cloud Run。

[查看有关从 GitHub Actions 部署到 Cloud Run 的更多详细信息和示例。](https://github.com/google-github-actions/deploy-cloudrun)

供参考：
https://github.com/google-github-actions/example-workflows/blob/main/workflows/deploy-cloudrun/cloudrun-docker.yml


---

# How to export telemetry data to Grafana

> Complete guide to exporting telemetry data with OpenTelemetry and Grafana. Learn how to configure collectors, visualize traces, and monitor application performance.

URL: https://docs.deno.com/examples/tutorials/grafana


[OpenTelemetry](https://opentelemetry.io/) (often abbreviated as OTel) is an
open-source observability framework that provides a standardized way to collect
and export telemetry data such as traces, metrics and logs. Deno has built-in
support for OpenTelemetry, making it easy to instrument your applications
without adding external dependencies. This integration works out of the box with
observability platforms like [Grafana](https://grafana.com/).

Grafana is an open-source observability platform that lets DevOps teams
visualize, query, and alert on metrics, logs, and traces from diverse data
sources in real time. It’s widely used for building dashboards to monitor
infrastructure, applications, and systems health.

Grafana also offers a hosted version called
[Grafana Cloud](https://grafana.com/products/cloud/). This tutorial will help
you configure your project to export OTel data to Grafana Cloud.

In this tutorial, we'll build a simple application and export its telemetry data
to Grafana Cloud. We'll cover:

- [Set up your chat app](#set-up-your-chat-app)
- [Set up a Docker collector](#set-up-a-docker-collector)
- [Generating telemetry data](#generating-telemetry-data)
- [Viewing telemetry data](#viewing-telemetry-data)

You can find the complete source code for this tutorial
[on GitHub](https://github.com/denoland/examples/tree/main/with-grafana).

## Set up your chat app

For this tutorial, we'll use a simple chat application to demonstrate how to
export telemetry data. You can find the
[code for the app on GitHub](https://github.com/denoland/examples/tree/main/with-grafana).

Either take a copy of that repository or create a
[main.ts](https://github.com/denoland/examples/blob/main/with-grafana/main.ts)
file and a
[.env](https://github.com/denoland/examples/blob/main/with-grafana/.env.example)
file.

In order to run the app you will need an OpenAI API key. You can get one by
signing up for an account at [OpenAI](https://platform.openai.com/signup) and
creating a new secret key. You can find your API key in the
[API keys section](https://platform.openai.com/account/api-keys) of your OpenAI
account. Once you have an API key, set up an `OPENAI_API-KEY` environment
variable in your `.env` file:

```env title=".env"
OPENAI_API_KEY=your_openai_api_key
```

## Set up a Docker collector

Next, we'll set up a Docker container to run the OpenTelemetry collector. The
collector is responsible for receiving telemetry data from your application and
exporting it to Grafana Cloud.

In the same directory as your `main.ts` file, create a `Dockerfile` and an
`otel-collector.yml` file. The `Dockerfile` will be used to build a Docker
image:

```dockerfile title="Dockerfile"
FROM otel/opentelemetry-collector-contrib:latest

COPY otel-collector.yml /otel-config.yml

CMD ["--config", "/otel-config.yml"]
```

[`FROM otel/opentelemetry-collector-contrib:latest`](https://hub.docker.com/r/otel/opentelemetry-collector-contrib/) -
This line specifies the base image for the container. It uses the official
OpenTelemetry Collector Contributor image, which contains all receivers,
exporters, processors, connectors, and other optional components, and pulls the
latest version.

`COPY otel-collector.yml /otel-config.yml` - This instruction copies our
configuration file named `otel-collector.yml` from the local build context into
the container. The file is renamed to `/otel-config.yml` inside the container.

`CMD ["--config", "/otel-config.yml"]` - This sets the default command that will
run when the container starts. It tells the OpenTelemetry Collector to use the
configuration file we copied in the previous step.

Next, let's setup a Grafana Cloud account and grab some info.

If you have not already,
[create a free Grafana Cloud account](https://grafana.com/auth/sign-up/create-user).
Once created, you will receive a Grafana Cloud stack. Click "Details".

![Click details on your Grafana Cloud stack](./images/how-to/grafana/grafana-1.png)

Next, find "OpenTelemetry" and click "Configure".

![Find and configure OpenTelemetry](./images/how-to/grafana/grafana-2.png)

This page will provide you with all the details you'll need to configure your
OpenTelemetry collector. Make note of your **OTLP Endpoint**, **Instance ID**,
and **Password / API Token** (you will have to generate one).

![Configuring OTel in Grafana Cloud](./images/how-to/grafana/grafana-3.png)

Next, add the following to your `otel-collector.yml` file to define how how
telemetry data should be collected and exported to Grafana Cloud:

```yml title="otel-collector.yml"
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

exporters:
  otlphttp/grafana_cloud:
    endpoint: $_YOUR_GRAFANA_OTLP_ENDPOINT
    auth:
      authenticator: basicauth/grafana_cloud

extensions:
  basicauth/grafana_cloud:
    client_auth:
      username: $_YOUR_INSTANCE_ID
      password: $_YOUR_API_TOKEN

processors:
  batch:

service:
  extensions: [basicauth/grafana_cloud]
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/grafana_cloud]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/grafana_cloud]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/grafana_cloud]
```

The `receivers` section configures how the collector receives data. It sets up
an OTLP (OpenTelemetry Protocol) receiver that listens on two protocols, `gRPC`
and `HTTP`, the `0.0.0.0` address means it will accept data from any source.

The `exporters` section defines where the collected data should be sent. Be sure
to include **the OTLP endpoint** provided by your Grafana Cloud instance.

The `extensions` section defines the authentication for OTel to export data to
Grafana Cloud. Be sure to include your Grafana Cloud **Instance ID**, as well as
your generated **Password / API Token**.

The `processors` section defines how the data should be processed before export.
It uses batch processing with a timeout of 5 seconds and a maximum batch size of
5000 items.

The `service` section ties everything together by defining three pipelines. Each
pipeline is responsible for a different type of telemetry data. The logs
pipeline collects application logs. The traces pipeline is for distributed
tracing data. The metric pipeline is for performance metrics.

Build and run the docker instance to start collecting your telemetry data with
the following command:

```sh
docker build -t otel-collector . && docker run -p 4317:4317 -p 4318:4318 otel-collector
```

## Generating telemetry data

Now that we have the app and the docker container set up, we can start
generating telemetry data. Run your application with these environment variables
to send data to the collector:

```sh
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 \
OTEL_SERVICE_NAME=chat-app \
OTEL_DENO=true \
deno run --allow-net --allow-env --env-file --allow-read main.ts
```

This command:

- Points the OpenTelemetry exporter to your local collector (`localhost:4318`)
- Names your service "chat-app" in Grafana Cloud
- Enables Deno's OpenTelemetry integration
- Runs your application with the necessary permissions

To generate some telemetry data, make a few requests to your running application
in your browser at [`http://localhost:8000`](http://localhost:8000).

Each request will:

1. Generate traces as it flows through your application
2. Send logs from your application's console output
3. Create metrics about the request performance
4. Forward all this data through the collector to Grafana Cloud

## Viewing telemetry data

After making some requests to your application, you'll see three types of data
in your Grafana Cloud dashboard:

1. **Traces** - End-to-end request flows through your system
2. **Logs** - Console output and structured log data
3. **Metrics** - Performance and resource utilization data

![Viewing logs in Grafana](./images/how-to/grafana/grafana-logs.png)

You can drill down into individual spans to debug performance issues:

![Viewing traces in Grafana](./images/how-to/grafana/grafana-traces.png)

🦕 Now that you have telemetry export working, you could:

1. Add custom spans and attributes to better understand your application
2. Set up alerts based on latency or error conditions
3. Deploy your application and collector to production using platforms like:
   - [Fly.io](https://docs.deno.com/examples/deploying_deno_with_docker/)
   - [Digital Ocean](https://docs.deno.com/examples/digital_ocean_tutorial/)
   - [AWS Lightsail](https://docs.deno.com/examples/aws_lightsail_tutorial/)

For more details on OpenTelemetry configuration, check out the
[Grafana Cloud documentation](https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability/collector/).


---

# 可执行脚本

> Guide to creating executable scripts with Deno. Learn about hashbangs, file permissions, cross-platform compatibility, and how to create command-line tools that can run directly from the terminal.

URL: https://docs.deno.com/examples/tutorials/hashbang


使 Deno 脚本可执行在创建小工具或用于文件操作、数据处理或从命令行运行的重复任务等任务时非常方便。可执行脚本允许您创建即席解决方案，而无需设置整个项目。

## 创建示例脚本

要使脚本可执行，请以哈希bang（有时称为 shebang）开头。它是一串字符（#!），告诉您的操作系统如何执行脚本。后面跟着应用于运行脚本的解释器的路径。

:::note

要在 Windows 上使用哈希bang，您需要安装 Windows 子系统 Linux（WSL）或使用类似 Unix 的 shell，如
[Git Bash](https://git-scm.com/downloads)。

:::

我们将创建一个简单的脚本，使用 [Deno.env](/api/deno/~/Deno.env) API 打印 Deno 安装路径。

创建一个名为 `hashbang.ts` 的文件，内容如下：

```ts title="hashbang.ts"
#!/usr/bin/env -S deno run --allow-env
const path = Deno.env.get("DENO_INSTALL");

console.log("Deno 安装路径:", path);
```

该脚本告诉系统使用 deno 运行时来运行脚本。-S 标志将命令分割成参数，并指示应将后续参数（`deno run --allow-env`）传递给 env 命令。

然后，脚本使用 `Deno.env.get()` 检索与环境变量 `DENO_INSTALL` 关联的值，并将其分配给名为 `path` 的变量。最后，它使用 `console.log()` 将路径打印到控制台。

### 执行脚本

为了执行脚本，您可能需要给予脚本执行权限，您可以使用 `chmod` 命令和 `+x` 标志（用于执行）来实现：

```sh
chmod +x hashbang.ts
```

您可以直接在命令行中执行脚本：

```sh
./hashbang.ts
```

## 在没有扩展名的文件中使用哈希bang

为了简洁，您可能希望省略脚本文件名的扩展名。在这种情况下，在脚本本身中使用 `--ext` 标志提供一个，然后您可以仅使用文件名运行脚本：

```shell title="my_script"
$ cat my_script
#!/usr/bin/env -S deno run --allow-env --ext=js
console.log("你好!");
$ ./my_script
你好!
```

🦕 现在您可以直接从命令行执行 Deno 脚本！记得为您的脚本文件设置执行权限（`chmod +x`），您就可以开始构建从简单的实用工具到复杂工具的任何东西。查看 [Deno 示例](/examples/) 获取您可以编写的脚本灵感。

---

# How to export telemetry data to Honeycomb

> Complete guide to exporting telemetry data with OpenTelemetry and Honeycomb.io. Learn how to configure collectors, visualize traces, and monitor application performance.

URL: https://docs.deno.com/examples/tutorials/honeycomb


[OpenTelemetry](https://opentelemetry.io/) (often abbreviated as OTel) is an
open-source observability framework that provides a standardized way to collect
and export telemetry data such as traces, metrics and logs. Deno has built-in
support for OpenTelemetry, making it easy to instrument your applications
without adding external dependencies. This integration works out of the box with
observability platforms like [Honeycomb](https://honeycomb.io).

Honeycomb is an observability platform designed for debugging and understanding
complex, modern distributed systems.

In this tutorial, we'll build a simple application and export its telemetry data
to Honeycomb. We'll cover:

- [Set up your chat app](#set-up-your-chat-app)
- [Set up a Docker collector](#set-up-a-docker-collector)
- [Generating telemetry data](#generating-telemetry-data)
- [Viewing telemetry data](#viewing-telemetry-data)

You can find the complete source code for this tutorial
[on GitHub](https://github.com/denoland/examples/tree/main/with-honeycomb).

## Set up your chat app

For this tutorial, we'll use a simple chat application to demonstrate how to
export telemetry data. You can find the
[code for the app on GitHub](https://github.com/denoland/examples/tree/main/with-honeycomb).

Either take a copy of that repository or create a
[main.ts](https://github.com/denoland/examples/blob/main/with-honeycomb/main.ts)
file and a
[.env](https://github.com/denoland/examples/blob/main/with-honeycomb/.env.example)
file.

In order to run the app you will need an OpenAI API key. You can get one by
signing up for an account at [OpenAI](https://platform.openai.com/signup) and
creating a new secret key. You can find your API key in the
[API keys section](https://platform.openai.com/account/api-keys) of your OpenAI
account. Once you have an API key, set up an `OPENAI_API-KEY` environment
variable in your `.env` file:

```env title=".env"
OPENAI_API_KEY=your_openai_api_key
```

## Set up a Docker collector

Next, we'll set up a Docker container to run the OpenTelemetry collector. The
collector is responsible for receiving telemetry data from your application and
exporting it to Honeycomb.

If you have not already, create a free Honeycomb account and set up an
[ingest API key](https://docs.honeycomb.io/configure/environments/manage-api-keys/).

In the same directory as your `main.ts` file, create a `Dockerfile` and an
`otel-collector.yml` file. The `Dockerfile` will be used to build a Docker
image:

```dockerfile title="Dockerfile"
FROM otel/opentelemetry-collector:latest

COPY otel-collector.yml /otel-config.yml

CMD ["--config", "/otel-config.yml"]
```

`FROM otel/opentelemetry-collector:latest` - This line specifies the base image
for the container. It uses the official OpenTelemetry Collector image and pulls
the latest version.

`COPY otel-collector.yml /otel-config.yml` - This instruction copies our
configuration file named `otel-collector.yml` from the local build context into
the container. The file is renamed to `/otel-config.yml` inside the container.

`CMD ["--config", "/otel-config.yml"]` - This sets the default command that will
run when the container starts. It tells the OpenTelemetry Collector to use the
configuration file we copied in the previous step.

Next, add the following to your `otel-collector.yml` file to define how how
telemetry data should be collected and exported to Honeycomb:

```yml title="otel-collector.yml"
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

exporters:
  otlp:
    endpoint: "api.honeycomb.io:443"
    headers:
      x-honeycomb-team: $_HONEYCOMB_API_KEY

processors:
  batch:
    timeout: 5s
    send_batch_size: 5000

service:
  pipelines:
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlp]
```

The `receivers` section configures how the collector receives data. It sets up
an OTLP (OpenTelemetry Protocol) receiver that listens on two protocols, `gRPC`
and `HTTP`, the `0.0.0.0` address means it will accept data from any source.

The `exporters` section defines where the collected data should be sent. It's
configured to send data to Honeycomb's API endpoint at `api.honeycomb.io:443`.
The configuration requires an API key for authentication, swap
`$_HONEYCOMB_API_KEY` for your actual Honeycomb API key.

The `processors` section defines how the data should be processed before export.
It uses batch processing with a timeout of 5 seconds and a maximum batch size of
5000 items.

The `service` section ties everything together by defining three pipelines. Each
pipeline is responsible for a different type of telemetry data. The logs
pipeline collects application logs. The traces pipeline is for distributed
tracing data. The metric pipeline is for performance metrics.

Build and run the docker instance to start collecting your telemetry data with
the following command:

```sh
docker build -t otel-collector . && docker run -p 4317:4317 -p 4318:4318 otel-collector
```

## Generating telemetry data

Now that we have the app and the docker container set up, we can start
generating telemetry data. Run your application with these environment variables
to send data to the collector:

```sh
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 \
OTEL_SERVICE_NAME=chat-app \
OTEL_DENO=true \
deno run --allow-net --allow-env --env-file --allow-read main.ts
```

This command:

- Points the OpenTelemetry exporter to your local collector (`localhost:4318`)
- Names your service "chat-app" in Honeycomb
- Enables Deno's OpenTelemetry integration
- Runs your application with the necessary permissions

To generate some telemetry data, make a few requests to your running application
in your browser at [`http://localhost:8000`](http://localhost:8000).

Each request will:

1. Generate traces as it flows through your application
2. Send logs from your application's console output
3. Create metrics about the request performance
4. Forward all this data through the collector to Honeycomb

## Viewing telemetry data

After making some requests to your application, you'll see three types of data
in your Honeycomb.io dashboard:

1. **Traces** - End-to-end request flows through your system
2. **Logs** - Console output and structured log data
3. **Metrics** - Performance and resource utilization data

![Viewing traces in Honeycomb](./images/how-to/honeycomb/honeycomb-3.webp)

You can drill down into individual spans to debug performance issues:

![Viewing expanded traces in Honeycomb](./images/how-to/honeycomb/honeycomb-4.webp)

🦕 Now that you have telemetry export working, you could:

1. Add custom spans and attributes to better understand your application
2. Set up alerts based on latency or error conditions
3. Deploy your application and collector to production using platforms like:
   - [Fly.io](https://docs.deno.com/examples/deploying_deno_with_docker/)
   - [Digital Ocean](https://docs.deno.com/examples/digital_ocean_tutorial/)
   - [AWS Lightsail](https://docs.deno.com/examples/aws_lightsail_tutorial/)

For more details on OpenTelemetry configuration, check out the
[Honeycomb documentation](https://docs.honeycomb.io/send-data/opentelemetry/collector/).


---

# How to export telemetry data to HyperDX

> Complete guide to exporting telemetry data with OpenTelemetry and HyperDX. Learn how to configure collectors, visualize traces, logs, metrics, and debug distributed applications effectively.

URL: https://docs.deno.com/examples/tutorials/hyperdx


[HyperDX](https://hyperdx.io) is an open source observability platform that
unifies logs, traces, metrics, exceptions, and session replays into a single
interface. It helps developers debug applications faster by providing a complete
view of your system's behavior and performance.

[OpenTelemetry](https://opentelemetry.io/) (often abbreviated as OTel) provides
a standardized way to collect and export telemetry data. Deno includes built-in
OpenTelemetry support, allowing you to instrument your applications without
additional dependencies. This integration works seamlessly with platforms like
HyperDX to collect and visualize telemetry data.

In this tutorial, we'll build a simple application and export its telemetry data
to HyperDX:

- [Set up your chat app](#set-up-your-chat-app)
- [Set up a Docker collector](#set-up-a-docker-collector)
- [Generating telemetry data](#generating-telemetry-data)
- [Viewing telemetry data](#viewing-telemetry-data)

You can find the complete source code for this tutorial
[on GitHub](https://github.com/denoland/examples/tree/main/with-hyperdx).

## Set up the app

For this tutorial, we'll use a simple chat application to demonstrate how to
export telemetry data. You can find the
[code for the app on GitHub](https://github.com/denoland/examples/tree/main/with-hyperdx).

Either take a copy of that repository or create a
[main.ts](https://github.com/denoland/examples/blob/main/with-hyperdx/main.ts)
file and a
[.env](https://github.com/denoland/examples/blob/main/with-hyperdx/.env.example)
file.

In order to run the app you will need an OpenAI API key. You can get one by
signing up for an account at [OpenAI](https://platform.openai.com/signup) and
creating a new secret key. You can find your API key in the
[API keys section](https://platform.openai.com/account/api-keys) of your OpenAI
account. Once you have an API key, set up an `OPENAI_API-KEY` environment
variable in your `.env` file:

```env title=".env"
OPENAI_API_KEY=your_openai_api_key
```

## Set up the collector

First, create a free HyperDX account to get your API key. Then, we'll set up two
files to configure the OpenTelemetry collector:

1. Create a `Dockerfile`:

```dockerfile title="Dockerfile"
FROM otel/opentelemetry-collector:latest

COPY otel-collector.yml /otel-config.yml

CMD ["--config", "/otel-config.yml"]
```

This Dockerfile:

- Uses the official OpenTelemetry Collector as the base image
- Copies your configuration into the container
- Sets up the collector to use your config when it starts

2. Create a file called `otel-collector.yml`:

```yml title="otel-collector.yml"
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

exporters:
  otlphttp/hdx:
    endpoint: "https://in-otel.hyperdx.io"
    headers:
      authorization: $_HYPERDX_API_KEY
    compression: gzip

processors:
  batch:

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/hdx]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/hdx]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp/hdx]
```

This configuration file sets up the OpenTelemetry collector to receive telemetry
data from your application and export it to HyperDX. It includes:

- The receivers section accepts data via gRPC (4317) and HTTP (4318)
- The Exporters section sends data to HyperDX with compression and
  authentication
- The processors section batches telemetry data for efficient transmission
- The pipelines section defines separate flows for logs, traces, and metrics

Build and run the docker instance to start collecting your telemetry data with
the following command:

```sh
docker build -t otel-collector . && docker run -p 4317:4317 -p 4318:4318 otel-collector
```

## Generating telemetry data

Now that we have the app and the docker container set up, we can start
generating telemetry data. Run your application with these environment variables
to send data to the collector:

```sh
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 \
OTEL_SERVICE_NAME=chat-app \
OTEL_DENO=true \
deno run --allow-net --allow-env --env-file --allow-read main.ts
```

This command:

- Points the OpenTelemetry exporter to your local collector (`localhost:4318`)
- Names your service "chat-app" in HyperDX
- Enables Deno's OpenTelemetry integration
- Runs your application with the necessary permissions

To generate some telemetry data, make a few requests to your running application
in your browser at [`http://localhost:8000`](http://localhost:8000).

Each request will:

1. Generate traces as it flows through your application
2. Send logs from your application's console output
3. Create metrics about the request performance
4. Forward all this data through the collector to HyperDX

## Viewing telemetry data

In your HyperDX dashboard, you'll see different views of your telemetry data:

### Logs View

![Viewing logs in HyperDX](./images/how-to/hyperdx/hyperdx-1.webp)

Click any log to see details:
![Viewing a single log in HyperDX](./images/how-to/hyperdx/hyperdx-2.webp)

### Request Traces

See all logs within a single request:
![Viewing all logs in a request in HyperDX](./images/how-to/hyperdx/hyperdx-3.webp)

### Metrics Dashboard

Monitor system performance:
![Viewing metrics in HyperDX](./images/how-to/hyperdx/hyperdx-4.webp)

🦕 Now that you have telemetry export working, you could:

1. Add custom spans and attributes to better understand your application
2. Set up alerts based on latency or error conditions
3. Deploy your application and collector to production using platforms like:
   - [Fly.io](https://docs.deno.com/examples/deploying_deno_with_docker/)
   - [Digital Ocean](https://docs.deno.com/examples/digital_ocean_tutorial/)
   - [AWS Lightsail](https://docs.deno.com/examples/aws_lightsail_tutorial/)

🦕 For more details on OpenTelemetry configuration with HyperDX, see their
[documentation](https://www.hyperdx.io/docs/install/opentelemetry).


---

# 初始化一个项目

> Guide to creating and structuring new Deno projects. Learn about starting a new project, task configuration, dependency management, and best practices for growing applications.

URL: https://docs.deno.com/examples/tutorials/initialize_project


虽然可以直接使用 `deno run` 运行脚本，但对于较大的项目，建议创建一个合理的目录结构。这样你可以更轻松地组织代码、管理依赖、编写脚本任务和运行测试。

通过运行以下命令初始化一个新项目：

```sh
deno init my_project
```

其中 `my_project` 是你的项目名称。你可以
[阅读更多关于项目结构的信息](/runtime/getting_started/first_project/)。

### 运行你的项目

导航到项目目录：

```sh
cd my_project
```

然后你可以直接使用 `deno task` 命令运行项目：

```sh
deno run dev
```

查看你新项目中的 `deno.json` 文件。你应该在 "tasks" 字段看到一个 `dev` 任务。

```json title="deno.json"
"tasks": {
  "dev": "deno run --watch main.ts"
},
```

`dev` 任务是一个常见任务，用于在开发模式下运行项目。正如你所看到的，它使用 `--watch` 标志运行 `main.ts` 文件，当有更改时会自动重新加载脚本。如果你打开 `main.ts` 文件并进行更改，就可以看到这一点的实际效果。

### 运行测试

在项目目录中运行：

```sh
deno test
```

这将执行项目中的所有测试。你可以阅读更多关于
[在 Deno 中测试的信息](/runtime/fundamentals/testing/)，我们将在稍后的教程中更深入地讨论测试。此时你有一个测试文件 `main_test.ts`，它测试 `main.ts` 中的 `add` 函数。

### 向你的项目添加内容

`main.ts` 文件作为应用程序的入口点。这里是你编写主要程序逻辑的地方。在开发项目时，你将从删除默认的加法程序开始，并将其替换为自己的代码。例如，如果你正在构建一个网络服务器，这里是你设置路由和处理请求的地方。

除了初始文件外，你可能还会创建其他模块（文件）来组织代码。考虑将相关功能分组成单独的文件。请记住，Deno [支持 ES 模块](/runtime/fundamentals/modules/)，因此你可以使用导入和导出语句来组织代码。

Deno 项目的示例文件夹结构：

```sh
my_project/
├── deno.json
├── main.ts
├── main_test.ts
├── routes/
│   ├── home.ts
│   ├── about.ts
├── services/
│   ├── user.ts
│   ├── post.ts
└── utils/
    ├── logger.ts
    ├── logger_test.ts
    ├── validator_test.ts
    └── validator.ts
```

这种结构可以保持你的项目整洁，并更容易找到和管理文件。

🦕 恭喜你！现在你知道如何用 `deno init` 创建一个全新的项目。请记住，Deno 鼓励简洁，避免复杂的构建工具。保持你的项目模块化、可测试且有条理。随着项目的发展，调整结构以适应你的需求。最重要的是，享受探索 Deno 功能的乐趣！

---

# 如何在 Kinsta 上部署 Deno

> Step-by-step guide to deploying Deno applications on Kinsta. Learn how to configure package.json, handle environment variables, set up Git deployments, and use Kinsta's application hosting platform.

URL: https://docs.deno.com/examples/tutorials/kinsta


[Kinsta 应用托管](https://kinsta.com/application-hosting)是一项服务，让您可以直接从 Git 仓库构建和部署您的 Web 应用。

## 准备您的应用

在 **Kinsta**，我们建议使用 [`deno-bin`](https://www.npmjs.com/package/deno-bin) 包来运行 Deno 应用。

为此，您的 `package.json` 应该如下所示：

```json title="package.json"
{
  "name": "deno app",
  "scripts": {
    "start": "deno run --allow-net index.js --port=${PORT}"
  },
  "devDependencies": {
    "deno-bin": "^1.28.2"
  }
}
```

## 示例应用

```js
import { parseArgs } from "jsr:@std/cli";

const { args } = Deno;
const port = parseArgs(args).port ? Number(parseArgs(args).port) : 8000;

Deno.serve({ port }, (_req) => new Response("Hello, world"));
```

应用本身不言自明。重要的是不要硬编码 `PORT`，而是使用 **Kinsta** 提供的环境变量。

还有一个 [仓库](https://github.com/kinsta/hello-world-deno) 可以帮助您入门。

## 部署

1. 在 [Kinsta 应用托管](https://kinsta.com/signup/?product_type=app-db) 注册，或直接登录 [My Kinsta](https://my.kinsta.com/) 管理面板。
2. 转到应用程序选项卡。
3. 连接您的 GitHub 仓库。
4. 按下 **添加服务 > 应用程序按钮**。
5. 按照向导步骤操作。

---

# Build a Real-time LLM Chat App with Deno

> Learn how to integrate Large Language Models (LLM) with Deno to create an interactive roleplay chat application with AI characters using OpenAI or Anthropic APIs.

URL: https://docs.deno.com/examples/tutorials/llm


Large Language Models (LLMs) like OpenAI's GPT and Anthropic's Claude are
powerful tools for creating intelligent, conversational applications. In this
tutorial, we'll build a real-time chat application where AI characters powered
by LLMs interact with users in a roleplay game setting.

You can see the code for the
[finished app on GitHub](https://github.com/denoland/tutorial-with-llm).

:::info Deploy your own

Want to skip the tutorial and deploy the finished app right now? Click the
button below to instantly deploy your own copy of the complete LLM chat
application to Deno Deploy. You'll get a live, working application that you can
customize and modify as you learn!

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-llm&mode=dynamic&entrypoint=main.ts&install=deno+install)

Once you have deployed, add your `OPENAI_API_KEY` or `ANTHROPIC_API_KEY` in the
project "Settings".

:::

## Initialize a new project

First, create a new directory for your project and initialize it:

```bash
mkdir deno-llm-chat
cd deno-llm-chat
deno init
```

## Project structure

We'll create a modular structure that separates concerns between LLM
integration, game logic, and server management:

```sh
├── main.ts                 # Main server entry point
├── main_test.ts            # Test file
├── deno.json               # Deno configuration
├── .env                    # Environment variables (API keys)
├── src/
│   ├── config/
│   │   ├── characters.ts   # Character configurations and presets
│   │   └── scenarios.ts    # Pre-defined scenario templates
│   ├── game/
│   │   ├── GameManager.ts  # Core game logic and state management
│   │   └── Character.ts    # AI character implementation
│   ├── llm/
│   │   └── LLMProvider.ts  # LLM integration layer (OpenAI/Anthropic)
│   └── server/
│       └── WebSocketHandler.ts # Real-time communication
└── static/
    ├── index.html         # Web interface
    ├── app.js            # Frontend JavaScript
    └── styles.css        # Application styling
```

## Set up dependencies

Add the required dependencies to your `deno.json`:

```json title="deno.json"
{
  "tasks": {
    "dev": "deno run -A --env-file --watch main.ts",
    "start": "deno run --allow-net --allow-env --allow-read main.ts",
    "test": "deno test --allow-net --allow-env"
  },
  "imports": {
    "@std/assert": "jsr:@std/assert@1",
    "@std/http": "jsr:@std/http@1",
    "@std/uuid": "jsr:@std/uuid@1",
    "@std/json": "jsr:@std/json@1"
  },
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.asynciterable",
      "deno.ns"
    ]
  }
}
```

## Configure environment variables

Create a `.env` file for your API keys. The application supports both OpenAI and
Anthropic. Comment out the config that you won't be using with a `#`.

```bash title=".env"
# Choose one of the following LLM providers:

# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here

# OR Anthropic Configuration  
# ANTHROPIC_API_KEY=your-anthropic-api-key-here

# Server Configuration (optional)
PORT=8000
```

You can get API keys from:

- [OpenAI Platform](https://platform.openai.com/api-keys)
- [Anthropic Console](https://console.anthropic.com/)

## Build the LLM Provider

The core of our application is the LLM provider that handles communication with
AI services. Create `src/llm/LLMProvider.ts`:

```typescript title="src/llm/LLMProvider.ts"
export interface LLMConfig {
  provider: "openai" | "anthropic" | "mock";
  apiKey?: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
}

export class LLMProvider {
  private config: LLMConfig;
  private rateLimitedUntil: number = 0;
  private retryCount: number = 0;
  private maxRetries: number = 3;

  constructor(config?: Partial<LLMConfig>) {
    const apiKey = config?.apiKey ||
      Deno.env.get("OPENAI_API_KEY") ||
      Deno.env.get("ANTHROPIC_API_KEY");

    // Auto-detect provider based on available API keys
    let provider = config?.provider;
    if (!provider && apiKey) {
      if (Deno.env.get("OPENAI_API_KEY")) {
        provider = "openai";
      } else if (Deno.env.get("ANTHROPIC_API_KEY")) {
        provider = "anthropic";
      }
    }

    this.config = {
      provider: provider || "mock",
      model: provider === "anthropic"
        ? "claude-3-haiku-20240307"
        : "gpt-3.5-turbo",
      maxTokens: 150,
      temperature: 0.8,
      ...config,
      apiKey,
    };

    console.log(`LLM Provider initialized: ${this.config.provider}`);
  }

  async generateResponse(prompt: string): Promise<string> {
    // Check rate limiting
    if (this.rateLimitedUntil > Date.now()) {
      console.warn("Rate limited, using mock response");
      return this.mockResponse(prompt);
    }

    try {
      switch (this.config.provider) {
        case "openai":
          return await this.callOpenAI(prompt);
        case "anthropic":
          return await this.callAnthropic(prompt);
        case "mock":
        default:
          return this.mockResponse(prompt);
      }
    } catch (error) {
      console.error("LLM API error:", error);

      if (this.shouldRetry(error)) {
        this.retryCount++;
        if (this.retryCount <= this.maxRetries) {
          console.log(`Retrying... (${this.retryCount}/${this.maxRetries})`);
          await this.delay(1000 * this.retryCount);
          return this.generateResponse(prompt);
        }
      }

      return this.mockResponse(prompt);
    }
  }

  private async callOpenAI(prompt: string): Promise<string> {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.config.apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: this.config.model,
        messages: [{ role: "user", content: prompt }],
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    this.retryCount = 0; // Reset on success
    return data.choices[0].message.content.trim();
  }

  private async callAnthropic(prompt: string): Promise<string> {
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": this.config.apiKey!,
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01",
      },
      body: JSON.stringify({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        messages: [{ role: "user", content: prompt }],
        temperature: this.config.temperature,
      }),
    });

    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.status}`);
    }

    const data = await response.json();
    this.retryCount = 0; // Reset on success
    return data.content[0].text.trim();
  }

  private mockResponse(prompt: string): string {
    const responses = [
      "I understand! Let me think about this...",
      "That's an interesting approach to the situation.",
      "I see what you're getting at. Here's what I think...",
      "Fascinating! I would approach it this way...",
      "Good point! That gives me an idea...",
    ];

    return responses[Math.floor(Math.random() * responses.length)];
  }

  private shouldRetry(error: any): boolean {
    // Retry on rate limits and temporary server errors
    const errorMessage = error.message?.toLowerCase() || "";
    return errorMessage.includes("rate limit") ||
      errorMessage.includes("429") ||
      errorMessage.includes("500") ||
      errorMessage.includes("502") ||
      errorMessage.includes("503");
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
```

In this file we set an LLM provider, this allows us to easily switch between
different LLM APIs or mock responses for testing. We also add a retry mechanism
for handling API errors.

## Create AI Characters

Characters are the heart of our roleplay application. Create
`src/game/Character.ts`:

```typescript title="src/game/Character.ts"
import { LLMProvider } from "../llm/LLMProvider.ts";

export class Character {
  public name: string;
  public class: string;
  public personality: string;
  public conversationHistory: string[] = [];
  private llmProvider: LLMProvider;

  constructor(
    name: string,
    characterClass: string,
    personality: string,
    llmProvider: LLMProvider,
  ) {
    this.name = name;
    this.class = characterClass;
    this.personality = personality;
    this.llmProvider = llmProvider;
  }

  async generateResponse(
    context: string,
    userMessage: string,
  ): Promise<string> {
    // Build the character's prompt with personality and context
    const characterPrompt = `
You are ${this.name}, a ${this.class} with this personality: ${this.personality}

Context: ${context}

Recent conversation:
${this.conversationHistory.slice(-3).join("\n")}

User message: ${userMessage}

Respond as ${this.name} in character. Keep responses under 150 words and maintain your personality traits. Be engaging and helpful to advance the roleplay scenario.
        `.trim();

    try {
      const response = await this.llmProvider.generateResponse(characterPrompt);

      // Add to conversation history
      this.conversationHistory.push(`User: ${userMessage}`);
      this.conversationHistory.push(`${this.name}: ${response}`);

      // Keep history manageable
      if (this.conversationHistory.length > 20) {
        this.conversationHistory = this.conversationHistory.slice(-10);
      }

      return response;
    } catch (error) {
      console.error(`Error generating response for ${this.name}:`, error);
      return `*${this.name} seems lost in thought and doesn't respond*`;
    }
  }

  getCharacterInfo() {
    return {
      name: this.name,
      class: this.class,
      personality: this.personality,
    };
  }

  clearHistory() {
    this.conversationHistory = [];
  }
}
```

Here we define the `Character` class, which represents each player character in
the game. This class will handle generating responses based on the character's
personality and the current game context.

## Set up character configurations

Create predefined character templates in `src/config/characters.ts`:

```typescript title="src/config/characters.ts"
export interface CharacterConfig {
  name: string;
  class: string;
  personality: string;
  emoji?: string;
  backstory?: string;
}

export const defaultCharacters: CharacterConfig[] = [
  {
    name: "Tharin",
    emoji: "⚔️",
    class: "Fighter",
    personality:
      "Brave and loyal team leader, always ready to protect allies. Takes charge in dangerous situations but listens to party input.",
    backstory: "A former city guard seeking adventure and justice.",
  },
  {
    name: "Lyra",
    emoji: "🔮",
    class: "Wizard",
    personality:
      "Curious and analytical strategist, loves solving puzzles. Uses magic creatively to support the party.",
    backstory: "A scholar of ancient magic seeking forgotten spells.",
  },
  {
    name: "Finn",
    emoji: "🗡️",
    class: "Rogue",
    personality:
      "Witty and sneaky scout, prefers clever solutions. Acts quickly and adapts to what allies need.",
    backstory: "A former street thief now using skills for good.",
  },
];
```

These templates are what the `Character` class will use to instantiate each
character with their unique traits. The LLM will use these traits to generate
responses that are consistent with each character's personality and backstory.

## Build the Game Manager

The Game Manager coordinates characters and maintains game state. Create
`src/game/GameManager.ts`:

```typescript title="src/game/GameManager.ts"
import { Character } from "./Character.ts";
import { LLMProvider } from "../llm/LLMProvider.ts";

export interface GameState {
  id: string;
  gmPrompt: string;
  characters: Character[];
  messages: GameMessage[];
  currentTurn: number;
  isActive: boolean;
  createdAt: Date;
}

export interface GameMessage {
  id: string;
  speaker: string;
  message: string;
  timestamp: Date;
  type: "gm" | "character" | "system";
}

export interface StartGameRequest {
  gmPrompt: string;
  characters: Array<{
    name: string;
    class: string;
    personality: string;
  }>;
}

export class GameManager {
  private games: Map<string, GameState> = new Map();
  private llmProvider: LLMProvider;

  constructor() {
    this.llmProvider = new LLMProvider();
  }

  async startNewGame(
    gmPrompt: string,
    characterConfigs: StartGameRequest["characters"],
  ): Promise<string> {
    const gameId = crypto.randomUUID();

    // Create characters with their LLM personalities
    const characters = characterConfigs.map((config) =>
      new Character(
        config.name,
        config.class,
        config.personality,
        this.llmProvider,
      )
    );

    const gameState: GameState = {
      id: gameId,
      gmPrompt,
      characters,
      messages: [],
      currentTurn: 0,
      isActive: true,
      createdAt: new Date(),
    };

    this.games.set(gameId, gameState);

    // Add initial system message
    this.addMessage(gameId, {
      speaker: "System",
      message: `Game started! Players: ${
        characters.map((c) => c.name).join(", ")
      }`,
      type: "system",
    });

    console.log(`New game started: ${gameId}`);
    return gameId;
  }

  async handlePlayerMessage(
    gameId: string,
    message: string,
  ): Promise<GameMessage[]> {
    const game = this.games.get(gameId);
    if (!game || !game.isActive) {
      throw new Error("Game not found or inactive");
    }

    // Add player message
    this.addMessage(gameId, {
      speaker: "Player",
      message,
      type: "gm",
    });

    // Generate responses from each character
    const responses: GameMessage[] = [];

    for (const character of game.characters) {
      try {
        const context = this.buildContext(game);
        const response = await character.generateResponse(context, message);

        const characterMessage = this.addMessage(gameId, {
          speaker: character.name,
          message: response,
          type: "character",
        });

        responses.push(characterMessage);

        // Small delay between character responses for realism
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        console.error(`Error getting response from ${character.name}:`, error);
      }
    }

    game.currentTurn++;
    return responses;
  }

  private buildContext(game: GameState): string {
    const recentMessages = game.messages.slice(-5);
    const context = [
      `Scenario: ${game.gmPrompt}`,
      `Current turn: ${game.currentTurn}`,
      "Recent events:",
      ...recentMessages.map((m) => `${m.speaker}: ${m.message}`),
    ].join("\n");

    return context;
  }

  private addMessage(
    gameId: string,
    messageData: Omit<GameMessage, "id" | "timestamp">,
  ): GameMessage {
    const game = this.games.get(gameId);
    if (!game) throw new Error("Game not found");

    const message: GameMessage = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      ...messageData,
    };

    game.messages.push(message);
    return message;
  }

  getGame(gameId: string): GameState | undefined {
    return this.games.get(gameId);
  }

  getActiveGames(): string[] {
    return Array.from(this.games.entries())
      .filter(([_, game]) => game.isActive)
      .map(([id, _]) => id);
  }

  endGame(gameId: string): boolean {
    const game = this.games.get(gameId);
    if (game) {
      game.isActive = false;
      console.log(`Game ended: ${gameId}`);
      return true;
    }
    return false;
  }
}
```

The game manager will handle all game-related logic, including starting new
games, processing player messages, and managing game state. When a player sends
a message, the game manager will route it to the appropriate character for
response generation.

## Add WebSocket Support

Real-time communication makes the roleplay experience more engaging. Create
`src/server/WebSocketHandler.ts`:

```typescript title="src/server/WebSocketHandler.ts"
import { GameManager } from "../game/GameManager.ts";

export interface WebSocketMessage {
  type: "start_game" | "send_message" | "join_game" | "get_game_state";
  gameId?: string;
  data?: any;
}

export class WebSocketHandler {
  private gameManager: GameManager;
  private connections: Map<string, WebSocket> = new Map();

  constructor(gameManager: GameManager) {
    this.gameManager = gameManager;
  }

  handleConnection(request: Request): Response {
    const { socket, response } = Deno.upgradeWebSocket(request);

    const connectionId = crypto.randomUUID();
    this.connections.set(connectionId, socket);

    socket.onopen = () => {
      console.log(`WebSocket connection opened: ${connectionId}`);
      this.sendMessage(socket, {
        type: "connection",
        data: { connectionId, message: "Connected to LLM Chat server" },
      });
    };

    socket.onmessage = async (event) => {
      try {
        const message: WebSocketMessage = JSON.parse(event.data);
        await this.handleMessage(socket, message);
      } catch (error) {
        console.error("Error handling WebSocket message:", error);
        this.sendError(socket, "Invalid message format");
      }
    };

    socket.onclose = () => {
      console.log(`WebSocket connection closed: ${connectionId}`);
      this.connections.delete(connectionId);
    };

    socket.onerror = (error) => {
      console.error(`WebSocket error for ${connectionId}:`, error);
    };

    return response;
  }

  private async handleMessage(socket: WebSocket, message: WebSocketMessage) {
    switch (message.type) {
      case "start_game":
        await this.handleStartGame(socket, message.data);
        break;
      case "send_message":
        await this.handleSendMessage(socket, message);
        break;
      case "get_game_state":
        await this.handleGetGameState(socket, message.gameId!);
        break;
      default:
        this.sendError(socket, `Unknown message type: ${message.type}`);
    }
  }

  private async handleStartGame(socket: WebSocket, data: any) {
    try {
      const { gmPrompt, characters } = data;
      const gameId = await this.gameManager.startNewGame(gmPrompt, characters);

      this.sendMessage(socket, {
        type: "game_started",
        data: {
          gameId,
          message:
            "Game started successfully! You can now send messages to interact with your characters.",
        },
      });
    } catch (error) {
      this.sendError(socket, `Failed to start game: ${error.message}`);
    }
  }

  private async handleSendMessage(
    socket: WebSocket,
    message: WebSocketMessage,
  ) {
    try {
      const { gameId, data } = message;
      if (!gameId) {
        this.sendError(socket, "Game ID required");
        return;
      }

      const responses = await this.gameManager.handlePlayerMessage(
        gameId,
        data.message,
      );

      this.sendMessage(socket, {
        type: "character_responses",
        data: { gameId, responses },
      });
    } catch (error) {
      this.sendError(socket, `Failed to process message: ${error.message}`);
    }
  }

  private async handleGetGameState(socket: WebSocket, gameId: string) {
    try {
      const game = this.gameManager.getGame(gameId);
      if (!game) {
        this.sendError(socket, "Game not found");
        return;
      }

      this.sendMessage(socket, {
        type: "game_state",
        data: {
          gameId,
          characters: game.characters.map((c) => c.getCharacterInfo()),
          messages: game.messages.slice(-10), // Last 10 messages
          isActive: game.isActive,
        },
      });
    } catch (error) {
      this.sendError(socket, `Failed to get game state: ${error.message}`);
    }
  }

  private sendMessage(socket: WebSocket, message: any) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  }

  private sendError(socket: WebSocket, error: string) {
    this.sendMessage(socket, {
      type: "error",
      data: { error },
    });
  }
}
```

Here we set up the WebSocket server to handle connections and messages.
Websockets allow for real-time communication between the client and server,
making them ideal for interactive applications like a chat app, or game. We send
messages back and forth between the client and server to keep the game state in
sync.

## Create the main server

Now let's tie everything together in `main.ts`:

```typescript title="main.ts"
import { GameManager } from "./src/game/GameManager.ts";
import { WebSocketHandler } from "./src/server/WebSocketHandler.ts";
import { defaultCharacters } from "./src/config/characters.ts";

const gameManager = new GameManager();
const wsHandler = new WebSocketHandler(gameManager);

async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);

  // Handle WebSocket connections
  if (req.headers.get("upgrade") === "websocket") {
    return wsHandler.handleConnection(req);
  }

  // Serve static files and API endpoints
  switch (url.pathname) {
    case "/":
      return new Response(await getIndexHTML(), {
        headers: { "content-type": "text/html" },
      });

    case "/api/characters":
      return new Response(JSON.stringify(defaultCharacters), {
        headers: { "content-type": "application/json" },
      });

    case "/api/game/start":
      if (req.method === "POST") {
        try {
          const body = await req.json();
          const gameId = await gameManager.startNewGame(
            body.gmPrompt,
            body.characters,
          );
          return new Response(JSON.stringify({ gameId }), {
            headers: { "content-type": "application/json" },
          });
        } catch (error) {
          return new Response(
            JSON.stringify({ error: error.message }),
            {
              status: 400,
              headers: { "content-type": "application/json" },
            },
          );
        }
      }
      break;

    case "/api/game/message":
      if (req.method === "POST") {
        try {
          const body = await req.json();
          const responses = await gameManager.handlePlayerMessage(
            body.gameId,
            body.message,
          );
          return new Response(JSON.stringify({ responses }), {
            headers: { "content-type": "application/json" },
          });
        } catch (error) {
          return new Response(
            JSON.stringify({ error: error.message }),
            {
              status: 400,
              headers: { "content-type": "application/json" },
            },
          );
        }
      }
      break;

    default:
      return new Response("Not Found", { status: 404 });
  }

  return new Response("Method Not Allowed", { status: 405 });
}

async function getIndexHTML(): Promise<string> {
  try {
    return await Deno.readTextFile("./static/index.html");
  } catch {
    // Return a basic HTML template if file doesn't exist
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <title>LLM Roleplay Chat</title>
</head>
<body>
   <h1>Oops! Something went wrong.</h1>
</body>
</html>
    `;
  }
}

const port = parseInt(Deno.env.get("PORT") || "8000");
console.log(`🎭 LLM Chat server starting on http://localhost:${port}`);

Deno.serve({ port }, handler);
```

In the `main.ts` file we set up an HTTP server and a WebSocket server to handle
real-time communication. We use the HTTP server to serve static files and
provide API endpoints, while the WebSocket server manages real-time interactions
between clients.

## Add a frontend

The frontend of our app will live in the `static` directory. Create an
`index.html`, `app.js` and a `style.css` file in the `static` directory.

### `index.html`

We'll create a very basic layout with a textarea to collect the user's scenario
input and a section to show the response messages with a text input to send
messages. Copy the content from
[this html file](https://github.com/denoland/tutorial-with-llm/blob/main/static/index.html)
into your `index.html`.

### `app.js`

In `app.js`, we'll add the JavaScript to handle user input and display
responses. Copy the content from
[this js file](https://github.com/denoland/tutorial-with-llm/blob/main/static/app.js)
into your `app.js`.

### `style.css`

We'll add some basic styles to make our app look nicer. Copy the content from
[this css file](https://github.com/denoland/tutorial-with-llm/blob/main/static/style.css)
into your `style.css`.

## Run your application

Start your development server:

```bash
deno task dev
```

Your LLM chat application will be available at `http://localhost:8000`. The
application will:

1. **Auto-detect your LLM provider** based on available API keys
2. **Fall back to mock responses** if no API keys are configured
3. **Handle rate limiting** gracefully with retries and fallbacks
4. **Provide real-time interaction** through WebSockets

## Deploy your application to the cloud

Now that you have your working LLM chat application, you can deploy it to the
cloud with Deno Deploy<sup>EA</sup>.

For the best experience, you can deploy your app directly from GitHub, which
will set up automated deployments. Create a GitHub repository and push your app
there.

[Create a new GitHub repository](https://github.com/new), then initialize and
push your app to GitHub:

```sh
git init -b main
git remote add origin https://github.com/<your_github_username>/<your_repo_name>.git
git add .
git commit -am 'initial commit'
git push -u origin main
```

Once your app is on GitHub, you can
[deploy it to Deno Deploy<sup>EA</sup>](https://console.deno.com/).

Don't forget to add your `OPENAI_API_KEY` or `ANTHROPIC_API_KEY` environment
variables in the project "Settings".

For a walkthrough of deploying your app, check out the
[Deno Deploy tutorial](/examples/deno_deploy_tutorial/).

## Testing

We've provided tests to verify your setup, copy the
[`main.test.ts`](https://github.com/denoland/tutorial-with-llm/blob/main/tests/main.test.ts)
file to your project directory and run the included tests to verify your setup:

```bash
deno task test
```

🦕 You now have a working LLM chat application, with realtime interaction, rate
limiting and error handling. Next you can customise it to your own play style!
Consider giving the LLM instructions on how to behave in different scenarios, or
how to respond to specific user inputs. You can add these into the character
configuration files.

You could also consider adding a database to store the conversation history for
long-term character and story development.


---

# 使用 Mock 进行隔离测试

> 掌握单元测试中的 Mock 技巧。了解如何使用 Spy、Stub、模拟时间及 Deno 其他工具来提升代码质量与测试可信度

URL: https://docs.deno.com/examples/tutorials/mocking


本指南基于
[Deno 测试基础](/examples/testing_tutorial/)，重点介绍可帮助你在测试中隔离代码的 Mock 技术。

为了实现高效的单元测试，你经常需要“模拟”（mock）代码所交互的数据。Mock 是一种测试技术，通过用可控的模拟数据替代真实数据来测试代码。当测试与外部服务（比如 API 或数据库）交互的组件时，这尤为有用。

Deno 标准库提供了[便捷的 Mock 工具](https://jsr.io/@std/testing/doc/mock)，让你的测试更轻松编写、更可靠且执行更快。

### 监听 (Spying)

在 Deno 中，你可以使用 [`spy`](https://jsr.io/@std/testing/doc/mock#spying) 监听函数调用情况。Spy 不会改变函数行为，但会记录如函数被调用次数及传入参数等重要信息。

通过使用 Spy，你可以检验代码是否与其依赖正确交互，而无需搭建复杂的基础设施。

下面示例测试了一个名为 `saveUser()` 的函数，它接受一个用户对象和一个数据库对象，然后调用数据库的 `save` 方法：

```ts
import { assertEquals } from "jsr:@std/assert";
import { assertSpyCalls, spy } from "jsr:@std/testing/mock";

// 定义类型以提升代码质量
interface User {
  name: string;
}

interface Database {
  save: (user: User) => Promise<User & { id: number }>;
}

// 待测试函数
function saveUser(
  user: User,
  database: Database,
): Promise<User & { id: number }> {
  return database.save(user);
}

// 使用 mock 测试
Deno.test("saveUser 调用了 database.save", async () => {
  // 创建一个带有 save 方法的 mock 数据库，save 方法被 spy 包裹
  const mockDatabase = {
    save: spy((user: User) => Promise.resolve({ id: 1, ...user })),
  };

  const user: User = { name: "Test User" };
  const result = await saveUser(user, mockDatabase);

  // 验证 mock 调用情况
  assertSpyCalls(mockDatabase.save, 1);
  assertEquals(mockDatabase.save.calls[0].args[0], user);
  assertEquals(result, { id: 1, name: "Test User" });
});
```

我们从 Deno 标准库导入必要的函数，用于断言相等和创建及校验 spy 函数。

这个模拟数据库是一个替代真实数据库对象的站位符，带有一个被 `spy` 包裹的 `save` 方法。这个 spy 函数会跟踪该方法的调用次数、记录传入的参数，并执行其底层实现（这里返回了包含 `user` 及 `id` 的 Promise）。

测试中调用了带有模拟数据的 `saveUser()`，我们通过断言验证了：

1. `save` 方法被调用了且仅调用了一次
2. 调用的第一个参数是我们传入的 `user` 对象
3. 返回结果包含原有的用户数据和新增的 ID

我们能够在无需搭建或清理复杂数据库状态的情况下，测试了 `saveUser` 功能。

### 清除 Spy

当多个测试都使用 spy 时，重要的是在测试之间重置或清除 spy，以避免相互干扰。Deno 测试库提供了使用 `restore()` 方法轻松恢复所有 spy 到原始状态。

下面示例演示如何在完成使用 spy 后清理它：

```ts
import { assertEquals } from "jsr:@std/assert";
import { assertSpyCalls, spy } from "jsr:@std/testing/mock";

Deno.test("spy 清理示例", () => {
  // 创建一个监听函数的 spy
  const myFunction = spy((x: number) => x * 2);

  // 使用 spy
  const result = myFunction(5);
  assertEquals(result, 10);
  assertSpyCalls(myFunction, 1);

  // 测试完成后，恢复 spy
  try {
    // 使用 spy 的测试代码
    // ...
  } finally {
    // 始终清理 spy
    myFunction.restore();
  }
});
```

方法的 spy 是可销毁的，可以用 `using` 关键字让它们自动恢复。这种做法避免了你必须用 `try` 代码块包裹断言，确保测试结束前方法能被恢复。

```ts
import { assertEquals } from "jsr:@std/assert";
import { assertSpyCalls, spy } from "jsr:@std/testing/mock";

Deno.test("使用可自动恢复的 spies", () => {
  const calculator = {
    add: (a: number, b: number) => a + b,
    multiply: (a: number, b: number) => a * b,
  };

  // spy 会在超出作用域时自动恢复
  using addSpy = spy(calculator, "add");

  // 使用 spy
  const sum = calculator.add(3, 4);
  assertEquals(sum, 7);
  assertSpyCalls(addSpy, 1);
  assertEquals(addSpy.calls[0].args, [3, 4]);

  // 不需要 try/finally 块，spy 会自动恢复
});

Deno.test("同时使用多个可自动恢复的 spies", () => {
  const calculator = {
    add: (a: number, b: number) => a + b,
    multiply: (a: number, b: number) => a * b,
  };

  // 两个 spy 都会自动恢复
  using addSpy = spy(calculator, "add");
  using multiplySpy = spy(calculator, "multiply");

  calculator.add(5, 3);
  calculator.multiply(4, 2);

  assertSpyCalls(addSpy, 1);
  assertSpyCalls(multiplySpy, 1);

  // 不需要清理代码
});
```

如果你有多个不支持 `using` 关键字的 spy，可以将它们保存在数组里，一次性调用恢复：

```ts
Deno.test("多个 spies 清理", () => {
  const spies = [];

  // 创建 spy
  const functionA = spy((x: number) => x + 1);
  spies.push(functionA);

  const objectB = {
    method: (x: number) => x * 2,
  };
  const spyB = spy(objectB, "method");
  spies.push(spyB);

  // 测试中使用 spies
  // ...

  // 测试结束时清理所有 spies
  try {
    // 使用 spies 的测试代码
  } finally {
    // 恢复所有 spies
    spies.forEach((spyFn) => spyFn.restore());
  }
});
```

正确清理 spies 能确保每个测试从干净的状态开始，避免测试间侧漏副作用。

### Stub（存根）

虽然 spy 用于记录方法调用而不改变行为，但 stub 会完全替换原有实现。
[Stub](https://jsr.io/@std/testing/doc/mock#stubbing) 是 mock 的一种形式，用于临时替换函数或方法实现，可用于模拟特定情况或预设返回值，也常用于重写依赖环境的功能。

在 Deno 中，你可以通过标准测试库的 `stub` 函数创建 stub：

```ts
import { assertEquals } from "jsr:@std/assert";
import { Stub, stub } from "jsr:@std/testing/mock";

// 定义类型以提升代码质量
interface User {
  name: string;
  role: string;
}

// 原始函数
function getCurrentUser(userId: string): User {
  // 可能涉及数据库调用的实现
  return { name: "Real User", role: "admin" };
}

// 待测试函数
function hasAdminAccess(userId: string): boolean {
  const user = getCurrentUser(userId);
  return user.role === "admin";
}

Deno.test("hasAdminAccess 使用 stub 用户", () => {
  // 创建替代 getCurrentUser 的 stub
  const getUserStub: Stub<typeof getCurrentUser> = stub(
    globalThis,
    "getCurrentUser",
    // 返回非管理员的测试用户
    () => ({ name: "Test User", role: "guest" }),
  );

  try {
    // 使用 stub 函数测试
    const result = hasAdminAccess("user123");
    assertEquals(result, false);

    // 测试中也能改变 stub 行为
    getUserStub.restore(); // 移除第一个 stub

    const adminStub = stub(
      globalThis,
      "getCurrentUser",
      () => ({ name: "Admin User", role: "admin" }),
    );

    try {
      const adminResult = hasAdminAccess("admin456");
      assertEquals(adminResult, true);
    } finally {
      adminStub.restore();
    }
  } finally {
    // 始终还原原始函数，避免影响其他测试
    getUserStub.restore();
  }
});
```

这里导入了必要函数，设置了一个可能调用数据库的原始 `getCurrentUser` 函数。

我们定义了待测试的 `hasAdminAccess()`，用来判断用户是否为管理员。

接着创建了 `hasAdminAccess with a stubbed user` 测试，用 stub 替换真实的 `getCurrentUser`，模拟返回一个非管理员用户。

测试调用这个 stub，会发现返回 `false`，符合预期。

然后将 stub 修改为返回管理员用户，断言结果为 `true`。

最后在 `finally` 中保证还原函数，避免对其他测试造成影响。

### 环境变量的 Stub

要实现确定性的测试，经常需要控制环境变量。Deno 标准库提供了相关工具：

```ts
import { assertEquals } from "jsr:@std/assert";
import { stub } from "jsr:@std/testing/mock";

// 依赖环境变量和时间的函数
function generateReport() {
  const environment = Deno.env.get("ENVIRONMENT") || "development";
  const timestamp = new Date().toISOString();

  return {
    environment,
    generatedAt: timestamp,
    data: {/* 报告数据 */},
  };
}

Deno.test("在受控环境下生成报告", () => {
  // Stub 环境变量
  const originalEnv = Deno.env.get;
  const envStub = stub(Deno.env, "get", (key: string) => {
    if (key === "ENVIRONMENT") return "production";
    return originalEnv.call(Deno.env, key);
  });

  // Stub 时间
  const dateStub = stub(
    Date.prototype,
    "toISOString",
    () => "2023-06-15T12:00:00Z",
  );

  try {
    const report = generateReport();

    // 验证使用受控值生成的结果
    assertEquals(report.environment, "production");
    assertEquals(report.generatedAt, "2023-06-15T12:00:00Z");
  } finally {
    // 始终还原 stub，避免影响其他测试
    envStub.restore();
    dateStub.restore();
  }
});
```

### 模拟时间 (Faking time)

与时间相关的代码难以测试，因为测试结果可能随执行时间变化。Deno 提供了一个
[`FakeTime`](https://jsr.io/@std/testing/doc/time) 工具，可在测试中模拟时间流动，控制日期相关函数。

以下示例演示如何测试依赖时间的函数：
`isWeekend()`（判断当天是否周六或周日返回 true），以及
`delayedGreeting()`（1 秒延迟后回调）：

```ts
import { assertEquals } from "jsr:@std/assert";
import { FakeTime } from "jsr:@std/testing/time";

// 基于当前时间的函数
function isWeekend(): boolean {
  const date = new Date();
  const day = date.getDay();
  return day === 0 || day === 6; // 0 是星期日，6 是星期六
}

// 使用定时器的函数
function delayedGreeting(callback: (message: string) => void): void {
  setTimeout(() => {
    callback("Hello after delay");
  }, 1000); // 1 秒延迟
}

Deno.test("时间相关测试", () => {
  using fakeTime = new FakeTime();

  // 创建从特定日期（星期一）开始的假时间
  const mockedTime: FakeTime = fakeTime(new Date("2023-05-01T12:00:00Z"));

  try {
    // 测试周一
    assertEquals(isWeekend(), false);

    // 向前推进时间到周六
    mockedTime.tick(5 * 24 * 60 * 60 * 1000); // 前进 5 天
    assertEquals(isWeekend(), true);

    // 测试带定时器的异步操作
    let greeting = "";
    delayedGreeting((message) => {
      greeting = message;
    });

    // 立即推进 1 秒以触发定时器
    mockedTime.tick(1000);
    assertEquals(greeting, "Hello after delay");
  } finally {
    // 始终还原真实时间
    mockedTime.restore();
  }
});
```

这里使用 `fakeTime` 创建受控时间环境，初始时间为 2023 年 5 月 1 日（星期一），返回的 `FakeTime` 对象可控制时间流逝。

我们在模拟周一时测试 `isWeekend()` 返回 `false`，推进到周六后为 `true`。

`fakeTime` 替换了 JS 的时间函数 (`Date`、`setTimeout`、`setInterval` 等)，让你无论实际测试时间何时，都可测试指定时间条件。此技术可避免依赖系统时钟导致的测试不稳定，并可通过快速推进时间来加速测试。

模拟时间适用于测试：

- 日历或日期相关功能，如日程、预约、过期时间
- 包含超时或定时器的代码，如轮询、延迟操作、去抖
- 动画或过渡效果的定时测试

和 Stub 类似，测试结束后记得调用 `restore()` 还原真实时间函数，避免影响其他测试。

## 高级 Mock 模式

### 部分 Mock

有时你只想 mock 某些对象方法，保留其他方法真实实现：

```ts
import { assertEquals } from "jsr:@std/assert";
import { stub } from "jsr:@std/testing/mock";

class UserService {
  async getUser(id: string) {
    // 复杂数据库查询
    return { id, name: "Database User" };
  }

  async formatUser(user: { id: string; name: string }) {
    return {
      ...user,
      displayName: user.name.toUpperCase(),
    };
  }

  async getUserFormatted(id: string) {
    const user = await this.getUser(id);
    return this.formatUser(user);
  }
}

Deno.test("使用 stub 进行部分 Mock", async () => {
  const service = new UserService();

  // 仅 mock getUser 方法
  const getUserMock = stub(
    service,
    "getUser",
    () => Promise.resolve({ id: "test-id", name: "Mocked User" }),
  );

  try {
    // formatUser 仍使用真实实现
    const result = await service.getUserFormatted("test-id");

    assertEquals(result, {
      id: "test-id",
      name: "Mocked User",
      displayName: "MOCKED USER",
    });

    // 验证 getUser 被正确调用
    assertEquals(getUserMock.calls.length, 1);
    assertEquals(getUserMock.calls[0].args[0], "test-id");
  } finally {
    getUserMock.restore();
  }
});
```

### Mock fetch 请求

测试涉及 HTTP 请求的代码通常需要模拟 `fetch` API：

```ts
import { assertEquals } from "jsr:@std/assert";
import { stub } from "jsr:@std/testing/mock";

// 使用 fetch 的函数
async function fetchUserData(userId: string) {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.status}`);
  }
  return await response.json();
}

Deno.test("Mock fetch API", async () => {
  const originalFetch = globalThis.fetch;

  // 创建 mock fetch 返回的响应
  const mockResponse = new Response(
    JSON.stringify({ id: "123", name: "John Doe" }),
    { status: 200, headers: { "Content-Type": "application/json" } },
  );

  // 用 stub 替换 fetch
  globalThis.fetch = stub(
    globalThis,
    "fetch",
    (_input: string | URL | Request, _init?: RequestInit) =>
      Promise.resolve(mockResponse),
  );

  try {
    const result = await fetchUserData("123");
    assertEquals(result, { id: "123", name: "John Doe" });
  } finally {
    // 还原原始 fetch
    globalThis.fetch = originalFetch;
  }
});
```

## 真实案例

现在我们将所有技巧合并，测试一个用户认证服务，该服务：

1. 验证用户凭证
2. 调用 API 进行认证
3. 存储带有过期时间的 token

下面示例创建了完整的 `AuthService` 类，用于登录、token 管理和鉴权。测试中使用了多种 Mock 技术：Stub fetch 请求、Spy 方法、模拟时间来测试 token 过期，并使用结构化测试步骤组织。

Deno 的测试 API 提供了 `t.step()` 方法，将测试逻辑分割为步骤或子测试，使复杂测试更易读，更便于定位问题。每步可单独断言，测试结果中分别报告。

```ts
import { assertEquals, assertRejects } from "jsr:@std/assert";
import { spy, stub } from "jsr:@std/testing/mock";
import { FakeTime } from "jsr:@std/testing/time";

// 目标服务
class AuthService {
  private token: string | null = null;
  private expiresAt: Date | null = null;

  async login(username: string, password: string): Promise<string> {
    // 校验输入
    if (!username || !password) {
      throw new Error("Username and password are required");
    }

    // 调用认证 API
    const response = await fetch("https://api.example.com/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error(`Authentication failed: ${response.status}`);
    }

    const data = await response.json();

    // 存储带 1 小时过期时间的 token
    this.token = data.token;
    this.expiresAt = new Date(Date.now() + 60 * 60 * 1000);

    return this.token;
  }

  getToken(): string {
    if (!this.token || !this.expiresAt) {
      throw new Error("Not authenticated");
    }

    if (new Date() > this.expiresAt) {
      this.token = null;
      this.expiresAt = null;
      throw new Error("Token expired");
    }

    return this.token;
  }

  logout(): void {
    this.token = null;
    this.expiresAt = null;
  }
}

Deno.test("AuthService 综合测试", async (t) => {
  await t.step("登录应该验证凭证", async () => {
    const authService = new AuthService();
    await assertRejects(
      () => authService.login("", "password"),
      Error,
      "Username and password are required",
    );
  });

  await t.step("登录应正确处理 API 调用", async () => {
    const authService = new AuthService();

    // mock 成功响应
    const mockResponse = new Response(
      JSON.stringify({ token: "fake-jwt-token" }),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );

    const fetchStub = stub(
      globalThis,
      "fetch",
      (_url: string | URL | Request, options?: RequestInit) => {
        // 验证请求数据正确
        const body = options?.body as string;
        const parsedBody = JSON.parse(body);
        assertEquals(parsedBody.username, "testuser");
        assertEquals(parsedBody.password, "password123");

        return Promise.resolve(mockResponse);
      },
    );

    try {
      const token = await authService.login("testuser", "password123");
      assertEquals(token, "fake-jwt-token");
    } finally {
      fetchStub.restore();
    }
  });

  await t.step("token 过期应正常工作", () => {
    using fakeTime = new FakeTime();

    const authService = new AuthService();
    const time = fakeTime(new Date("2023-01-01T12:00:00Z"));

    try {
      // mock 登录过程直接设置 token
      authService.login = spy(
        authService,
        "login",
        async () => {
          (authService as any).token = "fake-token";
          (authService as any).expiresAt = new Date(
            Date.now() + 60 * 60 * 1000,
          );
          return "fake-token";
        },
      );

      // 登录并验证 token
      authService.login("user", "pass").then(() => {
        const token = authService.getToken();
        assertEquals(token, "fake-token");

        // 将时间推进到过期后
        time.tick(61 * 60 * 1000);

        // token 应该已过期
        assertRejects(
          () => {
            authService.getToken();
          },
          Error,
          "Token expired",
        );
      });
    } finally {
      time.restore();
      (authService.login as any).restore();
    }
  });
});
```

该代码定义了 `AuthService` 类，包含三大功能：

- 登录：校验凭证，调用 API，保存带过期时间的 token
- 获取 Token：返回有效且未过期的 token
- 登出：清除 token 和过期时间

测试通过一个主测试，分为三个逻辑**步骤**，分别检验凭证验证、API 调用处理和 token 过期。

🦕 高效的 Mock 技术对于编写可靠、可维护的单元测试至关重要。Deno 提供多种强大工具帮助你在测试中隔离代码。掌握这些技巧后，你能编写更可靠、更快速且不依赖外部服务的测试。

更多测试资源请参考：

- [Deno 测试 API 文档](/api/deno/testing)
- [Deno 标准库测试模块](https://jsr.io/@std/testing)
- [Deno 测试基础教程](/examples/testing_tutorial/)

---

# 模块元数据

> A guide to working with module metadata in Deno. Learn about import.meta properties, main module detection, file paths, URL resolution, and how to access module context information in your applications.

URL: https://docs.deno.com/examples/tutorials/module_metadata


## 概念

- [import.meta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta)
  可以提供模块上下文的信息。
- 布尔值
  [import.meta.main](https://docs.deno.com/api/web/~/ImportMeta#property_main)
  会告诉你当前模块是否为程序入口点。
- 字符串
  [import.meta.url](https://docs.deno.com/api/web/~/ImportMeta#property_url)
  将给你当前模块的 URL。
- 字符串
  [import.meta.filename](https://docs.deno.com/api/web/~/ImportMeta#property_filename)
  将给你当前模块的完全解析路径。_仅适用于本地模块_。
- 字符串
  [import.meta.dirname](https://docs.deno.com/api/web/~/ImportMeta#property_dirname)
  将给你包含当前模块的目录的完全解析路径。_仅适用于本地模块_。
- [import.meta.resolve](https://docs.deno.com/api/web/~/ImportMeta#property_resolve)
  允许你解析相对于当前模块的说明符。此函数会考虑启动时提供的导入地图（如果有）。
- 字符串 [Deno.mainModule](https://docs.deno.com/api/deno/~/Deno.mainModule)
  将给你主模块入口点的 URL，即由 deno 运行时调用的模块。

## 示例

下面的示例使用两个模块来展示 `import.meta.url`、`import.meta.main` 和 `Deno.mainModule` 之间的差异。在这个示例中，`module_a.ts` 是主模块入口点：

```ts title="module_b.ts"
export function outputB() {
  console.log("模块 B 的 import.meta.url", import.meta.url);
  console.log("模块 B 的 mainModule url", Deno.mainModule);
  console.log(
    "模块 B 通过 import.meta.main 判断是否为主模块？",
    import.meta.main,
  );
}
```

```ts title="module_a.ts"
import { outputB } from "./module_b.ts";

function outputA() {
  console.log("模块 A 的 import.meta.url", import.meta.url);
  console.log("模块 A 的 mainModule url", Deno.mainModule);
  console.log(
    "模块 A 通过 import.meta.main 判断是否为主模块？",
    import.meta.main,
  );
  console.log(
    "解析 ./module_b.ts 的说明符",
    import.meta.resolve("./module_b.ts"),
  );
}

outputA();
console.log("");
outputB();
```

如果 `module_a.ts` 位于 `/home/alice/deno`，则运行 `deno run --allow-read module_a.ts` 的输出为：

```console
模块 A 的 import.meta.url file:///home/alice/deno/module_a.ts
模块 A 的 mainModule url file:///home/alice/deno/module_a.ts
模块 A 通过 import.meta.main 判断是否为主模块？ true
解析 ./module_b.ts 的说明符 file:///home/alice/deno/module_b.ts

模块 B 的 import.meta.url file:///home/alice/deno/module_b.ts
模块 B 的 mainModule url file:///home/alice/deno/module_a.ts
模块 B 通过 import.meta.main 判断是否为主模块？ false
```

---

# 如何在 Deno 中使用 Mongoose

> Step-by-step guide to using Mongoose with Deno. Learn how to set up MongoDB connectivity, create schemas, implement data models, and perform CRUD operations using Mongoose's schema-based modeling.

URL: https://docs.deno.com/examples/tutorials/mongoose


[Mongoose](https://mongoosejs.com/) 是一个流行的基于模式的库，用于建模 [MongoDB](https://www.mongodb.com/) 的数据。它简化了编写 MongoDB 验证、类型转换和其他相关业务逻辑的过程。

本教程将向您展示如何在 Deno 项目中设置 Mongoose 和 MongoDB。

[查看源代码](https://github.com/denoland/examples/tree/main/with-mongoose) 或
[查看视频指南](https://youtu.be/dmZ9Ih0CR9g)。

## 创建一个 Mongoose 模型

让我们创建一个简单的应用程序，连接到 MongoDB，创建一个 `Dinosaur` 模型，并向数据库添加和更新一个恐龙。

首先，我们将创建必要的文件和目录：

```console
touch main.ts && mkdir model && touch model/Dinosaur.ts
```

在 `/model/Dinosaur.ts` 中，我们将导入 `npm:mongoose`，定义 [模式]，并导出它：

```ts
import { model, Schema } from "npm:mongoose@^6.7";

// 定义模式。
const dinosaurSchema = new Schema({
  name: { type: String, unique: true },
  description: String,
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

// 验证
dinosaurSchema.path("name").required(true, "恐龙名称不能为空。");
dinosaurSchema.path("description").required(
  true,
  "恐龙描述不能为空。",
);

// 导出模型。
export default model("Dinosaur", dinosaurSchema);
```

## 连接到 MongoDB

现在，在我们的 `main.ts` 文件中，我们将导入 mongoose 和 `Dinosaur` 模式，并连接到 MongoDB：

```ts
import mongoose from "npm:mongoose@^6.7";
import Dinosaur from "./model/Dinosaur.ts";

await mongoose.connect("mongodb://localhost:27017");

// 检查连接状态。
console.log(mongoose.connection.readyState);
```

因为 Deno 支持顶级 `await`，我们能够简单地 `await mongoose.connect()`。

运行这个，我们应该期待得到一个日志 `1`：

```shell
$ deno run --allow-read --allow-sys --allow-env --allow-net main.ts
1
```

它成功了！

## 操作数据

让我们在 `/model/Dinosaur.ts` 中为我们的 `Dinosaur` 模式添加一个实例 [方法](https://mongoosejs.com/docs/guide.html#methods)：

```ts
// ./model/Dinosaur.ts

// 方法。
dinosaurSchema.methods = {
  // 更新描述。
  updateDescription: async function (description: string) {
    this.description = description;
    return await this.save();
  },
};

// ...
```

这个实例方法 `updateDescription` 将允许您更新记录的描述。

回到 `main.ts`，让我们开始在 MongoDB 中添加和操作数据。

```ts
// main.ts

// 创建一个新的 Dinosaur。
const deno = new Dinosaur({
  name: "Deno",
  description: "有史以来最快的恐龙。",
});

// 插入 deno。
await deno.save();

// 按名称查找 Deno。
const denoFromMongoDb = await Dinosaur.findOne({ name: "Deno" });
console.log(
  `在 MongoDB 中查找 Deno -- \n  ${denoFromMongoDb.name}: ${denoFromMongoDb.description}`,
);

// 更新 Deno 的描述并保存。
await denoFromMongoDb.updateDescription(
  "有史以来最快和最安全的恐龙。",
);

// 检查 MongoDB 以查看 Deno 的更新描述。
const newDenoFromMongoDb = await Dinosaur.findOne({ name: "Deno" });
console.log(
  `再次查找 Deno -- \n  ${newDenoFromMongoDb.name}: ${newDenoFromMongoDb.description}`,
);
```

运行代码，我们得到：

```console
在 MongoDB 中查找 Deno --
  Deno: 有史以来最快的恐龙。
再次查找 Deno --
  Deno: 有史以来最快和最安全的恐龙。
```

太棒了！

有关使用 Mongoose 的更多信息，请参考
[他们的文档](https://mongoosejs.com/docs/guide.html)。

---

# 如何在 Deno 中使用 MySQL2

> Step-by-step guide to using MySQL2 with Deno. Learn how to set up database connections, execute queries, handle transactions, and build data-driven applications using MySQL's Node.js driver.

URL: https://docs.deno.com/examples/tutorials/mysql2


[MySQL](https://www.mysql.com/) 是在
[2022年 Stack Overflow 开发者调查](https://survey.stackoverflow.co/2022/#most-popular-technologies-database)
中最受欢迎的数据库，并且有 Facebook、Twitter、YouTube 和 Netflix 等用户。

[在这里查看源代码。](https://github.com/denoland/examples/tree/main/with-mysql2)

你可以使用 `mysql2` node 包通过 `npm:mysql2` 在 Deno 中操作和查询 MySQL 数据库。这使我们能够使用其 Promise 包装器，并利用顶层 await。

```tsx
import mysql from "npm:mysql2@^2.3.3/promise";
```

## 连接到 MySQL

我们可以使用 `createConnection()` 方法连接到我们的 MySQL 服务器。你需要指定主机（在测试时为 `localhost`，或在生产中更可能是云数据库端点）以及用户和密码：

```tsx
const connection = await mysql.createConnection({
  host: "localhost",
  user: "root",
  password: "password",
});
```

你还可以在创建连接时可选指定一个数据库。在这里，我们将使用 `mysql2` 动态创建数据库。

## 创建和填充数据库

现在你已经建立了连接，可以使用 `connection.query()` 和 SQL 命令来创建数据库和表，以及插入初始数据。

首先，我们想要生成并选择要使用的数据库：

```tsx
await connection.query("CREATE DATABASE denos");
await connection.query("use denos");
```

然后我们想要创建表：

```tsx
await connection.query(
  "CREATE TABLE `dinosaurs` (   `id` int NOT NULL AUTO_INCREMENT PRIMARY KEY,   `name` varchar(255) NOT NULL,   `description` varchar(255) )",
);
```

表创建后，我们可以填充数据：

```tsx
await connection.query(
  "INSERT INTO `dinosaurs` (id, name, description) VALUES (1, 'Aardonyx', 'An early stage in the evolution of sauropods.'), (2, 'Abelisaurus', 'Abel's lizard has been reconstructed from a single skull.'), (3, 'Deno', 'The fastest dinosaur that ever lived.')",
);
```

现在我们有了所有数据，可以开始查询。

## 查询 MySQL

我们可以使用相同的 connection.query() 方法来编写我们的查询。首先，我们尝试获取 `dinosaurs` 表中的所有数据：

```tsx
const results = await connection.query("SELECT * FROM `dinosaurs`");
console.log(results);
```

此查询的结果是我们数据库中的所有数据：

```tsx
[
  [
    {
      id: 1,
      name: "Aardonyx",
      description: "An early stage in the evolution of sauropods."
    },
    {
      id: 2,
      name: "Abelisaurus",
      description: `Abel's lizard has been reconstructed from a single skull.`
    },
    { id: 3, name: "Deno", description: "The fastest dinosaur that ever lived." }
  ],
```

如果我们只想从数据库中获取单个元素，可以更改我们的查询：

```tsx
const [results, fields] = await connection.query(
  "SELECT * FROM `dinosaurs` WHERE `name` = 'Deno'",
);
console.log(results);
```

这将给我们一个单行结果：

```tsx
[{ id: 3, name: "Deno", description: "The fastest dinosaur that ever lived." }];
```

最后，我们可以关闭连接：

```tsx
await connection.end();
```

想要了解更多关于 `mysql2` 的信息，请查看他们的文档 [这里](https://github.com/sidorares/node-mysql2)。

---

# 构建一个 Next.js 应用

> 使用 Deno 构建 Next.js 应用的分步教程。学习如何设置项目，创建 API 路由，实现服务器端渲染，并构建一个全栈 TypeScript 应用。

URL: https://docs.deno.com/examples/tutorials/next


[Next.js](https://nextjs.org/) 是一个流行的用于构建服务器端渲染应用的框架。它基于 React 构建，并开箱即用提供了很多功能。

在本教程中，我们将构建一个
[简单的 Next.js 应用](https://tutorial-with-next.deno.deno.net/) 并使用 Deno 运行它。该应用会显示一个恐龙列表。当你点击其中一个时，会跳转到对应恐龙的详情页面。

你可以查看
[GitHub 上的完整应用代码](https://github.com/denoland/tutorial-with-next/tree/main)。

:::info 部署你自己的应用

想跳过教程，立即部署完成的应用？点击下面按钮，立刻将完整的 SvelteKit 恐龙应用副本部署到 Deno Deploy。你将获得一个可运行、可自定义、可修改的实时代码！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-next)

:::

## 使用 Deno 创建一个 Next.js 应用

Next 提供了一个 CLI 工具，可以快速创建新的 Next.js 应用。在终端运行以下命令，使用 Deno 创建新的 Next.js 应用：

```sh
deno run -A npm:create-next-app@latest
```

当提示时，选择默认选项以创建带有 TypeScript 的新 Next.js 应用。

Next.js 有些依赖仍然依赖于 `Object.prototype.__proto__`，并且需要 CommonJS 模块支持。为让 Deno 兼容 Next.js，更新你的 `deno.json` 文件，使用以下配置：

```json deno.json
{
  "nodeModulesDir": "auto",
  "unstable": [
    "unsafe-proto",
    "sloppy-imports"
  ],
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "strict": true,
    "jsx": "preserve"
  },
  "tasks": {
    "dev": "deno run -A --unstable-detect-cjs npm:next@latest dev",
    "build": "deno run -A --unstable-detect-cjs npm:next@latest build",
    "start": "deno run -A --unstable-detect-cjs npm:next@latest start"
  }
}
```

此配置包括：

- `nodeModulesDir: "auto"` —— 启用 npm 包的生命周期脚本
- `unstable: ["unsafe-proto", "sloppy-imports"]` —— Next.js 兼容性所需
- `--unstable-detect-cjs` 标志 —— 启用 CommonJS 模块检测支持 Next.js 依赖

现在你可以运行你的新的 Next.js 应用：

```sh
deno run dev
```

这将使用 Deno 启动 Next.js 开发服务器。`deno task dev` 命令会带有必要标志启动支持 CommonJS 的 Next.js 开发服务器。

访问 [http://localhost:3000](http://localhost:3000) 在浏览器查看应用。

## 添加后台服务

下一步是添加后台 API。我们将创建一个非常简单的 API，返回关于恐龙的信息。

我们会使用 Next.js 内置的
[API 路由处理](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
来设置恐龙 API。Next.js 使用基于文件系统的路由，文件夹结构直接定义路由。

我们将定义三个路由，第一个 `/api` 路由返回字符串 `Welcome to the dinosaur API`，然后 `/api/dinosaurs` 返回所有恐龙的数据，最后 `/api/dinosaurs/[dinosaur]` 根据 URL 中的名称返回特定恐龙。

### /api/

在新项目的 `src/app` 文件夹中创建一个 `api` 文件夹，在该文件夹中创建 `route.ts` 文件，用于处理 `/api` 路由。

将以下代码复制粘贴到 `api/route.ts` 文件中：

```ts title="route.ts"
export function GET() {
  return Response.json("welcome to the dinosaur API");
}
```

此代码定义了一个简单的路由处理器，返回包含字符串 `欢迎来到恐龙 API` 的 JSON 响应。

### /api/data.json

在 `api` 文件夹中，创建一个 `data.json` 文件，内含硬编码的恐龙数据。将
[这个 JSON 文件](https://raw.githubusercontent.com/denoland/deno-vue-example/main/api/data.json)
复制粘贴到 `data.json` 文件中。

### /api/dinosaurs

在 `api` 文件夹中，创建一个名为 `dinosaurs` 的文件夹，在其中创建一个 `route.ts` 文件来处理 `/api/dinosaurs` 请求。该路由将读取 `data.json` 文件，并返回所有恐龙的 JSON 数据：

```ts title="route.ts"
import data from "./data.json" with { type: "json" };

export function GET() {
  return Response.json(data);
}
```

### /api/dinosaurs/[dinosaur]

对于最后一个路由 `/api/dinosaurs/[dinosaur]`，在 `dinosaurs` 目录中创建一个 `[dinosaur]` 文件夹。在其中创建 `route.ts` 文件。该文件将读取 `data.json`，根据 URL 中的名称查找对应恐龙并以 JSON 返回：

```ts title="route.ts"
import data from "../../data.json" with { type: "json" };

type RouteParams = { params: Promise<{ dinosaur: string }> };

export const GET = async (_request: Request, { params }: RouteParams) => {
  const { dinosaur } = await params;

  if (!dinosaur) {
    return Response.json("未提供恐龙名称。");
  }

  const dinosaurData = data.find((item) =>
    item.name.toLowerCase() === dinosaur.toLowerCase()
  );

  return Response.json(dinosaurData ? dinosaurData : "未找到该恐龙。");
};
```

现在，如果你运行应用并访问
`http://localhost:3000/api/dinosaurs/brachiosaurus`，应该能看到关于腕龙的详细信息。

## 构建前端

现在我们已经设置了后台 API，接着构建前端页面来展示恐龙数据。

### 定义恐龙类型

首先，我们添加一个类型定义，描述恐龙数据结构。在 `app` 目录中创建 `types.ts` 文件，添加以下代码：

```ts title="types.ts"
export type Dino = { name: string; description: string };
```

### 更新首页

修改 `app` 目录中的 `page.tsx` 文件，从我们 API 获取恐龙数据，并以链接列表形式显示。

Next.js 中如果有客户端代码，需要在文件顶部添加 `"use client"` 指令。然后导入该页面需要的模块，并导出渲染页面的默认函数：

```tsx title="page.tsx"
"use client";

import { useEffect, useState } from "react";
import { Dino } from "./types";
import Link from "next/link";

export default function Home() {
}
```

在 `Home` 函数体内，定义一个状态变量存储恐龙数据，并使用 `useEffect` 钩子在组件挂载时从 API 拉取数据：

```tsx title="page.tsx"
const [dinosaurs, setDinosaurs] = useState<Dino[]>([]);

useEffect(() => {
  (async () => {
    const response = await fetch(`/api/dinosaurs`);
    const allDinosaurs = await response.json() as Dino[];
    setDinosaurs(allDinosaurs);
  })();
}, []);
```

接着，在 `Home` 函数体内返回一个链接列表，每个链接指向对应恐龙页面：

```tsx title="page.tsx"
return (
  <main id="content">
    <h1>Welcome to the Dinosaur app</h1>
    <p>Click on a dinosaur below to learn more.</p>
    <ul>
      {dinosaurs.map((dinosaur: Dino) => {
        return (
          <li key={dinosaur.name}>
            <Link href={`/${dinosaur.name.toLowerCase()}`}>
              {dinosaur.name}
            </Link>
          </li>
        );
      })}
    </ul>
  </main>
);
```

### 创建恐龙详情页面

在 `app` 目录下创建名为 `[dinosaur]` 的文件夹，里面创建 `page.tsx` 文件。该文件从 API 获取特定恐龙详情并渲染。

和首页类似，我们添加客户端代码导入，并导出默认函数，参数入参类型化：

```tsx title="[dinosaur]/page.tsx"
"use client";

import { useEffect, useState } from "react";
import { Dino } from "../types";
import Link from "next/link";

type RouteParams = { params: Promise<{ dinosaur: string }> };

export default function Dinosaur({ params }: RouteParams) {
}
```

在 `Dinosaur` 函数中，获取 URL 中选定恐龙名称，定义状态变量存储恐龙信息，创建 `useEffect` 钩子挂载时从 API 获取数据：

```tsx title="[dinosaur]/page.tsx"
const selectedDinosaur = params.then((params) => params.dinosaur);
const [dinosaur, setDino] = useState<Dino>({ name: "", description: "" });

useEffect(() => {
  (async () => {
    const resp = await fetch(`/api/dinosaurs/${await selectedDinosaur}`);
    const dino = await resp.json() as Dino;
    setDino(dino);
  })();
}, []);
```

最后，在组件中返回显示恐龙名称及描述的描述元素：

```tsx title="[dinosaur]/page.tsx"
return (
  <main id="content">
    <h1>{dinosaur.name}</h1>
    <p>{dinosaur.description}</p>
    <Link href="/">🠠 返回所有恐龙</Link>
  </main>
);
```

### 添加样式

给应用添加基础样式以使界面更美观。更新 `app/globals.css` 文件，使用
[此文件中的样式](https://raw.githubusercontent.com/denoland/tutorial-with-next/refs/heads/main/src/app/globals.css)。

## 运行应用

现在，你可以用 `deno run dev` 启动应用，然后在浏览器访问 `http://localhost:3000` 查看恐龙列表。点击恐龙可以看到更详细的信息！

## 部署应用

既然你的 Next.js 应用已运行，可以使用 Deno Deploy<sup>EA</sup> 部署到线上。

最佳体验是直接从 GitHub 部署，自动设置持续部署。先创建一个 GitHub 仓库并上传应用。

[创建新的 GitHub 仓库](https://github.com/new)，然后初始化并推送应用：

```sh
git init -b main
git remote add origin https://github.com/<your_github_username>/<your_repo_name>.git
git add .
git commit -am 'my next app'
git push -u origin main
```

一旦你的应用上线到 GitHub，你就可以
[部署到 Deno Deploy<sup>EA</sup>](https://console.deno.com/)。

想了解部署详情，请查看 
[Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在你可以用 Deno 构建并运行一个 Next.js 应用了！想进一步扩展，可以考虑
[添加数据库](/runtime/tutorials/connecting_to_databases/) 替代 `data.json` 文件，或尝试
[编写测试](/runtime/fundamentals/testing/) 以确保应用稳定，准备好生产环境。

---

# 使用 Deno 构建 Nuxt 应用

> 逐步指南，教你如何使用 Deno 构建 Nuxt 应用。学习如何创建完整的 Vue.js 全栈应用，实现服务器端渲染，添加 Tailwind 样式，并部署你的应用。

URL: https://docs.deno.com/examples/tutorials/nuxt


[Nuxt](https://nuxt.com/) 是一个基于 [Vue](https://vuejs.org/) 的直观框架，
提供了文件路由、多种渲染选项和开箱即用的自动代码拆分。凭借其模块化架构，Nuxt 通过提供结构化的开发方式简化了 Vue 应用的构建流程。

在本教程中，我们将使用 Deno 构建一个简单的 Nuxt 应用，显示恐龙列表，并允许你点击名字查看更多恐龙信息。

你可以在
[GitHub 上查看完整示例](https://github.com/denoland/examples/tree/main/with-nuxt)。

也可以体验
[Deno Deploy 上的在线示例](https://example-with-nuxt.deno.deno.net/)。

:::info 部署你的应用

想跳过教程，立即部署完整的 Nuxt 恐龙应用？点击下面按钮，瞬间将应用部署到 Deno Deploy。
你将获得一个可用的实时应用，可在学习时自由定制和修改！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/examples&path=with-nuxt)

:::

## 使用 Deno 脚手架 Nuxt 应用

通过 Deno 创建新的 Nuxt 项目：

```bash
deno -A npm:nuxi@latest init
```

选择创建项目的目录，并选择 `deno` 作为依赖管理方式。你也可以选择初始化 git 仓库，也可以之后再做。

然后进入新项目目录，运行 `deno task` 查看 Nuxt 可用任务：

```bash
cd nuxt-app
deno task
```

这会显示可用任务，如 `dev`、`build` 和 `preview`。`dev` 用于启动开发服务器。

## 启动开发服务器

启动开发服务器：

```bash
deno task dev
```

这会启动 Nuxt 开发服务器，在浏览器访问
[http://localhost:3000](http://localhost:3000) 查看默认 Nuxt 欢迎页面。

## 构建应用架构

基础 Nuxt 应用搭建完成后，开始建立应用架构。我们创建几个目录以组织代码，并为后续功能做准备。项目内创建如下目录：

```bash
NUXT-APP/
├── pages/                 # Vue 页面
│   └── dinosaurs/         # 恐龙页面
├── public/                # 静态文件
├── server/                # 服务器端代码
│   └── api/               # API 路由
```

## 添加恐龙数据

在 `api` 目录下创建 `data.json` 文件，用于存储硬编码的恐龙数据。

复制粘贴
[此 JSON 文件](https://raw.githubusercontent.com/denoland/tutorial-with-nuxt/refs/heads/main/src/data/data.json)
到 `data.json` 文件中。（实际应用中，通常从数据库或外部 API 获取数据。）

## 设置 API 路由

应用将包含两个 API 路由，分别提供：

- 供索引页面使用的完整恐龙列表
- 单个恐龙页面的详细恐龙信息

路由均为 `*.get.ts` 文件，Nuxt 会自动根据文件生成响应 `GET` 请求的 API 端点。
[文件命名决定 HTTP 方法及路由路径](https://nuxt.com/docs/guide/directory-structure/server#matching-http-method)。

初始的 `dinosaurs.get.ts` 十分简单，使用 [`defineCachedEventHandler`](https://nitro.build/guide/cache) 创建缓存端点提升性能。该函数直接返回完整恐龙数据数组，无任何过滤：

```tsx title="server/api/dinosaurs.get.ts"
import data from "./data.json" with { type: "json" };

export default defineCachedEventHandler(() => {
  return data;
});
```

单个恐龙的 `GET` 路由逻辑较多。它从事件上下文中取出名称参数，以不区分大小写方式匹配请求恐龙，缺少或错误时返回相应错误。我们创建 `dinosaurs` 文件夹，并新建 `[name].get.ts`：

```tsx title="server/api/dinosaurs/[name].get.ts"
import data from "../data.json";

export default defineCachedEventHandler((event) => {
  const name = getRouterParam(event, "name");

  if (!name) {
    throw createError({
      statusCode: 400,
      message: "未提供恐龙名称",
    });
  }

  const dinosaur = data.find(
    (dino) => dino.name.toLowerCase() === name.toLowerCase(),
  );

  if (!dinosaur) {
    throw createError({
      statusCode: 404,
      message: "未找到该恐龙",
    });
  }

  return dinosaur;
});
```

启动服务器 `deno task dev`，在浏览器访问
[http://localhost:3000/api/dinosaurs](http://localhost:3000/api/dinosaurs)，你应能看到包含所有恐龙的原始 JSON 响应！

![设置 API](./images/how-to/nuxt/nuxt-1.webp)

访问某个恐龙的特定 URL，如：
[http://localhost:3000/api/dinosaurs/aardonyx](http://localhost:3000/api/dinosaurs/aardonyx)，查看单个恐龙数据。

![设置 API](./images/how-to/nuxt/nuxt-2.webp)

接下来，设置 Vue 前端以显示索引页面和单个恐龙页面。

## 设置 Vue 前端

我们需要两个页面：

- 一个索引页，列出全部恐龙
- 一个单独页，展示指定恐龙详情

首先，创建索引页面。Nuxt 使用
[文件系统路由](https://nuxt.com/docs/getting-started/routing)，我们在根目录创建 `pages` 文件夹，并新建 `index.vue` 作为索引页。

利用 `useFetch` 组合函数请求先前创建的 API 端点：

```tsx title="pages/index.vue"
<script setup lang="ts">
const { data: dinosaurs } = await useFetch("/api/dinosaurs");
</script>

<template>
  <main id="content">
    <h1 class="text-2xl font-bold mb-4">Welcome to the Dinosaur app</h1>
    <p class="mb-4">Click on a dinosaur below to learn more.</p>
    <ul class="space-y-2">
      <li v-for="dinosaur in dinosaurs" :key="dinosaur.name">
        <NuxtLink
          :to="'/' + dinosaur.name.toLowerCase()"
          class="text-blue-600 hover:text-blue-800 hover:underline"
        >
          {{ dinosaur.name }}
        </NuxtLink>
      </li>
    </ul>
  </main>
</template>
```

然后，为显示单个恐龙信息，创建动态页面 `[name].vue`。该页面使用 Nuxt 的
[动态路由参数](https://nuxt.com/docs/getting-started/routing#route-parameters)，文件名中的 `[name]` 在 JavaScript 中通过 `route.params.name` 访问。我们用 `useRoute` 访问参数，并用 `useFetch` 根据名称获取指定恐龙数据：

```tsx title="pages/[name].vue"
<script setup lang="ts">
const route = useRoute();
const { data: dinosaur } = await useFetch(
  `/api/dinosaurs/${route.params.name}`
);
</script>

<template>
  <main v-if="dinosaur">
    <h1 class="text-2xl font-bold mb-4">{{ dinosaur.name }}</h1>
    <p class="mb-4">{{ dinosaur.description }}</p>
    <NuxtLink to="/" class="text-blue-600 hover:text-blue-800 hover:underline">
      返回所有恐龙
    </NuxtLink>
  </main>
</template>
```

接下来，将这些 Vue 组件串联起来，使访问根目录时能正确渲染。更新根目录的 `app.vue`，提供应用根组件。使用
[`NuxtLayout`](https://nuxt.com/docs/api/components/nuxt-layout) 保持一致结构，`NuxtPage` 用于动态页面渲染：

```tsx title="app.vue"
<template>
  <NuxtLayout>
    <div>
      <nav class="p-4 bg-gray-100">
        <NuxtLink to="/" class="text-blue-600 hover:text-blue-800">
          恐龙百科全书
        </NuxtLink>
      </nav>

      <div class="container mx-auto p-4">
        <NuxtPage />
      </div>
    </div>
  </NuxtLayout>
</template>;
```

运行 `deno task dev`，在 [http://localhost:3000](http://localhost:3000) 查看效果：

效果很棒！

```bash
deno install -D npm:tailwindcss npm:@tailwindcss/vite
```

随后，更新 `nuxt.config.ts`。导入 Tailwind 依赖并配置 Nuxt 应用以支持 Deno，启用开发工具，设置 Tailwind CSS：

```tsx title="nuxt.config.ts"
import tailwindcss from "@tailwindcss/vite";

export default defineNuxtConfig({
  compatibilityDate: "2025-05-15",
  devtools: { enabled: true },
  nitro: {
    preset: "deno",
  },
  app: {
    head: {
      title: "恐龙百科全书",
    },
  },
  css: ["~/assets/css/main.css"],
  vite: {
    plugins: [
      tailwindcss(),
    ],
  },
});
```

然后，创建新的 CSS 文件 `assets/css/main.css`，添加导入语句引入 tailwind 及其实用类：

```tsx title="assets/css/main.css"
@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;
```

## 运行应用

最后，通过以下命令运行应用：

```bash
deno task dev
```

应用将在 localhost:3000 启动：

<figure>

<video class="w-full" alt="使用 Deno 构建 Nuxt 应用。" autoplay muted loop playsinline src="./images/how-to/nuxt/nuxt-4.mp4"></video>

</figure>

完成了！

🦕 Nuxt 应用的下一步可以是使用 [Nuxt Auth](https://auth.nuxtjs.org/) 模块添加认证，集成 [Pinia](https://pinia.vuejs.org/) 状态管理，添加服务器端数据持久化（例如 [Prisma](https://docs.deno.com/examples/prisma_tutorial/) 或 [MongoDB](https://docs.deno.com/examples/mongoose_tutorial/)），以及搭建 Vitest 自动化测试，这些都将使应用更适合生产环境和大型项目。

---

# 处理操作系统信号

> Tutorial on handling operating system signals in Deno. Learn how to capture SIGINT and SIGBREAK events, manage signal listeners, and implement graceful shutdown handlers in your applications.

URL: https://docs.deno.com/examples/tutorials/os_signals


> ⚠️ 从 Deno v1.23 开始，Windows 仅支持监听 SIGINT 和 SIGBREAK。

## 概念

- [Deno.addSignalListener()](https://docs.deno.com/api/deno/~/Deno.addSignalListener)
  可用于捕获和监视操作系统信号。
- [Deno.removeSignalListener()](https://docs.deno.com/api/deno/~/Deno.removeSignalListener)
  可用于停止监听信号。

## 设置操作系统信号监听器

处理操作系统信号的 API 是基于已经熟悉的
[`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
和
[`removeEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)
API 模型化的。

> ⚠️ 请注意，监听操作系统信号并不会阻止事件循环完成，即如果没有其他挂起的异步操作，进程将退出。

你可以使用 `Deno.addSignalListener()` 函数来处理操作系统信号：

```ts title="add_signal_listener.ts"
console.log("按 Ctrl-C 触发 SIGINT 信号");

Deno.addSignalListener("SIGINT", () => {
  console.log("被中断！");
  Deno.exit();
});

// 添加一个超时以防止进程立即退出。
setTimeout(() => {}, 5000);
```

运行命令：

```shell
deno run add_signal_listener.ts
```

你可以使用 `Deno.removeSignalListener()` 函数注销之前添加的信号处理程序。

```ts title="signal_listeners.ts"
console.log("按 Ctrl-C 触发 SIGINT 信号");

const sigIntHandler = () => {
  console.log("被中断！");
  Deno.exit();
};
Deno.addSignalListener("SIGINT", sigIntHandler);

// 添加一个超时以防止进程立即退出。
setTimeout(() => {}, 5000);

// 在 1 秒后停止监听信号。
setTimeout(() => {
  Deno.removeSignalListener("SIGINT", sigIntHandler);
}, 1000);
```

运行命令：

```shell
deno run signal_listeners.ts
```

---

# 在 Deno 中使用上下文传播实现分布式追踪

> 在 Deno 应用中实现端到端的分布式追踪及自动上下文传播。本教程涵盖创建追踪服务、追踪上下文的自动传播，以及分布式追踪的可视化。

URL: https://docs.deno.com/examples/tutorials/otel_span_propagation


现代应用通常构建为多个服务相互通信的分布式系统。在调试问题或优化性能时，能够追踪请求在不同服务间的流动至关重要。这正是分布式追踪的作用所在。

自 Deno 2.3 起，运行时自动在服务边界间保留追踪上下文，使得分布式系统中的端到端追踪变得更加简单和强大。这意味着当一个服务向另一个服务发起请求时，追踪上下文会自动传播，让你能够将整个请求流程视为一个完整的追踪。

## 搭建分布式系统

我们的示例系统由两部分组成：

1. 一个提供 API 端点的服务器
2. 一个向服务器发起请求的客户端

### 服务器

我们搭建一个简单的 HTTP 服务器，用于响应 GET 请求并返回 JSON 消息：

```ts title="server.ts"
import { trace } from "npm:@opentelemetry/api@1";

const tracer = trace.getTracer("api-server", "1.0.0");

// 使用 Deno.serve 创建一个简单的 API 服务器
Deno.serve({ port: 8000 }, (req) => {
  return tracer.startActiveSpan("process-api-request", async (span) => {
    // 向 span 添加属性以提供更多上下文
    span.setAttribute("http.route", "/");
    span.updateName("GET /");

    // 添加一个 span 事件以便在追踪中查看
    span.addEvent("processing_request", {
      request_id: crypto.randomUUID(),
      timestamp: Date.now(),
    });

    // 模拟处理时间
    await new Promise((resolve) => setTimeout(resolve, 50));

    console.log("Server: Processing request in trace context");

    // 操作完成后结束 span
    span.end();

    return new Response(JSON.stringify({ message: "Hello from server!" }), {
      headers: { "Content-Type": "application/json" },
    });
  });
});
```

### 客户端

现在，让我们创建一个客户端向服务器发起请求：

```ts title="client.ts"
import { SpanStatusCode, trace } from "npm:@opentelemetry/api@1";

const tracer = trace.getTracer("api-client", "1.0.0");

// 为客户端操作创建一个父 span
await tracer.startActiveSpan("call-api", async (parentSpan) => {
  try {
    console.log("Client: Starting API call");

    // 该 span 内的 fetch 调用将自动：
    // 1. 为 fetch 操作创建子 span
    // 2. 将追踪上下文注入到外发请求头中
    const response = await fetch("http://localhost:8000/");
    const data = await response.json();

    console.log(`Client: Received response: ${JSON.stringify(data)}`);

    parentSpan.addEvent("received_response", {
      status: response.status,
      timestamp: Date.now(),
    });
  } catch (error) {
    console.error("Error calling API:", error);
    if (error instanceof Error) {
      parentSpan.recordException(error);
    }
    parentSpan.setStatus({
      code: SpanStatusCode.ERROR,
      message: error instanceof Error ? error.message : String(error),
    });
  } finally {
    parentSpan.end();
  }
});
```

## 使用 OpenTelemetry 进行追踪

客户端和服务器代码中已包含基础的 OpenTelemetry 仪表化：

1. 创建 tracer —— 两个文件均使用 `trace.getTracer()` 创建跟踪器，包含名称和版本信息。

2. 创建 span —— 我们使用 `startActiveSpan()` 创建表示操作的 span。

3. 添加上下文 —— 通过向 span 添加属性和事件提供更多上下文信息。

4. 结束 span —— 在操作完成时确保结束 span。

## 自动上下文传播

关键步骤发生在客户端向服务器发起请求时。客户端代码中的 fetch 调用：

```ts
const response = await fetch("http://localhost:8000/");
```

由于此 fetch 调用位于活动 span 内，Deno 会自动为 fetch 操作创建子 span，并将追踪上下文注入到外发请求头中。

服务器接收请求后，会从请求头中提取追踪上下文，并将服务器的 span 设为客户端 span 的子 span。

## 运行示例

运行此示例，首先启动服务器，为你的 otel 服务命名：

```sh
OTEL_DENO=true OTEL_SERVICE_NAME=server deno run --allow-net server.ts
```

然后，在另一个终端运行客户端，为客户端服务指定不同的名称，以便更清晰地观察传播：

```sh
OTEL_DENO=true OTEL_SERVICE_NAME=client deno run --allow-net client.ts
```

你应当看到：

1. 客户端打印日志 "Client: Starting API call"
2. 服务器打印日志 "Server: Processing request in trace context"
3. 客户端打印接收到的响应内容

## 查看追踪

要查看追踪，需要配置 OpenTelemetry 收集器和可视化工具，例如 [Grafana Tempo](/runtime/fundamentals/open_telemetry/#quick-start)。

可视化追踪时，你会看到：

1. 客户端的父 span
2. 连接到 HTTP 请求的子 span
3. 连接到服务器端的 span
4. 全部组成一个完整的追踪！

例如，在 Grafana 中的追踪可视化可能长这样：

![Viewing expanded traces in Grafana](./images/how-to/grafana/propagation.png)

🦕 现在你已经了解了 Deno 中的分布式追踪，接下来可以将这应用扩展到包含更多服务和异步操作的复杂系统中。

借助 Deno 的自动上下文传播，实现分布式追踪比以往任何时候都更简单！

---

# 如何使用 Planetscale 与 Deno

> Step-by-step guide to using Planetscale with Deno. Learn how to set up serverless MySQL databases, manage connections, execute queries, and build scalable applications with Planetscale's developer-friendly platform.

URL: https://docs.deno.com/examples/tutorials/planetscale


Planetscale 是一个与 MySQL 兼容的无服务器数据库，旨在为开发者提供工作流程，使开发者可以通过命令行创建、分支和部署数据库。

[在此处查看源码。](https://github.com/denoland/examples/tree/main/with-planetscale)

我们将使用 Planetscale 无服务器驱动程序 `@planetscale/database` 来与 Deno 配合使用。首先我们想要创建 `main.ts` 并从该包中导入连接方法：

```tsx
import { connect } from "npm:@planetscale/database@^1.4";
```

## 配置我们的连接

连接需要三种凭据：主机、用户名和密码。这些都是特定于数据库的，因此我们首先需要在 Planetscale 中创建一个数据库。您可以按照最初的说明[在这里](https://planetscale.com/docs/tutorials/planetscale-quick-start-guide)进行操作。别担心添加模式—我们可以通过 `@planetscale/database` 来完成这一点。

一旦您创建了数据库，前往概览，点击“连接”，选择“使用 `@planetscale/database` 连接”以获取主机和用户名。然后点击“密码”创建一个新的数据库密码。一旦您拥有这三项，您可以直接输入它们，或者更好的是，将它们存储为环境变量：

```bash
export HOST=<host>
export USERNAME=<username>
export PASSWORD=<password>
```

然后使用 `Deno.env` 调用它们：

```tsx
const config = {
  host: Deno.env.get("HOST"),
  username: Deno.env.get("USERNAME"),
  password: Deno.env.get("PASSWORD"),
};

const conn = connect(config);
```

如果您在仪表板中设置了环境变量，这在 Deno Deploy 上也可以工作。运行命令：

```shell
deno run --allow-net --allow-env main.ts
```

现在 `conn` 对象是一个与我们的 Planetscale 数据库的开放连接。

## 创建和填充我们的数据库表

现在您已成功建立连接，可以使用 SQL 命令通过 `conn.execute()` 创建表并插入初始数据：

```tsx
await conn.execute(
  "CREATE TABLE dinosaurs (id int NOT NULL AUTO_INCREMENT PRIMARY KEY, name varchar(255) NOT NULL, description varchar(255) NOT NULL);",
);
await conn.execute(
  "INSERT INTO `dinosaurs` (id, name, description) VALUES (1, 'Aardonyx', 'An early stage in the evolution of sauropods.'), (2, 'Abelisaurus', 'Abels lizard has been reconstructed from a single skull.'), (3, 'Deno', 'The fastest dinosaur that ever lived.')",
);
```

## 查询 Planetscale

我们也可以使用同样的 `conn.execute()` 来编写查询。让我们获取所有恐龙的列表：

```tsx
const results = await conn.execute("SELECT * FROM `dinosaurs`");
console.log(results.rows);
```

结果为：

```tsx
[
  {
    id: 1,
    name: "Aardonyx",
    description: "An early stage in the evolution of sauropods.",
  },
  {
    id: 2,
    name: "Abelisaurus",
    description: "Abels lizard has been reconstructed from a single skull.",
  },
  { id: 3, name: "Deno", description: "The fastest dinosaur that ever lived." },
];
```

我们也可以通过指定恐龙名称来仅获取数据库中的一行：

```tsx
const result = await conn.execute(
  "SELECT * FROM `dinosaurs` WHERE `name` = 'Deno'",
);
console.log(result.rows);
```

这将给我们一个单行结果：

```tsx
[{ id: 3, name: "Deno", description: "The fastest dinosaur that ever lived." }];
```

您可以在他们的[文档](https://planetscale.com/docs)中了解更多关于使用 Planetscale 的信息。

---

# 如何使用 Prisma 和 Oak 创建 RESTful API

> 使用 Prisma 和 Oak 以及 Deno 构建 RESTful API 的指南。学习如何设置数据库模式、生成客户端、实现 CRUD 操作，并以合适的类型安全性部署您的 API。

URL: https://docs.deno.com/examples/tutorials/prisma


[Prisma](https://prisma.io) 一直以来都是我们在 Deno 中最受欢迎的模块之一。鉴于 Prisma 的开发者体验非常出色，并且与众多持久数据存储技术兼容，需求是可以理解的。

我们很高兴向您展示如何在 Deno 中使用 Prisma。

在本教程中，我们将使用 Oak 和 Prisma 在 Deno 中设置一个简单的 RESTful API。

让我们开始吧。

[查看源代码](https://github.com/denoland/examples/tree/main/with-prisma) 或者 [查看视频教程](https://youtu.be/P8VzA_XSF8w)。

## 设置应用程序

首先创建文件夹 `rest-api-with-prisma-oak` 并导航到该文件夹：

```shell
mkdir rest-api-with-prisma-oak
cd rest-api-with-prisma-oak
```

然后，使用 Deno 运行 `prisma init`：

```shell
npx prisma@latest init --generator-provider prisma-client --output ./generated
```

让我们了解关键参数：

- `--generator-provider prisma-client`: 定义生成器提供者为 `"prisma-client"`，而非默认的 `"prisma-client-js"`。该 `"prisma-client"` 提供者针对 Deno 进行了优化，会生成兼容 Deno 运行时的 TypeScript 代码。

- `--output`: 定义 Prisma 将保存生成客户端文件的目录，包括类型定义和数据库访问工具。

这将生成 [`prisma/schema.prisma`](https://www.prisma.io/docs/orm/prisma-schema)。让我们用以下内容更新它：

:::tip

不要忘记在你的 schema.prisma 文件中的生成器块中添加 `runtime = "deno"`。这是 Prisma 正确与 Deno 一起工作所必需的。

:::

```ts
generator client {
  provider = "prisma-client"
  output   = "./generated"
  runtime = "deno"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Dinosaur {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String
}
```

Prisma 还会生成一个 `.env` 文件，其中包含 `DATABASE_URL` 环境变量。让我们将 `DATABASE_URL` 设置为 PostgreSQL 连接字符串。在本例中，我们将使用免费的 [Supabase PostgreSQL 数据库](https://supabase.com/database)。

接下来，创建数据库模式：

```shell
deno run -A npm:prisma@latest db push
```

完成后，我们需要生成 Prisma Client：

```shell
deno run -A npm:prisma@latest generate
```

## 在 Prisma 数据平台中设置 Accelerate

> 注意：此步骤为可选。Prisma Accelerate 并非基础功能所必需。

开始使用 Prisma 数据平台：

1. 注册免费 [Prisma 数据平台账户](https://console.prisma.io)。
2. 创建一个项目。
3. 进入您创建的项目。
4. 通过提供数据库的连接字符串启用 Accelerate。
5. 生成 Accelerate 连接字符串并复制到剪贴板。

将以 `prisma://` 开头的 Accelerate 连接字符串赋值给 `.env` 文件中的 `DATABASE_URL`，替换现有连接字符串。

接着，让我们创建一个种子脚本来初始化数据库。

## 为数据库添加种子数据

创建 `./prisma/seed.ts` 文件：

```shell
touch prisma/seed.ts
```

在 `./prisma/seed.ts` 中：

```ts
import { Prisma, PrismaClient } from "./generated/client.ts";

const prisma = new PrismaClient({
  datasourceUrl: Deno.env.get("DATABASE_URL"),
});

const dinosaurData: Prisma.DinosaurCreateInput[] = [
  {
    name: "Aardonyx",
    description: "在蜥脚类动物演化的早期阶段。",
  },
  {
    name: "Abelisaurus",
    description: "阿贝尔的蜥蜴是根据一个单独的头骨重建的。",
  },
  {
    name: "Acanthopholis",
    description: "不，这不是希腊的一个城市。",
  },
];

/**
 * 给数据库加种子。
 */

for (const u of dinosaurData) {
  const dinosaur = await prisma.dinosaur.create({
    data: u,
  });
  console.log(`创建了一个 ID 为 ${dinosaur.id} 的恐龙`);
}
console.log(`种子填充完成。`);

await prisma.$disconnect();
```

现在我们可以运行 `seed.ts`：

```shell
deno run -A --env prisma/seed.ts
```

:::tip

`--env` 标志用于告诉 Deno 从 `.env` 文件加载环境变量。

:::

完成后，您应该能够通过运行以下命令在 Prisma Studio 中看到您的数据：

```bash
deno run -A npm:prisma studio
```

您应该会看到与以下屏幕截图相似的内容：

![新恐龙出现在 Prisma 控制台](./images/how-to/prisma/1-dinosaurs-in-prisma.png)

## 创建您的 API 路由

我们将使用 [`oak`](https://jsr.io/@oak/oak) 来创建 API 路由。现在让我们保持简单。

首先创建一个 `main.ts` 文件：

```shell
touch main.ts
```

然后在您的 `main.ts` 文件中：

```ts
import { PrismaClient } from "./prisma/generated/client.ts";
import { Application, Router } from "jsr:@oak/oak";

/**
 * 初始化。
 */

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: Deno.env.get("DATABASE_URL")!,
    },
  },
});
const app = new Application();
const router = new Router();

/**
 * 设置路由。
 */

router
  .get("/", (context) => {
    context.response.body = "欢迎来到恐龙 API!";
  })
  .get("/dinosaur", async (context) => {
    // 获取所有恐龙。
    const dinosaurs = await prisma.dinosaur.findMany();
    context.response.body = dinosaurs;
  })
  .get("/dinosaur/:id", async (context) => {
    // 根据 ID 获取一只恐龙。
    const { id } = context.params;
    const dinosaur = await prisma.dinosaur.findUnique({
      where: {
        id: Number(id),
      },
    });
    context.response.body = dinosaur;
  })
  .post("/dinosaur", async (context) => {
    // 创建一只新的恐龙。
    const { name, description } = await context.request.body.json();
    const result = await prisma.dinosaur.create({
      data: {
        name,
        description,
      },
    });
    context.response.body = result;
  })
  .delete("/dinosaur/:id", async (context) => {
    // 根据 ID 删除一只恐龙。
    const { id } = context.params;
    const dinosaur = await prisma.dinosaur.delete({
      where: {
        id: Number(id),
      },
    });
    context.response.body = dinosaur;
  });

/**
 * 设置中间件。
 */

app.use(router.routes());
app.use(router.allowedMethods());

/**
 * 启动服务器。
 */

await app.listen({ port: 8000 });
```

现在，我们来运行它：

```shell
deno run -A --env main.ts
```

现在我们访问 `localhost:8000/dinosaur`：

![REST API 提供的所有恐龙的列表](./images/how-to/prisma/2-dinosaurs-from-api.png)

接下来，让我们用这个 `curl` 命令 `POST` 新用户：

```shell
curl -X POST http://localhost:8000/dinosaur -H "Content-Type: application/json" -d '{"name": "Deno", "description":"有史以来走在地球上最快、最安全、最易用的恐龙。" }'
```

您现在应该能在 Prisma Studio 中看到一行新数据：

![新恐龙 Deno 在 Prisma 中](./images/how-to/prisma/3-new-dinosaur-in-prisma.png)

很好！

## 接下来是什么？

使用 Deno 和 Prisma 构建您的下一个应用程序将更加高效和有趣，因为这两种技术都提供直观的开发者体验，包括数据建模、类型安全和强大的 IDE 支持。

如果您有兴趣将 Prisma 连接到 Deno Deploy，请 [查看这个很棒的指南](https://www.prisma.io/docs/guides/deployment/deployment-guides/deploying-to-deno-deploy)。

---

# Build Qwik with Deno

> Step-by-step guide to building Qwik applications with Deno. Learn about resumability, server-side rendering, route handling, and how to create fast, modern web applications with zero client-side JavaScript by default.

URL: https://docs.deno.com/examples/tutorials/qwik


[Qwik](https://qwik.dev/) 是一个 JavaScript 框架，通过利用可恢复性而不是水合，提供即时加载的 Web 应用程序。在本教程中，我们将构建一个简单的 Qwik 应用程序，并使用 Deno 运行它。该应用将显示恐龙列表。当你点击其中一只恐龙时，会将你带到一个包含更多细节的恐龙页面。

我们将讨论如何使用 Deno 构建一个简单的 Qwik 应用：

- [搭建一个 Qwik 应用](#scaffold-a-qwik-app)
- [设置数据和类型定义](#setup-data-and-type-definitions)
- [构建前端](#build-the-frontend)
- [后续步骤](#next-steps)

可以直接跳转到
[源码](https://github.com/denoland/examples/tree/main/with-qwik)，或者继续往下阅读！

## 搭建一个 Qwik 应用

我们可以通过 Deno 创建一个新的 Qwik 项目，如下所示：

```bash
deno init --npm qwik@latest
```

这将指导你完成 Qwik 和 Qwik City 的设置过程。在这里，我们选择了最简单的“空应用”部署，具有 npm 依赖项。

完成后，你将拥有如下的项目结构：

```
.
├── node_modules/
├── public/
└── src/
    ├── components/
    │   └── router-head/
    │       └── router-head.tsx
    └── routes/
        ├── index.tsx
        ├── layout.tsx
        ├── service-worker.ts
        ├── entry.dev.tsx
        ├── entry.preview.tsx
        ├── entry.ssr.tsx
        ├── global.css
        └── root.tsx
├── .eslintignore
├── .eslintrc.cjs
├── .gitignore
├── .prettierignore
├── package-lock.json
├── package.json
├── qwik.env.d.ts
├── README.md
├── tsconfig.json
└── vite.config.ts
```

大部分都是我们不会触碰的样板配置。了解 Qwik 如何工作的几个重要文件包括：

- `src/components/router-head/router-head.tsx`：管理你的 Qwik 应用中不同路由的 HTML 头元素（例如标题、元标签等）。
- `src/routes/index.tsx`：应用的主要入口点和用户访问根 URL 时看到的主页。
- `src/routes/layout.tsx`：定义包裹页面的常见布局结构，使你能够维护一致的 UI 元素，如页眉和页脚。
- `src/routes/service-worker.ts`：处理渐进式 Web 应用（PWA）功能、离线缓存和应用的后台任务。
- `src/routes/entry.ssr.tsx`：控制你的应用如何进行服务器端渲染，管理初始 HTML 生成和水合过程。
- `src/routes/root.tsx`：作为应用程序的外壳的根组件，包含全局提供者和主要路由结构。

现在我们可以在应用程序中构建自己的路由和文件。

## 设置数据和类型定义

我们将首先将我们的
[恐龙数据](https://github.com/denoland/examples/blob/main/with-qwik/src/data/dinosaurs.json)
添加到新的 `./src/data` 目录中，命名为 `dinosaurs.json`：

```jsonc
// ./src/data/dinosaurs.json

{
  "dinosaurs": [
    {
      "name": "霸王龙",
      "description": "一种巨大的肉食性恐龙，拥有强大的下颚和小巧的手臂。"
    },
    {
      "name": "腕龙",
      "description": "一种巨大的草食性恐龙，拥有非常长的脖子。"
    },
    {
      "name": "迅猛龙",
      "description": "一种小型但凶猛的掠食者，通常以群体狩猎。"
    }
    // ...
  ]
}
```

这就是我们的数据将从中提取的地方。在完整的应用中，这些数据将来自数据库。

> ⚠️️ 在本教程中，我们硬编码了数据。但是你可以连接到
> [多种数据库](https://docs.deno.com/runtime/tutorials/connecting_to_databases/) 和
> [甚至使用 ORM，如 Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/)与
> Deno。

接下来，让我们为我们的恐龙数据添加类型定义。我们将其放在 `./src/types.ts` 中：

```tsx
// ./src/types.ts

export type Dino = {
  name: string;
  description: string;
};
```

接下来，让我们添加 API 路由来提供这些数据。

## 添加 API 路由

首先，让我们创建一个路由，以加载主页的所有恐龙。此 API 端点使用 Qwik City 的
[`RequestHandler`](https://qwik.dev/docs/advanced/request-handling/) 创建一个 `GET` 端点，加载并返回我们的恐龙数据，并使用 json 帮助器进行适当的响应格式化。我们将在 `./src/routes/api/dinosaurs/index.ts` 中添加以下内容：

```tsx
// ./src/routes/api/dinosaurs/index.ts

import { RequestHandler } from "@builder.io/qwik-city";
import data from "~/data/dinosaurs.json" with { type: "json" };

export const onGet: RequestHandler = async ({ json }) => {
  const dinosaurs = data;
  json(200, dinosaurs);
};
```

接下来，让我们创建一个 API 路由，以获取单个恐龙的信息。这个路由将从 URL 获取参数，并用它来在我们的恐龙数据中进行搜索。我们将以下代码添加到 `./src/routes/api/dinosaurs/[name]/index.ts`：

```tsx
// ./src/routes/api/dinosaurs/[name]/index.ts

import { RequestHandler } from "@builder.io/qwik-city";
import data from "~/data/dinosaurs.json" with { type: "json" };

export const onGet: RequestHandler = async ({ params, json }) => {
  const { name } = params;
  const dinosaurs = data;

  if (!name) {
    json(400, { error: "未提供恐龙名称。" });
    return;
  }

  const dinosaur = dinosaurs.find(
    (dino) => dino.name.toLowerCase() === name.toLowerCase(),
  );

  if (!dinosaur) {
    json(404, { error: "未找到恐龙。" });
    return;
  }

  json(200, dinosaur);
};
```

现在 API 路由已连接并提供数据，让我们创建两个前端页面：主页和单个恐龙详情页。

## 构建前端

我们将通过更新 `./src/routes/index.tsx` 文件来创建我们的主页，使用 Qwik 的 [`routeLoader$`](https://qwik.dev/docs/route-loader/) 进行服务器端数据获取。这个 `component$` 在 SSR 期间通过 `useDinosaurs()` 加载并渲染恐龙数据：

```tsx
// ./src/routes/index.tsx

import { component$ } from "@builder.io/qwik";
import { Link, routeLoader$ } from "@builder.io/qwik-city";
import type { Dino } from "~/types";
import data from "~/data/dinosaurs.json" with { type: "json" };

export const useDinosaurs = routeLoader$(() => {
  return data;
});

export default component$(() => {
  const dinosaursSignal = useDinosaurs();

  return (
    <div class="container mx-auto p-4">
      <h1 class="text-3xl font-bold mb-4">欢迎来到恐龙应用</h1>
      <p class="mb-4">点击下面的恐龙以了解更多信息。</p>
      <ul class="space-y-2">
        {dinosaursSignal.value.dinosaurs.map((dinosaur: Dino) => (
          <li key={dinosaur.name}>
            <Link
              href={`/${dinosaur.name.toLowerCase()}`}
              class="text-blue-600 hover:underline"
            >
              {dinosaur.name}
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
});
```

现在我们有了主要的主页，让我们为单个恐龙信息添加一个页面。我们将使用 Qwik 的
[动态路由](https://qwik.dev/docs/routing/)，以 `[name]` 作为每个恐龙的关键字。此页面利用 `routeLoader$` 根据 URL 参数获取单个恐龙的详细信息，并内置错误处理以防无法找到恐龙。

该组件与我们的主页使用相同的 SSR 模式，但使用基于参数的数据加载，并为单个恐龙详情显示一个更简单的布局：

```tsx
// ./src/routes/[name]/index.tsx

import { component$ } from "@builder.io/qwik";
import { Link, routeLoader$ } from "@builder.io/qwik-city";
import type { Dino } from "~/types";
import data from "~/data/dinosaurs.json" with { type: "json" };

export const useDinosaurDetails = routeLoader$(({ params }): Dino => {
  const { dinosaurs } = data;
  const dinosaur = dinosaurs.find(
    (dino: Dino) => dino.name.toLowerCase() === params.name.toLowerCase(),
  );

  if (!dinosaur) {
    throw new Error("未找到恐龙");
  }

  return dinosaur;
});

export default component$(() => {
  const dinosaurSignal = useDinosaurDetails();

  return (
    <div class="container mx-auto p-4">
      <h1 class="text-3xl font-bold mb-4">{dinosaurSignal.value.name}</h1>
      <p class="mb-4">{dinosaurSignal.value.description}</p>
      <Link href="/" class="text-blue-600 hover:underline">
        返回所有恐龙
      </Link>
    </div>
  );
});
```

现在我们已经构建了我们的路由和前端组件，我们可以运行我们的应用：

```bash
deno task dev
```

这将启动应用程序，地址为 `localhost:5173`：

<figure>

<video class="w-full" alt="使用 Deno 构建的 Qwik 应用。" autoplay muted loop playsinline src="./images/how-to/qwik/demo.mp4"></video>

</figure>

完成！

## 后续步骤

🦕 现在你可以使用 Deno 构建和运行 Qwik 应用！以下是一些可以增强你恐龙应用的方法：

下一步可能是使用 Qwik 的延迟加载功能来加载恐龙图像和其他组件，或为复杂功能添加客户端状态管理。

- 添加持久数据存储
  [使用像 Postgres 或 MongoDB 的数据库](https://docs.deno.com/runtime/tutorials/connecting_to_databases/)
  和像 [Drizzle](https://docs.deno.com/examples/drizzle_tutorial/) 或
  [Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/) 的 ORM
- 使用 Qwik 的延迟加载功能来处理恐龙图像和组件
- 添加客户端状态管理
- 将你的应用自托管到
  [AWS](https://docs.deno.com/runtime/tutorials/aws_lightsail/),
  [Digital Ocean](https://docs.deno.com/runtime/tutorials/digital_ocean/), 和
  [Google Cloud Run](https://docs.deno.com/runtime/tutorials/google_cloud_run/)

---

# 使用 Vite 构建 React 应用

> Deno 和 Vite 构建 React 应用的完整指南。学习如何搭建项目、实现路由、添加 API 接口以及部署你的全栈 TypeScript 应用。

URL: https://docs.deno.com/examples/tutorials/react


[React](https://reactjs.org) 是最广泛使用的 JavaScript 前端库。

在本教程中，我们将使用 Deno 构建一个简单的 React 应用。该应用会展示一列恐龙列表。点击其中一个时，会跳转到该恐龙详情页面。你可以查看
[完成版应用的 GitHub 仓库](https://github.com/denoland/tutorial-with-react)
以及
[Deno Deploy 上的应用演示](https://tutorial-with-react.deno.deno.net/)

:::info 部署你自己的应用

想跳过教程，立即部署完成版应用？点击下面按钮，立即部署一份完整的 SvelteKit 恐龙应用的副本到 Deno Deploy。你将获得一个可用的实时应用，便于你在学习过程中自定义和修改！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-react&mode=dynamic&entrypoint=api/main.ts&build=deno+task+build&install=deno+install)

:::

## 使用 Vite 创建基础 React 应用

本教程将使用 [Vite](https://vitejs.dev/) 在本地提供服务。  
Vite 是现代 Web 项目的构建工具和开发服务器。它与 React 和 Deno 配合良好，利用 ES 模块，允许你直接导入 React 组件。

在终端中运行下面命令，使用 TypeScript 模板创建新的 React 应用：

```sh
$ deno init --npm vite my-react-app --template react-ts
```

## 运行开发服务器

切换到新创建的 React 应用目录并安装依赖：

```sh
cd <your_new_react_app>
deno install
```

现在你可以通过下面命令启动新 React 应用的服务：

```sh
deno run dev
```

这会启动 Vite 服务器，点击输出中的 localhost 链接，在浏览器中查看你的应用。

## 配置项目

我们将构建一个带有 Deno 后端的全栈 React 应用。需要配置 Vite 和 Deno 以实现协同工作。

安装 Vite 的 deno 插件、React 类型声明和 Vite React 插件：

```sh
deno add npm:@deno/vite-plugin@latest npm:@types/react@latest npm:@vitejs/plugin-react@latest
```

还需安装 Deno 的 Oak Web 框架处理 API 请求，以及 CORS 中间件允许来自 React 应用的跨域请求：

```sh
deno add jsr:@oak/oak jsr:@tajpouria/cors
```

这会将依赖写入新的 `deno.json` 文件。

我们还将在该文件中添加几个任务，方便在开发与生产模式下运行，并添加配置使 Deno 支持 React 和 Vite。将如下内容添加到你的 `deno.json` 文件：

```json
"tasks": {
    "dev": "deno run -A npm:vite & deno run server:start",
    "build": "deno run -A npm:vite build",
    "server:start": "deno run -A --watch ./api/main.ts",
    "serve": "deno run build && deno run server:start"
},
"nodeModulesDir": "auto",
"compilerOptions": {
    "types": [
        "react",
        "react-dom",
        "@types/react"
    ],
    "lib": [
        "dom",
        "dom.iterable",
        "deno.ns"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "react"
}
```

你可以同时使用 `package.json` 和 `deno.json` 来管理依赖和配置，也可以删除 `package.json`，只使用 `deno.json`，但需先把 `package.json` 中的依赖迁移到 `deno.json` 的 imports。

## 添加后端 API

我们的项目将拥有提供恐龙数据的后端 API。该 API 使用 Deno 和 Oak 构建，提供获取恐龙列表和特定恐龙详细信息的接口，数据来自一个 JSON 文件。实际生产中一般会是数据库，这里用静态 JSON 文件作为示例。

在项目根目录新建 `api` 文件夹。该目录下新建 `data.json` 文件，复制 [恐龙数据](https://github.com/denoland/tutorial-with-react/blob/main/api/data.json) 进该文件。

接着在 `api` 目录中创建 `main.ts` 文件，含处理 API 请求的 Oak 服务器代码。先导入依赖，创建 Oak 应用和路由器：

```ts title="api/main.ts"
import { Application, Router } from "@oak/oak";
import { oakCors } from "@tajpouria/cors";
import routeStaticFilesFrom from "./util/routeStaticFilesFrom.ts";
import data from "./data.json" with { type: "json" };

export const app = new Application();
const router = new Router();
```

然后定义两个主要 API 路由：

```ts title="api/main.ts"
router.get("/api/dinosaurs", (context) => {
  context.response.body = data;
});

router.get("/api/dinosaurs/:dinosaur", (context) => {
  if (!context?.params?.dinosaur) {
    context.response.body = "未提供恐龙名称。";
  }

  const dinosaur = data.find((item) =>
    item.name.toLowerCase() === context.params.dinosaur.toLowerCase()
  );

  context.response.body = dinosaur ?? "未找到恐龙。";
});
```

最后配置服务器中间件并启动监听：

```ts title="api/main.ts"
app.use(oakCors());
app.use(router.routes());
app.use(router.allowedMethods());
app.use(routeStaticFilesFrom([
  `${Deno.cwd()}/dist`,
  `${Deno.cwd()}/public`,
]));

if (import.meta.main) {
  console.log("服务器正在 http://localhost:8000 上监听");
  await app.listen({ port: 8000 });
}
```

服务器配置了 CORS，提供 API 路由，并从 `dist`（构建产物）和 `public` 目录提供静态文件。

## 提供静态文件

Oak 服务器还会提供构建后的 React 应用。我们需要配置它从 Vite 输出的 `dist` 目录提供静态文件。这里用工具函数 `routeStaticFilesFrom` 实现。在 `api` 目录下新建 `util/routeStaticFilesFrom.ts` 文件，内容如下：

```ts title="api/util/routeStaticFilesFrom.ts"
import { Context, Next } from "jsr:@oak/oak";

export default function routeStaticFilesFrom(staticPaths: string[]) {
  return async (context: Context<Record<string, object>>, next: Next) => {
    for (const path of staticPaths) {
      try {
        await context.send({ root: path, index: "index.html" });
        return;
      } catch {
        continue;
      }
    }

    await next();
  };
}
```

该函数尝试从给定路径中提供静态文件，找不到时调用下一个中间件。它会提供 `dist` 目录中的 `index.html`，即 React 应用的入口。

你可以通过运行 `deno run dev`，再在浏览器访问 `localhost:8000/api/dinosaurs` 测试 API，查看返回的所有恐龙 JSON 数据。

## React 应用设置

### 入口文件

React 应用入口在 `src/main.tsx`，这里无需修改，但值得关注这里将 React 应用挂载到 DOM。`react-dom/client` 中的 `createRoot` 将 `App` 组件渲染到 `index.html` 中的 `root` 节点。以下为 `src/main.tsx` 代码：

```tsx title="src/main.tsx"
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.tsx";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

## 添加路由

应用将有两个路由：`/` 和 `/:dinosaur`。

在 `src/App.tsx` 中设置路由：

```tsx title="src/App.tsx"
import { BrowserRouter, Route, Routes } from "react-router-dom";
import Index from "./pages/index.tsx";
import Dinosaur from "./pages/Dinosaur.tsx";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Index />} />
        <Route path="/:selectedDinosaur" element={<Dinosaur />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

## 代理以转发 API 请求

Vite 在端口 `3000` 提供 React 应用，API 在端口 `8000`。我们需要在 `vite.config.ts` 配置代理，将 API 请求转发：

```ts title="vite.config.ts"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import deno from "@deno/vite-plugin";

export default defineConfig({
  server: {
    port: 3000,
    proxy: {
      "/api": {
        target: "http://localhost:8000",
        changeOrigin: true,
      },
    },
  },
  plugins: [react(), deno()],
  optimizeDeps: {
    include: ["react/jsx-runtime"],
  },
});
```

## 创建页面

创建新目录 `pages`，再创建两个文件 `src/pages/index.tsx` 和 `src/pages/Dinosaur.tsx`。  
`Index` 页面列出所有恐龙，`Dinosaur` 页面展示单个恐龙详情。

### index.tsx

该页面从 API 获取恐龙列表，渲染成链接：

```tsx title="src/pages/index.tsx"
import { useEffect, useState } from "react";
import { Link } from "react-router-dom";

export default function Index() {
  const [dinosaurs, setDinosaurs] = useState([]);

  useEffect(() => {
    (async () => {
      const response = await fetch(`/api/dinosaurs/`);
      const allDinosaurs = await response.json();
      setDinosaurs(allDinosaurs);
    })();
  }, []);

  return (
    <main id="content">
      <h1>🦕 Dinosaur app</h1>
      <p>点击下方恐龙，了解详情。</p>
      {dinosaurs.map((dinosaur: { name: string; description: string }) => {
        return (
          <Link
            to={`/${dinosaur.name.toLowerCase()}`}
            key={dinosaur.name}
            className="dinosaur"
          >
            {dinosaur.name}
          </Link>
        );
      })}
    </main>
  );
}
```

### Dinosaur.tsx

该页面从 API 获取特定恐龙详情，并显示：

```tsx title="src/pages/Dinosaur.tsx"
import { useEffect, useState } from "react";
import { Link, useParams } from "react-router-dom";

export default function Dinosaur() {
  const { selectedDinosaur } = useParams();
  const [dinosaur, setDino] = useState({ name: "", description: "" });

  useEffect(() => {
    (async () => {
      const resp = await fetch(`/api/dinosaurs/${selectedDinosaur}`);
      const dino = await resp.json();
      setDino(dino);
    })();
  }, [selectedDinosaur]);

  return (
    <div>
      <h1>{dinosaur.name}</h1>
      <p>{dinosaur.description}</p>
      <Link to="/">🠠 返回所有恐龙</Link>
    </div>
  );
}
```

### 美化你的应用

我们为你编写了 [基础样式](https://raw.githubusercontent.com/denoland/tutorial-with-react/refs/heads/main/src/index.css)，可以复制到 `src/index.css`。

## 运行应用

运行应用，使用 `deno.json` 中定义的开发任务：

```sh
deno run dev
```

此命令将：

1. 在 3000 端口启动 Vite 开发服务器  
2. 在 8000 端口启动 API 服务器  
3. 配置代理，将前端 `/api` 请求转发给后端  

在浏览器访问 `localhost:3000`，你应能看到恐龙应用，点击列表查看详情。

## 理解项目结构

看看项目关键文件与目录：

```text
tutorial-with-react/
├── api/                    # 后端 API
│   ├── data.json          # 恐龙数据（700+ 种）
│   ├── main.ts            # 带 API 路由的 Oak 服务器
│   └── util/
│       └── routeStaticFilesFrom.ts
├── src/                    # React 前端
│   ├── main.tsx           # React 应用入口
│   ├── App.tsx            # 主应用及路由
│   ├── index.css          # 全局样式
│   └── pages/
│       ├── index.tsx      # 含恐龙列表的首页
│       └── Dinosaur.tsx   # 单个恐龙页面
├── public/                 # 静态资源
├── deno.json              # Deno 配置和任务
├── package.json           # Vite 的 npm 依赖
├── vite.config.ts         # 带代理的 Vite 配置
└── index.html             # HTML 模板
```

### 关键概念

1. **混合依赖管理**：项目同时使用 Deno 和 npm 依赖。服务器端依赖（如 Oak）用 Deno 管理，前端依赖则由 Vite 通过 npm 管理。

2. **开发与生产环境**：开发时，Vite 在 3000 端口提供 React 应用，并代理 API 请求到 8000 端口的 Oak 服务器。生产时，Oak 服务器在 8000 端口同时提供构建好的 React 应用和 API。

3. **现代 React 模式**：应用使用 React 18（注：React 19 尚未发布，文中应为 React 18），函数组件，Hooks 和 React Router 进行导航。

4. **类型安全**：示例中未使用独立类型文件，但大型项目里建议为数据结构创建 TypeScript 接口。

你可以在 [Deno Deploy 运行的应用](https://tutorial-with-react.deno.deno.net/) 看到示例。

## 构建和部署

我们配置了一个 `serve` 任务，构建 React 应用并由 Oak 后端提供。运行以下命令以生产模式构建和启动：

```sh
deno run build
deno run serve
```

此操作会：

1. 使用 Vite 构建 React 应用（输出到 `dist/`）  
2. 启动 Oak 服务器，提供 API 及构建后的 React 应用  

浏览器访问 `localhost:8000` 查看生产版本！

你可以将该应用部署到喜欢的云平台。推荐使用 [Deno Deploy](https://deno.com/deploy)，部署方便快捷。只需创建 GitHub 仓库并推送代码，然后连接到 Deno Deploy 即可。

### 创建 GitHub 仓库

[创建新的 GitHub 仓库](https://github.com/new)，初始化并推送应用代码：

```sh
git init -b main
git remote add origin https://github.com/<your_github_username>/<your_repo_name>.git
git add .
git commit -am 'my react app'
git push -u origin main
```

### 部署到 Deno Deploy

代码上传 GitHub 后，你可以
[将其部署至 Deno Deploy<sup>EA</sup>](https://console.deno.com/)。

完整部署流程请参考 [Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在你已准备好用 Vite 和 Deno 脚手架搭建和开发 React 应用！你可以构建超高速 Web 应用。希望你喜欢探索这些前沿工具，期待看到你的作品！

---

# 如何在 Deno 中使用 Redis

> Step-by-step guide to using Redis with Deno. Learn how to set up caching, implement message brokers, handle data streaming, and optimize your applications with Redis's in-memory data store.

URL: https://docs.deno.com/examples/tutorials/redis


[Redis](https://redis.io/) 是一个内存数据存储，你可以用它来缓存、作为消息代理或用于流数据处理。

[在这里查看源代码。](https://github.com/denoland/examples/tree/main/with-redis)

在这里，我们将设置 Redis 来缓存 API 调用的数据，从而加快对该数据后续请求的响应速度。我们将会：

- 设置一个 Redis 客户端，将每个 API 调用的数据保存在内存中
- 设置一个 Deno 服务器，以便我们可以方便地请求特定数据
- 在服务器处理程序中调用 Github API 来在第一次请求时获取数据
- 在每一次后续请求中从 Redis 提供数据

我们可以在一个文件 `main.ts` 中完成这一切。

## 连接到 Redis 客户端

我们需要两个模块。第一个是 Deno 服务器。我们将使用这个模块来获取用户的信息以查询我们的 API。第二个是 Redis。我们可以使用 `npm:` 修饰符获取 Redis 的节点包：

```tsx
import { createClient } from "npm:redis@^4.5";
```

我们使用 `createClient` 创建一个 Redis 客户端并连接到我们的本地 Redis 服务器：

```tsx
// 连接到本地的 Redis 实例
const client = createClient({
  url: "redis://localhost:6379",
});

await client.connect();
```

你还可以在这个 [配置](https://github.com/redis/node-redis/blob/master/docs/client-configuration.md) 对象中单独设置主机、用户、密码和端口。

## 设置服务器

我们的服务器将作为 Github API 的一个封装。客户端可以通过 URL 路径名调用我们的服务器，格式为 `http://localhost:3000/{username}`。

解析路径名并调用 Github API 将在我们服务器的处理函数内进行。我们去掉了前导斜杠，这样就得到了一个可以传递给 Github API 作为用户名的变量。然后我们将响应返回给用户。

```tsx
Deno.serve({ port: 3000 }, async (req) => {
  const { pathname } = new URL(req.url);
  // 去掉前导斜杠
  const username = pathname.substring(1);
  const resp = await fetch(`https://api.github.com/users/${username}`);
  const user = await resp.json();
  return new Response(JSON.stringify(user), {
    headers: {
      "content-type": "application/json",
    },
  });
});
```

我们用下面的命令来运行它：

```tsx
deno run --allow-net main.ts
```

如果我们在 Postman 中访问 [http://localhost:3000/ry](http://localhost:3000/ry)，我们将获得 Github 的响应：

![uncached-redis-body.png](./images/how-to/redis/uncached-redis-body.png)

让我们使用 Redis 来缓存这个响应。

## 检查缓存

一旦我们从 Github API 得到响应，我们可以使用 `client.set` 将其缓存到 Redis 中，将我们的用户名作为键，用户对象作为值：

```tsx
await client.set(username, JSON.stringify(user));
```

下次请求相同的用户名时，我们可以使用 `client.get` 来获取缓存的用户：

```tsx
const cached_user = await client.get(username);
```

如果密钥不存在，这将返回 null。因此我们可以在某些流程控制中使用它。当我们得到用户名时，我们将首先检查是否已经在缓存中拥有该用户。如果有，我们将提供缓存的结果。如果没有，我们将调用 Github API 获取用户，缓存它，然后提供 API 结果。在这两种情况下，我们将添加一个自定义头来显示我们正在提供的版本：

```tsx
const server = new Server({
  handler: async (req) => {
    const { pathname } = new URL(req.url);
    // 去掉前导斜杠
    const username = pathname.substring(1);
    const cached_user = await client.get(username);
    if (cached_user) {
      return new Response(cached_user, {
        headers: {
          "content-type": "application/json",
          "is-cached": "true",
        },
      });
    } else {
      const resp = await fetch(`https://api.github.com/users/${username}`);
      const user = await resp.json();
      await client.set(username, JSON.stringify(user));
      return new Response(JSON.stringify(user), {
        headers: {
          "content-type": "application/json",
          "is-cached": "false",
        },
      });
    }
  },

  port: 3000,
});

server.listenAndServe();
```

第一次运行这段代码我们将获得与上述相同的响应，并且我们将看到 `is-cached` 头被设置为 `false`：

![uncached-redis-header.png](./images/how-to/redis/uncached-redis-header.png)

但当再次使用相同的用户名调用时，我们得到了缓存的结果。内容是相同的：

![cached-redis-body.png](./images/how-to/redis/cached-redis-body.png)

但头部显示我们有缓存：

![cached-redis-header.png](./images/how-to/redis/cached-redis-header.png)

我们还可以看到响应快了大约 200 毫秒！

你可以在 [这里](https://redis.io/docs/) 查看 Redis 文档，以及在 [这里](https://github.com/redis/node-redis) 查看 Redis 节点包。

---

# Run a script

> A guide to creating and running basic scripts with Deno. Learn how to write and execute JavaScript and TypeScript code, understand runtime environments, and get started with fundamental Deno concepts.

URL: https://docs.deno.com/examples/tutorials/run_script


Deno 是一个安全的 JavaScript 和 TypeScript 运行时。

运行时是代码执行的环境。它提供了程序运行所需的基础设施，处理内存管理、I/O 操作以及与外部资源的交互等事务。运行时负责将高层次的代码（JavaScript 或 TypeScript）转换为计算机可以理解的机器指令。

当你在网页浏览器中运行 JavaScript（如 Chrome、Firefox 或 Edge）时，你正在使用浏览器运行时。

浏览器运行时与浏览器本身紧密耦合。它们提供了用于操作文档对象模型（DOM）、处理事件、发起网络请求等的 API。这些运行时是沙箱化的，它们在浏览器的安全模型中运行。它们无法访问浏览器之外的资源，比如文件系统或环境变量。

当你使用 Deno 运行代码时，你是在主机上直接执行你的 JavaScript 或 TypeScript 代码，而不是在浏览器的上下文中。因此，Deno 程序可以访问主机计算机上的资源，比如文件系统、环境变量和网络套接字。

Deno 提供了无缝的 JavaScript 和 TypeScript 代码运行体验。无论你喜欢 JavaScript 的动态特性还是 TypeScript 的类型安全，Deno 都能满足你的需求。

## 运行脚本

在本教程中，我们将使用 Deno 创建一个简单的 "Hello World" 示例，分别用 JavaScript 和 TypeScript 来演示。

我们将定义一个 `capitalize` 函数，该函数将单词的首字母大写。然后，我们定义一个 `hello` 函数，该函数返回带有大写名字的问候消息。最后，我们用不同的名字调用 `hello` 函数并将输出打印到控制台。

### JavaScript

首先，创建一个 `hello-world.js` 文件并添加以下代码：

```js title="hello-world.js"
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function hello(name) {
  return "Hello " + capitalize(name);
}

console.log(hello("john"));
console.log(hello("Sarah"));
console.log(hello("kai"));
```

使用 `deno run` 命令运行脚本：

```sh
$ deno run hello-world.js
Hello John
Hello Sarah
Hello Kai
```

### TypeScript

这个 TypeScript 示例与上面的 JavaScript 示例完全相同，代码只是增加了 TypeScript 支持的类型信息。

创建一个 `hello-world.ts` 文件并添加以下代码：

```ts title="hello-world.ts"
function capitalize(word: string): string {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function hello(name: string): string {
  return "Hello " + capitalize(name);
}

console.log(hello("john"));
console.log(hello("Sarah"));
console.log(hello("kai"));
```

使用 `deno run` 命令运行 TypeScript 脚本：

```sh
$ deno run hello-world.ts
Hello John
Hello Sarah
Hello Kai
```

🦕 恭喜你！现在你知道如何用 JavaScript 和 TypeScript 创建一个简单的脚本，并且如何使用 `deno run` 命令在 Deno 中运行它。继续探索教程和示例，以了解更多有关 Deno 的信息！

---

# Snapshot testing

> Learn how to use snapshot testing in Deno to compare outputs against recorded references, making it easier to detect unintended changes in your code

URL: https://docs.deno.com/examples/tutorials/snapshot


Snapshot testing is a testing technique that captures the output of your code
and compares it against a stored reference version. Rather than manually writing
assertions for each property, you let the test runner record the entire output
structure, making it easier to detect any unexpected changes.

The [Deno Standard Library](/runtime/fundamentals/standard_library/) has a
[snapshot module](https://jsr.io/@std/testing/doc/snapshot), which enables
developers to write tests which assert a value against a reference snapshot.
This reference snapshot is a serialized representation of the original value and
is stored alongside the test file.

## Basic usage

The `assertSnapshot` function will create a snapshot of a value and compare it
to a reference snapshot, which is stored alongside the test file in the
`__snapshots__` directory.

To create an initial snapshot (or to update an existing snapshot), use the
`-- --update` flag with the `deno test` command.

### Basic snapshot example

The below example shows how to use the snapshot library with the `Deno.test`
API. We can test a snapshot of a basic object, containing string and number
properties.

The `assertSnapshot(t, a)` function compares the object against a stored
snapshot. The `t` parameter is the test context that Deno provides, which the
snapshot function uses to determine the test name and location for storing
snapshots.

```ts title="example_test.ts"
import { assertSnapshot } from "jsr:@std/testing/snapshot";

Deno.test("isSnapshotMatch", async (t) => {
  const a = {
    hello: "world!",
    example: 123,
  };
  await assertSnapshot(t, a);
});
```

You will need to grant read and write file permissions in order for Deno to
write a snapshot file and then read it to test the assertion. If it is the first
time you are running the test a do not already have a snapshot, add the
`--update` flag:

```bash
deno test --allow-read --allow-write -- --update
```

If you already have a snapshot file, you can run the test with:

```bash
deno test --allow-read
```

The test will compare the current output of the object against the stored
snapshot. If they match, the test passes; if they differ, the test fails.

The snapshot file will look like this:

```ts title="__snapshots__/example_test.ts.snap"
export const snapshot = {};

snapshot[`isSnapshotMatch 1`] = `
{
  example: 123,
  hello: "world!",
}
`;
```

You can edit your test to change the `hello` string to `"everyone!"` and run the
test again with `deno test --allow-read`. This time the `assertSnapshot`
function will throw an `AssertionError`, causing the test to fail because the
snapshot created during the test does not match the one in the snapshot file.

## Updating snapshots

When adding new snapshot assertions to your test suite, or when intentionally
making changes which cause your snapshots to fail, you can update your snapshots
by running the snapshot tests in update mode. Tests can be run in update mode by
passing the `--update` or `-u` flag as an argument when running the test. When
this flag is passed, then any snapshots which do not match will be updated.

```bash
deno test --allow-read --allow-write -- --update
```

:::note

New snapshots will only be created when the `--update` flag is present.

:::

## Permissions

When running snapshot tests, the `--allow-read` permission must be enabled, or
else any calls to `assertSnapshot` will fail due to insufficient permissions.
Additionally, when updating snapshots, the `--allow-write` permission must be
enabled, as this is required in order to update snapshot files.

The assertSnapshot function will only attempt to read from and write to snapshot
files. As such, the allow list for `--allow-read` and `--allow-write` can be
limited to only include existing snapshot files, if desired.

## Version Control

Snapshot testing works best when changes to snapshot files are committed
alongside other code changes. This allows for changes to reference snapshots to
be reviewed along side the code changes that caused them, and ensures that when
others pull your changes, their tests will pass without needing to update
snapshots locally.

## Options

The `assertSnapshot` function can be called with an `options` object which
offers greater flexibility and enables some non standard use cases:

```ts
import { assertSnapshot } from "jsr:@std/testing/snapshot";

Deno.test("isSnapshotMatch", async (t) => {
  const a = {
    hello: "world!",
    example: 123,
  };
  await assertSnapshot(t, a, {/*custom options go here*/});
});
```

### serializer

When you run a test with `assertSnapshot`, the data you're testing needs to be
converted to a string format that can be written to the snapshot file (when
creating or updating snapshots) and compared with the existing snapshot (when
validating), this is called serialization.

The `serializer` option allows you to provide a custom serializer function. This
custom function will be called by `assertSnapshot` and be passed the value being
asserted. Your custom function must:

1. Return a `string`
2. Be deterministic, (it will always produce the same output, given the same
   input).

The code below shows a practical example of creating and using a custom
serializer function for snapshot testing. This serialiser removes any ANSI
colour codes from a string using the
[`stripColour`](https://jsr.io/@std/fmt/doc/colors) string formatter from the
Deno Standard Library.

```ts title="example_test.ts"
import { assertSnapshot, serialize } from "jsr:@std/testing/snapshot";
import { stripColor } from "jsr:@std/fmt/colors";

/**
 * Serializes `actual` and removes ANSI escape codes.
 */
function customSerializer(actual: string) {
  return serialize(stripColor(actual));
}

Deno.test("Custom Serializer", async (t) => {
  const output = "\x1b[34mHello World!\x1b[39m";
  await assertSnapshot(t, output, {
    serializer: customSerializer,
  });
});
```

```ts title="__snapshots__/example_test.ts.snap"
snapshot = {};

snapshot[`Custom Serializer 1`] = `"Hello World!"`;
```

Custom serializers can be useful in a variety of scenarios:

- To remove irrelevant formatting (like ANSI codes shown above) and improve
  legibility
- To handle non-deterministic data. Timestamps, UUIDs, or random values can be
  replaced with placeholders
- To mask or remove sensitive data that shouldn't be saved in snapshots
- Custom formatting to present complex objects in a domain-specific format

### Serialization with `Deno.customInspect`

Because the default serializer uses `Deno.inspect` under the hood, you can set
the property `Symbol.for("Deno.customInspect")` to a custom serialization
function if desired:

```ts title="example_test.ts"
// example_test.ts
import { assertSnapshot } from "jsr:@std/testing/snapshot";

class HTMLTag {
  constructor(
    public name: string,
    public children: Array<HTMLTag | string> = [],
  ) {}

  public render(depth: number) {
    const indent = "  ".repeat(depth);
    let output = `${indent}<${this.name}>\n`;
    for (const child of this.children) {
      if (child instanceof HTMLTag) {
        output += `${child.render(depth + 1)}\n`;
      } else {
        output += `${indent}  ${child}\n`;
      }
    }
    output += `${indent}</${this.name}>`;
    return output;
  }

  public [Symbol.for("Deno.customInspect")]() {
    return this.render(0);
  }
}

Deno.test("Page HTML Tree", async (t) => {
  const page = new HTMLTag("html", [
    new HTMLTag("head", [
      new HTMLTag("title", [
        "Simple SSR Example",
      ]),
    ]),
    new HTMLTag("body", [
      new HTMLTag("h1", [
        "Simple SSR Example",
      ]),
      new HTMLTag("p", [
        "This is an example of how Deno.customInspect could be used to snapshot an intermediate SSR representation",
      ]),
    ]),
  ]);

  await assertSnapshot(t, page);
});
```

This test will produce the following snapshot.

```ts title="__snapshots__/example_test.ts.snap"
export const snapshot = {};

snapshot[`Page HTML Tree 1`] = `
<html>
  <head>
    <title>
      Simple SSR Example
    </title>
  </head>
  <body>
    <h1>
      Simple SSR Example
    </h1>
    <p>
      This is an example of how Deno.customInspect could be used to snapshot an intermediate SSR representation
    </p>
  </body>
</html>
`;
```

In contrast, when we remove the `Deno.customInspect` method, the test will
produce the following snapshot:

```ts title="__snapshots__/example_test.ts.snap"
export const snapshot = {};

snapshot[`Page HTML Tree 1`] = `HTMLTag {
  children: [
    HTMLTag {
      children: [
        HTMLTag {
          children: [
            "Simple SSR Example",
          ],
          name: "title",
        },
      ],
      name: "head",
    },
    HTMLTag {
      children: [
        HTMLTag {
          children: [
            "Simple SSR Example",
          ],
          name: "h1",
        },
        HTMLTag {
          children: [
            "This is an example of how Deno.customInspect could be used to snapshot an intermediate SSR representation",
          ],
          name: "p",
        },
      ],
      name: "body",
    },
  ],
  name: "html",
}`;
```

You can see that this second snapshot is much less readable. This is because:

1. The keys are sorted alphabetically, so the name of the element is displayed
   after its children
2. It includes a lot of extra information, causing the snapshot to be more than
   twice as long
3. It is not an accurate serialization of the HTML which the data represents

Note that in this example it would be possible to achieve the same result by
calling:

```ts
await assertSnapshot(t, page.render(0));
```

However, depending on the public API you choose to expose, this may not be
practical.

It is also worth considering that this could have an impact beyond your snapshot
testing. For example, `Deno.customInspect` is also used to serialize objects
when calling `console.log` (and in some other cases). This may or may not be
desirable.

### `dir` and `path`

The `dir` and `path` options allow you to control where the snapshot file will
be saved to and read from. These can be absolute paths or relative paths. If
relative, they will be resolved relative to the test file.

For example, if your test file is located at `/path/to/test.ts` and the `dir`
option is set to `snapshots`, then the snapshot file would be written to
`/path/to/snapshots/test.ts.snap`.

- `dir` allows you to specify the snapshot directory, while still using the
  default format for the snapshot file name.

- `path` allows you to specify the directory and file name of the snapshot file.

If your test file is located at `/path/to/test.ts` and the `path` option is set
to `snapshots/test.snapshot`, then the snapshot file would be written to
`/path/to/snapshots/test.snapshot`.

:::note

If both `dir` and `path` are specified, the `dir` option will be ignored and the
`path` option will be handled as normal.

:::

### `mode`

The `mode` option controls how `assertSnapshot` behaves regardless of command
line flags and has two settings, `assert` or `update`:

- `assert`: Always performs comparison only, ignoring any `--update` or `-u`
  flags. If snapshots don't match, the test will fail with an `AssertionError`.

- `update`: Always updates snapshots. Any mismatched snapshots will be updated
  after tests complete.

This option is useful when you need different snapshot behaviors within the same
test suite:

```ts
// Create a new snapshot or verify an existing one
await assertSnapshot(t, stableComponent);

// Always update this snapshot regardless of command line flags
await assertSnapshot(t, experimentalComponent, {
  mode: "update",
  name: "experimental feature",
});

// Always verify but never update this snapshot regardless of command line flags
await assertSnapshot(t, criticalComponent, {
  mode: "assert",
  name: "critical feature",
});
```

### `name`

The name of the snapshot. If unspecified, the name of the test step will be used
instead.

```ts title="example_test.ts"
import { assertSnapshot } from "jsr:@std/testing/snapshot";

Deno.test("isSnapshotMatch", async (t) => {
  const a = {
    hello: "world!",
    example: 123,
  };
  await assertSnapshot(t, a, {
    name: "Test Name",
  });
});
```

```ts title="__snapshots__/example_test.ts.snap"
export const snapshot = {};

snapshot[`Test Name 1`] = `
{
  example: 123,
  hello: "world!",
}
`;
```

When `assertSnapshot` is run multiple times with the same value for name, then
the suffix will be incremented as normal. i.e. `Test Name 1`, `Test Name 2`,
`Test Name 3`, etc.

### `msg`

Used to set a custom error message. This will overwrite the default error
message, which includes the diff for failed snapshots:

```ts
Deno.test("custom error message example", async (t) => {
  const userData = {
    name: "John Doe",
    role: "admin",
  };

  await assertSnapshot(t, userData, {
    msg:
      "User data structure has changed unexpectedly. Please verify your changes are intentional.",
  });
});
```

When the snapshot fails, instead of seeing the default diff message, you'll see
your custom error message.

## Testing Different Data Types

Snapshot testing works with various data types and structures:

```ts
Deno.test("snapshot various types", async (t) => {
  // Arrays
  await assertSnapshot(t, [1, 2, 3, "four", { five: true }]);

  // Complex objects
  await assertSnapshot(t, {
    user: { name: "Test", roles: ["admin", "user"] },
    settings: new Map([["theme", "dark"], ["language", "en"]]),
  });

  // Error objects
  await assertSnapshot(t, new Error("Test error message"));
});
```

## Working with Asynchronous Code

When testing asynchronous functions, ensure you await the results before passing
them to the snapshot:

```ts
Deno.test("async function test", async (t) => {
  const fetchData = async () => {
    // Simulate API call
    return { success: true, data: ["item1", "item2"] };
  };

  const result = await fetchData();
  await assertSnapshot(t, result);
});
```

## Best Practices

### Keep Snapshots Concise

Avoid capturing large data structures that aren't necessary for your test. Focus
on capturing only what's relevant.

### Descriptive Test Names

Use descriptive test names that clearly indicate what's being tested:

```ts
Deno.test(
  "renders user profile card with all required fields",
  async (t) => {
    // ... test code
    await assertSnapshot(t, component);
  },
);
```

### Review Snapshots During Code Reviews

Always review snapshot changes during code reviews to ensure they represent
intentional changes and not regressions.

### Snapshot Organization

For larger projects, consider organizing snapshots by feature or component:

```ts
await assertSnapshot(t, component, {
  path: `__snapshots__/components/${componentName}.snap`,
});
```

## Snapshot Testing in CI/CD

### GitHub Actions Example

When running snapshot tests in CI environments, you'll typically want to verify
existing snapshots rather than updating them:

```yaml title=".github/workflows/test.yml"
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - name: Run tests
        run: deno test --allow-read
```

For pull requests that intentionally update snapshots, reviewers should verify
the changes are expected before merging.

## Practical Examples

### Testing HTML Output

HTML output testing with snapshots is particularly useful for web applications
where you want to ensure your components render the expected markup. This
approach allows you to catch unintended changes in your HTML structure,
attributes, or content that might affect the visual appearance or functionality
of your UI components.

By capturing a snapshot of the HTML output, you can:

- Verify that UI components render correctly with different props/data
- Detect regressions when refactoring rendering logic
- Document the expected output format of components

```ts
Deno.test("HTML rendering", async (t) => {
  const renderComponent = () => {
    return `<div class="card">
      <h2>User Profile</h2>
      <p>Username: testuser</p>
    </div>`;
  };

  await assertSnapshot(t, renderComponent());
});
```

### Testing API Responses

When building applications that interact with APIs, snapshot testing helps
ensure that the structure and format of API responses remain consistent. This is
particularly valuable for:

- Maintaining backward compatibility when updating API integrations
- Verifying that your API response parsing logic works correctly
- Documenting the expected shape of API responses for team collaboration
- Detecting unexpected changes in API responses that could break your
  application

```ts
Deno.test("API response format", async (t) => {
  const mockApiResponse = {
    status: 200,
    data: {
      users: [
        { id: 1, name: "User 1" },
        { id: 2, name: "User 2" },
      ],
      pagination: { page: 1, total: 10 },
    },
  };

  await assertSnapshot(t, mockApiResponse);
});
```

🦕 Snapshot testing is a powerful technique that complements traditional unit
tests by allowing you to capture and verify complex outputs without writing
detailed assertions. By incorporating snapshot tests into your testing strategy,
you can catch unintended changes, document expected behavior, and build more
resilient applications.


---

# 使用 Deno 构建 SolidJS 应用

> Build a SolidJS application with Deno. Learn how to set up a project, implement reactive components, handle routing, create API endpoints with Hono, and build a full-stack TypeScript application.

URL: https://docs.deno.com/examples/tutorials/solidjs


[SolidJS](https://www.solidjs.com/) 是一个声明式 JavaScript 库，用于
创建用户界面，强调细粒度的响应性和最小的开销。当与 Deno 的现代运行时环境相结合时，您将获得一个强大且高效的堆栈，用于构建 web 应用程序。在本教程中，
我们将构建一个简单的恐龙目录应用，演示这两种技术的关键特性。

我们将详细介绍如何使用 Deno 构建一个简单的 SolidJS 应用：

- [使用 Vite 搭建 SolidJS 应用](#scaffold-a-solidjs-app-with-vite)
- [设置 Hono 后端](#set-up-our-hono-backend)
- [创建我们的 SolidJS 前端](#create-our-solidjs-frontend)
- [后续步骤](#next-steps)

您可以直接跳到
[源代码](https://github.com/denoland/examples/tree/main/with-solidjs)
或按照下面的步骤进行操作！

## 使用 Vite 搭建 SolidJS 应用

让我们使用 [Vite](https://vite.dev/) 设置我们的 SolidJS 应用，这是一个现代的构建工具，提供了出色的开发体验，具备热模块替换和优化构建等特性。

```bash
deno init --npm vite@latest solid-deno --template solid-ts
```

我们的后端将由 [Hono](https://hono.dev/) 提供支持，我们可以通过 [JSR](https://jsr.io) 安装它。我们还将添加 `solidjs/router` 以实现客户端路由和恐龙目录页面之间的导航。

<figure>

```bash
deno add jsr:@hono/hono npm:@solidjs/router
```

<figcaption>
<a href="https://docs.deno.com/runtime/reference/cli/add/">
了解更多关于 <code>deno add</code> 和将 Deno 用作包管理器的信息。
</a>
</figcaption>
</figure>

我们还需要更新我们的 `deno.json` 文件，以包含一些任务和
`compilerOptions` 来运行我们的应用：

<figure>

```json
{
  "tasks": {
    "dev": "deno task dev:api & deno task dev:vite",
    "dev:api": "deno run --allow-env --allow-net --allow-read api/main.ts",
    "dev:vite": "deno run -A npm:vite",
    "build": "deno run -A npm:vite build",
    "serve": {
      "command": "deno task dev:api",
      "description": "运行构建，然后启动 API 服务器",
      "dependencies": ["deno task build"]
    }
  },
  "imports": {
    "@hono/hono": "jsr:@hono/hono@^4.6.12",
    "@solidjs/router": "npm:@solidjs/router@^0.14.10"
  },
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "solid-js",
    "lib": ["DOM", "DOM.Iterable", "ESNext"]
  }
}
```

<figcaption>
<a href="https://docs.deno.com/runtime/reference/cli/task/">您可以将 <code>tasks</code> 作为对象编写</a>。在这里，我们的 <code>serve</code> 命令包含一个 <code>description</code> 和 <code>dependencies</code>。
</figcaption>
</figure>

很好！接下来，让我们设置我们的 API 后端。

## 设置我们的 Hono 后端

在我们的主目录中，我们将建立一个 `api/` 目录并创建两个文件。首先，我们的恐龙数据文件，
[`api/data.json`](https://github.com/denoland/examples/blob/main/with-solidjs/api/data.json):

```jsonc
// api/data.json

[
  {
    "name": "Aardonyx",
    "description": "Sauropods 进化的早期阶段。"
  },
  {
    "name": "Abelisaurus",
    "description": "\"阿贝尔的蜥蜴\" 仅从单个头骨重建。"
  },
  {
    "name": "Abrictosaurus",
    "description": "Heterodontosaurus 的一个早期亲属。"
  },
  ...
]
```

这是我们将提取数据的地方。在完整的应用中，这些数据将来自数据库。

> ⚠️️ 在本教程中，我们是硬编码数据。但您可以连接到
> [多种数据库](https://docs.deno.com/runtime/tutorials/connecting_to_databases/) 和 [甚至使用 Prisma 等 ORM](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/) 与
> Deno。

其次，我们需要我们的 Hono 服务器，`api/main.ts`：

```tsx
// api/main.ts

import { Hono } from "@hono/hono";
import data from "./data.json" with { type: "json" };

const app = new Hono();

app.get("/", (c) => {
  return c.text("欢迎来到恐龙 API!");
});

app.get("/api/dinosaurs", (c) => {
  return c.json(data);
});

app.get("/api/dinosaurs/:dinosaur", (c) => {
  if (!c.req.param("dinosaur")) {
    return c.text("未提供恐龙名称。");
  }

  const dinosaur = data.find((item) =>
    item.name.toLowerCase() === c.req.param("dinosaur").toLowerCase()
  );

  console.log(dinosaur);

  if (dinosaur) {
    return c.json(dinosaur);
  } else {
    return c.notFound();
  }
});

Deno.serve(app.fetch);
```

这个 Hono 服务器提供了两个 API 端点：

- `GET /api/dinosaurs` 获取所有恐龙，并
- `GET /api/dinosaurs/:dinosaur` 根据名称获取特定恐龙

当我们运行 `deno task dev` 时，该服务器将在 `localhost:8000` 上启动。

最后，在我们开始构建前端之前，让我们更新我们的 `vite.config.ts` 文件如下，特别是 `server.proxy`，这告知我们的 SolidJS 前端 API 端点的位置信息。

```tsx
// vite.config.ts
import { defineConfig } from "vite";
import solid from "vite-plugin-solid";

export default defineConfig({
  plugins: [solid()],
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:8000",
        changeOrigin: true,
      },
    },
  },
});
```

## 创建我们的 SolidJS 前端

在我们开始构建前端组件之前，让我们快速在 `src/types.ts` 中定义 `Dino` 类型：

```tsx
// src/types.ts
export type Dino = {
  name: string;
  description: string;
};
```

`Dino` 类型接口确保了我们整个应用的类型安全，定义了我们的恐龙数据的形状，并启用了 TypeScript 的静态类型检查。

接下来，让我们设置我们的前端以接收数据。我们将要有两个页面：

- `Index.tsx`
- `Dinosaur.tsx`

下面是 `src/pages/Index.tsx` 页面的代码：

```tsx
// src/pages/Index.tsx

import { createSignal, For, onMount } from "solid-js";
import { A } from "@solidjs/router";
import type { Dino } from "../types.ts";

export default function Index() {
  const [dinosaurs, setDinosaurs] = createSignal<Dino[]>([]);

  onMount(async () => {
    try {
      const response = await fetch("/api/dinosaurs");
      const allDinosaurs = (await response.json()) as Dino[];
      setDinosaurs(allDinosaurs);
      console.log("获取的恐龙:", allDinosaurs);
    } catch (error) {
      console.error("获取恐龙失败:", error);
    }
  });

  return (
    <main id="content">
      <h1>欢迎来到恐龙应用</h1>
      <p>点击下面的恐龙以了解更多信息。</p>
      <For each={dinosaurs()}>
        {(dinosaur) => (
          <A href={`/${dinosaur.name.toLowerCase()}`} class="dinosaur">
            {dinosaur.name}
          </A>
        )}
      </For>
    </main>
  );
}
```

使用 SolidJS 时，有一些关键区别于 React 需要注意：

1. 我们使用 SolidJS 特有的原语：
   - `createSignal` 来代替 `useState`
   - `createEffect` 来代替 `useEffect`
   - `For` 组件来代替 `map`
   - `A` 组件来代替 `Link`
2. SolidJS 组件使用细粒度的反应性，因此我们像调用函数一样调用信号，例如 `dinosaur()` 而不仅仅是 `dinosaur`
3. 路由由 `@solidjs/router` 处理，而不是 `react-router-dom`
4. 组件导入使用 Solid 的 [`lazy`](https://docs.solidjs.com/reference/component-apis/lazy) 进行代码拆分

`Index` 页面使用 SolidJS 的 `createSignal` 来管理恐龙列表，并在组件加载时使用 `onMount` 来获取数据。我们使用 `For` 组件，这是 SolidJS 高效渲染列表的方式，而不是使用 JavaScript 的 map 函数。来自 `@solidjs/router` 的 `A` 组件创建了指向单个恐龙页面的客户端导航链接，避免了完整页面的重新加载。

现在是单个恐龙数据页面代码在 `src/pages/Dinosaur.tsx` 中：

```tsx
// src/pages/Dinosaur.tsx

import { createSignal, onMount } from "solid-js";
import { A, useParams } from "@solidjs/router";
import type { Dino } from "../types.ts";

export default function Dinosaur() {
  const params = useParams();
  const [dinosaur, setDinosaur] = createSignal<Dino>({
    name: "",
    description: "",
  });

  onMount(async () => {
    const resp = await fetch(`/api/dinosaurs/${params.selectedDinosaur}`);
    const dino = (await resp.json()) as Dino;
    setDinosaur(dino);
    console.log("恐龙", dino);
  });

  return (
    <div>
      <h1>{dinosaur().name}</h1>
      <p>{dinosaur().description}</p>
      <A href="/">返回所有恐龙</A>
    </div>
  );
}
```

`Dinosaur` 页面展示了 SolidJS 处理动态路由的方法，通过使用 `useParams` 来访问 URL 参数。它遵循与 `Index` 页面类似的模式，使用 `createSignal` 进行状态管理和 `onMount` 进行数据获取，但专注于单个恐龙的细节。这个 `Dinosaur` 组件还展示了如何在模板中访问信号值，通过将它们作为函数调用（例如，`dinosaur().name`），这是与 React 状态管理的重要区别。

最后，为了将所有内容串联在一起，我们将更新 `App.tsx` 文件，该文件将作为组件服务于 `Index` 和 `Dinosaur` 页面。`App` 组件使用 `@solidjs/router` 配置我们的路由，定义两个主要路由：一个用于我们的恐龙列表的索引路由，以及一个用于单个恐龙页面的动态路由。路径中的 `:selectedDinosaur` 参数创建了一个动态部分，可以与 URL 中的任何恐龙名称进行匹配。

```tsx
// src/App.tsx

import { Route, Router } from "@solidjs/router";
import Index from "./pages/Index.tsx";
import Dinosaur from "./pages/Dinosaur.tsx";
import "./App.css";

const App = () => {
  return (
    <Router>
      <Route path="/" component={Index} />
      <Route path="/:selectedDinosaur" component={Dinosaur} />
    </Router>
  );
};

export default App;
```

最后，这个 `App` 组件将从我们的主索引中调用：

```tsx
// src/index.tsx

import { render } from "solid-js/web";
import App from "./App.tsx";
import "./index.css";

const wrapper = document.getElementById("root");

if (!wrapper) {
  throw new Error("未找到包装 DIV");
}

render(() => <App />, wrapper);
```

我们应用的入口点使用 SolidJS 的 `render` 函数将 App 组件挂载到 DOM 中。它包括一个安全检查，以确保根元素在尝试渲染之前存在，从而在初始化过程中提供更好的错误处理。

现在，让我们运行 `deno task dev` 同时启动前端和后端：

<figure>

<video class="w-full" alt="在 Deno Deploy 中构建 Http 服务器的教程。" autoplay muted loop playsinline src="./images/how-to/solidjs/demo.mp4"></video>

</figure>

## 后续步骤

🦕 现在您可以使用 Deno 构建和运行 SolidJS 应用！以下是一些您可以增强恐龙应用的方法：

- 添加持久化数据存储
  [使用像 Postgres 或 MongoDB 的数据库](https://docs.deno.com/runtime/tutorials/connecting_to_databases/)
  和像 [Drizzle](https://deno.com/blog/build-database-app-drizzle) 或
  [Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/) 的 ORM
- 使用 SolidJS 的
  [`createContext`](https://docs.solidjs.com/reference/component-apis/create-context) 实现全局状态，在组件之间共享数据
- 使用
  [`createResource`](https://docs.solidjs.com/reference/basic-reactivity/create-resource) 的
  loading 属性添加加载状态
- 实现基于路由的代码分割，使用
  [`lazy`](https://docs.solidjs.com/reference/component-apis/lazy) 导入
- 使用 `Index` 组件提升列表渲染效率
- 将您的应用部署到
  [AWS](https://docs.deno.com/runtime/tutorials/aws_lightsail/),
  [Digital Ocean](https://docs.deno.com/runtime/tutorials/digital_ocean/)，或
  [Google Cloud Run](https://docs.deno.com/runtime/tutorials/google_cloud_run/)

SolidJS 独特的反应式原语、真实的 DOM 重新协调和 Deno 的现代运行时组合，为网络开发提供了一个极其高效的基础。在没有虚拟 DOM 开销和仅在需要的地方进行细粒度更新的情况下，您的应用可以实现最佳性能，同时保持清晰、可读的代码。

---

# Stubbing in tests

> Learn how to use stubs in Deno to isolate code during testing by replacing function implementations with controlled behavior

URL: https://docs.deno.com/examples/tutorials/stubbing


Stubbing is a powerful technique for isolating the code you're testing by
replacing functions with controlled implementations. While
[spies](/examples/mocking_tutorial/#spying) monitor function calls without
changing behavior, stubs go a step further by completely replacing the original
implementation, allowing you to simulate specific conditions or behaviors during
testing.

## What are stubs?

Stubs are fake implementations that replace real functions during testing. They
let you:

- Control what values functions return
- Simulate errors or specific edge cases
- Prevent external services like databases or APIs from being called
- Test code paths that would be difficult to trigger with real implementations

Deno provides robust stubbing capabilities through the
[Standard Library's testing tools](https://jsr.io/@std/testing/doc/mock#stubbing).

## Basic stub usage

Here's a simple example demonstrating how to stub a function:

```ts
import { assertEquals } from "jsr:@std/assert";
import { stub } from "jsr:@std/testing/mock";

// Original function
function getUserName(id: number): string {
  // In a real app, this might call a database
  return "Original User";
}

// Function under test
function greetUser(id: number): string {
  const name = getUserName(id);
  return `Hello, ${name}!`;
}

Deno.test("greetUser with stubbed getUserName", () => {
  // Create a stub that returns a controlled value
  const getUserNameStub = stub(globalThis, "getUserName", () => "Test User");

  try {
    // Test with the stubbed function
    const greeting = greetUser(123);
    assertEquals(greeting, "Hello, Test User!");
  } finally {
    // Always restore the original function
    getUserNameStub.restore();
  }
});
```

In this example, we:

1. Import the necessary functions from Deno's standard library
2. Create a stub for the `getUserName` function that returns "Test User" instead
   of calling the real implementation
3. Call our function under test, which will use the stubbed implementation
4. Verify the result meets our expectations
5. Restore the original function to prevent affecting other tests

## Using stubs in a testing scenario

Let's look at a more practical example with a `UserRepository` class that
interacts with a database:

```ts
import { assertSpyCalls, returnsNext, stub } from "jsr:@std/testing/mock";
import { assertThrows } from "jsr:@std/assert";

type User = {
  id: number;
  name: string;
};

// This represents our database access layer
const database = {
  getUserById(id: number): User | undefined {
    // In a real app, this would query a database
    return { id, name: "Ada Lovelace" };
  },
};

// The class we want to test
class UserRepository {
  static findOrThrow(id: number): User {
    const user = database.getUserById(id);
    if (!user) {
      throw new Error("User not found");
    }
    return user;
  }
}

Deno.test("findOrThrow method throws when the user was not found", () => {
  // Stub the database.getUserById function to return undefined
  using dbStub = stub(database, "getUserById", returnsNext([undefined]));

  // We expect this function call to throw an error
  assertThrows(() => UserRepository.findOrThrow(1), Error, "User not found");

  // Verify the stubbed function was called once
  assertSpyCalls(dbStub, 1);
});
```

In this example:

1. We're testing the `findOrThrow` method, which should throw an error when a
   user is not found
2. We stub `database.getUserById` to return `undefined`, simulating a missing
   user
3. We verify that `findOrThrow` throws the expected error
4. We also check that the database method was called exactly once

Note that we're using the `using` keyword with `stub`, which is a convenient way
to ensure the stub is automatically restored when it goes out of scope.

## Advanced stub techniques

### Returning different values on subsequent calls

Sometimes you want a stub to return different values each time it's called:

```ts
import { returnsNext, stub } from "jsr:@std/testing/mock";
import { assertEquals } from "jsr:@std/assert";

Deno.test("stub with multiple return values", () => {
  const fetchDataStub = stub(
    globalThis,
    "fetchData",
    // Return these values in sequence
    returnsNext(["first result", "second result", "third result"]),
  );

  try {
    assertEquals(fetchData(), "first result");
    assertEquals(fetchData(), "second result");
    assertEquals(fetchData(), "third result");
  } finally {
    fetchDataStub.restore();
  }
});
```

### Stubbing with implementation logic

You can also provide custom logic in your stub implementations:

```ts
import { stub } from "jsr:@std/testing/mock";
import { assertEquals } from "jsr:@std/assert";

Deno.test("stub with custom implementation", () => {
  // Create a counter to track how many times the stub is called
  let callCount = 0;

  const calculateStub = stub(
    globalThis,
    "calculate",
    (a: number, b: number) => {
      callCount++;
      return a + b * 2; // Custom implementation
    },
  );

  try {
    const result = calculate(5, 10);
    assertEquals(result, 25); // 5 + (10 * 2)
    assertEquals(callCount, 1);
  } finally {
    calculateStub.restore();
  }
});
```

## Stubbing API calls and external services

One of the most common uses of stubs is to replace API calls during testing:

```ts
import { assertEquals } from "jsr:@std/assert";
import { stub } from "jsr:@std/testing/mock";

async function fetchUserData(id: string) {
  const response = await fetch(`https://api.example.com/users/${id}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.status}`);
  }
  return await response.json();
}

Deno.test("fetchUserData with stubbed fetch", async () => {
  const mockResponse = new Response(
    JSON.stringify({ id: "123", name: "Jane Doe" }),
    { status: 200, headers: { "Content-Type": "application/json" } },
  );

  // Replace global fetch with a stubbed version
  const fetchStub = stub(
    globalThis,
    "fetch",
    () => Promise.resolve(mockResponse),
  );

  try {
    const user = await fetchUserData("123");
    assertEquals(user, { id: "123", name: "Jane Doe" });
  } finally {
    fetchStub.restore();
  }
});
```

## Best practices

1. **Always restore stubs**: Use `try/finally` blocks or the `using` keyword to
   ensure stubs are restored, even if tests fail.

2. **Use stubs for external dependencies**: Stub out database calls, API
   requests, or file system operations to make tests faster and more reliable.

3. **Keep stubs simple**: Stubs should return predictable values that let you
   test specific scenarios.

4. **Combine with spies when needed**: Sometimes you need to both replace
   functionality (stub) and track calls (spy).

5. **Stub at the right level**: Stub at the interface boundary rather than deep
   within implementation details.

🦕 Stubs are a powerful tool for isolating your code during testing, allowing
you to create deterministic test environments and easily test edge cases. By
replacing real implementations with controlled behavior, you can write more
focused, reliable tests that run quickly and consistently.

For more testing resources, check out:

- [Testing in isolation with mocks](/examples/mocking_tutorial/)
- [Deno Standard Library Testing Modules](https://jsr.io/@std/testing)
- [Basic Testing in Deno](/examples/testing_tutorial/)


---

# 创建子进程

> 在 Deno 中使用子进程的指南。学习如何启动进程、处理输入/输出流、管理进程生命周期，以及安全实现进程间通信模式。

URL: https://docs.deno.com/examples/tutorials/subprocess


## 概念

- Deno 可以通过 [Deno.Command](https://docs.deno.com/api/deno/~/Deno.Command) 启动子进程。
- 启动子进程需要 `--allow-run` 权限。
- 启动的子进程不在安全沙箱中运行。
- 通过 [stdin](https://docs.deno.com/api/deno/~/Deno.stdin)、[stdout](https://docs.deno.com/api/deno/~/Deno.stdout) 和 [stderr](https://docs.deno.com/api/deno/~/Deno.stderr) 流与子进程进行通信。

## 简单示例

该示例相当于从命令行运行 `echo "Hello from Deno!"`。

```ts title="subprocess_simple.ts"
// 定义用于创建子进程的命令
const command = new Deno.Command("echo", {
  args: [
    "Hello from Deno!",
  ],
});

// 创建子进程并收集输出
const { code, stdout, stderr } = await command.output();

console.assert(code === 0);
console.log(new TextDecoder().decode(stdout));
console.log(new TextDecoder().decode(stderr));
```

运行它：

```shell
$ deno run --allow-run=echo ./subprocess_simple.ts
Hello from Deno!
```

## 安全性

创建子进程需要 `--allow-run` 权限。请注意，子进程不在 Deno 沙箱中运行，因此具有与您自己从命令行运行命令时相同的权限。

## 与子进程通信

默认情况下，当您使用 `Deno.Command()` 时，子进程继承父进程的 `stdin`、`stdout` 和 `stderr`。如果您想与启动的子进程进行通信，您必须使用 `"piped"` 选项。

## 管道输出到文件

该示例相当于在 bash 中运行 `yes &> ./process_output`。

```ts title="subprocess_piping_to_files.ts"
import {
  mergeReadableStreams,
} from "jsr:@std/streams@1.0.0-rc.4/merge-readable-streams";

// 创建要附加到进程的文件
const file = await Deno.open("./process_output.txt", {
  read: true,
  write: true,
  create: true,
});

// 启动进程
const command = new Deno.Command("yes", {
  stdout: "piped",
  stderr: "piped",
});

const process = command.spawn();

// 示例：将 stdout 和 stderr 合并并发送到文件
const joined = mergeReadableStreams(
  process.stdout,
  process.stderr,
);

// 返回一个 Promise，直到进程被终止/关闭时解析
joined.pipeTo(file.writable).then(() => console.log("管道合并完成"));

// 手动停止进程，“yes” 将永远不会自行结束
setTimeout(() => {
  process.kill();
}, 100);
```

运行它：

```shell
$ deno run --allow-run=yes --allow-read=. --allow-write=. ./subprocess_piping_to_file.ts
```

## 使用便捷方法读取子进程输出

在使用启动的子进程时，您可以对 `stdout` 和 `stderr` 流使用便捷方法，轻松收集和解析输出。这些方法类似于 `Response` 对象上可用的方法：

```ts title="subprocess_convenience_methods.ts"
const command = new Deno.Command("deno", {
  args: [
    "eval",
    "console.log(JSON.stringify({message: 'Hello from subprocess'}))",
  ],
  stdout: "piped",
  stderr: "piped",
});

const process = command.spawn();

// 使用便捷方法收集输出
const stdoutText = await process.stdout.text();
const stderrText = await process.stderr.text();

console.log("stdout:", stdoutText);
console.log("stderr:", stderrText);

// 等待进程完成
const status = await process.status;
console.log("退出码:", status.code);
```

可用的便捷方法包括：

- `.text()` - 返回 UTF-8 编码的字符串输出
- `.bytes()` - 返回 `Uint8Array` 类型的输出
- `.arrayBuffer()` - 返回 `ArrayBuffer` 类型的输出
- `.json()` - 解析输出为 JSON 并返回该对象

```ts title="subprocess_json_parsing.ts"
const command = new Deno.Command("deno", {
  args: ["eval", "console.log(JSON.stringify({name: 'Deno', version: '2.0'}))"],
  stdout: "piped",
});

const process = command.spawn();

// 直接解析 JSON 输出
const jsonOutput = await process.stdout.json();
console.log("解析后的 JSON:", jsonOutput); // { name: "Deno", version: "2.0" }

await process.status;
```

---

# 构建一个 SvelteKit 应用

> 一个使用 Deno 构建 SvelteKit 应用的教程。学习如何设置 SvelteKit 项目，实现基于文件的路由，使用 load 函数管理状态，以及创建全栈 TypeScript 应用。

URL: https://docs.deno.com/examples/tutorials/svelte


[SvelteKit](https://kit.svelte.dev/) 是一个构建在
[Svelte](https://svelte.dev/) 之上的网页框架，Svelte 是一个现代前端编译器，可以生成高度优化的原生 JavaScript。SvelteKit 提供了基于文件的路由、服务器端渲染以及全栈功能等特性。

在本教程中，我们将使用 Deno 构建一个简单的 SvelteKit 应用。该应用会显示恐龙列表，当你点击某个恐龙时，会跳转到显示更多详情的恐龙页面。你可以在
[GitHub 查看完整应用](https://github.com/denoland/tutorial-with-svelte)。

你也可以在
[Deno Deploy 上访问实时演示](https://tutorial-with-svelte.deno.deno.net/)。

:::info 部署你自己的应用

想跳过教程，立即部署完整的应用吗？点击下方按钮，即可瞬间将完整的 SvelteKit 恐龙应用部署到 Deno Deploy。你将获得一个可运行的在线应用，可以在学习过程中自定义和修改！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-svelte)

:::

## 使用 Deno 创建 SvelteKit 应用

我们将使用 [SvelteKit](https://kit.svelte.dev/) 创建一个新的 SvelteKit 应用。在终端中运行以下命令来创建新应用：

```shell
deno run -A npm:sv create my-app
```

按提示输入你的应用名称，选择“Skeleton project”模板。当询问是否使用 TypeScript 时，选择“是，使用 TypeScript 语法”。

创建完成后，进入新项目目录并运行以下命令安装依赖：

```shell
deno install
```

然后运行下面的命令启动你的 SvelteKit 应用：

```shell
deno task dev
```

Deno 会执行 `package.json` 中的 `dev` 任务，启动 Vite 开发服务器。点击输出的 localhost 链接，在浏览器中打开你的应用。

## 配置格式化工具

`deno fmt` 支持带有
[`--unstable-component`](https://docs.deno.com/runtime/reference/cli/fmt/#formatting-options-unstable-component)
参数的 Svelte 文件。使用命令：

```sh
deno fmt --unstable-component
```

若想让 `deno fmt` 始终格式化 Svelte 文件，在你的 `deno.json` 文件顶层添加：

```json
"unstable": ["fmt-component"]
```

## 添加后端 API

我们将使用 SvelteKit 内置的 API 功能构建 API 路由。SvelteKit 允许你通过在路由目录中创建 `+server.js` 或 `+server.ts` 文件来定义 API 端点。

在 `src/routes` 目录中创建 `api` 文件夹，在该文件夹内创建 `data.json`，用来存放硬编码的恐龙数据。

将该 [json 文件](https://github.com/denoland/tutorial-with-svelte/blob/main/src/routes/api/data.json) 复制并粘贴到 `src/routes/api/data.json` 文件中。（如果是实际项目，通常会从数据库或外部 API 获取数据。）

接下来我们将构建返回恐龙信息的 API 路由。SvelteKit 提供简单的接口来创建 API 端点，使用服务器文件。

创建 `src/routes/api/dinosaurs/+server.ts` 处理 `/api/dinosaurs` 端点，返回全部恐龙数据：

```js title="src/routes/api/dinosaurs/+server.ts"
import { json } from "@sveltejs/kit";
import data from "../data.json" with { type: "json" };

export function GET() {
  return json(data);
}
```

然后创建 `src/routes/api/dinosaurs/[id]/+server.ts` 处理 `/api/dinosaurs/:id`，返回单个恐龙数据：

```ts title="src/routes/api/dinosaurs/[id]/+server.ts"
import { json } from "@sveltejs/kit";
import type { RequestHandler } from "./$types";
import data from "../../data.json" with { type: "json" };

export const GET: RequestHandler = ({ params }) => {
  const dinosaur = data.find((item) => {
    return item.name.toLowerCase() === params.id.toLowerCase();
  });

  if (dinosaur) {
    return json(dinosaur);
  }

  return json({ error: "Not found" }, { status: 404 });
};
```

SvelteKit 会根据文件结构自动处理路由。`+server.ts` 文件定义 API 端点，而 `[id]` 文件夹创建了动态路由参数。

## 构建前端

### 基于文件的路由和数据加载

SvelteKit 使用基于文件的路由，`src/routes` 目录结构决定应用的路由。与 Vue Router 不同，你无需手动配置路由 —— SvelteKit 会自动基于文件创建路由。

在 SvelteKit 中，`+page.svelte` 文件定义页面组件，`+page.ts` 文件定义加载数据的函数，会在页面加载前执行。这样内置了服务器端渲染和数据获取能力。

### 页面与组件

SvelteKit 将前端代码组织成页面和组件。页面由路由目录下的 `+page.svelte` 文件定义，组件是可复用的代码段，可以放在项目中的任意位置。

每个 Svelte 组件文件包含三个可选部分：`<script>`、`<template>`（HTML）和 `<style>`。`<script>` 是 JavaScript/TypeScript 逻辑，模板是 HTML 标记，`<style>` 中是作用域 CSS。

我们将创建首页和单个恐龙详情页，并使用加载函数从 API 获取恐龙信息。

#### 首页

首页展示从 API 获取的恐龙列表。先创建 `src/routes/+page.ts` 加载恐龙数据：

```ts title="src/routes/+page.ts"
import type { PageLoad } from "./$types";

export const load: PageLoad = async ({ fetch }) => {
  const res = await fetch(`/api/dinosaurs`);
  const dinosaurs = await res.json();

  return { dinosaurs };
};
```

该加载函数会在服务端和客户端运行，数据传递给页面组件。`fetch` 函数由 SvelteKit 提供，兼容服务端和客户端环境。

接着修改 `src/routes/+page.svelte` 显示恐龙列表：

```html title="src/routes/+page.svelte"
<script lang="ts">
  import type { PageProps } from "./$types";

  let { data }: PageProps = $props();
  let dinosaurs = data.dinosaurs;
</script>

<main>
  <h1>🦕 恐龙应用</h1>
  <p>点击下方恐龙了解更多信息。</p>
  {#each dinosaurs as dinosaur (dinosaur.name)}
  <a href="/{dinosaur.name.toLowerCase()}" class="dinosaur">
    {dinosaur.name}
  </a>
  {/each}
</main>
```

该代码使用 Svelte 的 [each 块](https://svelte.dev/docs/logic-blocks#each) 遍历 `dinosaurs` 数组，将每只恐龙渲染为一个链接。`{#each}` 是 Svelte 渲染列表的语法，`(dinosaur.name)` 提供每项的唯一 key。

#### 恐龙详情页

详情页展示单个恐龙信息。SvelteKit 通过方括号命名的文件夹创建动态路由，`[dinosaur]` 文件夹捕获 URL 中的恐龙名称。

先创建 `src/routes/[dinosaur]/+page.ts` 加载单个恐龙数据：

```ts title="src/routes/[dinosaur]/+page.ts"
import type { PageLoad } from "./$types";
import { error } from "@sveltejs/kit";

export const load: PageLoad = async ({ fetch, params }) => {
  const res = await fetch(`/api/dinosaurs/${params.dinosaur}`);
  const dinosaur = await res.json() as { name: string; description: string };

  if (res.status === 404) {
    return error(404, "未找到恐龙");
  }

  return { dinosaur };
};
```

该加载函数通过 `params` 对象访问 URL 参数 `dinosaur`。如果 API 返回 404，使用 SvelteKit 的 `error` 函数抛出 404 错误。

然后创建 `src/routes/[dinosaur]/+page.svelte` 显示恐龙详情：

```html title="src/routes/[dinosaur]/+page.svelte"
<script lang="ts">
  import type { PageProps } from "./$types";

  let { data }: PageProps = $props();
  let dinosaur = data.dinosaur;
</script>

<div>
  <h1>{dinosaur.name}</h1>
  <p>{dinosaur.description}</p>
  <a href="/">🠠 返回所有恐龙</a>
</div>
```

该页面显示恐龙名称和描述，并带有返回首页的链接。数据来源于加载函数，自动可用。

## 运行应用

既然已经配置好前端和后端 API 路由，我们可以运行应用。终端执行：

```shell
deno task dev
```

这会启动带有 Vite 的 SvelteKit 开发服务器。SvelteKit 会同时处理前端页面和我们创建的 API 路由，无需运行多个服务器线程。

在浏览器中访问 `http://localhost:5173` 来查看应用。点击恐龙查看详情！

你也可以访问 [Deno Deploy 在线版本](https://tutorial-with-svelte.deno.deno.net/)。

## 构建与部署

SvelteKit 内置构建能力。我们配置使用 Deno 适配器，优化构建以便部署到支持 Deno 的平台。执行以下命令构建生产版本：

```sh
deno task build
```

该命令会：

1. 使用 Vite 构建 SvelteKit 应用  
2. 生成优化后的生产资源  
3. 创建兼容 Deno 的服务器端代码  

构建后的应用可部署到支持 Deno 的平台，如 Deno Deploy。

你可以将应用部署到你喜欢的云服务。我们推荐使用 [Deno Deploy](https://deno.com/deploy)，简单又方便。你可以直接从 GitHub 部署，只需创建一个 GitHub 仓库并推送代码，然后连接到 Deno Deploy。

### 创建 GitHub 仓库

[新建一个 GitHub 仓库](https://github.com/new)，然后初始化并推送你的应用：

```sh
git init -b main
git remote add origin https://github.com/<your_github_username>/<your_repo_name>.git
git add .
git commit -am 'my svelte app'
git push -u origin main
```

### 部署到 Deno Deploy

当你的应用托管在 GitHub 后，你可以访问
[Deno Deploy<sup>EA</sup>](https://console.deno.com/) 仪表盘进行
部署。

想了解完整部署流程，请查看 [Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在你已经掌握如何使用 Deno 适配器运行 SvelteKit 应用，准备好构建真实世界的应用了！

---

# 使用 sv 和 Deno 构建 SvelteKit 应用

URL: https://docs.deno.com/examples/tutorials/sveltekit


自上线以来，SvelteKit 一直深受欢迎，而随着 Svelte 版本 5 最近发布，截至撰写本文时，没有比现在更合适的时机来展示如何用 Deno 运行它！

通过本教程，我们将演示如何使用 sv CLI 工具轻松搭建一个 SvelteKit 项目，并讲解数据加载的模式。

你可以在[GitHub](https://github.com/s-petey/deno-sveltekit)上查看完成的应用。

## 入门

我们可以通过 `npx sv create` 快速生成一个项目。这是[SvelteKit 的 CLI](https://github.com/sveltejs/cli)，功能强大且实用。

如果你已经观看了上面的视频，那就太好了！如果没有，下面是选择设置：

- 模板
  - SvelteKit minimal
- 类型检查
  - Typescript
- 项目附加
  - tailwindcss
- Tailwind 插件
  - typography
  - forms
- 包管理器
  - Deno

接下来，我们需要保持后台运行 `deno task dev`，这样可以在本地实时查看改动和应用运行状态。

### Deno 配置

`sv` 命令会生成一个 `package.json` 文件，我们需要将其转换为 `deno.json`。具体来说，将`scripts`改为`tasks`，并且把基于 `vite` 的命令加上 `npm:` 前缀。

示例：

```json
"dev": "vite dev",
```

转换为：

```json
"dev": "deno run -A npm:vite dev",
```

此时我们还希望集成 Deno 的格式化和代码检查工具，因此也加上这些任务。

```json
{
  "tasks": {
    "dev": "deno run -A npm:vite dev",
    "format": "deno fmt",
    "lint": "deno lint",
    "lint:fix": "deno lint --fix"
  }
}
```

配置好这些任务后，我们还需要针对 `format` 和 `lint` 命令设置规则。这里使用了 `unstable` 标记启用 `fmt-component`，它支持[svelte 组件文件](https://docs.deno.com/runtime/reference/cli/fmt/#supported-file-types)格式化。同时根据推荐设置增加了部分 lint 规则。

```json
{
  "fmt": {},
  "lint": {
    "include": ["src/**/*.{ts,js,svelte}"],
    "exclude": ["node_modules", ".svelte-kit", ".vite", "dist", "build"],
    "rules": {
      "tags": ["recommended"]
    }
  },
  "unstable": ["fmt-component"]
}
```

我们还需要在 `deno.json` 文件中设置 `nodeModulesDir`，以便命令能够正确找到 `node_modules` 目录。

```json
{
  "nodeModulesDir": "auto"
}
```

如果你使用 VSCode 或其他支持 `settings.json` 的编辑器，下面是一些推荐配置，实现保存自动格式化和代码检查。

```json
{
  "deno.enable": true,
  "deno.enablePaths": [
    "./deno.json"
  ],
  "editor.defaultFormatter": "denoland.vscode-deno"
}
```

### 目录结构讲解

需要注意几个不同的目录：

- `src`：应用代码根目录，大部分时间和精力都会在这里。
- `src/lib`：SvelteKit 的别名目录，用于快速导入，存放辅助函数或库代码。
- `src/routes`：存放应用渲染页面的目录，SvelteKit 采用文件夹路由机制。

#### 重要信息

SvelteKit 应用中我们将遵循一些约定（这里只介绍本教程涉及的）：

- 文件或文件夹名称中包含 `server` 的，**只允许在服务器端运行**，在客户端运行会报错。
- 在 `src/routes` 中，文件的命名有规范：
  - `+page.svelte` —— 浏览器端渲染的文件
  - `+page.server.ts` —— 服务端运行的文件，允许向相邻的 `+page.svelte` 发送和接收类型安全的数据
  - `+layout.svelte` —— 定义布局文件，能为同一目录或子目录的所有 `+page.svelte` 提供出口
  - `+error.svelte` —— 自定义错误页，可以美化错误展示界面

稍后你会看到我们将恐龙数据文件 `dinosaurs.ts` 放在 `lib/server` 中，这表示该文件**只应被其他服务端文件访问**。

### 设置“数据库”

出于简化考虑，我们会使用 TypeScript 文件中保存一个 `Map` 来访问和查找数据。新建文件及路径：

```
src/lib/server/dinosaurs.ts
```

文件内容，定义 Dinosaur 类型，并存储恐龙数据转成 Map 导出。

```ts
export type Dinosaur = { name: string; description: string };

const dinosaurs = new Map<string, Dinosaur>();

const allDinosaurs: Dino[] = [
  // 在这里粘贴你的所有恐龙信息
];

for (const dino of allDinosaurs) {
  dinosaurs.set(dino.name.toLowerCase(), dino);
}

export { dinosaurs };
```

通过以上设置，我们完成了“数据库”的搭建！接下来学习如何在页面调用它。

### 加载用于渲染的数据

现在我们需要创建一个位于 routes 根目录的新文件 `+page.server.ts`，此目录下应已有对应的 `+page.svelte`。

```
src/routes/+page.server.ts
```

新建文件后，初始化加载函数以载入恐龙数据！

```ts
/// src/routes/+page.server.ts
import { dinosaurs } from '$lib/server/dinosaurs.js';

export const load = async ({ url }) => {
  return { dinosaurs: Array.from(dinosaurs) };
};
```

这里做的事情是将 Map 转为数组，以便 `+page.svelte` 里渲染。你可在页面内移除不需要内容或简单添加以下内容：

```html
<script lang="ts">
  /// src/routes/+page.svelte
  let { data } = $props();
</script>

<section class="mb-4 grid max-h-96 grid-cols-2 gap-4 overflow-y-auto">
  {#each data.dinosaurs as item}
  <a class="rounded border p-4" href="/{item.name}">{item.name}</a>
  {/each}
</section>
```

注意在操作 `data` 时我们拥有类型安全，能确认 `data.dinosaurs` 存在且类型正确！

### 添加单独的恐龙详情页

既然我们渲染了恐龙列表并为每个添加了链接，可以添加相应路由来渲染详情。

```
src/routes/[name]/+page.server.ts
src/routes/[name]/+page.svelte
```

这里有个特别点在于使用了带方括号的 `[name]` 文件夹名，代表路由参数命名。我们可以任意命名，但因为希望路由能访问形如 `localhost:5173/Ingenia` 的地址，故用参数 `name`。

理解后可以编写 server loader 获取恐龙数据并传递给页面：

```ts
/// src/routes/[name]/+page.server.ts
import { dinosaurs } from "$lib/server/dinosaurs.js";
import { error } from "@sveltejs/kit";

export const load = async ({ params: { name } }) => {
  const dino = dinosaurs.get(name.toLowerCase());

  if (!dino) {
    throw error(404, { message: "Dino not found" });
  }

  return { name: dino.name, description: dino.description };
};
```

这里我们抛出错误，提醒找不到恐龙。当前还未设置自定义错误页，因此访问不存在路径时会出现默认错误页。现在我们创建一个根目录级的错误页处理。

```
src/routes/+error.svelte
```

页面简单，可自行添加美化：

```html
<script lang="ts">
  import { page } from "$app/state";
</script>

<h1>{page.status}: {page.error?.message}</h1>
```

显示错误状态码及错误信息即可。

解决了错误页干扰后，我们继续显示具体恐龙详情！

```html
<script lang="ts">
  /// src/routes/[name]/+page.svelte
  let { data } = $props();
</script>

<h1>{data.name}</h1>

<p>{data.description}</p>
```

可以看到依然保持类型安全，确认 `name` 和 `description` 存在，并正常渲染。

但有个问题是：用户访问该详情页，无论是从首页链接点击或手动输入网址，无法方便返回首页。

### 布局

希望所有页面共享一些通用信息或链接，可以利用 `+layout.svelte` 文件。我们来更新 routes 根目录下的布局。

目标是实现：

1. 允许用户导航到主页
2. 展示 Deno 和 SvelteKit 的优质文档链接
3. 页面显示萌萌的恐龙图片！

```html
<script lang="ts">
  import "../app.css";
  let { children } = $props();
</script>

<header class="flex flex-row place-content-between items-center p-4">
  <h1 class="text-2xl"><a href="/">Deno Sveltekit</a></h1>
  <img id="deno" class="w-32" src="/vite-deno.svg" alt="Vite with Deno" />
</header>

<main class="container mx-auto p-4">
  {@render children()}
</main>

<footer class="my-4 flex flex-row justify-center gap-4">
  <p class="font-bold">
    <a href="https://svelte.dev/docs/kit">Sveltekit 文档</a>
  </p>
  <p class="font-bold">
    <a href="https://docs.deno.com/">Deno 文档</a>
  </p>
</footer>
```

这是我们第一次看到 `{@render children()}`，它相当于 React 里的“插槽”，渲染对应子页面内容。

回到应用，发现标题已带有返回首页的链接，十分方便。

### 进阶路由、搜索参数及样式

我们不想一次性渲染所有恐龙，那样滚动太长。希望用户能搜索并分页浏览恐龙，同时体现 Svelte 5 靓功能——代码片段(snippets)！

打开首页和对应的服务端代码，做一些修改。

之前简单返回了恐龙数组，现在加入搜索和分页逻辑。

```ts
import { dinosaurs } from "$lib/server/dinosaurs.js";

export const load = async ({ url }) => {
  // 通过 SvelteKit 注入的 url 获取搜索参数
  const queryParams = url.searchParams;

  // 使用 q 作为搜索关键字
  const q = queryParams.get("q");

  // 使用 page 确定当前页码
  const pageParam = queryParams.get("page");
  let page = 1;
  // 校验 page 参数，非数字则使用默认1
  if (pageParam) {
    const parsedPage = parseInt(pageParam);
    if (!isNaN(parsedPage)) {
      page = parsedPage;
    }
  }

  // 使用 limit 控制每页数量
  const limitParam = queryParams.get("limit");
  let limit = 25;
  // 校验 limit 参数，非数字则默认25
  if (limitParam) {
    const parsedLimit = parseInt(limitParam);
    if (!isNaN(parsedLimit)) {
      limit = parsedLimit;
    }
  }

  // 搜索处理：无 q 时展示全部，有 q 时进行名称匹配
  const filteredDinosaurs = Array.from(dinosaurs.values()).filter((d) => {
    if (!q) {
      return true;
    }

    return d.name.toLowerCase().includes(q.toLowerCase());
  });

  // 计算分页数据
  const offset = Math.abs((page - 1) * limit);
  const paginatedDinosaurs = Array.from(filteredDinosaurs).slice(
    offset,
    offset + limit,
  );
  const totalDinosaurs = filteredDinosaurs.length;
  const totalPages = Math.ceil(totalDinosaurs / limit);

  // 最后返回更多分页信息以便前端展示
  return {
    dinosaurs: paginatedDinosaurs,
    q,
    page,
    limit,
    totalPages,
    totalDinosaurs,
  };
};
```

呼，工作量不小，完成后添加分页和搜索输入控件到页面中。

```html
<script lang="ts">
	import { goto, invalidate, replaceState } from '$app/navigation';
	import { page as sveltePage } from '$app/state';

	let { data } = $props();

	// 改变页码，更新 URL 查询参数
	function handlePageChange(page: number) {
		const params = new URLSearchParams(sveltePage.url.searchParams);

		params.set('page', page.toString());
		goto(`?${params.toString()}`, { keepFocus: true });
	}

	// 处理搜索表单提交，根据是否有 q 设置对应参数并重置页码
	function handleQueryChange(
		event: SubmitEvent & {
			currentTarget: EventTarget & HTMLFormElement;
		}
	) {
		event.preventDefault();
		const q = event.currentTarget.q.value;
		const params = new URLSearchParams(sveltePage.url.searchParams);

		if (q) {
			params.set('q', q);
			params.set('page', '1');
			goto(`?${params.toString()}`, { keepFocus: true });
		} else {
			params.delete('q');
			params.delete('page');
			goto(`?${params.toString()}`, { keepFocus: true });
		}
	}
</script>

<form onsubmit={handleQueryChange} class="mb-4">
	<label class="mb-2 block text-sm font-bold" for="q">搜索</label>
	<input
		class="focus:shadow-outline w-full form-input appearance-none rounded border px-3 py-2 leading-tight text-gray-700 shadow focus:outline-none"
		type="text"
		id="q"
		name="q"
		placeholder="搜索"
		defaultValue={data.q ?? ''}
	/>
</form>

<section class="mb-4 grid max-h-96 grid-cols-2 gap-4 overflow-y-auto">
	{#each data.dinosaurs as item}
		<a class="rounded border p-4" href="/{item.name}">{item.name}</a>
	{/each}

	{#if data.dinosaurs.length === 0}
		<p>未找到恐龙</p>
	{/if}
</section>

<!-- 分页 -->
{#if data.totalPages > 0}
	<div class="mb-4 flex justify-center">
		<div class="grid w-1/2 grid-flow-col gap-2">
			{@render pageButton(data.page - 1, data.page === 1, false, '←')}

			{#each { length: data.totalPages }, page}
				{#if page >= data.page - 2 && page <= data.page + 2}
					{@render pageButton(page + 1, data.page === page + 1, data.page === page + 1, page + 1)}
				{:else if (page === 0 || page === 1) && page !== data.page - 1}
					{@render pageButton(page + 1, data.page === page + 1, data.page === page + 1, page + 1)}
				{:else if page >= data.totalPages - 2 && page !== data.page - 1}
					{@render pageButton(page + 1, data.page === page + 1, data.page === page + 1, page + 1)}
				{/if}
			{/each}

			{@render pageButton(data.page + 1, data.page === data.totalPages, false, '→')}
		</div>
	</div>
{/if}

{#snippet pageButton(page: number, disabled: boolean, active: boolean, child: string | number)}
	<button
		class="rounded border p-4"
		class:disabled
		{disabled}
		class:active
		type="button"
		onclick={() => handlePageChange(page)}
	>
		{child}
	</button>
{/snippet}

<style lang="postcss">
	.active {
		@apply bg-emerald-400 text-white;
	}

	.disabled {
		@apply cursor-not-allowed opacity-50;
	}
</style>
```

注意搜索框使用了 `defaultValue={data.q ?? ''}`，防止页面渲染时显示 `undefined` 或 `null`。

利用 Snippets，可以定义可复用的 Svelte 代码片段，`{#snippet pageButton(...)}` 定义内容，后续用 `{@render pageButton(...)}` 调用并传递类型安全参数。分页按钮运用了该特性。

还有个 Svelte 巧妙点是页面中的 `<style>` 局部生效，不会影响其他文件。所以我们为分页按钮添加的 `.active` 和 `.disabled` 类样式不会全局污染。

此处稍微美化了样式，当然你可以根据个人喜好继续调整布局和风格！

---

# Build an app with Tanstack and Deno

> Complete guide to building applications with Tanstack and Deno. Learn how to implement Query for data fetching, Router for navigation, manage server state, and create type-safe full-stack applications.

URL: https://docs.deno.com/examples/tutorials/tanstack


[Tanstack](https://tanstack.com/) is a set of framework-agnostic data management
tools. With Tanstack, developers can manage server state efficiently with
[Query](https://tanstack.com/query/latest), create powerful tables with
[Table](https://tanstack.com/table/latest), handle complex routing with
[Router](https://tanstack.com/router/latest), and build type-safe forms with
[Form](https://tanstack.com/form/latest). These tools work seamlessly across
[React](/examples/react_tutorial), [Vue](/examples/vue_tutorial),
[Solid](/examples/solidjs_tutorial), and other frameworks while maintaining
excellent TypeScript support.

In this tutorial, we’ll build a simple app using
[Tanstack Query](https://tanstack.com/query/latest) and
[Tanstack Router](https://tanstack.com/router/latest/docs/framework/react/quick-start).
The app will display a list of dinosaurs. When you click on one, it'll take you
to a dinosaur page with more details.

- [Start with the backend API](#start-with-the-backend-api)
- [Create a Tanstack-driven frontend](#create-tanstack-driven-frontend)
- [Next steps](#next-steps)

Feel free to skip directly to
[the source code](https://github.com/denoland/examples/tree/main/with-tanstack)
or follow along below!

## Start with the backend API

Within our main directory, let's setup an `api/` directory and create our
dinosaur data file, `api/data.json`:

```jsonc
// api/data.json

[
  {
    "name": "Aardonyx",
    "description": "An early stage in the evolution of sauropods."
  },
  {
    "name": "Abelisaurus",
    "description": "\"Abel's lizard\" has been reconstructed from a single skull."
  },
  {
    "name": "Abrictosaurus",
    "description": "An early relative of Heterodontosaurus."
  },
  ...
]
```

This is where our data will be pulled from. In a full application, this data
would come from a database.

> ⚠️️ In this tutorial we hard code the data. But you can connect
> to [a variety of databases](https://docs.deno.com/runtime/tutorials/connecting_to_databases/) and [even use ORMs like Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/) with
> Deno.

Secondly, let's create our [Hono](https://hono.dev/) server. We start by
installing Hono from [JSR](https://jsr.io) with `deno add`:

```shell
deno add jsr:@hono/hono
```

Next, let's create an `api/main.ts` file and populate it with the below. Note
we'll need to import
[`@hono/hono/cors`](https://hono.dev/docs/middleware/builtin/cors) and define
key attributes to allow the frontend to access the API routes.

```ts
// api/main.ts

import { Hono } from "@hono/hono";
import { cors } from "@hono/hono/cors";
import data from "./data.json" with { type: "json" };

const app = new Hono();

app.use(
  "/api/*",
  cors({
    origin: "http://localhost:5173",
    allowMethods: ["GET", "POST", "PUT", "DELETE"],
    allowHeaders: ["Content-Type", "Authorization"],
    exposeHeaders: ["Content-Type", "Authorization"],
    credentials: true,
    maxAge: 600,
  }),
);

app.get("/", (c) => {
  return c.text("Welcome to the dinosaur API!");
});

app.get("/api/dinosaurs", (c) => {
  return c.json(data);
});

app.get("/api/dinosaurs/:dinosaur", (c) => {
  if (!c.req.param("dinosaur")) {
    return c.text("No dinosaur name provided.");
  }

  const dinosaur = data.find((item) =>
    item.name.toLowerCase() === c.req.param("dinosaur").toLowerCase()
  );

  if (dinosaur) {
    return c.json(dinosaur);
  } else {
    return c.notFound();
  }
});

Deno.serve(app.fetch);
```

The Hono server provides two API endpoints:

- `GET /api/dinosaurs` to fetch all dinosaurs, and
- `GET /api/dinosaurs/:dinosaur` to fetch a specific dinosaur by name

Before we start working on the frontend, let's update our `deno tasks` in our
`deno.json` file. Yours should look something like this:

```jsonc
{
  "tasks": {
    "dev": "deno --allow-env --allow-net api/main.ts"
  }
  // ...
}
```

Now, the backend server will be started on `localhost:8000` when we run
`deno task dev`.

## Create Tanstack-driven frontend

Let's create the frontend that will use this data. First, we'll quickly scaffold
a new React app with Vite using the TypeScript template in the current
directory:

```shell
deno init --npm vite@latest --template react-ts ./
```

Then, we'll install our Tanstack-specific dependencies:

```shell
deno install npm:@tanstack/react-query npm:@tanstack/react-router
```

Let's update our `deno tasks` in our `deno.json` to add a command to start the
Vite server:

```jsonc
// deno.json
{
  "tasks": {
    "dev": "deno task dev:api & deno task dev:vite",
    "dev:api": "deno --allow-env --allow-net api/main.ts",
    "dev:vite": "deno -A npm:vite"
  }
  // ...
}
```

We can move onto building our components. We'll need two main pages for our app:

- `DinosaurList.tsx`: the index page, which will list out all the dinosaurs, and
- `Dinosaur.tsx`: the leaf page, which displays information about a single
  dinosaur

Let's create a new `./src/components` directory and, within that, the file
`DinosaurList.tsx`:

```ts
// ./src/components/DinosaurList.tsx

import { useQuery } from "@tanstack/react-query";
import { Link } from "@tanstack/react-router";

async function fetchDinosaurs() {
  const response = await fetch("http://localhost:8000/api/dinosaurs");
  if (!response.ok) {
    throw new Error("Failed to fetch dinosaurs");
  }
  return response.json();
}

export function DinosaurList() {
  const {
    data: dinosaurs,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["dinosaurs"],
    queryFn: fetchDinosaurs,
  });

  if (isLoading) return <div>Loading...</div>;
  if (error instanceof Error) {
    return <div>An error occurred: {error.message}</div>;
  }

  return (
    <div>
      <h2 className="text-xl font-semibold mb-4">Dinosaur List</h2>
      <ul className="space-y-2">
        {dinosaurs?.map((dino: { name: string; description: string }) => (
          <li key={dino.name}>
            <Link
              to="/dinosaur/$name"
              params={{ name: dino.name }}
              className="text-blue-500 hover:underline"
            >
              {dino.name}
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

This uses
[`useQuery`](https://tanstack.com/query/v4/docs/framework/react/guides/queries)
from **Tanstack Query** to fetch and cache the dinosaur data automatically, with
built-in loading and error states. Then it uses
[`Link`](https://tanstack.com/router/v1/docs/framework/react/api/router/linkComponent)
from **Tanstack Router** to create client-side navigation links with type-safe
routing parameters.

Next, let's create the `DinosaurDetail.tsx` component in the `./src/components/`
folder, which will show details about a single dinosaur:

```ts
// ./src/components/DinosaurDetail.tsx

import { useParams } from "@tanstack/react-router";
import { useQuery } from "@tanstack/react-query";

async function fetchDinosaurDetail(name: string) {
  const response = await fetch(`http://localhost:8000/api/dinosaurs/${name}`);
  if (!response.ok) {
    throw new Error("Failed to fetch dinosaur detail");
  }
  return response.json();
}

export function DinosaurDetail() {
  const { name } = useParams({ from: "/dinosaur/$name" });
  const {
    data: dinosaur,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["dinosaur", name],
    queryFn: () => fetchDinosaurDetail(name),
  });

  if (isLoading) return <div>Loading...</div>;
  if (error instanceof Error) {
    return <div>An error occurred: {error.message}</div>;
  }

  return (
    <div>
      <h2 className="text-xl font-semibold mb-4">{name}</h2>
      <p>{dinosaur?.description}</p>
    </div>
  );
}
```

Again, this uses `useQuery` from **Tanstack Query** to fetch and cache
individual dinosaur details, with
[`queryKey`](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
including the dinosaur name to ensure proper caching. Additionally, we use
[`useParams`](https://tanstack.com/router/v1/docs/framework/react/api/router/useParamsHook)
from **Tanstack Router** to safely extract and type the URL parameters defined
in our route configuration.

Before we can run this, we need to encapsulate these components into a layout.
Let's create another file in the `./src/components/` folder called `Layout.tsx`:

```ts
// ./src/components/Layout.tsx

export function Layout() {
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">Dinosaur Encyclopedia</h1>
      <nav className="mb-4">
        <Link to="/" className="text-blue-500 hover:underline">
          Home
        </Link>
      </nav>
      <Outlet />
    </div>
  );
}
```

You may notice the
[`Outlet`](https://tanstack.com/router/v1/docs/framework/react/guide/outlets)
component towards the bottom of our newly created layout. This component is from
**Tanstack Router** and renders the child route's content, allowing for nested
routing while maintaining a consistent layout structure.

Next, we'll have to wire up this layout with `./src/main.tsx`, which an
important file that sets up the Tanstack Query client for managing server state
and the Tanstack Router for handling navigation:

```ts
// ./src/main.tsx

import React from "react";
import ReactDOM from "react-dom/client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createRouter, RouterProvider } from "@tanstack/react-router";
import { routeTree } from "./routeTree";

const queryClient = new QueryClient();

const router = createRouter({ routeTree });

declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  </React.StrictMode>,
);
```

You'll notice we import
[`QueryClientProvider`](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider),
which wraps the entire application to allow for query caching and state
management. We also import `RouterProvider`, which connects our defined routes
to React's rendering system.

Finally, we'll need to define a
[`routeTree.tsx`](https://tanstack.com/router/v1/docs/framework/react/guide/route-trees)
file in our `./src/` directory. This file defines our application's routing
structure using Tanstack Router's type-safe route definitions:

```ts
// ./src/routeTree.tsx

import { RootRoute, Route } from "@tanstack/react-router";
import { DinosaurList } from "./components/DinosaurList";
import { DinosaurDetail } from "./components/DinosaurDetail";
import { Layout } from "./components/Layout";

const rootRoute = new RootRoute({
  component: Layout,
});

const indexRoute = new Route({
  getParentRoute: () => rootRoute,
  path: "/",
  component: DinosaurList,
});

const dinosaurRoute = new Route({
  getParentRoute: () => rootRoute,
  path: "dinosaur/$name",
  component: DinosaurDetail,
});

export const routeTree = rootRoute.addChildren([indexRoute, dinosaurRoute]);
```

In `./src/routeTree.tsx`, we create a hierarchy of routes with `Layout` as the
root component. Then we set two child routes, their paths and components — one
for the dinosaur list, `DinosaurList`, and the other for the individual dinosaur
details with a dynamic parameter, `DinosaurDetail`.

With all that complete, we can run this project:

```shell
deno task dev
```

<figure>

<video class="w-full" alt="Build an app with Deno and Tanstack." autoplay muted loop playsinline src="./images/how-to/tanstack/demo.mp4"></video>

</figure>

## Next steps

This is just the beginning of building with Deno and Tanstack. You can add
persistent data storage like
[using a database like Postgres or MongoDB](https://docs.deno.com/runtime/tutorials/connecting_to_databases/)
and an ORM like [Drizzle](https://deno.com/blog/build-database-app-drizzle) or
[Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/). Or
deploy your app to
[AWS](https://docs.deno.com/runtime/tutorials/aws_lightsail/),
[Digital Ocean](https://docs.deno.com/runtime/tutorials/digital_ocean/), or
[Google Cloud Run](https://docs.deno.com/runtime/tutorials/google_cloud_run/)

You could also add real-time updates using
[Tanstack Query's refetching capabilities](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching),
[implement infinite scrolling](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
for large dinosaur lists, or
[add complex filtering and sorting](https://tanstack.com/table/v8/docs/guide/column-filtering)
using **[Tanstack Table](https://tanstack.com/table/latest)**. The combination
of Deno's built-in web standards, tooling, and native TypeScript support, as
well as Tanstack's powerful data management opens up numerous possibilities for
building robust web applications.


---

# Writing tests

> Learn key concepts like test setup and structure, assertions, async testing, mocking, test fixtures, and code coverage

URL: https://docs.deno.com/examples/tutorials/testing


Testing is critical in software development to ensure your code works as
expected, and continues to work as you make changes. Tests verify that your
functions, modules, and applications behave correctly, handle edge cases
appropriately, and maintain expected performance characteristics.

## Why testing matters

Testing your code allows you to catch bugs, issues or regressions before they
reach production, saving time and resources. Tests are also useful to help plan
out the logic of your application, they can serve as a human readable
description of how your code is meant to be used.

Deno provides [built-in testing capabilities](/runtime/fundamentals/testing/),
making it straightforward to implement robust testing practices in your
projects.

## Writing tests with `Deno.test`

Defining a test in Deno is straightforward - use the `Deno.test()` function to
register your test with the test runner. This function accepts either a test
name and function, or a configuration object with more detailed options. All
test functions in files that match patterns like `*_test.{ts,js,mjs,jsx,tsx}` or
`*.test.{ts,js,mjs,jsx,tsx}` are automatically discovered and executed when you
run the `deno test` command.

Here are the basic ways to define tests:

```ts
// Basic test with a name and function
Deno.test("my first test", () => {
  // Your test code here
});

// Test with configuration options
Deno.test({
  name: "my configured test",
  fn: () => {
    // Your test code here
  },
  ignore: false, // Optional: set to true to skip this test
  only: false, // Optional: set to true to only run this test
  permissions: { // Optional: specify required permissions
    read: true,
    write: false,
  },
});
```

### A simple example test

Let's start with a simple test. Create a file called `main_test.ts`, in it we
will test a basic addition operation using Deno's testing API and the
`assertEquals` function from the [Deno Standard Library](https://jsr.io/@std).

We use `Deno.test` and provide a name that describes what the test will do:

```ts title="main_test.ts"
// hello_test.ts
import { assertEquals } from "jsr:@std/assert";

// Function we want to test
function add(a: number, b: number): number {
  return a + b;
}

Deno.test("basic addition test", () => {
  // Arrange - set up the test data
  const a = 1;
  const b = 2;

  // Act - call the function being tested
  const result = add(a, b);

  // Assert - verify the result is what we expect
  assertEquals(result, 3);
});
```

To run this test, use the `deno test` command:

```sh
deno test hello_test.ts
```

You should see output indicating that your test has passed:

```
running 1 test from ./hello_test.ts
basic addition test ... ok (2ms)

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (2ms)
```

Try changing the function implementation to make the test fail:

```ts
function add(a: number, b: number): number {
  return a - b; // Changed from addition to subtraction
}
```

You'll see an error message that clearly shows what went wrong:

```sh
running 1 test from ./hello_test.ts
basic addition test ... FAILED (3ms)

failures:

basic addition test => ./hello_test.ts:12:3
error: AssertionError: Values are not equal:
    
    [Diff] Actual / Expected
    
    -   -1
    +   3

  at assertEquals (https://jsr.io/@std/assert@0.218.2/assert_equals.ts:31:9)
  at Object.fn (file:///path/to/hello_test.ts:12:3)
  at asyncOpSanitizer (ext:core/01_core.js:199:13)
  at Object.sanitizeOps (ext:core/01_core.js:219:15)
  at runTest (ext:test/06_test_runner.js:319:29)
  at test (ext:test/06_test_runner.js:593:7)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out (3ms)
```

This clear feedback helps you quickly identify and fix issues in your code.

## Test structure and organization

Deno will automatically find and run tests that match naming patterns like
`*_test.{ts,js,mjs,jsx,tsx}` or `*.test.{ts,js,mjs,jsx,tsx}`. There are plenty
of ways to organize your test files, we recommend co-locating your unit tests
with the code they are testing, and keeping integration tests and configuration
in a `tests` directory. This allows for immediate discovery of unit tests and
simplified imports, while keeping a separation between different types of tests.

Here's an example of how you might structure your project with tests:

```sh
my-deno-project/
├── src/
│   ├── models/
│   │   ├── user.ts
│   │   ├── user_test.ts          // Unit tests for user model
│   │   ├── product.ts
│   │   └── product_test.ts       // Unit tests for product model
│   ├── services/
│   │   ├── auth-service.ts
│   │   ├── auth-service_test.ts  // Unit tests for auth service
│   │   ├── data-service.ts
│   │   └── data-service_test.ts  // Unit tests for data service
│   └── utils/
│       ├── helpers.ts
│       └── helpers_test.ts       // Unit tests for helpers
├── tests/
│   ├── integration/              // Integration tests directory
│   │   ├── api_test.ts           // Tests API endpoints
│   │   └── db_test.ts            // Tests database interactions
│   ├── e2e/                      // End-to-end tests
│   │   └── user_flow_test.ts     // Tests complete user workflows
│   └── fixtures/                 // Shared test data and utilities
│       ├── test_data.ts          // Test data used across tests
│       └── setup.ts              // Common setup functions
├── main.ts
└── deno.json                     // Project configuration
```

This kind of structure offers a centralized place for test configuration while
maintaining the benefits of co-locating unit tests with their relevant files.
With this structure, you can:

```sh
# Run all tests
deno test

# Run only unit tests
deno test src/

# Run only integration tests
deno test tests/integration/

# Run specific module tests
deno test src/models/

# Run a specific test file
deno test src/models/user_test.ts
```

## Assertions

Assertions are the building blocks of effective tests, allowing you to verify
that your code behaves as expected. They check if a specific condition is true
and throw an error if it's not, causing the test to fail. Good assertions are
clear, specific, and help identify exactly what went wrong when a test fails.

Deno doesn't include assertions in its core library, but you can import them
from the [Deno standard library](https://jsr.io/@std/assert):

```ts
import {
  assertArrayIncludes, // Check that array contains value
  assertEquals, // Check that values are equal
  assertExists, // Check that value is not null or undefined
  assertMatch, // Check that string matches regex pattern
  assertNotEquals, // Check that values are not equal
  assertObjectMatch, // Check that object has expected properties
  assertRejects, // Check that Promise rejects
  assertStrictEquals, // Check that values are strictly equal (===)
  assertStringIncludes, // Check that string contains substring
  assertThrows, // Check that function throws an error
} from "jsr:@std/assert";

Deno.test("assertion examples", () => {
  // Basic assertions
  assertEquals(1 + 1, 2);
  assertNotEquals("hello", "world");
  assertExists("Hello");

  // String assertions
  assertStringIncludes("Hello, world!", "world");
  assertMatch("deno@1.0.0", /^deno@\d+\.\d+\.\d+$/);

  // Object assertions
  assertObjectMatch(
    { name: "Jane", age: 25, city: "Tokyo" },
    { name: "Jane" }, // Only checks specified properties
  );

  // Strict equality (type + value)
  assertStrictEquals("deno", "deno");

  // Error assertions
  assertThrows(
    () => {
      throw new Error("Something went wrong");
    },
    Error,
    "Something went wrong",
  );
});
```

For those that prefer fluent assertions (familiar to users of Jest), you can use
the `expect` module:

```ts
import { expect } from "jsr:@std/expect";

Deno.test("expect style assertions", () => {
  // Basic matchers
  expect(5).toBe(5);
  expect({ name: "deno" }).toEqual({ name: "deno" });

  // Collection matchers
  expect([1, 2, 3]).toContain(2);

  // Truthiness matchers
  expect(true).toBeTruthy();
  expect(0).toBeFalsy();
  expect(null).toBeNull();
  expect(undefined).toBeUndefined();

  // Number matchers
  expect(100).toBeGreaterThan(99);
  expect(1).toBeLessThan(2);

  // String matchers
  expect("Hello world").toMatch(/world/);

  // Function/error matchers
  expect(() => {
    throw new Error("fail");
  }).toThrow();
});
```

### Real-world Example

Here's a more realistic example testing a function that processes user data:

```ts
// user_processor.ts
export function validateUser(user: any): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!user.name || typeof user.name !== "string") {
    errors.push("Name is required and must be a string");
  }

  if (!user.email || !user.email.includes("@")) {
    errors.push("Valid email is required");
  }

  if (
    user.age !== undefined && (typeof user.age !== "number" || user.age < 18)
  ) {
    errors.push("Age must be a number and at least 18");
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

// user_processor_test.ts
import { assertEquals } from "jsr:@std/assert";
import { validateUser } from "./user_processor.ts";

Deno.test("validateUser", async (t) => {
  await t.step("should validate a correct user object", () => {
    const user = {
      name: "John Doe",
      email: "john@example.com",
      age: 30,
    };

    const result = validateUser(user);
    assertEquals(result.valid, true);
    assertEquals(result.errors.length, 0);
  });

  await t.step("should return errors for invalid user", () => {
    const user = {
      name: "",
      email: "invalid-email",
      age: 16,
    };

    const result = validateUser(user);
    assertEquals(result.valid, false);
    assertEquals(result.errors.length, 3);
    assertEquals(result.errors[0], "Name is required and must be a string");
    assertEquals(result.errors[1], "Valid email is required");
    assertEquals(result.errors[2], "Age must be a number and at least 18");
  });

  await t.step("should handle missing properties", () => {
    const user = {
      name: "Jane Doe",
      // email and age missing
    };

    const result = validateUser(user);
    assertEquals(result.valid, false);
    assertEquals(result.errors.length, 1);
    assertEquals(result.errors[0], "Valid email is required");
  });
});
```

## Async testing

Deno handles async tests naturally. Just make your test function async and use
await:

```ts
import { assertEquals } from "jsr:@std/assert";

Deno.test("async test example", async () => {
  const response = await fetch("https://deno.land");
  const status = response.status;
  assertEquals(status, 200);
});
```

### Testing async functions

When testing functions that return promises, you should always await the result:

```ts
// async-function.ts
export async function fetchUserData(userId: string) {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.status}`);
  }
  return await response.json();
}

// async-function_test.ts
import { assertEquals, assertRejects } from "jsr:@std/assert";
import { fetchUserData } from "./async-function.ts";

Deno.test("fetchUserData success", async () => {
  // Mock the fetch function for testing
  globalThis.fetch = async (url: string) => {
    const data = JSON.stringify({ id: "123", name: "Test User" });
    return new Response(data, { status: 200 });
  };

  const userData = await fetchUserData("123");
  assertEquals(userData.id, "123");
  assertEquals(userData.name, "Test User");
});

Deno.test("fetchUserData failure", async () => {
  // Mock the fetch function to simulate an error
  globalThis.fetch = async (url: string) => {
    return new Response("Not Found", { status: 404 });
  };

  await assertRejects(
    async () => await fetchUserData("nonexistent"),
    Error,
    "Failed to fetch user: 404",
  );
});
```

## Mocking in tests

Mocking is an essential technique for isolating the code being tested from its
dependencies. Deno provides built-in utilities and third-party libraries for
creating mocks.

### Basic Mocking

You can create simple mocks by
[replacing functions or objects with your own
implementations](/examples/mocking_tutorial/). This allows you to control the
behavior of dependencies and test how your code interacts with them.

```ts
// Example of a module with a function we want to mock
const api = {
  fetchData: async () => {
    const response = await fetch("https://api.example.com/data");
    return response.json();
  },
};

// In your test file
Deno.test("basic mocking example", async () => {
  // Store the original function
  const originalFetchData = api.fetchData;

  // Replace with mock implementation
  api.fetchData = async () => {
    return { id: 1, name: "Test Data" };
  };

  try {
    // Test using the mock
    const result = await api.fetchData();
    assertEquals(result, { id: 1, name: "Test Data" });
  } finally {
    // Restore the original function
    api.fetchData = originalFetchData;
  }
});
```

### Using Spy Functions

Spies allow you to track function calls without changing their behavior:

```ts
import { spy } from "jsr:@std/testing/mock";

Deno.test("spy example", () => {
  // Create a spy on console.log
  const consoleSpy = spy(console, "log");

  // Call the function we're spying on
  console.log("Hello");
  console.log("World");

  // Verify the function was called correctly
  assertEquals(consoleSpy.calls.length, 2);
  assertEquals(consoleSpy.calls[0].args, ["Hello"]);
  assertEquals(consoleSpy.calls[1].args, ["World"]);

  // Restore the original function
  consoleSpy.restore();
});
```

For more advanced mocking techniques, check our
[dedicated guide on mocking in Deno](/examples/mocking_tutorial/).

## Test hooks

Deno provides test hooks for running setup and teardown code. Here's a simple
example using `beforeEach` to ensure clean state between tests:

```ts
import { assertEquals } from "jsr:@std/assert";

let testData: string[] = [];

Deno.test.beforeEach(() => {
  testData = ["initial", "data"];
});

Deno.test("first test", () => {
  testData.push("first");
  assertEquals(testData.length, 3);
});

Deno.test("second test", () => {
  testData.push("second");
  assertEquals(testData.length, 3); // Clean state from beforeEach
});
```

For complete information on all available hooks (`beforeAll`, `beforeEach`,
`afterEach`, `afterAll`), see the
[Testing documentation](/runtime/fundamentals/testing/#test-hooks).

## Coverage

Code coverage is a metric that helps you understand how much of your code is
being tested. It measures which lines, functions, and branches of your code are
executed during your tests, giving you insight into areas that might lack proper
testing.

Coverage analysis helps you to:

- Identify untested parts of your codebase
- Ensure critical paths have tests
- Prevent regressions when making changes
- Measure testing progress over time

:::note

High coverage doesn't guarantee high-quality tests. It simply shows what code
was executed, not whether your assertions are meaningful or if edge cases are
handled correctly.

:::

Deno provides built-in coverage tools to help you analyze your test coverage. To
collect coverage information:

```bash
deno test --coverage=coverage_dir
```

This generates coverage data in a specified directory (here, `coverage_dir`). To
view a human-readable report:

```bash
deno coverage coverage_dir
```

You'll see output like:

```sh
file:///projects/my-project/src/utils.ts 85.7% (6/7)
file:///projects/my-project/src/models/user.ts 100.0% (15/15)
file:///projects/my-project/src/services/auth.ts 78.3% (18/23)

total: 87.5% (39/45)
```

For more detailed insights, you can also generate an HTML report:

```bash
deno coverage --html coverage_dir
```

This creates an interactive HTML report in the specified directory that shows
exactly which lines are covered and which are not.

By default, the coverage tool automatically excludes:

- Test files (matching patterns like `test.ts` or `test.js`)
- Remote files (those not starting with `file:`)

This ensures your coverage reports focus on your application code rather than
test files or external dependencies.

### Coverage Configuration

You can exclude files from coverage reports by using the `--exclude` flag:

```bash
deno coverage --exclude="test_,vendor/,_build/,node_modules/" coverage_dir
```

### Integrating with CI

For continuous integration environments, you might want to enforce a minimum
coverage threshold:

```yaml
# In your GitHub Actions workflow
- name: Run tests with coverage
  run: deno test --coverage=coverage_dir

- name: Check coverage meets threshold
  run: |
    COVERAGE=$(deno coverage coverage_dir | grep "total:" | grep -o '[0-9]\+\.[0-9]\+')
    if (( $(echo "$COVERAGE < 80" | bc -l) )); then
      echo "Test coverage is below 80%: $COVERAGE%"
      exit 1
    fi
```

When working on your test coverage, remember to set realistic goals, aim for
meaningful coverage with high quality tests over 100% coverage.

## Comparison with other testing frameworks

If you're coming from other JavaScript testing frameworks, here's how Deno's
testing capabilities compare:

| Feature       | Deno             | Jest                   | Mocha                      | Jasmine               |
| ------------- | ---------------- | ---------------------- | -------------------------- | --------------------- |
| Setup         | Built-in         | Requires installation  | Requires installation      | Requires installation |
| Syntax        | `Deno.test()`    | `test()`, `describe()` | `it()`, `describe()`       | `it()`, `describe()`  |
| Assertions    | From std library | Built-in expect        | Requires assertion library | Built-in expect       |
| Mocking       | From std library | Built-in jest.mock()   | Requires sinon or similar  | Built-in spies        |
| Async support | Native           | Needs special handling | Supports promises          | Supports promises     |
| File watching | `--watch` flag   | watch mode             | Requires nodemon           | Requires extra tools  |
| Code coverage | Built-in         | Built-in               | Requires istanbul          | Requires istanbul     |

### Testing Style Comparison

**Deno:**

```ts
import { assertEquals } from "jsr:@std/assert";

Deno.test("add function", () => {
  assertEquals(1 + 2, 3);
});
```

**Jest:**

```ts
test("add function", () => {
  expect(1 + 2).toBe(3);
});
```

**Mocha:**

```ts
import { assert } from "chai";

describe("math", () => {
  it("should add numbers", () => {
    assert.equal(1 + 2, 3);
  });
});
```

**Jasmine:**

```ts
describe("math", () => {
  it("should add numbers", () => {
    expect(1 + 2).toBe(3);
  });
});
```

## Next steps

🦕 Deno's built-in testing capabilities make it easy to write and run tests
without needing to install extra testing frameworks or tools. By following the
patterns and practices outlined in this tutorial, you can ensure your Deno
applications are well-tested and reliable.

For more information about testing in Deno, check out:

- [Testing documentation](/runtime/fundamentals/testing)
- [Mocking data for tests](/examples/mocking_tutorial/)
- [Writing benchmark tests](/examples/benchmarking/)


---

# Build a Typesafe API with tRPC and Deno

> A guide to building type-safe APIs with tRPC and Deno. Learn how to set up endpoints, implement RPC procedures, handle data validation, and create efficient client-server applications.

URL: https://docs.deno.com/examples/tutorials/trpc


Deno 是一个
[一体化、零配置的工具链](https://docs.deno.com/runtime/manual/tools)
，用于编写 JavaScript 和
[TypeScript](https://docs.deno.com/runtime/fundamentals/typescript/)，
[natively supports Web Platform APIs](https://docs.deno.com/runtime/reference/web_platform_apis/)，
使其成为快速构建后端和 API 的理想选择。为了使我们的 API 更易于维护，我们可以使用 [tRPC](https://trpc.io/)，这是一个 TypeScript RPC
([远程过程调用](https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8))
框架，它使您能够在没有模式声明或代码生成的情况下构建完全类型安全的 API。

在本教程中，我们将使用 tRPC 和 Deno 构建一个简单的类型安全 API，该 API 返回有关恐龙的信息：

- [设置 tRPC](#set-up-trpc)
- [设置服务器](#set-up-the-trpc-server)
- [设置客户端](#set-up-the-trpc-client)
- [接下来会怎样？](#whats-next)

您可以在
[这个 GitHub 仓库](https://github.com/denoland/examples/tree/main/with-trpc)
中找到本教程的所有代码。

## 设置 tRPC

要在 Deno 中开始使用 tRPC，我们需要安装所需的依赖项。由于 Deno 的 npm 兼容性，我们可以使用 tRPC 包的 npm 版本以及用于输入验证的 Zod：

```bash
deno install npm:@trpc/server@next npm:@trpc/client@next npm:zod jsr:@std/path
```

这将安装最新的 tRPC 服务器和客户端包，
[Zod](https://zod.dev/) 用于运行时类型验证，以及
[Deno 标准库的 `path`](https://jsr.io/@std/path) 工具。这些包将允许我们在客户端和服务器代码之间构建一个类型安全的 API 层。

这将在项目根目录创建一个 `deno.json` 文件，以管理 npm 和
[jsr](https://jsr.io/) 依赖项：

```tsx
{
  "imports": {
    "@std/path": "jsr:@std/path@^1.0.6",
    "@trpc/client": "npm:@trpc/client@^11.0.0-rc.593",
    "@trpc/server": "npm:@trpc/server@^11.0.0-rc.593",
    "zod": "npm:zod@^3.23.8"
  }
}
```

## 设置 tRPC 服务器

构建我们的 tRPC 应用的第一步是设置服务器。我们将通过初始化 tRPC 并创建我们的基本路由器和过程构建器来开始。这些将是定义我们的 API 端点的基础。

创建一个 `server/trpc.ts` 文件：

```tsx
// server/trpc.ts

import { initTRPC } from "@trpc/server";

/**
 * tRPC 后端的初始化
 * 每个后端只应执行一次！
 */

const t = initTRPC.create();

/**
 * 导出可重用的路由器和过程帮助程序
 * 可在整个路由器中使用
 */

export const router = t.router;
export const publicProcedure = t.procedure;
```

这初始化了 tRPC 并导出了我们将用来定义 API 端点的路由器和过程构建器。`publicProcedure` 允许我们创建不需要身份验证的端点。

接下来，我们将创建一个简单的数据层来管理我们的恐龙数据。创建一个 `server/db.ts` 文件，如下所示：

```tsx
// server/db.ts
import { join } from "@std/path";

type Dino = { name: string; description: string };

const dataPath = join("data", "data.json");

async function readData(): Promise<Dino[]> {
  const data = await Deno.readTextFile(dataPath);
  return JSON.parse(data);
}

async function writeData(dinos: Dino[]): Promise<void> {
  await Deno.writeTextFile(dataPath, JSON.stringify(dinos, null, 2));
}

export const db = {
  dino: {
    findMany: () => readData(),
    findByName: async (name: string) => {
      const dinos = await readData();
      return dinos.find((dino) => dino.name === name);
    },
    create: async (data: { name: string; description: string }) => {
      const dinos = await readData();
      const newDino = { ...data };
      dinos.push(newDino);
      await writeData(dinos);
      return newDino;
    },
  },
};
```

这创建了一个简单的基于文件的数据库，用于读取和写入恐龙数据到 JSON 文件。在生产环境中，您通常会使用一个适当的数据库，但这对于我们的演示来说效果很好。

> ⚠️️ 在本教程中，我们硬编码数据并使用基于文件的数据库。然而，您可以
> [连接到多种数据库](https://docs.deno.com/runtime/tutorials/connecting_to_databases/)
> 并使用如 [Drizzle](https://docs.deno.com/examples/drizzle) 或
> [Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/) 的 ORM。

最后，我们需要提供实际数据。让我们创建一个 `./data.json` 文件，包含一些示例恐龙数据：

```tsx
// data/data.json
[
  {
    "name": "Aardonyx",
    "description": "An early stage in the evolution of sauropods."
  },
  {
    "name": "Abelisaurus",
    "description": "\"Abel's lizard\" has been reconstructed from a single skull."
  },
  {
    "name": "Abrictosaurus",
    "description": "An early relative of Heterodontosaurus."
  },
  {
    "name": "Abrosaurus",
    "description": "A close Asian relative of Camarasaurus."
  },
  ...
 ]
```

现在，我们可以创建我们的主服务器文件，定义我们的 tRPC 路由器和过程。创建一个 `server/index.ts` 文件：

```tsx
// server/index.ts

import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { z } from "zod";
import { db } from "./db.ts";
import { publicProcedure, router } from "./trpc.ts";

const appRouter = router({
  dino: {
    list: publicProcedure.query(async () => {
      const dinos = await db.dino.findMany();
      return dinos;
    }),
    byName: publicProcedure.input(z.string()).query(async (opts) => {
      const { input } = opts;
      const dino = await db.dino.findByName(input);
      return dino;
    }),
    create: publicProcedure
      .input(z.object({ name: z.string(), description: z.string() }))
      .mutation(async (opts) => {
        const { input } = opts;
        const dino = await db.dino.create(input);
        return dino;
      }),
  },
  examples: {
    iterable: publicProcedure.query(async function* () {
      for (let i = 0; i < 3; i++) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        yield i;
      }
    }),
  },
});

// 导出类型路由器类型签名，这由客户端使用。
export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);
```

这设置了三个主要端点：

- `dino.list`: 返回所有恐龙
- `dino.byName`: 根据名称返回特定恐龙
- `dino.create`: 创建新的恐龙
- `examples.iterable`: 演示 tRPC 对异步可迭代对象的支持

服务器已配置为在 3000 端口监听并处理所有 tRPC 请求。

虽然您现在可以运行服务器，但您将无法访问任何路由并让它返回数据。让我们修复这个问题！

## 设置 tRPC 客户端

服务器准备好后，我们可以创建一个客户端来使用类型安全地调用我们的 API。创建一个 `client/index.ts` 文件：

```tsx
// client/index.ts
/**
 * 这是客户端代码，使用来自服务器的推断类型
 */
import {
  createTRPCClient,
  splitLink,
  unstable_httpBatchStreamLink,
  unstable_httpSubscriptionLink,
} from "@trpc/client";
/**
 * 我们只从服务器导入 `AppRouter` 类型 - 这在运行时不可用
 */
import type { AppRouter } from "../server/index.ts";

// 初始化 tRPC 客户端
const trpc = createTRPCClient<AppRouter>({
  links: [
    splitLink({
      condition: (op) => op.type === "subscription",
      true: unstable_httpSubscriptionLink({
        url: "http://localhost:3000",
      }),
      false: unstable_httpBatchStreamLink({
        url: "http://localhost:3000",
      }),
    }),
  ],
});

const dinos = await trpc.dino.list.query();
console.log("Dinos:", dinos);

const createdDino = await trpc.dino.create.mutate({
  name: "Denosaur",
  description:
    "A dinosaur that lives in the deno ecosystem. Eats Nodes for breakfast.",
});
console.log("Created dino:", createdDino);

const dino = await trpc.dino.byName.query("Denosaur");
console.log("Denosaur:", dino);

const iterable = await trpc.examples.iterable.query();

for await (const i of iterable) {
  console.log("Iterable:", i);
}
```

这段客户端代码演示了 tRPC 的几个关键特性：

1. **从服务器路由器的类型推断**。客户端通过导入 `AppRouter` 类型自动继承所有类型定义。这意味着您获得完整的类型支持和编译时类型检查，适用于所有 API 调用。如果您在服务器上修改过程，TypeScript 将立即标记任何不兼容的客户端用法。
2. **进行查询和变更**。该示例演示了两种类型的 API 调用：查询（`list` 和 `byName`）用于提取数据而不产生副作用，以及变更（`create`）用于修改服务器端状态的操作。客户端自动知道每个过程的输入和输出类型，从而在整个请求周期中提供类型安全。
3. **使用异步可迭代对象**。`examples.iterable` 演示了 tRPC 对使用异步可迭代对象流数据的支持。这一特性对于实时更新或分块处理大型数据集特别有用。

现在，让我们启动服务器以查看其工作情况。在我们的 `deno.json` 配置文件中，让我们创建一个新属性 `tasks`，包含以下命令：

```json
{
  "tasks": {
    "start": "deno -A server/index.ts",
    "client": "deno -A client/index.ts"
  }
  // deno.json 中的其他属性保持不变。
}
```

我们可以使用 `deno task` 列出可用的任务：

```bash
deno task
Available tasks:
- start
    deno -A server/index.ts
- client
    deno -A client/index.ts
```

现在，我们可以使用 `deno task start` 启动服务器。运行之后，我们可以使用 `deno task client` 启动客户端。您应该会看到如下输出：

```bash
deno task client
Dinos: [
  {
    name: "Aardonyx",
    description: "An early stage in the evolution of sauropods."
  },
  {
    name: "Abelisaurus",
    description: "Abel's lizard has been reconstructed from a single skull."
  },
  {
    name: "Abrictosaurus",
    description: "An early relative of Heterodontosaurus."
  },
  ...
]
Created dino: {
  name: "Denosaur",
  description: "A dinosaur that lives in the deno ecosystem. Eats Nodes for breakfast."
}
Denosaur: {
  name: "Denosaur",
  description: "A dinosaur that lives in the deno ecosystem. Eats Nodes for breakfast."
}
Iterable: 0
Iterable: 1
Iterable: 2
```

成功了！运行 `./client/index.ts` 显示了如何创建一个 tRPC 客户端，并使用其 JavaScript API 与数据库交互。但我们如何检查 tRPC 客户端是否从数据库推断了正确的类型呢？让我们将 `./client/index.ts` 中的代码片段修改为传递一个 `number` 而不是一个 `string` 作为 `description`：

```diff
// ...
const createdDino = await trpc.dino.create.mutate({
  name: "Denosaur",
  description:
-   "A dinosaur that lives in the deno ecosystem. Eats Nodes for breakfast.",
+   100,
});
console.log("Created dino:", createdDino);
// ...
```

当我们重新运行客户端：

```bash
deno task client
...
error: Uncaught (in promise) TRPCClientError: [
  {
    "code": "invalid_type",
    "expected": "string",
    "received": "number",
    "path": [
      "description"
    ],
    "message": "Expected string, received number"
  }
]
    at Function.from (file:///Users/andyjiang/Library/Caches/deno/npm/registry.npmjs.org/@trpc/client/11.0.0-rc.608/dist/TRPCClientError.mjs:35:20)
    at file:///Users/andyjiang/Library/Caches/deno/npm/registry.npmjs.org/@trpc/client/11.0.0-rc.608/dist/links/httpBatchStreamLink.mjs:118:56
    at eventLoopTick (ext:core/01_core.js:175:7)
```

tRPC 成功抛出了一个 `invalid_type` 错误，因为它期望的是 `string` 而不是 `number`。

## 接下来会怎样？

现在您对如何在 Deno 中使用 tRPC 有了基本的了解，您可以：

1. 使用 [Next.js](https://trpc.io/docs/client/nextjs) 或
   [React](https://trpc.io/docs/client/react) 构建一个实际的前端
2. [使用 tRPC 中间件为您的 API 添加身份验证](https://trpc.io/docs/server/middlewares#authorization)
3. 实施实时功能
   [使用 tRPC 订阅](https://trpc.io/docs/server/subscriptions)
4. 为更复杂的数据结构添加 [输入验证](https://trpc.io/docs/server/validators)
5. 与适当的数据库集成，如
   [PostgreSQL](https://docs.deno.com/runtime/tutorials/connecting_to_databases/#postgres)
   或使用 ORM，如 [Drizzle](https://docs.deno.com/examples/drizzle) 或
   [Prisma](https://docs.deno.com/runtime/tutorials/how_to_with_npm/prisma/)
6. 将应用程序部署到 [Deno Deploy](https://deno.com/deploy) 或
   [通过 Docker 部署到任何公共云](https://docs.deno.com/runtime/tutorials/#deploying-deno-projects)

🦕 祝您在 Deno 和 tRPC 编码时享受类型安全的乐趣！

---

# 构建一个 Vue.js 应用

> 一个使用 Deno 构建 Vue.js 应用的教程。学习如何设置 Vite 项目，实现组件架构，添加路由，管理状态，并创建一个全栈 TypeScript 应用。

URL: https://docs.deno.com/examples/tutorials/vue


[Vue.js](https://vuejs.org/) 是一个渐进式前端 JavaScript 框架。它提供了创建动态和交互式用户界面的工具和特性。

在本教程中，我们将使用 Vite 和 Deno 构建一个简单的 Vue.js 应用。该应用将显示恐龙列表。当你点击其中一个时，它将带你到一个包含更多详细信息的恐龙页面。你可以在 [GitHub 上查看完成的应用](https://github.com/denoland/tutorial-with-vue)。

你可以在 [Deno Deploy](https://tutorial-with-vue.deno.deno.net/) 上查看该应用的实时版本。

:::info 部署你自己的

想跳过教程，立即部署完成的应用程序吗？点击下面的按钮，立即将您自己的完整 SvelteKit 恐龙应用程序部署到 Deno Deploy。您将获得一个实时的、可工作的应用程序，您可以在学习的过程中进行自定义和修改！

[![Deploy on Deno](https://deno.com/button)](https://console.deno.com/new?clone=https://github.com/denoland/tutorial-with-vue&mode=dynamic&entrypoint=api/main.ts&build=deno+task+build&install=deno+install)

:::

## 使用 Vite 和 Deno 创建 Vue.js 应用

我们将使用 [Vite](https://vitejs.dev/) 来搭建一个基本的 Vue.js 应用。在你的终端中，运行以下命令以使用 Vite 创建一个新的 .js 应用：

```shell
deno run -A npm:create-vite
```

当提示时，给你的应用命名，并从提供的框架中选择 `Vue`，将 `TypeScript` 作为变体。

创建后，`cd` 进入你的新项目并运行以下命令来安装依赖：

```shell
deno install
```

然后，运行以下命令来提供你的新 Vue.js 应用：

```shell
deno task dev
```

Deno 将运行 `package.json` 文件中的 `dev` 任务，这将启动 Vite 服务器。点击输出的本地主机链接，在浏览器中查看你的应用。

## 配置格式化工具

`deno fmt` 支持使用 
[`--unstable-component`](https://docs.deno.com/runtime/reference/cli/fmt/#formatting-options-unstable-component)
标志格式化 Vue 文件。使用命令：

```sh
deno fmt --unstable-component
```

要配置 `deno fmt` 始终格式化你的 Vue 文件，请在 `deno.json` 文件的顶层添加：

```json
"unstable": ["fmt-component"]
```

## 添加后端 API

我们将使用 Deno 和 Oak 构建一个 API 服务器。这里将提供我们的恐龙数据。

在项目的根目录下创建一个 `api` 文件夹。在该文件夹中，创建一个 `data.json`，它将包含硬编码的恐龙数据。

复制并粘贴
[此 JSON 文件](https://github.com/denoland/tutorial-with-react/blob/main/api/data.json)
到 `api/data.json` 文件中。（如果你构建的是一个真实应用，你可能会从数据库或外部 API 获取这些数据。）

我们接下来将构建一些返回恐龙信息的 API 路由。我们需要 Oak 作为 HTTP 服务器以及
[CORS 中间件](https://jsr.io/@tajpouria/cors) 来启用
[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。

通过更新 `deno.json` 文件的 imports 部分添加依赖：

```json title="deno.json"
{
  "imports": {
    "@oak/oak": "jsr:@oak/oak@^17.1.5",
    "@tajpouria/cors": "jsr:@tajpouria/cors@^1.2.1",
    "vue-router": "npm:vue-router@^4.5.1"
  }
}
```

接下来，创建 `api/main.ts`，导入所需模块并创建一个新的 `Router` 实例以定义一些路由：

```ts title="api/main.ts"
import { Application, Router } from "@oak/oak";
import { oakCors } from "@tajpouria/cors";
import routeStaticFilesFrom from "./util/routeStaticFilesFrom.ts";
import data from "./data.json" with { type: "json" };

export const app = new Application();
const router = new Router();
```

随后，在同一文件中，我们将定义两个路由。一个是 `/api/dinosaurs` 返回所有恐龙，另一个是 `/api/dinosaurs/:dinosaur`，根据 URL 中的名称返回特定恐龙：

```ts title="api/main.ts"
router.get("/api/dinosaurs", (context) => {
  context.response.body = data;
});

router.get("/api/dinosaurs/:dinosaur", (context) => {
  if (!context?.params?.dinosaur) {
    context.response.body = "未提供恐龙名称。";
  }

  const dinosaur = data.find((item) =>
    item.name.toLowerCase() === context.params.dinosaur.toLowerCase()
  );

  context.response.body = dinosaur ?? "未找到该恐龙。";
});
```

在同一文件底部，将我们刚定义的路由挂载到应用程序。我们还必须包括静态文件服务器，最后启动服务器监听 8000 端口：

```ts title="api/main.ts"
app.use(oakCors());
app.use(router.routes());
app.use(router.allowedMethods());
app.use(routeStaticFilesFrom([
  `${Deno.cwd()}/dist`,
  `${Deno.cwd()}/public`,
]));

if (import.meta.main) {
  console.log("服务器监听端口 http://localhost:8000");
  await app.listen({ port: 8000 });
}
```

你还需要创建 `api/util/routeStaticFilesFrom.ts` 文件来服务静态文件：

```ts title="api/util/routeStaticFilesFrom.ts"
import { Context, Next } from "@oak/oak";

// 配置静态站点路由，以便我们可以服务
// Vite 构建输出和 public 文件夹
export default function routeStaticFilesFrom(staticPaths: string[]) {
  return async (context: Context<Record<string, object>>, next: Next) => {
    for (const path of staticPaths) {
      try {
        await context.send({ root: path, index: "index.html" });
        return;
      } catch {
        continue;
      }
    }

    await next();
  };
}
```

你可以使用命令 `deno run --allow-env --allow-net --allow-read api/main.ts` 运行 API 服务器。我们将创建一个任务来在后台运行此命令，并更新 dev 任务以同时运行 Vue 应用和 API 服务器。

更新你的 `package.json` 脚本如下：

```json title="package.json"
{
  "scripts": {
    "dev": "deno task dev:api & deno task dev:vite",
    "dev:api": "deno run --allow-env --allow-net api/main.ts",
    "dev:vite": "deno run -A npm:vite",
    "build": "deno run -A npm:vite build",
    "server:start": "deno run -A --watch ./api/main.ts",
    "serve": "deno run build && deno run server:start",
    "preview": "vite preview"
  }
}
```

确保你的 `vite.config.ts` 包含 Deno 插件和开发代理配置：

```ts title="vite.config.ts"
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import deno from "@deno/vite-plugin";

export default defineConfig({
  server: {
    port: 3000,
    proxy: {
      "/api": {
        target: "http://localhost:8000",
        changeOrigin: true,
      },
    },
  },
  plugins: [vue(), deno()],
  optimizeDeps: {
    include: ["react/jsx-runtime"],
  },
});
```

如果你现在运行 `npm run dev` 并访问浏览器的 `localhost:8000/api/dinosaurs`，应该能看到所有恐龙的 JSON 响应。

## 构建前端

### 入口点和路由

在 `src` 目录中，你会找到一个 `main.ts` 文件。这是 Vue.js 应用的入口点。我们的应用将有多个路由，因此需要一个路由器来处理客户端的路由。我们将使用官方的 [Vue Router](https://router.vuejs.org/)。

更新 `src/main.ts`，导入并使用路由器：

```ts
import { createApp } from "vue";
import router from "./router/index.ts";

import "./style.css";
import App from "./App.vue";

createApp(App)
  .use(router)
  .mount("#app");
```

通过更新 `deno.json` 中的导入路径，将 Vue Router 模块添加到项目中：

```json title="deno.json"
{
  "imports": {
    "@oak/oak": "jsr:@oak/oak@^17.1.5",
    "@tajpouria/cors": "jsr:@tajpouria/cors@^1.2.1",
    "vue-router": "npm:vue-router@^4.5.1"
  }
}
```

接着，在 `src` 目录中创建 `router` 文件夹，并在其中创建 `index.ts` 文件，内容如下：

```ts title="router/index.ts"
import { createRouter, createWebHistory } from "vue-router";
import HomePage from "../components/HomePage.vue";
import Dinosaur from "../components/Dinosaur.vue";

export default createRouter({
  history: createWebHistory("/"),
  routes: [
    {
      path: "/",
      name: "Home",
      component: HomePage,
    },
    {
      path: "/:dinosaur",
      name: "Dinosaur",
      component: Dinosaur,
      props: true,
    },
  ],
});
```

这将创建一个包含两个路由的路由器：`/` 和 `/:dinosaur`。`HomePage` 组件渲染于 `/` 路径，`Dinosaur` 组件渲染于 `/:dinosaur` 路径。

最后，删除 `src/App.vue` 文件中的全部内容，仅保留 `<RouterView>` 组件：

```html title="App.vue"
<template>
  <RouterView />
</template>
```

### 组件

Vue.js 将前端 UI 分解为多个组件。每个组件是一个可复用的代码片段。我们将创建三个组件：主页组件、恐龙列表组件和单个恐龙组件。

每个组件文件由三部分组成：`<script>`、`<template>` 和 `<style>`。`<script>` 标签包含该组件的 JavaScript 逻辑，`<template>` 包含 HTML 结构，`<style>` 包含 CSS 样式。

在 `/src/components` 目录中，创建三个新文件：`HomePage.vue`、`Dinosaurs.vue` 和 `Dinosaur.vue`。

#### Dinosaurs 组件

`Dinosaurs` 组件将从之前搭建的 API 获取恐龙列表，并使用
[Vue Router 的 `RouterLink` 组件](https://router.vuejs.org/guide/)将它们渲染为链接。
（鉴于我们使用的是 TypeScript，不要忘记在 `<script>` 标签中添加 `lang="ts"`。）

将以下代码添加到 `Dinosaurs.vue` 文件：

```html title="Dinosaurs.vue"
<script lang="ts">
  import { defineComponent } from "vue";

  export default defineComponent({
    async setup() {
      const res = await fetch("/api/dinosaurs");
      const dinosaurs = await res.json() as Dinosaur[];
      return { dinosaurs };
    },
  });
</script>

<template>
  <span v-for="dinosaur in dinosaurs" :key="dinosaur.name">
    <RouterLink
      :to="{ name: 'Dinosaur', params: { dinosaur: `${dinosaur.name.toLowerCase()}` } }"
    >
      {{ dinosaur.name }}
    </RouterLink>
  </span>
</template>
```

此代码使用 Vue.js 的 
[v-for](https://vuejs.org/api/built-in-directives.html#v-for) 指令遍历 `dinosaurs` 数组，将每个恐龙渲染为一个 `RouterLink` 组件。`RouterLink` 的 `:to` 属性定义点击时导航的路由，`:key` 用于唯一标识每个恐龙。

#### HomePage 组件

主页组件将显示一个标题，并渲染 `Dinosaurs` 组件。将以下代码加入 `HomePage.vue`：

```html title="HomePage.vue"
<script setup lang="ts">
  import Dinosaurs from "./Dinosaurs.vue";
</script>
<template>
  <h1>欢迎来到恐龙应用！🦕</h1>
  <p>点击一个恐龙以了解更多信息</p>
  <Suspense>
    <template #default>
      <Dinosaurs />
    </template>
    <template #fallback>
      <div>加载中...</div>
    </template>
  </Suspense>
</template>
```

由于 `Dinosaurs` 组件是异步获取数据，采用 
[`Suspense` 组件](https://vuejs.org/guide/built-ins/suspense.html) 来处理加载状态。

#### Dinosaur 组件

`Dinosaur` 组件会显示特定恐龙的名称和描述，并提供返回完整列表的链接。

首先，为即将获取的数据定义类型。在 `src` 目录中创建 `types.ts` 文件，添加以下内容：

```ts title="types.ts"
type Dinosaur = {
  name: string;
  description: string;
};

type ComponentData = {
  dinosaurDetails: null | Dinosaur;
};
```

接着，更新 `Dinosaur.vue` 文件：

```html title="Dinosaur.vue"
<script lang="ts">
  import { defineComponent } from "vue";

  export default defineComponent({
    props: { dinosaur: String },
    data(): ComponentData {
      return {
        dinosaurDetails: null,
      };
    },
    async mounted() {
      const res = await fetch(
        `/api/dinosaurs/${this.dinosaur}`,
      );
      this.dinosaurDetails = await res.json();
    },
  });
</script>

<template>
  <h1>{{ dinosaurDetails?.name }}</h1>
  <p>{{ dinosaurDetails?.description }}</p>
  <RouterLink to="/">🠠 返回所有恐龙</RouterLink>
</template>
```

此代码通过 `props` 定义名为 `dinosaur` 的属性传入组件。`mounted` 生命周期钩子根据 `dinosaur` prop 异步获取特定恐龙的详细信息，存储在 `dinosaurDetails` 数据属性中，随后在模板中渲染。

## 运行应用

现在我们已经配置好了前端和后端，可以运行应用。在终端执行：

```shell
npm run dev
```

这将同时启动端口 8000 上的 Deno API 服务器和端口 3000 上的 Vite 开发服务器。Vite 服务器将代理 API 请求到 Deno 服务器。

在浏览器中访问 `http://localhost:3000` 查看应用。点击某个恐龙以查看它的详情！

你也可以在 [Deno Deploy](https://tutorial-with-vue.deno.deno.net/) 查看应用的实时版本。

[Vue 应用演示](./images/how-to/vue/vue.gif)

```shell
deno run serve
```

此命令将构建 Vue 应用，并通过 Deno 服务器在端口 8000 提供服务。

## 构建与部署

我们已设置了 `serve` 任务，使用 Oak 后端服务器构建并提供 Vue 应用。运行以下命令以生产模式构建并提供应用：

```sh
deno run build
deno run serve
```

这将：

1. 使用 Vite 构建 Vue 应用（输出到 `dist/` 目录）
2. 启动 Oak 服务器，同时提供 API 和已构建的 Vue 应用

在浏览器中访问 `localhost:8000` 查看生产版本的应用！

你可以将此应用部署到你喜欢的云服务。我们推荐使用
[Deno Deploy](https://deno.com/deploy) 以获得简单便捷的部署体验。你可以直接从 GitHub 部署，只需创建 GitHub 仓库并推送代码，然后连接到 Deno Deploy。

### 创建 GitHub 仓库

[创建一个新的 GitHub 仓库](https://github.com/new)，然后初始化并推送你的应用代码：

```sh
git init -b main
git remote add origin https://github.com/<你的_github_用户名>/<你的仓库名>.git
git add .
git commit -am '我的 Vue 应用'
git push -u origin main
```

### 部署到 Deno Deploy

当你的应用已上传至 GitHub，即可通过 Deno Deploy<sup>EA</sup> 仪表盘部署你的应用。
<a href="https://console.deno.com/" class="docs-cta deploy-cta deploy-button">部署我的应用</a>

有关部署应用的详细步骤，请参阅
[Deno Deploy 教程](/examples/deno_deploy_tutorial/)。

🦕 现在你已经可以使用 Vite 在 Deno 中运行 Vue 应用，准备好构建真实世界的应用了！

---

# Testing web apps

> A comprehensive guide to testing web applications with Deno

URL: https://docs.deno.com/examples/tutorials/web_testing


Deno is a JavaScript runtime that operates outside of the browser, as such, you
cannot directly manipulate the Document Object Model in Deno as you would in a
browser. However you can use a library like
[deno-dom](https://jsr.io/@b-fuze/deno-dom),
[JSDom](https://github.com/jsdom/jsdom) or
[LinkeDOM](https://www.npmjs.com/package/linkedom) to work with the DOM. This
tutorial will guide you through how to effectively test your web applications
using Deno.

## Testing UI components and DOM manipulation

Let's say you have a website that shows a uers's profile, you can set up a test
function to verify that the DOM element creation works correctly. This code sets
up a basic card element then tests whether the created DOM structure matches
what was expected.

```ts
import { assertEquals } from "jsr:@std/assert";
import { DOMParser, Element } from "jsr:@b-fuze/deno-dom";

// Component or function that manipulates the DOM
function createUserCard(user: { name: string; email: string }): Element {
  const doc = new DOMParser().parseFromString("<div></div>", "text/html")!;
  const card = doc.createElement("div");
  card.className = "user-card";

  const name = doc.createElement("h2");
  name.textContent = user.name;
  card.appendChild(name);

  const email = doc.createElement("p");
  email.textContent = user.email;
  email.className = "email";
  card.appendChild(email);

  return card;
}

Deno.test("DOM manipulation test", () => {
  // Create a test user
  const testUser = { name: "Test User", email: "test@example.com" };

  // Call the function
  const card = createUserCard(testUser);

  // Assert the DOM structure is correct
  assertEquals(card.className, "user-card");
  assertEquals(card.children.length, 2);
  assertEquals(card.querySelector("h2")?.textContent, "Test User");
  assertEquals(card.querySelector(".email")?.textContent, "test@example.com");
});
```

## Testing Event Handling

Web applications often handle user interactions through events. Here's how to
test event handlers. This code sets up a button that tracks its active/inactive
state and updates its appearance when clicked. The accompanying test verifies
the toggle functionality by creating a button, checking its initial state,
simulating clicks, and asserting that the button correctly updates its state
after each interaction:

```ts
import { DOMParser } from "jsr:@b-fuze/deno-dom";
import { assertEquals } from "jsr:@std/assert";

// Component with event handling
function createToggleButton(text: string) {
  const doc = new DOMParser().parseFromString("<div></div>", "text/html")!;
  const button = doc.createElement("button");

  button.textContent = text;
  button.dataset.active = "false";

  button.addEventListener("click", () => {
    const isActive = button.dataset.active === "true";
    button.dataset.active = isActive ? "false" : "true";
    button.classList.toggle("active", !isActive);
  });

  return button;
}

Deno.test("event handling test", () => {
  // Create button
  const button = createToggleButton("Toggle Me");

  // Initial state
  assertEquals(button.dataset.active, "false");
  assertEquals(button.classList.contains("active"), false);

  // Simulate click event
  button.dispatchEvent(new Event("click"));

  // Test after first click
  assertEquals(button.dataset.active, "true");
  assertEquals(button.classList.contains("active"), true);

  // Simulate another click
  button.dispatchEvent(new Event("click"));

  // Test after second click
  assertEquals(button.dataset.active, "false");
  assertEquals(button.classList.contains("active"), false);
});
```

## Testing Fetch Requests

Testing components that make network requests requires mocking the fetch API.

In the below example we will [mock](/examples/mocking_tutorial/) the `fetch` API
to test a function that retrieves user data from an external API. The test
creates a spy function that returns predefined responses based on the requested
URL, allowing you to test both successful requests and error handling without
making actual network calls:

```ts
import { assertSpyCalls, spy } from "jsr:@std/testing/mock";
import { assertEquals } from "jsr:@std/assert";

// Component that fetches data
async function fetchUserData(
  userId: string,
): Promise<{ name: string; email: string }> {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.status}`);
  }
  return await response.json();
}

Deno.test("fetch request test", async () => {
  // Mock fetch response
  const originalFetch = globalThis.fetch;

  const mockFetch = spy(async (input: RequestInfo | URL): Promise<Response> => {
    const url = input.toString();
    if (url === "https://api.example.com/users/123") {
      return new Response(
        JSON.stringify({ name: "John Doe", email: "john@example.com" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    }
    return new Response("Not found", { status: 404 });
  });

  // Replace global fetch with mock
  globalThis.fetch = mockFetch;

  try {
    // Call the function with a valid ID
    const userData = await fetchUserData("123");

    // Assert the results
    assertEquals(userData, { name: "John Doe", email: "john@example.com" });
    assertSpyCalls(mockFetch, 1);

    // Test error handling (optional)
    try {
      await fetchUserData("invalid");
      throw new Error("Should have thrown an error for invalid ID");
    } catch (error) {
      assertEquals((error as Error).message, "Failed to fetch user: 404");
    }

    assertSpyCalls(mockFetch, 2);
  } finally {
    // Restore the original fetch
    globalThis.fetch = originalFetch;
  }
});
```

## Using Testing Steps to set up and teardown

For complex tests, you can use steps to organize test logic into discrete
sections, making tests more readable and maintainable. Steps also enable better
isolation between different parts of your test. Using step naming you can
implement a setup and teardown of the test conditions.

```ts
import { DOMParser } from "jsr:@b-fuze/deno-dom";
import { assertEquals, assertExists } from "jsr:@std/assert";

Deno.test("complex web component test", async (t) => {
  const doc = new DOMParser().parseFromString(
    "<!DOCTYPE html><html></html>",
    "text/html",
  );
  const body = doc.createElement("body");
  const container = doc.createElement("div");
  body.appendChild(container);

  await t.step("initial rendering", () => {
    container.innerHTML = `<div id="app"></div>`;
    const app = container.querySelector("#app");
    assertExists(app);
    assertEquals(app.children.length, 0);
  });

  await t.step("adding content", () => {
    const app = container.querySelector("#app");
    assertExists(app);

    const header = doc.createElement("header");
    header.textContent = "My App";
    app.appendChild(header);

    assertEquals(app.children.length, 1);
    assertEquals(app.firstElementChild?.tagName.toLowerCase(), "header");
  });

  await t.step("responding to user input", () => {
    const app = container.querySelector("#app");
    assertExists(app);

    const button = doc.createElement("button");
    button.textContent = "Click me";
    button.id = "test-button";
    app.appendChild(button);

    let clickCount = 0;
    button.addEventListener("click", () => clickCount++);

    button.dispatchEvent(new Event("click"));
    button.dispatchEvent(new Event("click"));

    assertEquals(clickCount, 2);
  });

  await t.step("removing content", () => {
    const app = container.querySelector("#app");
    assertExists(app);

    const header = app.querySelector("header");
    assertExists(header);

    header.remove();
    assertEquals(app.children.length, 1); // Only the button should remain
  });
});
```

## Best Practices for Web Testing in Deno

1. Maintain isolation - Each test should be self-contained and not depend on
   other tests.

2. Use names to show intent - descriptive names for tests make it clear what is
   being tested and give more readable output in the console

3. Clean up after your tests - remove any DOM elements created during tests to
   prevent test pollution.

4. Mock external services (such as APIs) to make tests faster and more reliable.

5. Organize tests into logical steps using `t.step()` for complex components.

## Running Your Tests

Execute your tests with the Deno test command:

```bash
deno test
```

For web tests, you might need additional permissions:

```bash
deno test --allow-net --allow-read --allow-env
```

🦕 By following the patterns in this tutorial, you can write comprehensive tests
for your web applications that verify both functionality and user experience.

Remember that effective testing leads to more robust applications and helps
catch issues before they reach your users.


---

# 使用 Deno 构建字词查找应用

> A tutorial on creating a word search application with Deno. Learn how to build a web server, implement pattern matching, handle HTTP requests, and create an interactive web interface using Oak framework.

URL: https://docs.deno.com/examples/tutorials/word_finder


## 开始

在本教程中，我们将使用 Deno 创建一个简单的字词查找网页应用。
不需要有 Deno 的前置知识。

## 介绍

我们的字词查找应用将接受用户提供的模式字符串并
返回与该模式匹配的所有英语字典中的单词。模式
可以包括字母字符以及 `_` 和 `?`。`?` 可以代表
模式中不存在的任何字母。`_` 可以代表任何字母。

例如，模式 `c?t` 匹配 "cat" 和 "cut"。模式 `go?d`
匹配单词 "goad" 和 "gold"（但不匹配 "good"）。

![字词查找 UI](./images/word_finder.png)

## 构建视图

下面的函数渲染 HTML 以创建上面显示的简单用户界面。
您可以指定模式和单词列表以自定义 HTML 内容。如果指定了
模式，则它会出现在搜索文本框中。如果指定了单词列表，
则会渲染一个带有项目符号的单词列表。

```jsx title="render.js"
export function renderHtml(pattern, words) {
  let searchResultsContent = "";
  if (words.length > 0) {
    let wordList = "";
    for (const word of words) {
      wordList += `<li>${word}</li>`;
    }
    searchResultsContent = `
        <p id="search-result-count" data-count="${words.length}">找到的单词数量: ${words.length}</p>
        <ul id="search-result" name="search-results">
          ${wordList}
        </ul>
      `;
  }

  return `<html>
    <head>
        <title>Deno 字词查找器</title>
        <meta name="version" content="1.0" />
    </head>
    <body>
        <h1>Deno 字词查找器</h1>

        <form id="perform-search" name="perform-search" method="get" action="/api/search">
            <label for="search-text">搜索文本:</label>
            <input id="search-text" name="search-text" type="text" value="${pattern}" />
            <input type="submit" />
        </form>

        ${searchResultsContent}

        <h2>使用说明</h2>

        <p>
            输入一个单词，使用 _ 和 ? 来表示未知字符。使用 ? 代表包括那些未被使用的字母（可以将其视为“财富之轮”的占位符）。使用 _ 将找到包含任何字符的单词（无论它是否为“已揭示”）。
            <br />
            <br />
            例如，d__d 将返回:
            <ul>
                <li>dand</li>
                <li>daud</li>
                <li>dead</li>
                <li>deed</li>
                <li>dird</li>
                <li>dodd</li>
                <li>dowd</li>
                <li>duad</li>
                <li>dyad</li>
            </ul>
            <br />
            而 go?d 将返回:
            <ul>
                <li>goad</li>
                <li>gold</li>
            </ul>
        </p>
    </body>
  </html>
  `;
}
```

## 查询字典

我们还需要一个简单的搜索功能，它扫描字典并返回
所有与指定模式匹配的单词。下面的函数接受一个模式和
字典，并返回所有匹配的单词。

```jsx title="search.js"
export function search(pattern, dictionary) {
  // 创建一个正则表达式模式，排除单词中已有的字符
  let excludeRegex = "";
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern[i];
    if (c != "?" && c != "_") {
      excludeRegex += "^" + c;
    }
  }
  excludeRegex = "[" + excludeRegex + "]";

  // 让问号仅匹配未在单词中出现的字符
  let searchPattern = pattern.replace(/\?/g, excludeRegex);

  // 让下划线匹配任何字符
  searchPattern = "^" + searchPattern.replace(/\_/g, "[a-z]") + "$";

  // 找到字典中所有匹配模式的单词
  let matches = [];
  for (let i = 0; i < dictionary.length; i++) {
    const word = dictionary[i];
    if (word.match(new RegExp(searchPattern))) {
      matches.push(word);
    }
  }

  return matches;
}
```

## 运行 Deno 服务器

[Oak](https://jsr.io/@oak/oak) is a framework that lets you easily setup a
server in Deno (analogous to JavaScript's Express) and we'll be using it to host
our application. Our server will use our search function to populate our HTML
template with data and then return the customized HTML back to the viewer. We
can conveniently rely on the `/usr/share/dict/words` file as our dictionary
which is a standard file present on most Unix-like operating systems.

```jsx title="server.js"
import { Application, Router } from "jsr:@oak/oak";
import { search } from "./search.js";
import { renderHtml } from "./render.js";

const dictionary = (await Deno.readTextFile("/usr/share/dict/words")).split(
  "\n",
);

const app = new Application();
const port = 8080;

const router = new Router();

router.get("/", async (ctx) => {
  ctx.response.body = renderHtml("", []);
});

router.get("/api/search", async (ctx) => {
  const pattern = ctx.request.url.searchParams.get("search-text");
  ctx.response.body = renderHtml(pattern, search(pattern, dictionary));
});

app.use(router.routes());
app.use(router.allowedMethods());

console.log("正在监听 http://localhost:" + port);
await app.listen({ port });
```

我们可以使用以下命令启动服务器。请注意，我们需要显式
授予对文件系统和网络的访问权限，因为 Deno 默认是安全的。

```bash
deno run --allow-read --allow-net server.js
```

现在如果您访问 [http://localhost:8080](http://localhost:8080/) 您应该能够查看字词查找应用。

## 示例代码

您可以在 [这里](https://github.com/awelm/deno-word-finder) 找到完整的示例代码。

---

# All-in-one tooling

> Learn about Deno's built-in developer tools. Watch how to use the integrated formatter, linter, and test runner to improve code quality without additional configuration or third-party dependencies.

URL: https://docs.deno.com/examples/videos/all-in-one_tooling


## Video description

In Node.js, before we can get started working on our project, we have to go
through a configuration step for things like linting, formatting, and testing.
Deno saves us a ton of time by including these tools natively. Let's take a look
at what's included with these built-in CLI tools.

## Transcript and code

Here we have a function called sing:

```javascript
function sing(phrase: string, times: number): string {
  return Array(times).fill(phrase).join(" ");
}
```

Now let's run the formatter:

```shell
deno fmt
```

The formatter automatically formats your code to follow Deno's rules and
conventions. Let's run it to clean up any formatting issues.

Deno even formats code snippets in markdown files. So anything that is enclosed
in triple backticks will be formatted when you run this command as well.

The deno lint command is used to analyze your code for potential issues. It’s
similar to ESLint but built into Deno.

```shell
deno lint --help
```

This will lint all of the JavaScript and TypeScript files in the current
directory and in subdirectories.

You can also lint specific files by passing their names

```shell
# lint specific files
deno lint myfile1.ts myfile2.ts
```

You can run it on specific directories

```shell
deno lint src/
```

And if you're feeling like you want to skip linting certain files, at the top of
the files, you can add a comment, and deno will know to skip this one.

```javascript
// deno-lint-ignore-file
// deno-lint-ignore-file -- reason for ignoring
```

Deno also has some CLI commands for testing. In our directory here we have a
test file. It uses the name of the function and test.

```javascript title="sing_test.ts"
import { sing } from "./sing.ts";
import { assertEquals } from "jsr:@std/assert";

Deno.test("sing repeats a phrase", () => {
  const result = sing("La", 3);
  assertEquals(result, "La La La");
});
```

Now, we’ll run our tests using the deno test command. Deno automatically
discovers and runs test files.

```shell
deno test
```

The way Deno decides which files should be considered test files is that it
follows:

`_test.ts`, `_test.js`, `_test.tsx`, `_test.jsx`, `.test.js`, `.test.ts`,
`.test.tsx`, `.test.jsx`

`deno test encourage.test.js`

Or you can pass a specific directory path and Deno will search for test files in
there.

```sh
./tests/
```

You can even check code coverage. By default, when you run deno test \--coverage
a coverage profile will be generated in the /coverage directory in the current
working directory.

```shell
deno test --coverage
```

From there you can run deno coverage to print a coverage report to standard
output

```shell
deno coverage
```

As you can see, Deno's built-in tools are pretty cool. We don't have to spend a
whole day configuring these settings before we can start working on our project.
And we can format, lint, and test code without the need for third-party
dependencies.


---

# Compatibility with Node & npm

URL: https://docs.deno.com/examples/videos/backward_compat_with_node_npm


## Video description

Explore how to integrate Deno into your existing Node.js projects seamlessly. In
this video, we'll use Node.js standard libraries and npm modules with simple
prefixes, maintain compatibility with CommonJS projects, and make use of Deno's
features like dependency installation, formatting, and linting. Make the
transition of your Node.js projects effortlessly without the need for major
rewrites.

## Transcript and code

Making the choice to use Deno does not mean that we can't take advantage of the
Node.js ecosystem. It also doesn't mean that we have to rebuild all of our
Node.js projects from scratch.

Using the features of the standard library, or the npm ecosystem, is as simple
as adding a prefix. If you want to learn more about the Node apis you can check
out [the Node API documentation](/api/node/).

Here's an example of Using Node's file system module with the promises API:

```typescript title="main.ts"
async function readFile() {
  try {
    const data = await fs.readFile("example.txt", "utf8");
    console.log(data);
  } catch (error) {
    console.error("Error reading file", error);
  }
}

readFile();
```

We read the file and we console log the data.

In node, we would import `fs` from `fs/promises` eg:

```typescript
import fs from "fs/promises";
```

In Deno, we just put the Node prefix in front of the import, eg:

```typescript
import fs from "node:fs/promises";
```

Then we run `deno main.ts` and opt into the "Running Deno with Node.js Built-in
read access".

If we run `deno main.ts` and allow
[read access](/runtime/fundamentals/security/) its going to read from the file.

Updating any imports in our apps to use this Node specifier will enable any code
using node.js built-ins.

Deno even supports CommonJS projects, which feels above and beyond I think
that's pretty cool!

What if we wanted to use an npm module, from say, Sentry, in our application.

We're going to use the **npm colon specifier** this time:

```typescript title="main.ts"
import * as Sentry from "npm:@sentry/node";

Sentry.init({ dsn: "https://example.com" });

function main() {
  try {
    throw new Error("This is an error");
  } catch (error) {
    Sentry.captureException(error);
    console.error("Error caught", error);
  }
}
```

We'll run the command:

```sh
deno run main.ts
```

Which will ask for access to our home directory, and other places, and there we
go! We are capturing this error as well! This backwards compatibility is pretty
amazing.

Are you working on an existing Node.js project? Well with Deno 2 you can do that
too. You can use `deno install` to install dependencies you can `deno fmt` for
formatting you can `deno lint` for linting we can even run `deno lint --fix` to
fix any linting problems automatically.

And yes you can also run Deno directly, so for any of the scripts that are part
of a `package.json` just run `deno task` with the name of the script, eg:

```sh
deno task dev
```

We can use all of the code that we've written before without having to change it
or stretch it too much, Deno just makes it work!


---

# Browser APIs in Deno

> Explore web standard APIs in Deno's server-side environment. Learn how to use fetch, streams, text encoders, and other browser-compatible features while building modern applications with familiar web APIs.

URL: https://docs.deno.com/examples/videos/browser_apis_in_deno


## Video description

Deno wants to give developers the most browser-like programming environment
possible. Deno uses web standard APIs, so if you're familiar with building for
the web, then you're familiar with Deno. If not, when you learn how to use deno,
you're also learning how to build for the web.

 If you take a look at the docs, it gives you a good sense of what's available,
so we got things like Canvas and internationalization and messaging and storage
and streams, temporal, WebSockets, all of those things that we like to use on
the web, we're going to find them built in to Deno.

## Transcript and code

Let's take a look at `fetch` first. This works like you might think.

 We're going to take a response. from fetching the JSON placeholder API. Then
we're going to take that response and convert it to JSON as a new variable and
console.log it. Now, if we take a look at this in the terminal, we'll say deno
allow network, so that we can opt into this running that fetch immediately.

```javascript title="main.ts"
const response = await fetch("https://snowtooth-hotel-api.fly.dev");
const data = await response.json();
console.log(data);
```

And we're done here. All the data comes back like we would expect.

```shell
deno add jsr:@std/streams
```

 So let me show you what I mean by this. We're going to keep that fetch. We're
going to say if that response body value exists, we're going to create a new
variable called transformed stream, and we'll set that equal to response dot
body. Thank you. And here we're going to use the function called pipe through.

And Pipe through is this method in JavaScript that's going to allow us to take
the output of the readable stream and pass it through to modify the stream's
data. The first thing we're going to do is decode the byte stream into a text
stream. So we'll say new text, decoder stream. Then we'll chain on another one
of these functions pipeThrough.

So this time we're going to split the text stream into lines. So we'll have
different lines coming back from our data. Now the text line stream is actually
coming from a library that we need to include.

```javascript
import { TextLineStream } from "@std/streams";
import { toTransformStream } from "@std/streams/to-transform-stream";

const response = await fetch("https://example.com/data.txt");

// Ensure the response body exists
if (response.body) {
  // Create a stream reader that processes the response body line by line
  const transformedStream = response.body
    // Decode the byte stream into a text stream
    .pipeThrough(new TextDecoderStream())
    // Split the text stream into lines
    .pipeThrough(new TextLineStream())
    // Get a reader to read the lines
    //.getReader();
    .pipeThrough(toTransformStream(async function* (src) {
      for await (const chunk of src) {
        if (chunk.trim().length === 0) {
          continue;
        }
        console.log(chunk);
        yield chunk;
      }
    }));
  // Create a reader to consume the transformed stream
  const reader = transformedStream.getReader();
  // Read and log each line of text from the stream
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    console.log(value); // Log each parsed JSON object
  }
}
```

## Setting Up Configuration

So we're going to say `deno add jsr@std/streams`. That will create our
`deno.json` configuration file over here. There will be another video to dig
into this in a little more depth, but just know for now that this is including
any imports that are part of our project. So the transform stream is coming
together, but there's a few more steps.

## Using the Transform Stream

The next step is we use pipeThrough again. Now this time we're going to use
another function to transform stream, and this is going to come from standard
streams and specifically the function `toTransformStream`. Now this time we're
going to pass in here an asynchronous generator. We know that it's a generator
because we use that asterisk there and the body of this function is a loop, and
here we're going to say const chunk, so the little blob of data that we're
dealing with, chunk of source, which is the value that's passed in there.

We're going to say `console.log(chunk)`, and we're also going to yield the chunk
here. Okay, so what is this `console.log` doing for us? Let's go ahead and run
`deno --allow-net main.ts`. This is showing us that this is the top line of our
HTML document.

So we actually need a way to iterate through this, and we're going to do this by
creating a reader to consume this transformed stream. So let's get rid of our
console log here. Here we're going to create a value called reader that's going
to be set equal to `transformedStream.getReader()`. Now from here, what we can
do is create a little while loop here. So while that value is true.

We want to destructure `{value, done}` from `await reader.read()`. So again, we
can call the `.read()` method on that reader. Then we're going to say if `done`
is true, then we want to break out of the loop. Otherwise, we want to
`console.log(value)`.

Nice. So now we're going to see our HTML here printed line by line in our
console.

 All right, so that is a quick example of using our text line stream. We can use
it in combination with fetch. And if you want to learn more about this API, you
can check out the documentation here. Deno offers us a truly browser-like
environment for using things like fetch, Web Workers, and much, much more.

Deno has made it really smooth to use these web-standard APIs in a way that
feels familiar and friendly.


---

# Build an API server with TypeScript

> A guide to creating a RESTful API server using Hono and TypeScript in Deno. Watch how to implement CRUD operations, handle routing, manage data persistence, and build a production-ready backend service.

URL: https://docs.deno.com/examples/videos/build_api_server_ts


## Video description

Use the light-weight Hono framework (spiritual successor to Express) to build a
RESTful API server that supports CRUD operations with a database.

## Transcript and code

If you’ve worked on a Node project in the past, you might have used Express to
set up a web server or to host an API. Let’s take a look at how we might do
something similar by using Hono, a small simple framework that we can use with
any runtime, but we’re going to use it with Deno. Basic Hono Setup

We’ll add Hono to our project with [JSR](https://jsr.io):

```shell
deno add jsr:@hono/hono
```

That will then be added to the deno.json file.

Then in our main file, we’ll create the basic Hono setup.

```ts
import { Hono } from "@hono/hono";

const app = new Hono();

app.get("/", (c) => {
  return c.text("Hello from the Trees!");
});

Deno.serve(app.fetch);
```

Let’s run that `deno run --allow-net main.ts` and we’ll see it in the browser at
`localhost:8000`.

## CRUD Operations

Now that we’ve set up the simple server with Hono, we can start to build out our
database.

We’re going to use localStorage for this, but keep in mind that you can use any
persistent data storage with Deno - postgres, sql - Wherever you like to store
your data.

Let’s start by creating a container for some data. We’ll start with an interface
that describes a tree type:

```ts
interface Tree {
  id: string;
  species: string;
  age: number;
  location: string;
}
```

Then we’ll create some data:

```ts
const oak: Tree = {
  id: "3",
  species: "oak",
  age: 3,
  location: "Jim's Park",
};
```

Then we’re going to create a few helper functions that will help us interact
with localStorage:

```ts
const setItem = (key: string, value: Tree) => {
  localStorage.setItem(key, JSON.stringify(value));
};

const getItem = (key: string): Tree | null => {
  const item = localStorage.getItem(key);
  return item ? JSON.parse(item) : null;
};
```

Now let’s use them:

```ts
setItem(`trees_${oak.id}`, oak);
const newTree = getItem(`trees_${oak.id}`);
console.log(newTree);
```

```shell
deno --allow-net main.ts
```

- `setItem` is adding the tree
- You can also use `setItem` to update the record -- if the key already exists
  the value will be updated

```ts
const oak: Tree = {
  id: "3",
  species: "oak",
  age: 4,
  location: "Jim's Park",
};

localStorage.setItem(`trees_${oak.id}`, JSON.stringify(oak));
```

Ok, so now let’s use Hono’s routing to create some REST API routes now that we
understand how to work with these database methods:

```ts
app.post("/trees", async (c) => {
  const { id, species, age, location } = await c.req.json();
  const tree: Tree = { id, species, age, location };
  setItem(`trees_${id}`, tree);
  return c.json({
    message: `We just added a ${species} tree!`,
  });
});
```

To test this out we’ll send a curl request:

```shell
curl -X POST http://localhost:8000/trees \
  -H "Content-Type: application/json" \
  -d '{"id": "2", "species": "Willow", "age": 100, "location": "Juniper Park"}'
```

To prove that we created that tree, let’s get the data by its ID:

```ts
app.get("/trees/:id", async (c) => {
  const id = c.req.param("id");
  const tree = await kv.get(["trees", id]);
  if (!tree.value) {
    return c.json({ message: "Tree not found" }, 404);
  }
  return c.json(tree.value);
});
```

To test that, let’s run a curl request for the data

```shell
curl http://localhost:8000/trees/1
```

Or you can go to it in the browser: `http://localhost:8000/trees/1`

We can update a tree of course. Kind of like before but we’ll create a route for
that:

```ts
app.put("/trees/:id", (c) => {
  const id = c.req.param("id");
  const { species, age, location } = c.req.json();
  const updatedTree: Tree = { id, species, age, location };
  setItem(`trees_${id}`, updatedTree);
  return c.json({
    message: `Tree has relocated to ${location}!`,
  });
});
```

And we’ll change the location because we’re going to PUT this tree somewhere
else:

```shell
curl -X PUT http://localhost:8000/trees/1 \
  -H "Content-Type: application/json" \
  -d '{"species": "Oak", "age": 8, "location": "Theft Park"}'
```

Finally if we wanted to delete a tree we can using the Hono delete function.

```ts
const deleteItem = (key: string) => {
  localStorage.removeItem(key);
};

app.delete("/trees/:id", (c) => {
  const id = c.req.param("id");
  deleteItem(`trees_${id}`);
  return c.json({
    message: `Tree ${id} has been cut down!`,
  });
});
```

We’ve used Deno in combination with Hono to build a little REST API for our tree
data. If we wanted to deploy this, we could and we could deploy with zero config
to [Deno deploy](https://deno.com/deploy).

You can deploy this to any cloud VPS like AWS, GCP, Digital Ocean, with the
[official Docker image](https://github.com/denoland/deno_docker)

## Complete code sample

```ts
import { Hono } from "@hono/hono";

const app = new Hono();

interface Tree {
  id: string;
  species: string;
  age: number;
  location: string;
}

const setItem = (key: string, value: Tree) => {
  localStorage.setItem(key, JSON.stringify(value));
};

const getItem = (key: string): Tree | null => {
  const item = localStorage.getItem(key);
  return item ? JSON.parse(item) : null;
};

const deleteItem = (key: string) => {
  localStorage.removeItem(key);
};

const oak: Tree = {
  id: "3",
  species: "oak",
  age: 3,
  location: "Jim's Park",
};

setItem(`trees_${oak.id}`, oak);
const newTree = getItem(`trees_${oak.id}`);
console.log(newTree);

app.get("/", (c) => {
  return c.text("Hello from the Trees!");
});

app.post("/trees", async (c) => {
  const { id, species, age, location } = await c.req.json();
  const tree: Tree = { id, species, age, location };
  setItem(`trees_${id}`, tree);
  return c.json({
    message: `We just added a ${species} tree!`,
  });
});

app.get("/trees/:id", async (c) => {
  const id = await c.req.param("id");
  const tree = getItem(`trees_${id}`);
  if (!tree) {
    return c.json({ message: "Tree not found" }, 404);
  }
  return c.json(tree);
});

app.put("/trees/:id", async (c) => {
  const id = c.req.param("id");
  const { species, age, location } = await c.req.json();
  const updatedTree: Tree = { id, species, age, location };
  setItem(`trees_${id}`, updatedTree);
  return c.json({
    message: `Tree has relocated to ${location}!`,
  });
});

app.delete("/trees/:id", (c) => {
  const id = c.req.param("id");
  deleteItem(`trees_${id}`);
  return c.json({
    message: `Tree ${id} has been cut down!`,
  });
});

Deno.serve(app.fetch);
```


---

# 字节和文本导入

URL: https://docs.deno.com/examples/videos/byte_and_text_imports


## 视频描述

Deno 团队的 David 向你展示如何导入字节和文本文件，让你能够将它们包含在模块图中，以实现自动摇树优化等功能。

---

# Build a Command Line Utility

URL: https://docs.deno.com/examples/videos/command_line_utility


## Video description

Learn to build a command line tool using Deno's standard library. You'll explore
how to parse arguments, handle flags, and provide helpful messages using utility
functions. Follow along as we build a ski resort information app, handle errors
gracefully, and compile the script into an executable for multiple platforms,
including Windows, MacOS, and Linux. By the end of this video, you'll understand
how to take full advantage of Deno's features to develop and distribute your own
CLI tools.

## Transcript and code

### An introduction to Deno's Standard Library

If you want to create a command line tool you can do so with
[Deno's standard Library](https://docs.deno.com/runtime/fundamentals/standard_library/).
It contains dozens of stable libraries with helpful utility functions that can
cover a lot of the basics when working with JavaScript in the web. The standard
Library also works in multiple runtimes and environments like Node.js and the
browser.

### Setting up a command line tool

We're going to create a commandline tool, and then we're going to compile it so
it can be used on a number of different platforms as an executable.

Create a new file called `main.ts` and parse these arguments (remember we can
always grab them from `Deno.args`), and then we'll console log them:

```typescript title="main.ts"
const location = Deno.args[0];

console.log(`Welcome to ${location}`);
```

Now if I run `deno main.ts` and then I provide the name of a ski resort like
Aspen that's going to plug that into the string, eg:

```sh
deno main.ts Aspen
## Welcome to Aspen
```

### Installing and Using Standard Libraries

Now lets install one of those standard libraries. In the terminal run:

```sh
deno add jsr:@std/cli
```

This is going to install the [cli library](https://jsr.io/@std/cli), from the
Deno standard library, into our project so we could make use of some of their
helpful functions.

The Helpful function that we'll use here is called `parseArgs`. We can import
that with:

```typescript
import { parseArgs } from "jsr:@std/cli/parse-args";
```

Then we can update our code to use this function, passing the argument and
removing the zero. Our `main.ts` file now looks like this:

```typescript title="main.ts"
import { parseArgs } from "jsr:@std/cli/parse-args";

const args = parseArgs(Deno.args);

console.log(args);
```

Let's go ahead and try this out, in your terminal run:

```sh
deno main.ts -h Hello
```

We can see that `Hello` has been added to our args object. All right, so that's
working as expected.

### Building the Ski Resort Information App

Now our app is going to be a ski resort information app, so we want to populate
our app with a little bit of data to start. We're going to create a value called
`resorts`. This is an object with a few different keys so we'll say `elevation`,
`snow` and `expectedSnowfall`. Then let's just copy and paste these so that we
can move a little more quickly we'll set `Aspen` to `7945` `snow` to
`packed powder`, `expectedSnowfall` to `15`. Then let's add one more of these
we'll set `Vail` to `8120` and then we'll say `expectedSnowfall` is `25`.

```typescript title="main.ts"
const resorts = {
  Whistler: {
    elevation: 2214,
    snow: "Powder",
    expectedSnowfall: "20",
  },

  Aspen: {
    elevation: 7945,
    snow: "packed powder",
    expectedSnowfall: 15,
  },
  Vail: {
    elevation: 8120,
    snow: "packed powder",
    expectedSnowfall: 25,
  },
};
```

We have a few different resorts here. Ultimately we want to be able to run our
app with a command line argument that's going to provide the resort name and
then have that CLI tool return the information about that resort.

### Handling Command Line Arguments

So let's go ahead and pass another object to parse args, here we're going to
define an alias - so we're going to say "if I pass the `r` flag we want to have
it assume it means `resort`. Then let's also use the default here, we'll set the
`default` `resort` to `Whistler`:

```typescript title="main.ts"
const args = parseArgs(Deno.args, {
  alias: {
    resort: "r",
  },
  default: {
    resort: "Whistler",
  },
});
```

From here we can set up a const called `resortName` and set it to `args.resort`.
Then get the resort, with `resorts[resortName]` (we'll fix that type error in a
second), and update the console log:

```typescript title="main.ts"
const resortName = args.resort;
const resort = resorts[resortName];

console.log(
  `Resort: ${resortName} Elevation: ${resort.elevation} feet Snow: ${resort.snow} Expected Snowfall: ${resort.expectedSnowfall}`,
);
```

To test this out we can use:

```sh
deno main.ts -r Aspen
```

Which will give us a printout of all of Aspen's details.

We can also run this without any arguments which should give the details for
Whistler, because that was set as default:

```sh
deno main.ts
```

Same goes for our full name, so we could say:

```sh
deno main.ts --resort Veil
```

And that should give us those details as well.

### Improving Error Handling

Now if I tried to run this with a resort that's not there, let's say `Bachelor`;
there's an error so that's kind of an ugly one. It's hitting this moment where
it's trying to parse that out and it can't find it. So we could make this a
little nicer by saying if there's no `resort` in our data set that matches the
input, let's run a console error saying
`resort name not found, try Whistler Aspen or Veil` and then we'll hop out of
that process with a `Deno.exit`:

```typescript title="main.ts"
if (!resort) {
  console.error(
    `Resort ${resortName} name not found. Try Whistler, Aspen, or Veil`,
  );
  Deno.exit(1);
}
```

### Fixing the types

Okay so this here isn't looking so good we can look at the problems here in
typescript - it's telling us that this implicitly has an `any` type, you can
look up more about this error but I'll show you how to fix this one. Update the
type of `resortName` to be a key of `resorts`:

```typescript title="main.ts"
const resortName = args.resort as keyof typeof resorts;
```

What this has done is extract the value of `args.resort` and it's going to
assert that there is a valid key inside of the data.

### Adding Help and Color Output

Let's take this one more step, we're going to say if `args.help`, we will
console log and then we're going to give our users a little message to say "hey
this is actually how you use this" if they do happen to ask for help at any
moment, and we'll update the alias here to say `help` is `H`, finally we'll make
sure to call `Deno.exit` so that we jump out of the process as soon as we're
done with that:

```typescript title="main.ts"
const args = parseArgs(Deno.args, {
  alias: {
    resort: "r",
    help: "h",
  },
  default: {
    resort: "Whistler",
  },
});

...

if (args.help) {
  console.log(`
    usage: ski-cli --resort <resort name>
    -h, --help    Show Help
    -r, --resort  Name of the ski resort (default: Whistler)
  `);
  Deno.exit();
}
```

You can test your help setup by running the following:

```sh
deno main.ts -h
```

Next let's log our results here in color. Deno has support for CSS using the
`%C` syntax.

This will take the text and apply the style that we pass in as the second
argument to the `console.log()`. Here we could set `color:blue` as the second
argument, eg:

````typescript title="main.ts"
console.log(`
    %c
    Resort: ${resortName} 
    Elevation: ${resort.elevation} feet 
    Snow: ${resort.snow} 
    Expected Snowfall: ${resort.expectedSnowfall}
    `, "color:blue"
);

Then run the program again:

```sh
deno main.ts -r Veil
````

You should see everything logged in a blue color. How cool is that?!

### Compiling the Tool for Different Platforms

I want other people to be able to enjoy the app too. Compiling this tool into an
executable is pretty easy with Deno. As you might imagine, the command for
running this is `deno compile` and then the name of our script. This is going to
compile the code to the project as an executable:

```sh
deno compile main.ts
```

You should see the executable in your project folder called MyDenoProject. Now
you can run this as an executable with `./`, eg:

```sh
./MyDenoProject --resort Aspen
```

So this is really great for me, but what happens if I want to share this to
other platforms? All you would need to do is run `deno compile` again, this time
passing in a `--target` flag for where you want to compile to.

Let's say we wanted to compile it for Windows we'd use:

```sh
deno compile --target x86_64-pc-windows-msvc --output ski-cli-windows main.ts
```

or for a Mac:

```sh
deno compile --target x86_64-apple-darwin --output ski-cli-macos main.ts
```

or for Linux:

```sh
deno compile --target x86_64-unknown-linux-gnu --output ski-cli-linux main.ts
```

You can see all of the
[options for compiling your apps](/runtime/reference/cli/compile/) in the Deno
documentation. There are a lot of different flags that you can use for your own
specific use cases.

To recap we always have access to the Deno Standard Library that we can take
advantage of with all these different helpful functions. If we wanted to create
a command line utility, like we've done here, we always have access to the
[`Deno` global namespace](/api/deno/~/Deno) for these arguments. We can parse
the arguments using the parse args function from the standard Library CLI
package and we can run a compile for all platforms so that our app can be
consumed anywhere.


---

# 使用 Deno JSON 进行配置

URL: https://docs.deno.com/examples/videos/configuration_with_deno_json


## 视频说明

在本视频中，我们使用 deno.json 文件来管理您 Deno 项目中的依赖和配置。学习如何创建和配置像 'start' 和 'format' 这样的任务来简化您的工作流程。我们还将探索如何自定义格式化和代码检查规则，并理解导入映射的概念以实现更清晰的导入。然后我们将看看 Deno 的 deno.json 和 Node 的 package.json 之间的兼容性，从而实现无缝的项目集成。

## 文本记录和代码

### JSR 包管理简介

每次我们使用 JSR 安装包时，它都会被放入这个 `deno.json` 文件中作为一个导入。

```json title="deno.json"
{
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

### 创建和运行任务

所以，我们可以使用这个文件来管理我们的依赖，但我们也可以将它用于许多其他配置任务。具体来说，为了让我们快速开始，先配置一些实际的任务。我们将创建一个 `"start"` 任务。这个任务会运行 `deno --allow-net main.ts`。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts"
  },
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

所以，把它想象成运行命令的快捷方式。我们可以这样说：

```sh
deno task start
```

这会运行该命令，类似的，

```sh
deno run start
```

也可以用。

我们再添加一个任务，命名为 `"format"`。这个任务会结合两个操作，我们说 `deno fmt && deno lint`。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts",
    "format": "deno fmt && deno lint"
  },
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

现在运行

```sh
deno task format
```

这样它会帮我们运行所有操作。

### 格式化和代码检查配置

你也可以使用这个文件为这些命令设置配置项。比如说 `"fmt"` ，然后使用一些不同的规则，文档中关于格式化的部分[这里](/runtime/fundamentals/configuration/#formatting)有详细说明。你可以使用多种选项，比如我们设置 `"useTabs"` 为 `true` ，然后设置 `"lineWidth": 80`。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts",
    "format": "deno fmt && deno lint"
  },
  "fmt": {
    "useTabs": true,
    "lineWidth": 80
  },
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

现在运行

```sh
deno task format
```

这会带着这些规则运行全部格式化和代码检查。

代码检查你也可以设置。我们添加 `"lint"` 配置。这同样在文档中，紧接着格式化规则的文档[这里](/runtime/fundamentals/configuration/#linting)可以看到各种配置选项，根据你的项目需求进行配置。在这里，我们增加一个 `"rules"` 键，里面可以包含想要包含或排除的规则。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts",
    "format": "deno fmt && deno lint"
  },
  "lint": {
    "rules": {}
  },
  "fmt": {
    "useTabs": true,
    "lineWidth": 80
  },
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

假设代码里有

```typescript title="main.ts"
// @ts-ignore
import { sing } from "jsr:@eveporcello/sing";

console.log(sing("sun", 3));
```

这个规则会使得，如果我在文件顶部加上这条注释，在项目中的预期行为是让 TypeScript 忽略该文件中的类型检查，不管是否符合类型规则。但是如果我再运行

```sh
deno task format
```

它会告诉我：“嘿，你不能这样，你不能不带注释地忽略这些文件。” 这是规则的一部分。但我们知道有办法绕过这个限制，虽然有些人可能不想去避开规则，但我还是给大家演示一下。我们设置一个 `"exclude": ["ban-ts-comment"]`。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts",
    "format": "deno fmt && deno lint"
  },
  "lint": {
    "rules": {
      "exclude": ["ban-ts-comment"]
    }
  },
  "fmt": {
    "useTabs": true,
    "lineWidth": 80
  },
  "imports": {
    "@eveporcello/sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

然后运行

```sh
deno task format
```

这次就能顺利运行了，我们的 `// @ts-ignore` 就奏效了。

### 处理导入映射

在 `deno.json` 文件中还有一个导入映射的概念。现在我们导入的是 `"@eveporcello/sing"`，但也可以简写。比如直接用 `"sing"`。

```json title="deno.json"
{
  "tasks": {
    "start": "deno --allow-net main.ts",
    "format": "deno fmt && deno lint"
  },
  "lint": {
    "rules": {
      "exclude": ["ban-ts-comment"]
    }
  },
  "fmt": {
    "useTabs": true,
    "lineWidth": 80
  },
  "imports": {
    "sing": "jsr:@eveporcello/sing@^0.1.0"
  }
}
```

然后将代码换成只用 `"sing"`：

```typescript title="main.ts"
// @ts-ignore
import { sing } from "sing";

console.log(sing("sun", 3));
```

再运行

```sh
deno main.ts
```

它会按预期工作。这就是所谓的“裸模块标识符”，它是通过导入映射把这个特定依赖映射到该 JSR 包，允许我们写出干净简洁的导入。

如果想了解更多不同的配置选项，请查看文档[这里](/runtime/fundamentals/configuration/)关于配置。Deno 也支持 `package.json`，以兼容 Node.js 项目。如果在同一目录中同时存在 `deno.json` 和 `package.json`，Deno 会理解两个文件中指定的依赖。所以这里有很多选项可用，这对你在工作 Deno 项目中会非常有用。

---

# Benchmarking with Deno bench

> Learn how to measure code performance using Deno's built-in benchmarking tool. Discover baseline comparisons, grouped benchmarks, and precise measurement techniques for optimizing your TypeScript and JavaScript code.

URL: https://docs.deno.com/examples/videos/deno_bench


## Video description

[`deno bench`](/runtime/reference/cli/bench/) is an easy to use benchmarking
tool that ships with the Deno runtime. Here are 3 ways that can level up how you
use deno bench.

## Transcript and code

What's up everyone it's Andy from Deno and today we're going to talk about
`deno bench`. This video is a continuation of our **Deno tool chain** series.

`deno bench` is a benchmarking tool that makes it easy to measure performance,
and if you're coming from Node, `deno bench` saves you time from finding and
integrating a third party benchmarking tool.

### Baseline Summaries

Today we're going to cover some cool use cases with `deno bench`. Most of the
time we'll want to benchmark two or more ways of doing the same thing, here
we're comparing parsing a URL from a string, parsing a URL with a path, and then
also parsing a URL with a path and a URL object:

```typescript title="main_bench.ts"
Deno.bench("url parsing", () => {
  new URL("https://deno.land");
});

Deno.bench("url parsing with path", () => {
  new URL("./welcome.ts", "https://deno.land/");
});

const BASE_URL = new URL("https://deno.land");
Deno.bench("url parsing with a path and a URL object", () => {
  new URL("./welcome.ts", BASE_URL);
});
```

Then run:

```sh
deno bench main_bench.ts
```

The output results show how long it takes each benchmark in nano seconds, as
well as how many iterations per second. Not only that but also includes the CPU
chip and the runtime.

The results indicate that the first approach is the fastest. But what if you
want a more clear way to show exactly how much faster it is? We can pass the
`baseline:true` option into the Benchmark:

```typescript title="main_bench.ts"
Deno.bench("url parsing", { baseline: true }, () => {
  new URL("https://deno.land");
});

...etc
```

When we run it there is now a summary section at the bottom of the output that
shows you exactly how much faster the benchmarks are compared to the baseline.

If you want multiple benchmarks but in the same file you can organize the output
using the `group` option. If we add a fourth Benchmark for splitting text and
run the file we'll see all of the results grouped together, which isn't very
helpful. Instead we can add a group of `url` to the URL benchmarks and a group
of `text` to the text benchmarks:

```typescript title="main_bench.ts"
Deno.bench("url parsing", { baseline: true, group: "url" }, () => {
  new URL("https://deno.land");
});

...etc

const TEXT = "Lorem ipsum dolor sit amet";
Deno.bench("split on whitespace", { group: "text" }, () => {
  TEXT.split(" ");
});
```

Now you will see our results are organized by group.

### More specific benchmarking with `b.start()` and `b.end()`

Did you know that you can be specific about when to start and stop measuring
your benchmarks? Here's a new Benchmark file where we plan to benchmark parsing
the first word of the releases markdown file, which is all the release notes
from the Deno runtime project over the past 5 years. It's over 6,000 lines long!

```typescript title="file_bench.ts"
const FILENAME = "./Releases.md";

Deno.bench("get first word", () => {
  const file = Deno.readTextFileSync(FILENAME);
  const firstWord = file.split(" ")[0];
});
```

Running `deno bench` shows that this operation takes a long time, but it's
mostly because the benchmark requires reading the file in memory. So how do we
benchmark reading just the first word? If we use the `bench`
`context parameter`, we have access to the `start()` and `end()` functions.

```typescript title="file_bench.ts"
const FILENAME = "./Releases.md";

Deno.bench("get first word", (b) => {
  b.start();
  const file = Deno.readTextFileSync(FILENAME);
  const firstWord = file.split(" ")[0];
  b.end();
});
```

Now when we run `deno bench`, you'll notice that this benchmark only measures
the reading of the first word.

This was just a glimpse into `deno bench`, if you want to check out the other
options on Deno Bench check out the other options available to you, you can use
your editor to `ctrl+click` through to the bench definitions, or look at the
[`deno bench` documentation](/runtime/reference/cli/bench/). There are some
other options that you can pass such as
[`only`](/runtime/reference/cli/bench/#bench-definition-filtering) and
[`ignore`](/runtime/reference/cli/bench/#options-ignore).


---

# Deno 覆盖率

> Learn how to measure test coverage in Deno projects. Watch how to generate coverage reports, analyze code coverage metrics, and use the HTML report feature.

URL: https://docs.deno.com/examples/videos/deno_coverage


## 视频描述

我们在 1.39 版本中更新了 `deno coverage`，使其输出更好，并支持 HTML 生成。

## 摘要与代码

如果你正在使用 `deno test`，你是否查看过 `deno coverage`？

`deno coverage` 是查看测试覆盖率的好方法，只需将覆盖标志添加到 Deno 测试中：

```sh
deno test --coverage
```

这会将覆盖数据保存到 `/coverage`。然后运行覆盖命令：

```sh
deno coverage ./coverage
```

以查看覆盖报告。

在 Deno 1.39 中，`deno coverage` 有两个方面的更新；首先，它现在输出一个简洁的摘要表，其次，如果你添加 `--html` 标志：

```sh
deno coverage ./coverage --html
```

覆盖工具会生成静态 HTML，以便你可以在浏览器中查看你的覆盖率。

我们对 Deno 覆盖率还有更多的计划，比如将步骤简化为一个命令等。

---

# Your Deno Dev Environment

> Learn how to set up your Deno development environment. Watch how to install Deno, configure VS Code, enable type checking and autocomplete, and optimize your TypeScript development workflow.

URL: https://docs.deno.com/examples/videos/deno_dev_environment


## Video description

How to set up your development environment for Deno

## Transcript and code

To install Deno, we'll run curl. So we're going to grab this curl command
[from the documentation](https://docs.deno.com/runtime/getting_started/installation/).

```shell
curl -fsSL https://deno.land/install.sh | sh
```

We'll go to our terminal, we'll paste that in, hit enter, and this will install
Deno in the background to the most recent version. When I do this, it'll ask me
if I want to add Deno to the path. We'll go ahead and say yes, and you can add
these setup completions here.

And now we have installed this to our path. If you're on Windows, there are
installation instructions for you here in the documentation.

To generate a Deno project from scratch, let's go ahead and type
`deno init MyDenoProject`. This is going to create that folder for me. I can
then cd into that folder. Now if we open this up in VSCode, this has created a
`deno.json` file, a `main_test.ts` file, and a `main.ts` file. So this is a
quick way of getting started.

If you're using VSCode, there are a few configuration options that you'll want
to set up. So we'll go up here to code and settings. We'll select extensions. So
over here in your extensions, you're going to search for Deno, and then we'll
[select the one that has been created by Denoland here](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno).

```javascript
{
  "deno.enable": true,
}
```

We're going to run install, and this will install our Deno land extension. Next
we'll type `command shift P`. This will open up our command palette here, and we
can type `deno initialize workspace configuration`. We're going to go ahead and
click that. That's going to generate this VSCode folder with settings. This is
going to enable hints and autocomplete and all of that right here in the code
editor. So if I start to type anything from `deno serve`, for example, that's
going to give me a look at what the expected parameters of that function are.
That's very helpful.

This is also going to give us hints when importing. So we'll say import star as
path from JSR at standard slash path.

```javascript
import * as path from "jsr:@std/path";
```

So all of them are listed there. Pretty cool. And then if we wanted to do
something for a remote module, something like OpenAI from
[https://deno.land/x/openai@v4.67.1/mod.ts](https://deno.land/x/openai@v4.67.1/mod.ts)
(or now, even better, from [JSR](https://jsr.io/@openai/openai))

```javascript
import OpenAI from "jsr:@openai/openai";
```

This is then going to give us the standard library as well as X for all of those
third party APIs. So you can actually drill down into OpenAI from here. You just
need to select the version, so we'll say OpenAI at v461. And then you can even
drill down into that individual file.

If you take a look at
[the documentation
here, this will guide you through the process of setting up your own unique
environment](/runtime/getting_started/setup_your_environment/). There are
[shell completions](/runtime/getting_started/setup_your_environment/#shell-completions)
that you can add, so depending on which CLI tool you're using, you can set this
up over here, whether it's Bash or PowerShell or ZShell or whatever it might be.


---

# 使用 Deno fmt 进行格式化

URL: https://docs.deno.com/examples/videos/deno_fmt


## 视频描述

一个快速的提示和技巧集，关于
[Deno 内置格式化工具 `deno fmt`](/runtime/reference/cli/fmt/)。

大家好，我是来自 Deno 的 Andy，回到 **Deno 工具链系列** 的另一集，在这里我们深入探讨 Deno 的子命令。

今天我们将看看 `deno fmt`，我们的内置格式化工具，它是可定制的、性能优越并且灵活到适应任何工作流。让我们直接开始吧。

### 什么是 `deno fmt`？

`deno fmt` 将格式化以下文件扩展名：

- `.js`
- `.jsx`
- `.ts`
- `.tsx`
- `.json`
- `.jsonc`
- `.md`
- `.markdown`

使用 `deno fmt` 的最简单方法是从命令行运行它：

```sh
deno fmt
```

你甚至可以将字符串或文件输入到它：

```sh
echo ' console.log(    5  );' | deno fmt -
## console.log(5);
```

你还可以使用 `--check` 标志，它将检查你的代码是否被 `deno fmt` 格式化。如果没有格式化，它将返回一个非零的退出代码：

```sh
echo ' console.log(    5  );' | deno fmt --check -
## Not formatted stdin
```

这在 CI 中非常有用，当你想检查代码是否正确格式化时。

### 编辑器集成

`deno fmt` 也可以在你的编辑器中使用，比如 VS Code。可以在编辑器设置中将 `deno fmt` 设置为默认格式化工具，例如在 VS Code 中：

```json title=".vscode/settings.json"
{
  "editor.defaultFormatter": "denoland.vscode-deno",
  "editor.formatOnSave": true
}
```

你也可以设置保存时自动格式化为 true。

### 多种格式化方式

在某些情况下，有多种格式化方式，并且 Deno 允许你决定想要如何格式化。例如，一个对象可以水平或垂直格式化，这取决于你将第一个项放置在哪里。例如：

```typescript
const foo = { bar: "baz", qux: "quux" };

// 或者

const foo = {
  bar: "baz",
  qux: "quux",
};
```

数组也是如此。你可以根据第一个项的位置选择水平或垂直格式化。例如：

```typescript
const foo = ["bar", "baz", "qux"];

// 或者

const foo = [
  "bar",
  "baz",
  "qux",
];
```

### 移除转义引号

`deno fmt` 还可以减少字符串中的转义字符。例如， 如果你有一个包含转义引号的字符串，`deno fmt` 将移除它们：

<!-- deno-fmt-ignore-start -->
```typescript
console.log("hello \"world\"");
```
<!-- deno-fmt-ignore-end -->

将会格式化为：

```typescript
console.log('hello "world"');
```

### 忽略行或文件

如果你想让 `deno fmt` 跳过一行或一个文件怎么办？你可以使用 `//deno-fmt-ignore` 注释来告诉 `deno fmt` 跳过下一行，例如：

```typescript
console.log("This   line    will  be  formatted");

// deno-fmt-ignore
console.log("This   line  will  not be    formatted");
```

要让 `deno fmt` 跳过一个文件，可以在文件顶部使用 `// deno-fmt-ignore-file` 注释来忽略它。或者，你可以在你的 `deno.json` 配置文件的 `fmt` 字段下使用：

```json
{
  "fmt": {
    "exclude": ["main.ts", "*.json"]
  }
}
```

### 格式化 markdown

`deno fmt` 也适用于 markdown 文件。你可以选择如何格式化散文，通过将选项 `"proseWrap"` 设置为 `always`、`never` 或 `preserve`，例如：

```json
{
  "fmt": {
    "proseWrap": "always"
  }
}
```

如果你用两个 `1` 开始编号列表，`deno fmt` 也可以格式化带有编号的列表，例如：

```markdown title="list.md"
1. First
1. Second
1. Third
1. Fourth
1. Fifth
```

格式化工具将自动将列表格式化为所有的 `1`，但当你渲染它时，它会正确显示编号列表！

如果这样做很奇怪，你也可以先写下 `1` 然后写下 `2`，运行 `deno fmt`，这样将会为你正确编号其余的列表。

`deno fmt` 也会格式化你 markdown 中的 JavaScript 和 TypeScript 代码块。它甚至可以在 markdown 中格式化 markdown！

### 格式化选项

让我们看看
[在 `deno fmt` 中可用的所有选项](/runtime/reference/cli/fmt/#formatting-options)。
注意，所有这些选项在 CLI 中都有相应的标志。

```json
{
  "fmt": {
    "useTabs": true,
    "lineWidth": 80,
    "indentWidth": 2,
    "semiColons": false,
    "singleQuote": true,
    "proseWrap": "always",
    "exclude": ["**/logs.json"]
  }
}
```

- `--use-tabs`
- `--line-width <line-width>`
- `--indent-width <indent-width>`
- `--no-semicolons`
- `--single-quote`
- `--prose-wrap <prose-wrap>`
- `--ignore=<ignore>`

### `deno fmt` 的性能

`deno fmt` 非常快，尤其是在随后的运行中由于缓存，默认启用缓存。下面是我们对 Deno 标准库进行的第一次运行。让我们再运行一次！系统时间显示第二次运行快了三分之一。如果我们更新文件并再次运行，依然很快，因为 `deno fmt` 只检查更改的文件。让我们将其与 `Prettier`（一款流行的 Node 格式化工具）进行比较，我们将启用缓存标志运行 Prettier。即便是在第二次运行时，`deno fmt` 的速度几乎快了 20 倍！

---

# Getting started with Deno test

URL: https://docs.deno.com/examples/videos/deno_test



---

# Deploy Deno to AWS Lambda

URL: https://docs.deno.com/examples/videos/deploy_deno_to_aws_lambda


## Video description

Show how to deploy Deno applications to AWS Lambda (using a community runtime
for Lambda).

## Transcript and code

### Run Deno on AWS Lambda

Running Deno on AWS Lambda? Sure, you can do that. With AWS lambda the
serverless pricing can be cheaper than a VPS and can be easier to maintain
because it can auto scale behind the scenes.

<!-- We have our tree app here, and we want to host it on AWS.  -->

To make that work, we’re going to use the aws-lambda-adapter project to make
sure that our `Deno.serve` function runs as we expect it to. This is a popular
approach to deploying to AWS lambda due to control, flexibility, and
consistency.

There’s a nice article on this on the blog if you want to learn more about these
considerations.

Let’s take a look at the Dockerfile that we can use to make this work:

```dockerfile
# Set up the base image
FROM public.ecr.aws/awsguru/aws-lambda-adapter:0.9.0 AS aws-lambda-adapter
FROM denoland/deno:bin-2.0.2 AS deno_bin
FROM debian:bookworm-20230703-slim AS deno_runtime
COPY --from=aws-lambda-adapter /lambda-adapter /opt/extensions/lambda-adapter
COPY --from=deno_bin /deno /usr/local/bin/deno
ENV PORT=8000
EXPOSE 8000
RUN mkdir /var/deno_dir
ENV DENO_DIR=/var/deno_dir

# Copy the function code
WORKDIR "/var/task"
COPY . /var/task

# Warmup caches
RUN timeout 10s deno -A main.ts || [ $? -eq 124 ] || exit 1

CMD ["deno", "-A", "main.ts"]
```

Then we’ll build the Docker image.

```shell
docker build -t my-deno-project .
```

Now we need to start interfacing with AWS. If this is your first time working
with AWS, you can create an account:
[https://aws.amazon.com](https://aws.amazon.com)

And if you haven’t installed the AWS CLI, you can do that too. You know if it’s
installed by typing `aws` into your Terminal or Command Prompt. If that returns
an error you can install with homebrew or follow the instructions through the
website:
[https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)

```
brew install awscli
```

Then you’ll want to make sure that you’re set up with `aws configure`.
Everything that it is looking for is in the
[Security Credentials section of the
AWS Console](https://us-east-1.console.aws.amazon.com/ecr/private-registry/repositories).

### Use the CLI to create an ECR

The ECR is a registry service where we can push our docker container

```
aws ecr create-repository --repository-name my-deno-project --region us-east-1 | grep repositoryUri
```

This outputs a URI for the repo: \`"repositoryUri":
"\<\<myuserid\>\>[.dkr.ecr.us-west-1.amazonaws.com/my-deno-project](http://.dkr.ecr.us-west-1.amazonaws.com/my-deno-project)",\`

Then log in using the URI that comes back

```shell
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <username>.dkr.ecr.us-east-1.amazonaws.com/my-deno-project
```

Tag the image

```shell
docker tag my-deno-project:latest <myProject>.dkr.ecr.us-east-1.amazonaws.com/my-deno-project:latest
```

Then Push the image to ECR

```shell
docker push <myproject>.dkr.ecr.us-west-1.amazonaws.com/my-deno-project:latest
```

Now we need to create a function that will host our app:

- [https://us-east-1.console.aws.amazon.com/lambda/home?region=us-east-1\#/begin](https://us-east-1.console.aws.amazon.com/lambda/home?region=us-east-1#/begin)
- Think of a function as being a place where the app is going to run
- Select Create a Function
- Select Container Image Radio Button
- Call the function `tree-app`
- Select the app from the Browse Containers button
- Halfway down the page select “Configuration”
- Select `Function URL`
- Create a URL
- Select None so the endpoint is public
- Select Save
- Check the app in the browser

One thing to keep in mind with Lambda functions is cold start performance. Cold
starts happen when AWS needs to initialize your function, and it can cause
slight delays. There’s a pretty cool
[blog here that goes through Deno vs. other
tools](https://deno.com/blog/aws-lambda-coldstart-benchmarks).

Using Deno with AWS Lambda functions is a great way to stand up your app quickly
in a familiar environment.


---

# Deploying Deno with Docker

URL: https://docs.deno.com/examples/videos/deploying_deno_with_docker


## Video description

See how to deploy Deno applications with Docker to a compatible cloud
environment.

## Resources

- https://github.com/denoland/deno_docker
- https://fly.io/
- https://docs.deno.com/runtime/reference/docker/

## Transcript and code

Deno has made a lot of things seem easy: linting, formatting, interoperability
with the Node ecosystem, testing, TypeScript, but how about deployment? How easy
is it to get Deno running in production? Pretty easy!

Let’s start with a look at our app. It’s an app that provides us with some
information about trees. On the homepage we get some text At the trees route, we
get some JSON At the dynamic route based on the tree’s id, we get information
about that single tree.

```ts
import { Hono } from "jsr:@hono/hono";

const app = new Hono();

interface Tree {
  id: string;
  species: string;
  age: number;
  location: string;
}

const oak: Tree = {
  id: "1",
  species: "oak",
  age: 3,
  location: "Jim's Park",
};

const maple: Tree = {
  id: "2",
  species: "maple",
  age: 5,
  location: "Betty's Garden",
};

const trees: Tree[] = [oak, maple];

app.get("/", (c) => {
  return c.text("🌲 🌳 The Trees Welcome You! 🌲 🌳");
});

app.get("/trees", (c) => {
  return c.json(trees);
});

app.get("/trees/:id", (c) => {
  const id = c.req.param("id");
  const tree = trees.find((tree) => tree.id === id);
  if (!tree) return c.json({ message: "That tree isn't here!" }, 404);
  return c.json(tree);
});

Deno.serve(app.fetch);
```

## Run Locally with Docker

Make sure that Docker is installed on your machine. In your terminal or command
prompt, you can run docker and if you get a big list of commands, you have it.
If not, head over to https://www.docker.com/ and download it based on your
operating system.

### Test run docker:

```shell
docker
```

Then run the command to get running on `localhost:8000` with Docker

```shell
docker run -it -p 8000:8000 -v $PWD:/my-deno-project denoland/deno:2.0.2 run
--allow-net /my-deno-project/main.ts
```

Visit the app running at `localhost:8000`

It’s also possible to run this with a docker config file.

```dockerfile
FROM
denoland/deno:2.0.2

# The port that your application listens to.

EXPOSE 8000

WORKDIR /app

# Prefer not to run as root.
USER deno

# These steps will be re-run upon each file change in your working directory:
COPY . .

# Compile the main app so that it doesn't need to be compiled each startup/entry.
RUN deno cache main.ts

# Warmup caches
RUN timeout 10s deno -A main.ts || [ $? -eq 124 ] || exit 1

CMD ["run", "--allow-net", "main.ts"]
```

Then build it

```shell
docker build -t my-deno-project .
```

From there, you can deploy the app to your hosting provider of choice. I’m going
to use fly.io today.

## Deploy to fly.io

If you haven’t worked with fly before, it’s a cloud platform that allows you to
deploy and run fullstack apps. They run in multiple regions throughout the world
which makes them a pretty nice option. https://fly.io/

### Install Fly

Install with curl

```shell
curl -L https://fly.io/install.sh | sh
```

### Log in with Fly via CLI

```shell
fly auth login
```

This will open the browser for you to log into your account (or create one if
you haven’t already). Then we’ll launch the app with fly using:

```shell
flyctl launch
```

This will generate a fly.toml file for the app, and you can choose different
settings if you’d like to. And more importantly it will launch it! We’ll just
wait for the process to complete, and we should be able to view our app running
at that location.

So with Deno, we can use Docker to containerize the app and with Fly we can get
the app hosted in production in just a few minutes.

## More information on working with Docker

For a closer look at Deno's support of Docker, including best practices, running
tests with Docker, using workspaces, and more, please take a look at our
[Deno and Docker reference documentation](https://docs.deno.com/runtime/reference/docker/).


---

# ECMAScript Modules

URL: https://docs.deno.com/examples/videos/esmodules



---

# 使用 deno compile 进行图片打包

URL: https://docs.deno.com/examples/videos/image_bundling_deno_compile


## 视频描述

Deno 团队的 Divy 向你展示如何在 [他的 Flappybird 游戏](https://github.com/littledivy/flappybird)中使用 `deno compile` 通过 bytes 导入来嵌入图片资源。

---

# 与 Node.js 的互操作性

URL: https://docs.deno.com/examples/videos/interoperability_with_nodejs


## 视频描述

Deno 在其 v2.0 版本中获得了许多互操作性功能。在本视频中，我们将探讨如何使用 Node.js 内置 API、NPM 模块和 JSR 包。

## 记录与示例

[Deno 2.0](https://deno.com/blog/v2) 发布了，它非常不错。Deno 最令人惊叹的功能之一是它与其他平台（包括 Node）的互操作性。例如，我们可以使用核心 Node.js 内置 API。我们所需要做的就是在这里添加这个 Node 指定符。

```ts
import fs from "node:fs/promises";
```

Deno 还支持使用 NPM 模块。您只需在导入时添加 NPM 指定符，就可以开始使用。

```ts
import { * } as Sentry from "npm:@sentry/node";
```

我们还可以利用 [JSR](https://jsr.io)，这是一个用于 TypeScript 和 JavaScript 的开源包注册表。

```ts
import OpenAI from "jsr:@openai/openai";
```

当然，JSR 与 Deno、Node.js、bun 和 CloudFlare workers 一起工作。您甚至可以将 JSR 包安装到 Vite 和 Next.js 应用程序中。

Deno 还为我们提供了 [导入映射](https://docs.deno.com/runtime/fundamentals/modules/#differentiating-between-imports-or-importmap-in-deno.json-and---import-map-option)，这帮助我们管理依赖项。您可以从 JSR 安装一个包。导入将被添加到 `deno.json`，您甚至可以使用简写来描述这一点，以进一步简化您的代码。Deno 2.0 专注于提供一个非常稳固的开发体验。使用 Deno 新创建项目和迁移变得更加轻松。

---

# Introduction to Deno APIs

URL: https://docs.deno.com/examples/videos/intro_to_deno_apis


## Video description

In this video, we explore the powerful APIs provided by Deno in the global
namespace. We demonstrate file system operations like creating, reading,
writing, and appending to files using Deno's built-in methods. Then, examine how
to handle command line arguments, environment variables, and set up a basic
server. We can reduce the need for external APIs with these Deno built-in APIs.

## Transcript and examples

In the global name space, Deno has a ton of APIs that you can take advantage of.
Let's take a look at a few of them.

### Creating and writing to files

In order to write a file, first we will await Deno.open and we'll pass in the
name of the file that we want to create. The second argument is going to be an
object where we'll set `read`, `write` and `create` to `true`:

```ts title="main.ts"
await Deno.open("thoughts.txt", {
  read: true,
  write: true,
  create: true,
});
```

To run this, we will use:

```sh
deno main.ts
```

When run, the console will prompt us to allow read access, so we'll say yes (or
`y`). Then it's going to ask us for write access, which is pretty cool (and
we'll allow that too with `y`), so we've granted both and now we have created a
file called `thoughts.txt`.

If we wanted to write some data to this file we could make some adjustments to
our `main.ts` file. Let's create a variable for our file (called file), then
we're going to add `append:true` to the object we pass to the `Deno.open` method
(we can also get rid of create I suppose, since the file has already been
created):

```ts title="main.ts"
const file = await Deno.open("thoughts.txt", {
  read: true,
  write: true,
  append: true,
});
```

Next, below this, we'll make a constant called `encoder`, and make it equal a
new text encoder. Then we'll make a second constant called `data`, which will
call `encode`. Finally we'll add a string with a newline and some text to
`data`:

```ts title="main.ts"
const encoder = new TextEncoder();
const data = encoder.encode("\nI think basil is underrated.");
```

Then we'll `await file.Write(data)`, which will take that data and write it to
the thoughts file, and finally we'll close the file.

```ts title=main.ts"
await file.write(data);
file.close();
```

This time we will run the file with the required permissions:

```sh
deno --allow-read --allow-write main.ts
```

If we take a look back at our `thoughts.txt` file it will say "I think basil is
underrated". The text has been appended to our file.

### Reading and appending to files

There are some other options as well, so let's go back to the top of our file
this time instead of using `Deno.open` we'll use `Deno.readFile`. Which means we
can remove the second argument object, because we're being very specific about
what we actually want to do here. Then we'll console log the file.

```ts title="main.ts"
const file = await Deno.readFile("thoughts.txt");
console.log(file);
```

If we run this with:

```sh
deno --allow-read main.ts
```

The encoded file will be logged to the console, which isn't quite what I want. I
actually want the human readable text. So what I can do here is I can use
`Deno.readTextFile` instead of `Deno.readFile`, which will write the text from
the file directly to the console.

We can also write to the file with `Deno.writeTextFile`. For example:

```ts title="main.ts"
await Deno.writeTextFile(
  "thoughts.txt",
  "Fall is a great season",
);
```

Which, if we run with `deno --allow-write main.ts`, will overwrite the contents
of the `thoughts.txt` file with the string about fall.

We can update that code to use `append: true`:

```ts title="main.ts"
await Deno.writeTextFile(
  "thoughts.txt",
  "\nWinter is the most fun season!",
  { append: true },
);
```

If we run it again, with `deno --allow-write main.ts`, it's going to append the
second sentence to the end of the file.

### Exploring command line arguments

We also have the option to explore command line arguments, so we could say:

```ts title="main.ts"
const name = Deno.args[0];
console.log(name);
```

We can run this with our usual deno command, but this time pass in a commandline
argument, lets say `Eve`:

```sh
deno main.ts Eve
```

The name `Eve` will be logged to the console.

If we want to get fancy, we can update the logged template string to pass out a
message:

```ts title="main.ts"
const name = Deno.args[0];
console.log(`How are you today, ${name}?`);
```

## Using env variables

On the Deno global, we also have environment variables. Let's create one called
`home`, and log our home directory to the console:

```ts title="main.ts"
const home = Deno.env.get("HOME");
console.log(`Home directory: ${home}`);
```

When run with `deno main.ts`, Deno will request environment access, which we can
allow with `y`. Or we can run the command with the `--allow-env` flag, and our
home directory will be logged to the console.

### Setting up a simple HTTP server

Finally, lets look at our trusty `server` constructor. We can create a handler
that returns a response, and then pass that handler to the `Deno.serve` method.

```ts title="main.ts"
function handler(): Response {
  return new Response("It's happening!");
}

Deno.serve(handler);
```

When run with

```sh
deno --allow-net main.ts
```

We'll see that a server is running and listening on port 8000. We can visit
`localhost:8000` in the browser and we should see the text "It's happening!".

So there are a ton of these that you can take advantage of but it's very nice to
know that we don't have to include an external library for everything, Deno has
us covered when it comes to managing errors handling servers and working with
the file system.


---

# Connect to Mongoose and MongoDB

URL: https://docs.deno.com/examples/videos/mongoose



---

# Connect to Prisma

URL: https://docs.deno.com/examples/videos/prisma



---

# Publishing Modules with JSR

URL: https://docs.deno.com/examples/videos/publishing_modules_with_jsr


## Transcript and examples

[JSR](https://jsr.io) is a registry specifically designed for modern JavaScript
projects. JSR - the JavaScript registry - has a bunch of cool features. But if
you've used npm before, you might be thinking, "why do I need this and why do I
need to learn another one of these?"

- Well, first it's optimized for TypeScript.
- JSR only supports ES Modules.
- And finally, npm is the centralized registry for node projects, but there are
  other runtimes. Obviously Deno, but you can also use these packages in Bun,
  Cloudflare workers and more

Think of it like a superset. JSR doesn't replace npm, it builds on top of it.

So here at [jsr.io](https://jsr.io), you can search for whatever you want. I'm
looking for this library called Oak that is a middleware framework for handling
HTTP requests. I'll search for it here, and this will take me to
[the documentation page](https://jsr.io/@oak/oak).

If you want to install a package, all you need to do is add it:

```sh
deno add jsr:@oak/oak
```

Then we can use it inside of our file like this.

```javascript
import { Application } from "jsr:@oak/oak/application";
import { Router } from "jsr:@oak/oak/router";

const router = new Router();
router.get("/", (context) => {
  context.response.body = "HEY!";
});

const app = new Application();
app.use(router.routes());
app.use(router.allowedMethods());

app.listen({ port: 8080 });
```

Pretty cool! But what is it like to publish our own JSR package? It's actually
great.

JSR packages can depend on other packages from JSR but also on any npm package.

Let's build a small library and publish it to JSR. Remember
[our `sing` function from earlier](/examples/all-in-one_tooling/), let's make
this a function that can be consumed by other people in the JavaScript
community. You're welcome everyone.

```typescript
export function sing(
  phrase: string,
  times: number,
): string {
  return Array(times).fill(phrase).join(" ");
}

sing("la", 3);
```

<a href="https://jsr.io/new" class="docs-cta jsr-cta">Publish to JSR
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

Now if we [head over to jsr.io, we can publish it](https://jsr.io/new). The
first time I ever try to publish a package, JSR will ask me which scope I want
to publish to. I can create that here.

Then I'll create the package name and follow the instructions.

Let's try using our new packaga in a project using Vite. The following command
will walk us through setting up a new Vite project.

```shell
deno run --allow-read --allow-write --allow-env npm:create-vite-extra@latest
```

Now we can import our new package by adding it to our project:

```shell
deno add jsr:@eveporcello/sing
```

And then importing it when we need it

```typescript
import { sing } from "@eveporcello/sing";
```

 So if I had to give myself a grade on this, I don't even have to give myself a
grade. [JSR will give me a grade](https://jsr.io/@eveporcello/sing/score) of
29%, which I don't know. Probably not so good. But this has a whole list of
improvements that I can make.

I need to add a readme to my package. I need to add examples. All of these
different things. So I can on my own time develop this to ensure that I have 100
percent here so that my code is well documented and very consumable by other
developers.


---

# Build a React app

URL: https://docs.deno.com/examples/videos/react_app_video



---

# Build a Realtime WebSocket Application

URL: https://docs.deno.com/examples/videos/realtime_websocket_app



---

# TypeScript and JSX

URL: https://docs.deno.com/examples/videos/ts_jsx



---

# Build a Vue app

URL: https://docs.deno.com/examples/videos/vue_app_video



---

# 什么是 Deno？

URL: https://docs.deno.com/examples/videos/what_is_deno


## 视频描述

对 Deno 及其历史的简短介绍

## 转录和代码

Deno 是一个用于 JavaScript、TypeScript 和 WebAssembly 项目的开源运行时，基于 V8 和 Rust 构建。它现代、快速、灵活，并且默认安全。

Deno 是由 Node.js 的创建者 Ryan Dahl 创建的，在 2018 年，他在 [JSConf EU](https://www.youtube.com/watch?v=M3BM9TB-8yA) 上发表了一次著名演讲，谈到了他对 Node.js 的一些遗憾。Deno 提供了所有这些问题的解决方案。

凭借着曾经的经验，Deno 给我们提供了一个在细节上经过深思熟虑的运行时。细节包括默认支持 TypeScript。您可以运行或导入 TypeScript，而无需安装除了 Deno CLI 以外的任何东西。

Deno 内置了 TypeScript 编译器，因此它可以直接运行您的 TypeScript 代码，而无需任何额外的配置。

细节还包括代码检查、格式化和测试。Deno 是一个一体化工具链，您可以使用它开始您的项目，而无需将您在地球上有限的时间花费在配置上。细节如网络标准。

Deno 基于您可能熟悉的网络标准，如 Fetch 和 WebSockets。

您无需学习任何新东西即可使用它们。如果您在浏览器中使用过它们，那么您已经准备好在 Deno 中使用它们。Deno 默认是安全的。您必须特别启用对敏感 API 的权限，如网络、文件系统和环境访问。Deno 让您主动选择这些权限，就像您在浏览器中选择地理位置一样。

在 [本课程中](https://www.youtube.com/watch?v=KPTOo4k8-GE&list=PLvvLnBDNuTEov9EBIp3MMfHlBxaKGRWTe)，我们将通过实践活动来深入了解 Deno 的最重要功能。无论您之前是否尝试过 Deno，或者这一切对您来说都是新鲜事，我相信您会喜欢这里的。


---

# lint/rules/adjacent-overload-signatures.md

URL: https://docs.deno.com/lint/rules/adjacent-overload-signatures


要求重载签名必须相邻。

不相邻的重载签名可能导致代码难以阅读和维护。

**无效示例：**

（`bar` 在 `foo` 重载之间被声明）

```typescript
type FooType = {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void;
  foo(sn: string | number): void;
};
```

```typescript
interface FooInterface {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void;
  foo(sn: string | number): void;
}
```

```typescript
class FooClass {
  foo(s: string): void;
  foo(n: number): void;
  bar(): void {}
  foo(sn: string | number): void {}
}
```

```typescript
export function foo(s: string): void;
export function foo(n: number): void;
export function bar(): void {}
export function foo(sn: string | number): void {}
```

**有效示例：**

（`bar` 在 `foo` 之后被声明）

```typescript
type FooType = {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void;
  bar(): void;
};
```

```typescript
interface FooInterface {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void;
  bar(): void;
}
```

```typescript
class FooClass {
  foo(s: string): void;
  foo(n: number): void;
  foo(sn: string | number): void {}
  bar(): void {}
}
```

```typescript
export function foo(s: string): void;
export function foo(n: number): void;
export function foo(sn: string | number): void {}
export function bar(): void {}
```

---

# lint/rules/ban-ts-comment.md

URL: https://docs.deno.com/lint/rules/ban-ts-comment


不允许在没有注释的情况下使用 Typescript 指令。

Typescript 指令降低了编译器的有效性，这种情况应仅在特殊情况下使用。原因应在指令旁边通过注释进行说明。

**无效：**

```typescript
// @ts-expect-error
let a: number = "I am a string";
```

```typescript
// @ts-ignore
let a: number = "I am a string";
```

```typescript
// @ts-nocheck
let a: number = "I am a string";
```

**有效：**

```typescript
// @ts-expect-error: 临时解决方案（请参见票据 #422）
let a: number = "I am a string";
```

```typescript
// @ts-ignore: 临时解决方案（请参见票据 #422）
let a: number = "I am a string";
```

```typescript
// @ts-nocheck: 临时解决方案（请参见票据 #422）
let a: number = "I am a string";
```

---

# lint/rules/ban-types.md

URL: https://docs.deno.com/lint/rules/ban-types


禁止使用原始包装对象（例如 `String` 这个对象是 `string` 原始类型的包装），以及不明确的 `Function` 类型和误解的 `Object` 类型。

原始包装对象的使用情况非常少见，更多的情况是使用原始类型时出现错误。你也不能将原始包装对象赋值给原始类型，这会导致后续的类型问题。作为参考，[TypeScript 手册] 也表示我们不应使用这些包装对象。

[TypeScript 手册]: https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#number-string-boolean-symbol-and-object

对于 `Function`，最好明确指定整个函数签名，而不是使用模糊的 `Function` 类型，这样不会给你提供函数的类型安全。

最后，`Object` 和 `{}` 意味着“任何非空值”，而不是“任何对象类型”。`object` 是表示“任何对象类型”的不错选择。

**无效：**

```typescript
let a: Boolean;
let b: String;
let c: Number;
let d: Symbol;
let e: Function;
let f: Object;
let g: {};
```

**有效：**

```typescript
let a: boolean;
let b: string;
let c: number;
let d: symbol;
let e: () => number;
let f: object;
let g: Record<string, never>;
```

---

# lint/rules/ban-unknown-rule-code.md

URL: https://docs.deno.com/lint/rules/ban-unknown-rule-code


警告在忽略指令中使用未知规则代码。

我们有时需要出于某些原因抑制和忽略 lint 错误。我们可以使用 [忽略指令](/go/lint-ignore/) 来实现，指定应被忽略的规则名称，如下所示：

```typescript
// deno-lint-ignore no-explicit-any no-unused-vars
const foo: any = 42;
```

此规则检查指定规则名称的有效性（即 `deno_lint` 是否提供该规则）。

**无效：**

```typescript
// 拼写错误
// deno-lint-ignore eq-eq-e
console.assert(x == 42);

// 未知规则名称
// deno-lint-ignore UNKNOWN_RULE_NAME
const b = "b";
```

**有效：**

```typescript
// deno-lint-ignore eq-eq-eq
console.assert(x == 42);

// deno-lint-ignore no-unused-vars
const b = "b";
```

---

# lint/rules/ban-untagged-ignore.md

URL: https://docs.deno.com/lint/rules/ban-untagged-ignore


需要将 `deno-lint-ignore` 注解与一个或多个规则名称。

忽略所有规则可能会掩盖意外或未来的问题。因此，您需要明确指定要忽略的规则。

**无效:**

```typescript
// deno-lint-ignore
export function duplicateArgumentsFn(a, b, a) {}
```

**有效:**

```typescript
// deno-lint-ignore no-dupe-args
export function duplicateArgumentsFn(a, b, a) {}
```

---

# lint/rules/ban-untagged-todo.md

URL: https://docs.deno.com/lint/rules/ban-untagged-todo


要求 TODO 注释必须带有用户标签（`@user`）或问题引用（`#issue`）。

没有用户或问题引用的 TODO 注释会变得陈旧，并且没有简单的方法来获取更多信息。

**无效示例：**

```typescript
// TODO 改进计算引擎
export function calcValue(): number {}
```

```typescript
// TODO 改进计算引擎 (@djones)
export function calcValue(): number {}
```

```typescript
// TODO 改进计算引擎 (#332)
export function calcValue(): number {}
```

**有效示例：**

```typescript
// TODO(djones) 改进计算引擎
export function calcValue(): number {}
```

```typescript
// TODO(@djones) 改进计算引擎
export function calcValue(): number {}
```

```typescript
// TODO(#332)
export function calcValue(): number {}
```

```typescript
// TODO(#332) 改进计算引擎
export function calcValue(): number {}
```

---

# lint/rules/ban-unused-ignore.md

URL: https://docs.deno.com/lint/rules/ban-unused-ignore


警告未使用的忽略指令。

我们有时出于某些原因不得不抑制和忽略 lint 错误，我们可以使用 [忽略指令](/go/lint-ignore/) 来实现。

然而，在某些情况下，比如重构之后，我们可能会拥有不再必要的忽略指令。这些多余的忽略指令可能会让未来的代码阅读者困惑，更糟糕的是，可能无意中掩盖未来的 lint 错误。为了防止这种情况，此规则检测未使用的多余忽略指令。

**无效:**

```typescript
// 实际上这行是有效的，因为 `export` 意味着“已使用”，
// 所以这个指令是多余的
// deno-lint-ignore no-unused-vars
export const foo = 42;
```

**有效:**

```typescript
export const foo = 42;
```

---

# lint/rules/camelcase.md

URL: https://docs.deno.com/lint/rules/camelcase


强制在变量名中使用 camelCase。

代码库中的一致性是可读性和可维护性的关键。此规则强制要求您创建的变量声明和对象属性名使用 camelCase。

值得注意的是：

- `_` 可以出现在变量的开头或结尾
- 所有大写变量名（例如常量）可以在其名称中包含 `_`
- 如果由于某些原因必须在对象中使用 snake_case 键，请将其用引号括起来
- 此规则也适用于通过 ES 模块导入或导出的变量，但不适用于这些变量的对象属性

**无效：**

```typescript
let first_name = "Ichigo";
const obj1 = { last_name: "Hoshimiya" };
const obj2 = { first_name };
const { last_name } = obj1;

function do_something() {}
function foo({ snake_case = "default value" }) {}

class snake_case_class {}
class Also_Not_Valid_Class {}

import { not_camelCased } from "external-module.js";
export * as not_camelCased from "mod.ts";

enum snake_case_enum {
  snake_case_variant,
}

type snake_case_type = { some_property: number };

interface snake_case_interface {
  some_property: number;
}
```

**有效：**

```typescript
let firstName = "Ichigo";
const FIRST_NAME = "Ichigo";
const __myPrivateVariable = "Hoshimiya";
const myPrivateVariable_ = "Hoshimiya";
const obj1 = { "last_name": "Hoshimiya" }; // 如果对象键被引号括起来，则有效
const obj2 = { "first_name": first_name };
const { last_name: lastName } = obj;

function doSomething() {} // 函数声明必须是 camelCase 但是...
do_something(); // ...允许 snake_case 的函数调用
function foo({ snake_case: camelCase = "default value" }) {}

class PascalCaseClass {}

import { not_camelCased as camelCased } from "external-module.js";
export * as camelCased from "mod.ts";

enum PascalCaseEnum {
  PascalCaseVariant,
}

type PascalCaseType = { someProperty: number };

interface PascalCaseInterface {
  someProperty: number;
}
```

---

# lint/rules/constructor-super.md

URL: https://docs.deno.com/lint/rules/constructor-super


验证构造函数和 `super()` 调用的正确使用。

派生类（例如 `class A extends B`）的定义构造函数必须始终调用 `super()`。扩展非构造函数的类（例如 `class A extends null`）不得有构造函数。

**无效示例：**

```typescript
class A {}
class Z {
  constructor() {}
}

class B extends Z {
  constructor() {} // 缺少 super() 调用
}
class C {
  constructor() {
    super(); // 语法错误
  }
}
class D extends null {
  constructor() {} // 非法构造函数
}
class E extends null {
  constructor() { // 非法构造函数
    super();
  }
}
```

**有效示例：**

```typescript
class A {}
class B extends A {}
class C extends A {
  constructor() {
    super();
  }
}
class D extends null {}
```

---

# lint/rules/default-param-last.md

URL: https://docs.deno.com/lint/rules/default-param-last


强制默认参数在函数签名中位于最后。

具有默认值的参数本质上是可选的，但不能在函数调用中省略而不将函数输入映射到不同的参数，这会导致混淆和错误。将它们指定为最后一个参数允许在不改变其他参数语义的情况下省略它们。

**无效：**

```typescript
function f(a = 2, b) {}
function f(a = 5, b, c = 5) {}
```

**有效：**

```typescript
function f() {}
function f(a) {}
function f(a = 5) {}
function f(a, b = 5) {}
function f(a, b = 5, c = 5) {}
function f(a, b = 5, ...c) {}
function f(a = 2, b = 3) {}
```

---

# lint/rules/eqeqeq.md

URL: https://docs.deno.com/lint/rules/eqeqeq


强制使用类型安全的相等运算符 `===` 和 `!==` 代替更容易出错的 `==` 和 `!=` 运算符。

`===` 和 `!==` 确保比较的值不仅相同且类型相同。另一方面，`==` 和 `!=` 在值比较之前会进行类型转换，这可能导致意外的结果。例如 `5 == "5"` 是 `true`，而 `5 === "5"` 是 `false`。

**无效：**

```typescript
if (a == 5) {}
if ("hello world" != input) {}
```

**有效：**

```typescript
if (a === 5) {}
if ("hello world" !== input) {}
```

---

# lint/rules/explicit-function-return-type.md

URL: https://docs.deno.com/lint/rules/explicit-function-return-type


要求所有函数都有明确的返回类型。

明确的返回类型有许多优点，包括代码更易理解和更好的类型安全。从函数的签名中可以清楚地看出返回类型（如果有的话）是什么。

**无效：**

```typescript
function someCalc() {
  return 2 * 2;
}
function anotherCalc() {
  return;
}
```

**有效：**

```typescript
function someCalc(): number {
  return 2 * 2;
}
function anotherCalc(): void {
  return;
}
```

---

# lint/rules/explicit-module-boundary-types.md

URL: https://docs.deno.com/lint/rules/explicit-module-boundary-types


要求所有模块导出具备完全类型声明。

具备完全类型的函数参数和返回值清晰地定义了模块的输入和输出（称为模块边界）。这将使任何使用该模块的用户能够以类型安全的方式明确如何提供输入和处理输出。

**无效：**

```typescript
// 缺少返回类型（例如 void）
export function printDoc(doc: string, doubleSided: boolean) {
  return;
}

// 缺少参数类型（例如 `arg` 是字符串类型）
export const arrowFn = (arg): string => `hello ${arg}`;

// 缺少返回类型（例如 boolean）
export function isValid() {
  return true;
}
```

**有效：**

```typescript
// 带有类型的输入参数和返回值
export function printDoc(doc: string, doubleSided: boolean): void {
  return;
}

// 输入类型为字符串，返回值类型为字符串
export const arrowFn = (arg: string): string => `hello ${arg}`;

// 尽管缺少返回类型，但这仍然有效，因为它没有被导出
function isValid() {
  return true;
}
```

---

# lint/rules/for-direction.md

URL: https://docs.deno.com/lint/rules/for-direction


需要 `for` 循环控制变量以正确的方向递增。

以错误的方向递增 `for` 循环控制变量会导致无限循环。这可以通过不正确的初始化、错误的继续步骤逻辑或错误方向的循环控制变量递增造成。

**无效：**

```typescript
// 无限循环
for (let i = 0; i < 2; i--) {}
```

**有效：**

```typescript
for (let i = 0; i < 2; i++) {}
```

---

# lint/rules/fresh-handler-export.md

URL: https://docs.deno.com/lint/rules/fresh-handler-export


检查命名是否正确，适用于命名的 fresh 中间件导出。

`routes/` 文件夹中的文件可以导出在任何渲染之前运行的中间件。它们应该作为名为 `handler` 的命名导出提供。此规则检查何时导出被错误地命名为 `handlers` 而不是 `handler`。

**无效：**

```js
export const handlers = {
  GET() {},
  POST() {},
};
export function handlers() {}
export async function handlers() {}
```

**有效：**

```jsx
export const handler = {
  GET() {},
  POST() {},
};
export function handler() {}
export async function handler() {}
```

---

# lint/rules/fresh-server-event-handlers.md

URL: https://docs.deno.com/lint/rules/fresh-server-event-handlers


不允许在 fresh 服务器组件中使用事件处理程序。

在 fresh 应用中的 `routes/` 文件夹内的组件仅在服务器上渲染。
它们不会在客户端渲染，设置事件处理程序将没有效果。

请注意，这条规则仅适用于 `routes/` 文件夹内的服务器组件，而不适用于 fresh 岛屿或任何其他组件。

**无效：**

```jsx
<button onClick={() => {}} />
<button onclick={() => {}} />
<my-custom-element foo={() => {}} />
```

**有效：**

```jsx
<button />
<my-custom-element />
```

---

# lint/rules/getter-return.md

URL: https://docs.deno.com/lint/rules/getter-return


要求所有属性获取器函数返回一个值。

获取器函数返回属性的值。如果函数不返回值，则违反了此合同。

**无效:**

```typescript
let foo = {
  get bar() {},
};

class Person {
  get name() {}
}
```

**有效:**

```typescript
let foo = {
  get bar() {
    return true;
  },
};

class Person {
  get name() {
    return "alice";
  }
}
```

---

# lint/rules/guard-for-in.md

URL: https://docs.deno.com/lint/rules/guard-for-in


要求 `for-in` 循环包含 `if` 语句。

使用 `for-in` 循环遍历对象时，会包含通过原型链继承的属性。这种行为可能导致你的循环中出现意外的项。

**无效示例：**

```typescript
for (const key in obj) {
  foo(obj, key);
}
```

**有效示例：**

```typescript
for (const key in obj) {
  if (Object.hasOwn(obj, key)) {
    foo(obj, key);
  }
}
```

```typescript
for (const key in obj) {
  if (!Object.hasOwn(obj, key)) {
    continue;
  }
  foo(obj, key);
}
```

---

# lint/rules/jsx-boolean-value.md

URL: https://docs.deno.com/lint/rules/jsx-boolean-value


强制一致的 JSX 布尔值样式。传递 `true` 作为布尔值可以使用简写语法省略。

**无效:**

```tsx
const foo = <Foo isFoo={true} />;
const foo = <Foo isFoo={false} />;
```

**有效:**

```tsx
const foo = <Foo isFoo />;
const foo = <Foo isFoo={false} />;
```

---

# lint/rules/jsx-button-has-type.md

URL: https://docs.deno.com/lint/rules/jsx-button-has-type


Enforce `<button>` elements to have a `type` attribute. If a `<button>` is
placed inside a `<form>` element it will act as a submit button by default which
can be unexpected.

**Invalid:**

```tsx
const btn = <button>click me</button>;
const btn = <button type="2">click me</button>;
```

**Valid:**

```tsx
const btn = <button type="button">click me</button>;
const btn = <button type="submit">click me</button>;
const btn = <button type={btnType}>click me</button>;
const btn = <button type={condition ? "button" : "submit"}>click me</button>;
```


---

# lint/rules/jsx-curly-braces.md

URL: https://docs.deno.com/lint/rules/jsx-curly-braces


确保在 JSX 表达式周围一致使用花括号。

**无效：**

```tsx
const foo = <Foo foo=<div /> />;
const foo = <Foo str={"foo"} />;
const foo = <div>{"foo"}</div>;
```

**有效：**

```tsx
const foo = <Foo foo={<div />} />;
const foo = <Foo str="foo" />;
const foo = <div>foo</div>;
```

---

# lint/rules/jsx-key.md

URL: https://docs.deno.com/lint/rules/jsx-key


确保在将可迭代对象传递给 JSX 时存在 `key` 属性。这允许框架优化元素顺序的检查。

**无效：**

```tsx
const foo = [<div>foo</div>];
const foo = [<>foo</>];
[1, 2, 3].map(() => <div />);
Array.from([1, 2, 3], () => <div />);
```

**有效：**

```tsx
const foo = [<div key="a">foo</div>];
const foo = [<Fragment key="b">foo</Fragment>];
[1, 2, 3].map((x) => <div key={x} />);
Array.from([1, 2, 3], (x) => <div key={x} />);
```

---

# lint/rules/jsx-no-children-prop.md

URL: https://docs.deno.com/lint/rules/jsx-no-children-prop


将子元素作为 JSX 子元素传递，而不是作为属性。

**无效：**

```tsx
<div children="foo" />
<div children={[<Foo />, <Bar />]} />
```

**有效：**

```tsx
<div>foo</div>
<div><Foo /><Bar /></div>
```

---

# lint/rules/jsx-no-comment-text-nodes.md

URL: https://docs.deno.com/lint/rules/jsx-no-comment-text-nodes


JavaScript comments inside text nodes are rendered as plain text in JSX. This is
often unexpected.

**Invalid:**

```tsx
<div>// comment</div>
<div>/* comment */</div>
```

**Valid:**

```tsx
<div>{/* comment */}</div>;
```


---

# lint/rules/jsx-no-duplicate-props.md

URL: https://docs.deno.com/lint/rules/jsx-no-duplicate-props


不允许重复的 JSX 属性。后面的属性将始终覆盖前面的属性，这常常会导致意想不到的结果。

**无效：**

```tsx
<div id="1" id="2" />;
<App a a />;
<App a {...b} a />;
```

**有效：**

```tsx
<div id="1" />
<App a />
<App a {...b} />
<App {...b} b />
```

---

# lint/rules/jsx-no-unescaped-entities.md

URL: https://docs.deno.com/lint/rules/jsx-no-unescaped-entities


Leaving the `>` or `}` character in JSX is often undesired and difficult to
spot. Enforce that these characters must be passed as strings.

**Invalid:**

```tsx
<div>></div>
<div>}</div>
```

**Valid:**

```tsx
<div>&gt;</div>,
<div>{">"}</div>,
<div>{"}"}</div>,
```


---

# lint/rules/jsx-no-useless-fragment.md

URL: https://docs.deno.com/lint/rules/jsx-no-useless-fragment


片段仅在 JSX "块" 的顶部是必要的，并且仅在有多个子元素时需要。在其他情况下不需要片段。

**无效:**

```tsx
<></>
<><div /></>
<><App /></>
<p>foo <>bar</></p>
```

**有效:**

```tsx
<>{foo}</>
<><div /><div /></>
<>foo <div /></>
<p>foo bar</p>
```

---

# lint/rules/jsx-props-no-spread-multi.md

URL: https://docs.deno.com/lint/rules/jsx-props-no-spread-multi


重复同样的表达式通常是一个错误，并且会导致不必要的计算。

**无效：**

```tsx
<div {...foo} {...foo} />
<div {...foo} a {...foo} />
<Foo {...foo.bar} {...foo.bar} />
```

**有效：**

```tsx
<div {...foo} />
<div {...foo.bar} a />
<Foo {...foo.bar} />
```

---

# lint/rules/jsx-void-dom-elements-no-children.md

URL: https://docs.deno.com/lint/rules/jsx-void-dom-elements-no-children


确保 HTML 中的空元素没有任何子元素，因为这不是有效的 HTML。有关更多信息，请参阅
[`空元素` 文章在 MDN](https://developer.mozilla.org/en-US/docs/Glossary/Void_element)。

**无效：**

```tsx
<br>foo</br>
<img src="a.jpg">foo</img>
```

**有效：**

```tsx
<br />
<img src="a.jpg" />
```

---

# lint/rules/no-array-constructor.md

URL: https://docs.deno.com/lint/rules/no-array-constructor


强制执行数组构造的常规用法。

数组构造通常通过文字表示法进行，例如 `[]` 或 `[1, 2, 3]`。不推荐使用 `new Array()` 或 `new Array(1, 2, 3)`。这样做有两个原因。首先，当提供一个参数时，会定义数组的长度，而多个参数则填充不定大小的数组。当只使用文字表示法创建预填充数组时，可以避免这种混淆。避免使用 `Array` 构造函数的第二个理由是，`Array` 全局可能会被重新定义。

这个规则的一个例外是，在创建固定大小的新数组时，例如 `new Array(6)`。这是创建固定长度数组的常规方式。

**无效：**

```typescript
// 这是 4 个元素，而不是大小为 100 的 3 个元素的数组
const a = new Array(100, 1, 2, 3);

const b = new Array(); // 应使用 [] 替代
```

**有效：**

```typescript
const a = new Array(100);
const b = [];
const c = [1, 2, 3];
```

---

# lint/rules/no-async-promise-executor.md

URL: https://docs.deno.com/lint/rules/no-async-promise-executor


要求不使用 async promise 执行器函数。

Promise 构造函数将一个执行器函数作为参数，该函数具有 `resolve` 和
`reject` 参数，可以用于控制创建的 Promise 的状态。这个函数可以是 async，但出于几个原因，通常不推荐这样做：

- 如果 async 执行器函数抛出错误，错误将会丢失，并且不会导致新构造的 Promise 被拒绝。这可能使得调试和处理某些错误变得困难。
- 如果一个 async Promise 执行器函数正在使用 await，那么这通常表明实际上并不需要使用新的 Promise 构造函数，可以重构代码以避免使用 Promise，或者可以缩小新的 Promise 构造函数的作用域，将 async 代码提取出来并改为同步执行。

**无效：**

```typescript
new Promise(async function (resolve, reject) {});
new Promise(async (resolve, reject) => {});
```

**有效：**

```typescript
new Promise(function (resolve, reject) {});
new Promise((resolve, reject) => {});
```

---

# lint/rules/no-await-in-loop.md

URL: https://docs.deno.com/lint/rules/no-await-in-loop


在 for 循环体中未使用 `await`。

Async 和 await 在 Javascript 中用于提供并行执行。如果在 for 循环中的每个元素都使用 `await` 进行等待，那么这就 negates 了使用 async/await 的好处，因为在当前元素完成之前，循环中的其他元素无法被处理。

一种常见的解决方案是重构代码，使循环体异步运行并捕获生成的 promises。循环结束后，可以一次性 await 所有的 promises。

**无效示例：**

```javascript
async function doSomething(items) {
  const results = [];
  for (const item of items) {
    // 数组中的每个项都在等待前一个项完成
    results.push(await someAsyncProcessing(item));
  }
  return processResults(results);
}
```

**有效示例：**

```javascript
async function doSomething(items) {
  const results = [];
  for (const item of items) {
    // 异步启动所有项的处理...
    results.push(someAsyncProcessing(item));
  }
  // ...然后在循环后等待它们完成
  return processResults(await Promise.all(results));
}
```

---

# lint/rules/no-await-in-sync-fn.md

URL: https://docs.deno.com/lint/rules/no-await-in-sync-fn


禁止在非异步函数中使用 `await` 关键字。

在非异步函数中使用 `await` 关键字是语法错误。要在函数内部使用 `await`，必须通过 `async` 关键字将该函数标记为异步。

**无效：**

```javascript
function foo() {
  await bar();
}

const fooFn = function foo() {
  await bar();
};

const fooFn = () => {
  await bar();
};
```

**有效：**

```javascript
async function foo() {
  await bar();
}

const fooFn = async function foo() {
  await bar();
};

const fooFn = async () => {
  await bar();
};
```

---

# lint/rules/no-boolean-literal-for-arguments.md

URL: https://docs.deno.com/lint/rules/no-boolean-literal-for-arguments


要求所有函数在调用时，无论参数数量为多少，都使用自文档常量代替 `boolean` 字面量作为参数。

定义可以接受 `boolean` 作为参数的函数是很常见的。然而，传递 `boolean` 字面量作为参数可能会导致缺乏上下文，无法明确参数在被调用函数中的角色。

解决上述问题的一个简单方法是使用自文档常量，这些常量最终可以作为“命名的布尔值”，使得在函数调用的上下文中更好地理解参数的含义。

**无效示例：**

```typescript
function redraw(allViews: boolean, inline: boolean) {
  // redraw logic.
}
redraw(true, true);

function executeCommand(recursive: boolean, executionMode: EXECUTION_MODES) {
  // executeCommand logic.
}
executeCommand(true, EXECUTION_MODES.ONE);

function enableLogs(enable: boolean) {
  // enabledLogs logic.
}
enableLogs(true);
```

**有效示例：**

```typescript
function redraw(allViews: boolean, inline: boolean) {
  // redraw logic.
}
const ALL_VIEWS = true, INLINE = true;
redraw(ALL_VIEWS, INLINE);

function executeCommand(recursive: boolean, executionMode: EXECUTION_MODES) {
  // executeCommand logic.
}
const RECURSIVE = true;
executeCommand(RECURSIVE, EXECUTION_MODES.ONE);

function enableLogs(enable: boolean) {
  // enabledLogs logic.
}
const ENABLE = true;
enableLogs(ENABLE);
```

---

# lint/rules/no-case-declarations.md

URL: https://docs.deno.com/lint/rules/no-case-declarations


在 `case` 或 `default` 子句中要求使用大括号来限制 `let`、`const`、`function` 和 `class` 的作用域。

如果 `case` 或 `default` 块中没有大括号，词法声明会在整个 switch 块中可见，但只有在被赋值时才会初始化，而这仅在达到该 case/default 时发生。这可能会导致意外错误。解决方案是确保每个 `case` 或 `default` 块用大括号包裹，以限制声明的作用域。

**无效示例：**

```typescript
switch (choice) {
  // `let`、`const`、`function` 和 `class` 在整个 switch 语句中作用域可见
  case 1:
    let a = "选择 1";
    break;
  case 2:
    const b = "选择 2";
    break;
  case 3:
    function f() {
      return "选择 3";
    }
    break;
  default:
    class C {}
}
```

**有效示例：**

```typescript
switch (choice) {
  // 以下 `case` 和 `default` 子句用大括号包裹
  case 1: {
    let a = "选择 1";
    break;
  }
  case 2: {
    const b = "选择 2";
    break;
  }
  case 3: {
    function f() {
      return "选择 3";
    }
    break;
  }
  default: {
    class C {}
  }
}
```

---

# lint/rules/no-class-assign.md

URL: https://docs.deno.com/lint/rules/no-class-assign


不允许修改类声明的变量。

声明一个类，例如 `class A {}`，将创建一个变量 `A`。与任何变量一样，这个变量可以被修改或重新赋值。在大多数情况下，这是一种错误，并不是预期的结果。

**无效：**

```typescript
class A {}
A = 0; // 重新赋值给类变量本身
```

**有效：**

```typescript
class A {}
let c = new A();
c = 0; // 重新赋值给变量 `c`
```

---

# lint/rules/no-compare-neg-zero.md

URL: https://docs.deno.com/lint/rules/no-compare-neg-zero


不允许与负零（`-0`）进行比较。

直接将一个值与负数进行比较可能不会按预期工作，因为它也会对非负零（即`0`和`+0`）通过。可以使用 `Object.is` 进行与负零的显式比较。

**无效：**

```typescript
if (x === -0) {}
```

**有效：**

```typescript
if (x === 0) {}

if (Object.is(x, -0)) {}
```

---

# lint/rules/no-cond-assign.md

URL: https://docs.deno.com/lint/rules/no-cond-assign


禁止在条件语句中使用赋值操作符 `=`。

在条件语句中使用赋值操作符通常是因为误打了相等运算符 `==`。如果在条件语句中确实需要赋值，则此规则允许通过将赋值放入括号中来实现。

**无效：**

```typescript
let x;
if (x = 0) {
  let b = 1;
}
```

```typescript
function setHeight(someNode) {
  do {
    someNode.height = "100px";
  } while (someNode = someNode.parentNode);
}
```

**有效：**

```typescript
let x;
if (x === 0) {
  let b = 1;
}
```

```typescript
function setHeight(someNode) {
  do {
    someNode.height = "100px";
  } while ((someNode = someNode.parentNode));
}
```

---

# lint/rules/no-console.md

URL: https://docs.deno.com/lint/rules/no-console


不允许使用 `console` 全局对象。

开发人员通常会意外地提交 `console.log` / `console.error` 语句，这些语句特别是在调试之后留下。此外，在代码中使用这些语句可能会泄露敏感信息到输出中或使控制台充满不必要的信息。此规则通过不允许使用 `console` 来帮助维护干净和安全的代码。

此规则在库中尤其有用，因为你几乎从不想将信息输出到控制台。

**无效:**

```typescript
console.log("调试信息");
console.error("调试信息");
console.debug(obj);

if (debug) console.log("调试中");

function log() {
  console.log("日志");
}
```

**有效:**

对于任何实际想要使用控制台的调用，建议通过 `deno-lint-ignore` 注释显式启用控制台。

```typescript
function logWarning(message: string) {
  // deno-lint-ignore no-console
  console.warn(message);
}
```

---

# lint/rules/no-const-assign.md

URL: https://docs.deno.com/lint/rules/no-const-assign


禁止修改声明为 `const` 的变量。

修改声明为 `const` 的变量将导致运行时错误。

**无效：**

```typescript
const a = 0;
a = 1;
a += 1;
a++;
++a;
```

**有效：**

```typescript
const a = 0;
const b = a + 1;

// `c` 在每次循环迭代中超出作用域，允许新的赋值
for (const c in [1, 2, 3]) {}
```

---

# lint/rules/no-constant-condition.md

URL: https://docs.deno.com/lint/rules/no-constant-condition


不允许在条件测试中使用常量表达式。

在条件测试中使用常量表达式通常是错误的，或者是在开发过程中引入的临时情况，并不适合用于生产环境。

**无效：**

```typescript
if (true) {}
if (2) {}
do {} while (x = 2); // 无限循环
```

**有效：**

```typescript
if (x) {}
if (x === 0) {}
do {} while (x === 2);
```

---

# lint/rules/no-control-regex.md

URL: https://docs.deno.com/lint/rules/no-control-regex


不允许在正则表达式中使用 ASCII 控制字符。

控制字符是位于 ASCII 范围内的不可见字符，范围为 0-31。在正则表达式中使用这些字符是不常见的，通常是正则表达式中的错误。

**无效示例：**

```typescript
// 使用 ASCII (31) 回车符 (十六进制 x0d) 的例子
const pattern1 = /\x0d/;
const pattern2 = /\u000d/;
const pattern3 = new RegExp("\\x0d");
const pattern4 = new RegExp("\\u000d");
```

**有效示例：**

```typescript
// 使用 ASCII (32) 空格 (十六进制 x20) 的例子
const pattern1 = /\x20/;
const pattern2 = /\u0020/;
const pattern3 = new RegExp("\\x20");
const pattern4 = new RegExp("\\u0020");
```

---

# lint/rules/no-debugger.md

URL: https://docs.deno.com/lint/rules/no-debugger


禁止使用 `debugger` 语句。

`debugger` 是一个用于停止 JavaScript 执行环境并在该语句处启动调试器的语句。现代调试器和工具不再需要这个语句，保留它可能会导致您的代码在生产环境中停止执行。

**无效示例：**

```typescript
function isLongString(x: string) {
  debugger;
  return x.length > 100;
}
```

**有效示例：**

```typescript
function isLongString(x: string) {
  return x.length > 100; // 在这里设置断点
}
```

---

# lint/rules/no-delete-var.md

URL: https://docs.deno.com/lint/rules/no-delete-var


不允许删除变量。

`delete` 用于从对象中移除一个属性。通过 `var`、`let` 和 `const` 声明的变量无法被删除（`delete` 将返回 `false`）。在严格模式下，当试图删除一个变量时会抛出语法错误。

**无效示例：**

```typescript
const a = 1;
let b = 2;
let c = 3;
delete a; // 将返回 false
delete b; // 将返回 false
delete c; // 将返回 false
```

**有效示例：**

```typescript
let obj = {
  a: 1,
};
delete obj.a; // 返回 true
```

---

# lint/rules/no-deprecated-deno-api.md

URL: https://docs.deno.com/lint/rules/no-deprecated-deno-api


警告使用已弃用的 - Deno APIs。

以下 API 将从 `Deno.*` 命名空间中移除，但有更新的 API 可以迁移。请参阅
[Deno 1.x 到 2.x 迁移指南](https://docs.deno.com/runtime/manual/advanced/migrate_deprecations)
以获取迁移说明。

- `Deno.Buffer`
- `Deno.Closer`
- `Deno.close()`
- `Deno.Conn.rid`
- `Deno.copy()`
- `Deno.customInspect`
- `Deno.File`
- `Deno.fstatSync()`
- `Deno.fstat()`
- `Deno.FsWatcher.rid`
- `Deno.ftruncateSync()`
- `Deno.ftruncate()`
- `Deno.futimeSync()`
- `Deno.futime()`
- `Deno.isatty()`
- `Deno.Listener.rid`
- `Deno.ListenTlsOptions.certFile`
- `Deno.ListenTlsOptions.keyFile`
- `Deno.readAllSync()`
- `Deno.readAll()`
- `Deno.Reader`
- `Deno.ReaderSync`
- `Deno.readSync()`
- `Deno.read()`
- `Deno.run()`
- `Deno.seekSync()`
- `Deno.seek()`
- `Deno.serveHttp()`
- `Deno.Server`
- `Deno.shutdown`
- `Deno.stderr.rid`
- `Deno.stdin.rid`
- `Deno.stdout.rid`
- `Deno.TlsConn.rid`
- `Deno.UnixConn.rid`
- `Deno.writeAllSync()`
- `Deno.writeAll()`
- `Deno.Writer`
- `Deno.WriterSync`
- `Deno.writeSync()`
- `Deno.write()`
- `new Deno.FsFile()`

以下 API 将从 `Deno.*` 命名空间中移除且没有替代方案。

- `Deno.resources()`
- `Deno.metrics()`

---

# lint/rules/no-dupe-args.md

URL: https://docs.deno.com/lint/rules/no-dupe-args


不允许在函数签名中多次使用相同的参数名称。

如果你向一个函数提供多个相同名称的参数，最后一个实例将会覆盖前面的实例。这很可能是一个无意的拼写错误。

**无效：**

```typescript
function withDupes(a, b, a) {
  console.log("我是第二个a的值:", a);
}
```

**有效：**

```typescript
function withoutDupes(a, b, c) {
  console.log("我是第一个（也是唯一的）a的值:", a);
}
```

---

# lint/rules/no-dupe-class-members.md

URL: https://docs.deno.com/lint/rules/no-dupe-class-members


不允许在类中一个成员函数名使用多次。

在一个类中声明同名的函数两次会导致之前的声明被覆盖，从而造成意想不到的行为。

**无效:**

```typescript
class Foo {
  bar() {}
  bar() {}
}
```

**有效:**

```typescript
class Foo {
  bar() {}
  fizz() {}
}
```

---

# lint/rules/no-dupe-else-if.md

URL: https://docs.deno.com/lint/rules/no-dupe-else-if


不允许在 `if`/`else if` 语句中重复使用相同的条件。

当您在 `if`/`else if` 语句中重复使用一个条件时，重复的条件将永远不会被达到（除非出现不寻常的副作用），这意味着这几乎总是一个错误。

**无效：**

```typescript
if (a) {}
else if (b) {}
else if (a) {} // 上述条件的重复

if (a === 5) {}
else if (a === 6) {}
else if (a === 5) {} // 上述条件的重复
```

**有效：**

```typescript
if (a) {}
else if (b) {}
else if (c) {}

if (a === 5) {}
else if (a === 6) {}
else if (a === 7) {}
```

---

# lint/rules/no-dupe-keys.md

URL: https://docs.deno.com/lint/rules/no-dupe-keys


不允许在对象字面量中使用重复的键。

在对象字面量中多次设置相同的键会覆盖该键的其他赋值，并可能导致意外的行为。

**无效：**

```typescript
const foo = {
  bar: "baz",
  bar: "qux",
};
```

```typescript
const foo = {
  "bar": "baz",
  bar: "qux",
};
```

```typescript
const foo = {
  0x1: "baz",
  1: "qux",
};
```

**有效：**

```typescript
const foo = {
  bar: "baz",
  quxx: "qux",
};
```

---

# lint/rules/no-duplicate-case.md

URL: https://docs.deno.com/lint/rules/no-duplicate-case


不允许在 `switch` 语句中重复使用相同的 case 子句。

当你在 `switch` 语句中重复使用一个 case 测试表达式时，重复的 case 将永远无法达到，这意味着这几乎总是一个错误。

**无效：**

```typescript
const someText = "a";
switch (someText) {
  case "a": // (1)
    break;
  case "b":
    break;
  case "a": // (1) 的重复
    break;
  default:
    break;
}
```

**有效：**

```typescript
const someText = "a";
switch (someText) {
  case "a":
    break;
  case "b":
    break;
  case "c":
    break;
  default:
    break;
}
```

---

# lint/rules/no-empty-character-class.md

URL: https://docs.deno.com/lint/rules/no-empty-character-class


不允许在正则表达式中使用空字符类。

正则表达式字符类是一系列用方括号括起来的字符，例如 `[abc]`。如果方括号内没有任何内容，它将不会匹配任何东西，这很可能是一个拼写错误或失误。

**无效:**

```typescript
/^abc[]/.test("abcdefg"); // false，因为 `d` 不匹配空字符类
"abcdefg".match(/^abc[]/); // null
```

**有效:**

```typescript
// 没有字符类
/^abc/.test("abcdefg"); // true
"abcdefg".match(/^abc/); // ["abc"]

// 有一个有效的字符类
/^abc[a-z]/.test("abcdefg"); // true
"abcdefg".match(/^abc[a-z]/); // ["abcd"]
```

---

# lint/rules/no-empty-enum.md

URL: https://docs.deno.com/lint/rules/no-empty-enum


不允许声明空枚举。

一个没有成员的枚举没有任何意义。此规则将捕获这些情况，将其视为不必要的代码或错误的空实现。

**无效：**

```typescript
enum Foo {}
```

**有效：**

```typescript
enum Foo {
  ONE = "ONE",
}
```

---

# lint/rules/no-empty-interface.md

URL: https://docs.deno.com/lint/rules/no-empty-interface


不允许声明空接口。

一个没有成员的接口没有任何意义。此规则将捕获这些情况，视为不必要的代码或错误的空实现。

**无效：**

```typescript
interface Foo {}
```

**有效：**

```typescript
interface Foo {
  name: string;
}

interface Bar {
  age: number;
}

// 使用至少有一个扩展的空接口是允许的。

// 使用空接口将 Baz 的身份从类型更改为接口。
type Baz = { profession: string };
interface Foo extends Baz {}

// 使用空接口扩展已经存在的 Foo 声明
// 以及 Bar 接口的成员
interface Foo extends Bar {}

// 使用空接口作为联合类型
interface Baz extends Foo, Bar {}
```

---

# lint/rules/no-empty-pattern.md

URL: https://docs.deno.com/lint/rules/no-empty-pattern


禁止在解构中使用空模式。

在解构中，可以使用空模式，如 `{}` 或 `[]`，这些模式没有任何效果，可能与作者的意图不符。

**无效示例：**

```typescript
// 在下面的例子中，{} 和 [] 并不是对象字面量或空数组，
// 而是解构变量名的占位符
const {} = someObj;
const [] = someArray;
const {a: {}} = someObj;
const [a: []] = someArray;
function myFunc({}) {}
function myFunc([]) {}
```

**有效示例：**

```typescript
const { a } = someObj;
const [a] = someArray;

// 将解构变量默认值设为对象字面量的正确方法
const { a = {} } = someObj;

// 将解构变量默认值设为空数组的正确方法
const [a = []] = someArray;

function myFunc({ a }) {}
function myFunc({ a = {} }) {}
function myFunc([a]) {}
function myFunc([a = []]) {}
```

---

# lint/rules/no-empty.md

URL: https://docs.deno.com/lint/rules/no-empty


禁止使用空的块语句。

空的块语句是合法的，但通常表示某些内容被遗漏，从而可能降低代码的可读性。此规则忽略仅包含注释的块语句。此规则也忽略空的构造函数和函数体（包括箭头函数）。

**无效：**

```typescript
if (foo) {}

while (foo) {}

switch (foo) {}

try {
  doSomething();
} catch (e) {
} finally {
}
```

**有效：**

```typescript
if (foo) {
  // 空
}

while (foo) {
  /* 空 */
}

try {
  doSomething();
} catch (e) {
  // 无论错误如何，继续
}

try {
  doSomething();
} finally {
  /* 无论错误如何，继续 */
}
```

---

# lint/rules/no-eval.md

URL: https://docs.deno.com/lint/rules/no-eval


不允许使用 `eval`。

`eval` 是一个潜在危险的函数，它可能会使你的代码面临多种安全漏洞。除了速度慢之外，`eval` 通常还可以通过更好的解决方案来避免使用。

**无效：**

```typescript
const obj = { x: "foo" };
const key = "x";
const value = eval("obj." + key);
```

**有效：**

```typescript
const obj = { x: "foo" };
const value = obj[key];
```

---

# lint/rules/no-ex-assign.md

URL: https://docs.deno.com/lint/rules/no-ex-assign


不允许重新赋值异常参数。

一般来说，没有好的理由去重新赋值异常参数。一旦重新赋值，从那时起代码就无法再访问错误。

**无效：**

```typescript
try {
  someFunc();
} catch (e) {
  e = true;
  // 无法再访问抛出的错误
}
```

**有效：**

```typescript
try {
  someFunc();
} catch (e) {
  const anotherVar = true;
}
```

---

# lint/rules/no-explicit-any.md

URL: https://docs.deno.com/lint/rules/no-explicit-any


禁止使用 `any` 类型。

使用 `any` 类型会禁用该变量周围的类型检查系统，违背了 TypeScript 提供类型安全代码的目的。此外，使用 `any` 会降低代码的可读性，因为不容易立即理解所引用的值是什么类型。对于所有类型，最好做到明确。对于无法选择更具体类型的情况，可以使用 `unknown` 作为 `any` 的更安全的替代方案。

**无效的示例：**

```typescript
const someNumber: any = "two";
function foo(): any {
  return undefined;
}
```

**有效的示例：**

```typescript
const someNumber: string = "two";
function foo(): undefined {
  return undefined;
}
```

---

# lint/rules/no-external-import.md

URL: https://docs.deno.com/lint/rules/no-external-import


禁止使用外部导入。

- 这个 lint 规则的动机是什么？
  - 如果通过 URL 导入外部模块，该规则会发出警告。 "deps.ts" 和导入映射是例外。
- 为什么被 lint 的代码被认为是不好的？
  - 导入外部模块可以正常工作，但如果这些模块在项目中的多个地方被导入，当你想要升级这些模块时，会需要付出时间和精力。
- 何时应使用它？
  - 为了避免这种情况，你可以使用 "deps.ts 约定" 或
    [导入映射](https://docs.deno.com/runtime/manual/basics/import_maps)，
    在这里你可以导入所有外部模块，然后重新导出它们或为它们分配别名。
  - 如果你想遵循 "deps.ts 约定" 或使用导入映射。

**无效示例：**

```typescript
import { assertEquals } from "https://deno.land/std@0.126.0/testing/asserts.ts";
```

**有效示例：**

```typescript
import { assertEquals } from "./deps.ts";
```

```typescript
// deps.ts

export {
  assert,
  assertEquals,
  assertStringIncludes,
} from "https://deno.land/std@0.126.0/testing/asserts.ts";
```

你可以在这里参考对此约定的解释
https://docs.deno.com/runtime/manual/basics/modules/#it-seems-unwieldy-to-import-urls-everywhere

---

# lint/rules/no-extra-boolean-cast.md

URL: https://docs.deno.com/lint/rules/no-extra-boolean-cast


禁止不必要的布尔类型强制转换。

在某些上下文中，例如 `if`、`while` 或 `for` 语句，表达式会自动转为布尔值。因此，像双重否定 (`!!foo`) 或强制转换 (`Boolean(foo)`) 这样的技术是多余的，并且与不进行否定或强制转换得到的结果相同。

**无效：**

```typescript
if (!!foo) {}
if (Boolean(foo)) {}
while (!!foo) {}
for (; Boolean(foo);) {}
```

**有效：**

```typescript
if (foo) {}
while (foo) {}
for (; foo;) {}
```

---

# lint/rules/no-extra-non-null-assertion.md

URL: https://docs.deno.com/lint/rules/no-extra-non-null-assertion


禁止不必要的非空断言。

非空断言使用 `!` 指示编译器你知道这个值不为 null。连续使用该操作符超过一次，或者与可选链操作符（`?`）结合使用是令人困惑且不必要的。

**无效示例：**

```typescript
const foo: { str: string } | null = null;
const bar = foo!!.str;

function myFunc(bar: undefined | string) {
  return bar!!;
}
function anotherFunc(bar?: { str: string }) {
  return bar!?.str;
}
```

**有效示例：**

```typescript
const foo: { str: string } | null = null;
const bar = foo!.str;

function myFunc(bar: undefined | string) {
  return bar!;
}
function anotherFunc(bar?: { str: string }) {
  return bar?.str;
}
```

---

# lint/rules/no-fallthrough.md

URL: https://docs.deno.com/lint/rules/no-fallthrough


不允许隐式穿透 case 语句。

没有 `break` 的 case 语句将执行其主体，然后继续执行下一个 case 或 default 块的代码。虽然这有时是出于故意，但很多时候开发者忘记添加 break 语句，原本只打算执行单个 case 语句。此规则强制要求你要么在每个 case 语句末尾加上 break 语句，要么添加一个明确的注释表明穿透是故意的。穿透注释必须包含 `fallthrough`、`falls through` 或 `fall through` 之一。

**无效示例：**

```typescript
switch (myVar) {
  case 1:
    console.log("1");

  case 2:
    console.log("2");
}
// 如果 myVar = 1，则输出 `1` 和 `2`。这是故意的吗？
```

**有效示例：**

```typescript
switch (myVar) {
  case 1:
    console.log("1");
    break;

  case 2:
    console.log("2");
    break;
}
// 如果 myVar = 1，则仅输出 `1`

switch (myVar) {
  case 1:
    console.log("1");
    /* falls through */
  case 2:
    console.log("2");
}
// 如果 myVar = 1，故意输出 `1` 和 `2`
```

---

# lint/rules/no-func-assign.md

URL: https://docs.deno.com/lint/rules/no-func-assign


不允许重写/重新赋值已有函数。

Javascript 允许对函数定义进行重新赋值。这通常是开发者的错误，或者编码实践不佳，因为代码的可读性和可维护性将受到影响。

**无效示例：**

```typescript
function foo() {}
foo = bar;

const a = function baz() {
  baz = "现在我是一串字符串";
};

myFunc = existingFunc;
function myFunc() {}
```

**有效示例：**

```typescript
function foo() {}
const someVar = foo;

const a = function baz() {
  const someStr = "现在我是一串字符串";
};

const anotherFuncRef = existingFunc;

let myFuncVar = function () {};
myFuncVar = bar; // 变量重新赋值，不是函数重新声明
```

---

# lint/rules/no-global-assign.md

URL: https://docs.deno.com/lint/rules/no-global-assign


禁止对原生 Javascript 对象进行赋值。

在 Javascript 中，`String` 和 `Object` 例如是原生对象。像任何对象一样，它们可以被重新赋值，但几乎永远不明智，因为这可能导致意想不到的结果和难以追踪的错误。

**无效：**

```typescript
Object = null;
undefined = true;
window = {};
```

---

# lint/rules/no-implicit-declare-namespace-export.md

URL: https://docs.deno.com/lint/rules/no-implicit-declare-namespace-export


禁止在 ["环境" 命名空间] 中使用隐式导出。

TypeScript 隐式导出所有成员的 ["环境" 命名空间]，除非存在命名导出。

["环境" 命名空间]: https://www.typescriptlang.org/docs/handbook/namespaces.html#ambient-namespaces

**无效：**

```ts
// foo.ts 或 foo.d.ts
declare namespace ns {
  interface ImplicitlyExported {}
  export type Exported = true;
}
```

**有效：**

```ts
// foo.ts 或 foo.d.ts
declare namespace ns {
  interface NonExported {}
  export {};
}

declare namespace ns {
  interface Exported {}
  export { Exported };
}

declare namespace ns {
  export interface Exported {}
}
```

---

# lint/rules/no-import-assertions.md

URL: https://docs.deno.com/lint/rules/no-import-assertions


不允许在导入属性中使用 `assert` 关键字。

ES 导入属性（以前称为导入断言）已更改为使用 `with` 关键字。使用 `assert` 的旧语法仍然被支持，但已被弃用。

**无效:**

```typescript
import obj from "./obj.json" assert { type: "json" };
import("./obj2.json", { assert: { type: "json" } });
```

**有效:**

```typescript
import obj from "./obj.json" with { type: "json" };
import("./obj2.json", { with: { type: "json" } });
```

---

# lint/rules/no-import-assign.md

URL: https://docs.deno.com/lint/rules/no-import-assign


禁止重新分配导入模块绑定。

ES 模块导入绑定应被视为只读，因为在代码执行期间修改它们可能会导致运行时错误。这也会导致代码可读性差和维护困难。

**无效示例：**

```typescript
import defaultMod, { namedMod } from "./mod.js";
import * as modNameSpace from "./mod2.js";

defaultMod = 0;
namedMod = true;
modNameSpace.someExportedMember = "hello";
modNameSpace = {};
```

**有效示例：**

```typescript
import defaultMod, { namedMod } from "./mod.js";
import * as modNameSpace from "./mod2.js";

// 绑定导入的属性可以被设置
defaultMod.prop = 1;
namedMod.prop = true;
modNameSpace.someExportedMember.prop = "hello";
```

---

# lint/rules/no-import-prefix.md

URL: https://docs.deno.com/lint/rules/no-import-prefix


确保所有依赖项都在 `deno.json` 或 `package.json` 中声明。

### 无效示例：

```ts
import foo from "https://deno.land/std/path/mod.ts";
import foo from "jsr:@std/path@1";
import foo from "npm:preact@10";
```

### 有效示例：

```ts
// 在 `deno.json` 或 `package.json` 中映射
import foo from "@std/path";
```

---

# lint/rules/no-inferrable-types.md

URL: https://docs.deno.com/lint/rules/no-inferrable-types


禁止容易推断的类型。

对 JavaScript 原始类型（以及 `null`）的变量初始化在其类型上是显而易见的。指定它们的类型可能会增加代码的冗长性。例如，对于 `const x: number = 5`，指定 `number` 是不必要的，因为 `5` 显然是一个数字。

**无效的例子：**

```typescript
const a: bigint = 10n;
const b: bigint = BigInt(10);
const c: boolean = true;
const d: boolean = !0;
const e: number = 10;
const f: number = Number("1");
const g: number = Infinity;
const h: number = NaN;
const i: null = null;
const j: RegExp = /a/;
const k: RegExp = RegExp("a");
const l: RegExp = new RegExp("a");
const m: string = "str";
const n: string = `str`;
const o: string = String(1);
const p: symbol = Symbol("a");
const q: undefined = undefined;
const r: undefined = void someValue;

class Foo {
  prop: number = 5;
}

function fn(s: number = 5, t: boolean = true) {}
```

**有效的例子：**

```typescript
const a = 10n;
const b = BigInt(10);
const c = true;
const d = !0;
const e = 10;
const f = Number("1");
const g = Infinity;
const h = NaN;
const i = null;
const j = /a/;
const k = RegExp("a");
const l = new RegExp("a");
const m = "str";
const n = `str`;
const o = String(1);
const p = Symbol("a");
const q = undefined;
const r = void someValue;

class Foo {
  prop = 5;
}

function fn(s = 5, t = true) {}
```

---

# lint/rules/no-inner-declarations.md

URL: https://docs.deno.com/lint/rules/no-inner-declarations


不允许在嵌套块中定义变量或函数。

在嵌套块中声明函数可能会导致代码可读性降低，以及由于不同 JavaScript 运行时之间的兼容性问题而产生意想不到的结果。这不适用于在嵌套块上下文中有效的命名函数或匿名函数。

在嵌套块中使用 `var` 声明的变量也可能导致代码可读性降低。由于这些变量会提升到模块根部，因此最好在模块根部声明它们以提高清晰度。请注意，使用 `let` 或 `const` 声明的变量是块作用域的，因此此规则不适用于它们。

**无效示例：**

```typescript
if (someBool) {
  function doSomething() {}
}

function someFunc(someVal: number): void {
  if (someVal > 4) {
    var a = 10;
  }
}
```

**有效示例：**

```typescript
function doSomething() {}
if (someBool) {}

var a = 10;
function someFunc(someVal: number): void {
  var foo = true;
  if (someVal > 4) {
    let b = 10;
    const fn = function doSomethingElse() {};
  }
}
```

---

# lint/rules/no-invalid-regexp.md

URL: https://docs.deno.com/lint/rules/no-invalid-regexp


不允许在 RegExp 构造函数中指定无效的正则表达式。

指定无效的正则表达式字面量将在编译时导致 SyntaxError，然而在 RegExp 构造函数中指定无效的正则表达式字符串则只会在运行时被发现。

**无效：**

```typescript
const invalidRegExp = new RegExp(")");
```

**有效：**

```typescript
const goodRegExp = new RegExp(".");
```


---

# lint/rules/no-invalid-triple-slash-reference.md

URL: https://docs.deno.com/lint/rules/no-invalid-triple-slash-reference


警告三斜杠引用指令的错误用法。

Deno 支持 `types`、`path`、`lib` 和 `no-default-lib` 的三斜杠引用指令。此 lint 规则检查是否存在无效或格式不正确的指令，因为这很可能是一个错误。

此外，请注意，仅允许在 JavaScript 文件中使用 `types` 指令。该指令用于告诉 TypeScript 编译器与某个 JavaScript 文件对应的类型定义文件的位置。然而，即使在 v1.10 之前的 Deno 手册中（例如 [v1.9.2]），也有错误的说法称在这种情况下应该使用 `path` 指令。实际上，应该使用 `types` 指令。有关更多细节，请参阅 [最新手册]。因此，该规则还会检测在 JavaScript 文件中使用 `types` 以外的指令，并建议将其替换为 `types` 指令。

[v1.9.2]: https://deno.land/manual@v1.9.2/typescript/types#using-the-triple-slash-reference-directive  
[最新手册]: https://deno.land/manual/typescript/types#using-the-triple-slash-reference-directive

**无效：**

_JavaScript_

```javascript
/// <reference path="./mod.d.ts" />
/// <reference no-default-lib="true" />
/// <reference foo="bar" />

// ... 剩余的 JavaScript ...
```

_TypeScript_

```typescript
/// <reference foo="bar" />

// ... 剩余的 TypeScript ...
```

**有效：**

_JavaScript_

```javascript
/// <reference types="./mod.d.ts" />
/// <reference lib="es2017.string" />

// ... 剩余的 JavaScript ...
```

_TypeScript_

```typescript
/// <reference types="./mod.d.ts" />
/// <reference path="./mod.d.ts" />
/// <reference lib="es2017.string" />
/// <reference no-default-lib="true" />

// ... 剩余的 TypeScript ...
```

---

# lint/rules/no-irregular-whitespace.md

URL: https://docs.deno.com/lint/rules/no-irregular-whitespace


不允许使用非空格或非制表符的空白字符。

非空格或非制表符的空白字符在您的代码中可能非常难以识别，因为编辑器通常会以不可见的方式渲染它们。这些不可见的字符可能会导致问题或意外行为。有时这些字符会通过复制/粘贴或错误的键盘快捷键不小心添加进去。

以下字符是不允许的：

```
\u000B - 行制表符 (\v) - <VT>
\u000C - 换页符 (\f) - <FF>
\u00A0 - 不换行空格 - <NBSP>
\u0085 - 下一行
\u1680 - 奥甘空格标记
\u180E - 蒙古元音分隔符 - <MVS>
\ufeff - 零宽不换行空格 - <BOM>
\u2000 - 四分之一宽度
\u2001 - 半宽度
\u2002 - 仿半角 - <ENSP>
\u2003 - 半角 - <EMSP>
\u2004 - 每个字母树
\u2005 - 每个字母四分之一
\u2006 - 每个字母六分之一
\u2007 - 数字空格
\u2008 - 标点空格 - <PUNCSP>
\u2009 - 瘦空格
\u200A - 瘪空格
\u200B - 零宽空格 - <ZWSP>
\u2028 - 行分隔符
\u2029 - 段落分隔符
\u202F - 窄不换行空格
\u205f - 中等数学空格
\u3000 - 表意空格
```

要修复此 linting 问题，请将上述字符的实例替换为常规空格、制表符或换行符。如果不清楚 offending 字符的位置，请尝试从头开始重新输入该行。

---

# lint/rules/no-misused-new.md

URL: https://docs.deno.com/lint/rules/no-misused-new


禁止为接口定义 `constructor` 或为类定义 `new`

为接口指定 `constructor` 或为类定义 `new` 方法是不正确的，应避免这样做。

**无效：**

```typescript
class C {
  new(): C;
}

interface I {
  constructor(): void;
}
```

**有效：**

```typescript
class C {
  constructor() {}
}

interface I {
  new (): C;
}
```

---

# lint/rules/no-namespace.md

URL: https://docs.deno.com/lint/rules/no-namespace


不允许在 TypeScript 代码中使用 `namespace` 和 `module` 关键字。

`namespace` 和 `module` 都被认为是过时的关键字，用于组织代码。相反，通常更倾向于使用 ES2015 模块语法（例如 `import`/`export`）。

然而，此规则仍然允许在以下两种情况下使用这些关键字：

- 它们用于定义 ["ambient" 命名空间] 并与 `declare` 关键字一起使用
- 它们写在 TypeScript 的类型定义文件中：`.d.ts`

["ambient" 命名空间]: https://www.typescriptlang.org/docs/handbook/namespaces.html#ambient-namespaces

**无效：**

```typescript
// foo.ts
module mod {}
namespace ns {}
```

```dts
// bar.d.ts
// 在 `.d.ts` 中允许使用 `module` 和 `namespace` 关键字的所有情况
```

**有效：**

```typescript
// foo.ts
declare global {}
declare module mod1 {}
declare module "mod2" {}
declare namespace ns {}
```

```dts
// bar.d.ts
module mod1 {}
namespace ns1 {}
declare global {}
declare module mod2 {}
declare module "mod3" {}
declare namespace ns2 {}
```

---

# lint/rules/no-new-symbol.md

URL: https://docs.deno.com/lint/rules/no-new-symbol


禁止使用 `new` 操作符与内置的 `Symbol`。

`Symbol` 是通过作为函数调用来创建的，但我们有时会错误地使用 `new` 操作符进行调用。该规则检测此类错误使用 `new` 操作符的情况。

**无效：**

```typescript
const foo = new Symbol("foo");
```

**有效：**

```typescript
const foo = Symbol("foo");

function func(Symbol: typeof SomeClass) {
  // 这个 `Symbol` 不是内置的
  const bar = new Symbol();
}
```

---

# lint/rules/no-node-globals.md

URL: https://docs.deno.com/lint/rules/no-node-globals


禁止使用 NodeJS 全局对象。

NodeJS 暴露了一组全局对象，这些对象与 deno（和 web）不同，因此代码不应假设它们是可用的。相反，应该根据需要从其定义模块导入对象。

**无效：**

```typescript
// foo.ts
const buf = Buffer.from("foo", "utf-8"); // 在 deno 中，Buffer 不是全局对象
```

**有效：**

```typescript
// foo.ts
import { Buffer } from "node:buffer";

const foo = Buffer.from("foo", "utf-8");
```

---

# lint/rules/no-non-null-asserted-optional-chain.md

URL: https://docs.deno.com/lint/rules/no-non-null-asserted-optional-chain


禁止在可选链表达式后使用非空断言。

`?.` 可选链表达式在对象为 `null` 或 `undefined` 时会返回 `undefined`。使用 `!` 非空断言来断言 `?.` 可选链表达式的结果为非空是不正确的。

**无效示例：**

```typescript
foo?.bar!;
foo?.bar()!;
```

**有效示例：**

```typescript
foo?.bar;
foo?.bar();
```

---

# lint/rules/no-non-null-assertion.md

URL: https://docs.deno.com/lint/rules/no-non-null-assertion


禁止使用 `!` 后缀运算符进行非空断言。

TypeScript 的 `!` 非空断言运算符向类型系统断言某个表达式是非空的，即不为 `null` 或 `undefined`。使用断言向类型系统传递新信息通常是代码不完全类型安全的迹象。通常更好的做法是通过结构化程序逻辑，使 TypeScript 能够理解何时值可能是可空的。

**无效示例：**

```typescript
interface Example {
  property?: string;
}
declare const example: Example;

const includes = example.property!.includes("foo");
```

**有效示例：**

```typescript
interface Example {
  property?: string;
}
declare const example: Example;

const includes = example.property?.includes("foo") ?? false;
```

---

# lint/rules/no-obj-calls.md

URL: https://docs.deno.com/lint/rules/no-obj-calls


禁止像函数一样调用内置全局对象。

以下内置对象即使看起来像构造函数，也不应该被当作函数调用：

- `Math`
- `JSON`
- `Reflect`
- `Atomics`

将这些对象作为函数调用会导致运行时错误。此规则静态地防止了这种错误使用。

**无效的：**

```typescript
const math = Math();
const newMath = new Math();

const json = JSON();
const newJSON = new JSON();

const reflect = Reflect();
const newReflect = new Reflect();

const atomics = Atomics();
const newAtomics = new Atomics();
```

**有效的：**

```typescript
const area = (radius: number): number => Math.PI * radius * radius;

const parsed = JSON.parse("{ foo: 42 }");

const x = Reflect.get({ x: 1, y: 2 }, "x");

const first = Atomics.load(foo, 0);
```

---

# lint/rules/no-octal.md

URL: https://docs.deno.com/lint/rules/no-octal


禁止使用以 `0` 开头的数字文字表达八进制数。

八进制数可以通过以 `0` 开头的数字文字来表达，例如 `042`，但这种表达方式常常会让程序员感到困惑。这就是为什么 ECMAScript 的严格模式会对这种表达抛出 `SyntaxError`。

自 ES2015 起，另一个前缀 `0o` 作为替代方案被引入。今天的代码中强烈建议使用这个新的表达方式。

**无效：**

```typescript
const a = 042;
const b = 7 + 042;
```

**有效：**

```typescript
const a = 0o42;
const b = 7 + 0o42;
const c = "042";
```

---

# lint/rules/no-process-global.md

URL: https://docs.deno.com/lint/rules/no-process-global


禁止使用 NodeJS 的 `process` 全局变量。

NodeJS 和 Deno 暴露了 `process` 全局变量，但它们很难被工具进行静态分析，因此代码不应假设它们是可用的。相反，请使用 `import process from "node:process"`。

**无效：**

```typescript
// foo.ts
const foo = process.env.FOO;
```

**有效：**

```typescript
// foo.ts
import process from "node:process";

const foo = process.env.FOO;
```

---

# lint/rules/no-prototype-builtins.md

URL: https://docs.deno.com/lint/rules/no-prototype-builtins


不允许直接使用 `Object.prototype` 的内置方法。

如果通过 `Object.create(null)` 创建对象，则这些对象没有指定原型。这可能会导致运行时错误，因为你假设对象具有来自 `Object.prototype` 的属性，并尝试调用以下方法：

- `hasOwnProperty`
- `isPrototypeOf`
- `propertyIsEnumerable`

因此，始终建议显式地从 `Object.prototype` 调用这些方法。

**无效示例：**

```typescript
const a = foo.hasOwnProperty("bar");
const b = foo.isPrototypeOf("bar");
const c = foo.propertyIsEnumerable("bar");
```

**有效示例：**

```typescript
const a = Object.prototype.hasOwnProperty.call(foo, "bar");
const b = Object.prototype.isPrototypeOf.call(foo, "bar");
const c = Object.prototype.propertyIsEnumerable.call(foo, "bar");
```

---

# lint/rules/no-redeclare.md

URL: https://docs.deno.com/lint/rules/no-redeclare


不允许重新声明具有相同名称的变量、函数和参数。

JavaScript 允许我们使用 `var` 重新声明具有相同名称的变量，但不应使用重新声明，因为这会使变量难以追踪。

此外，这条 lint 规则也不允许使用 `let` 或 `const` 进行重新声明，尽管 ESLint 是允许的。这是有益的，因为我们可以在实际运行代码之前发现语法错误。

至于函数和参数，JavaScript 只是将这些视为运行时错误，运行时抛出 `SyntaxError`。静态检测这种错误也是有益的。

**无效:**

```typescript
var a = 3;
var a = 10;

let b = 3;
let b = 10;

const c = 3;
const c = 10;

function d() {}
function d() {}

function e(arg: number) {
  var arg: number;
}

function f(arg: number, arg: string) {}
```

**有效:**

```typescript
var a = 3;
function f() {
  var a = 10;
}

if (foo) {
  let b = 2;
} else {
  let b = 3;
}
```

---

# lint/rules/no-regex-spaces.md

URL: https://docs.deno.com/lint/rules/no-regex-spaces


禁止在正则表达式字面量中使用多个空格。

当正则表达式变得复杂时，正则表达式字面量中的多个空格通常难以阅读。相反，最好只使用一个空格字符，并通过 `{n}` 语法指定空格应该出现的次数，例如：

```typescript
// 正则表达式字面量中的多个空格使得预期匹配的空格数量更难理解
const re = /foo   bar/;

// 使用 `{n}` 语法提高可读性
const re = /foo {3}var/;
```

**无效：**

```typescript
const re1 = /  /;
const re2 = /foo  bar/;
const re3 = / a b  c d /;
const re4 = /foo  {3}bar/;

const re5 = new RegExp("  ");
const re6 = new RegExp("foo  bar");
const re7 = new RegExp(" a b  c d ");
const re8 = new RegExp("foo  {3}bar");
```

**有效：**

```typescript
const re1 = /foo/;
const re2 = / /;
const re3 = / {3}/;
const re4 = / +/;
const re5 = / ?/;
const re6 = / */;

const re7 = new RegExp("foo");
const re8 = new RegExp(" ");
const re9 = new RegExp(" {3}");
const re10 = new RegExp(" +");
const re11 = new RegExp(" ?");
const re12 = new RegExp(" *");
```

---

# lint/rules/no-self-assign.md

URL: https://docs.deno.com/lint/rules/no-self-assign


禁止自我赋值。

自我赋值像 `a = a;` 根本没有任何效果。如果代码中存在自我赋值，大多数情况下意味着作者仍在重构过程中，还有剩余的工作需要完成。

**无效:**

```typescript
a = a;
[a] = [a];
[a, b] = [a, b];
[a, b] = [a, c];
[a, ...b] = [a, ...b];
a.b = a.b;
```

**有效:**

```typescript
let a = a;
a += a;
a = [a];
[a, b] = [b, a];
a.b = a.c;
```

---

# lint/rules/no-self-compare.md

URL: https://docs.deno.com/lint/rules/no-self-compare


禁止比较两个完全相同的值或变量。

将一个变量或值与其自身进行比较通常是一个错误，可能是拼写错误或重构错误。这对读者来说可能会造成困惑，并可能引入运行时错误。

**无效：**

```typescript
if (x === x) {
}
if ("x" === "x") {
}
if (a.b === a.b) {
}
if (a["b"] === a["b"]) {
}
```

**有效：**

```typescript
if (x === y) {
}
if ("x" === "y") {
}
if (a.b === a.c) {
}
if (a["b"] === a["c"]) {
}
```

---

# lint/rules/no-setter-return.md

URL: https://docs.deno.com/lint/rules/no-setter-return


不允许从设置器返回值。

设置器应该用于给属性设置某个值，这意味着从设置器返回值是没有意义的。实际上，返回的值会被忽略，根本无法使用，尽管从设置器返回值不会产生错误。这就是为什么静态检查这种错误的 lint 工具是非常有益的原因。

请注意，返回时不带值是被允许的；这是一种用于从函数中提前返回的有用技巧。

**无效示例：**

```typescript
const a = {
  set foo(x: number) {
    return "something";
  },
};

class B {
  private set foo(x: number) {
    return "something";
  }
}

const c = {
  set foo(x: boolean) {
    if (x) {
      return 42;
    }
  },
};
```

**有效示例：**

```typescript
// 返回时不带值是允许的，因为它用于提前返回
const a = {
  set foo(x: number) {
    if (x % 2 == 0) {
      return;
    }
  },
};

// 不是设置器，而是获取器
class B {
  get foo() {
    return 42;
  }
}

// 不是设置器
const c = {
  set(x: number) {
    return "something";
  },
};
```

---

# lint/rules/no-shadow-restricted-names.md

URL: https://docs.deno.com/lint/rules/no-shadow-restricted-names


禁止对受限名称的遮蔽。

以下 (a) 是全局对象的属性，或者 (b) 标识符在 JavaScript 中是“受限”名称：

- [`NaN`]
- [`Infinity`]
- [`undefined`]
- [`eval`]
- [`arguments`]

这些名称在 JavaScript 中并不是保留的，这意味着没有任何东西可以阻止人们将其他值赋值给它们（即遮蔽）。换句话说，您可以将 `undefined` 用作标识符或变量名。（有关更多详细信息，请参见 [MDN]）

[`NaN`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN
[`Infinity`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity
[`undefined`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined
[`eval`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval
[`arguments`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
[MDN]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined#description

```typescript
function foo() {
  const undefined = "bar";
  console.log(undefined); // 输出: "bar"
}
```

当然，像这样遮蔽很可能会让其他开发者感到困惑，应该避免这种情况。此 lint 规则会检测并发出警告。

**无效：**

```typescript
const undefined = 42;

function NaN() {}

function foo(Infinity) {}

const arguments = () => {};

try {
} catch (eval) {}
```

**有效：**

```typescript
// 如果未赋值，`undefined` 可能被遮蔽
const undefined;

const Object = 42;

function foo(a: number, b: string) {}

try {
} catch (e) {}
```

---

# lint/rules/no-sloppy-imports.md

URL: https://docs.deno.com/lint/rules/no-sloppy-imports


强制在模块说明符中指定显式路径引用。

非显式说明符是模糊的，需要在每次运行时查找正确的文件路径，这会带来性能开销。

注意：此 lint 规则仅在使用 `--unstable-sloppy-imports` 时激活。

### 无效示例：

```typescript
import { add } from "./math/add";
import { ConsoleLogger } from "./loggers";
```

### 有效示例：

```typescript
import { add } from "./math/add.ts";
import { ConsoleLogger } from "./loggers/index.ts";
```

---

# lint/rules/no-slow-types.md

URL: https://docs.deno.com/lint/rules/no-slow-types


强制使用明确或可以简单推断的类型。

阅读更多：https://jsr.io/docs/about-slow-types

---

# lint/rules/no-sparse-arrays.md

URL: https://docs.deno.com/lint/rules/no-sparse-arrays


不允许稀疏数组。

稀疏数组是包含 _空槽_ 的数组，这些空槽可能被处理为 `undefined` 值，或者被数组方法跳过，这可能导致意想不到的行为：

```typescript
[1, , 2].join(); // => '1,,2'
[1, undefined, 2].join(); // => '1,,2'

[1, , 2].flatMap((item) => item); // => [1, 2]
[1, undefined, 2].flatMap((item) => item); // => [1, undefined, 2]
```

**无效：**

```typescript
const items = ["foo", , "bar"];
```

**有效：**

```typescript
const items = ["foo", "bar"];
```

---

# lint/rules/no-sync-fn-in-async-fn.md

URL: https://docs.deno.com/lint/rules/no-sync-fn-in-async-fn


不允许在异步函数内部使用同步函数。

使用像 `Deno.readTextFileSync` 这样的同步函数会阻塞 Deno 事件循环，因此不推荐在异步函数内使用它，因为它会停止所有其他异步任务的进程。

**无效示例：**

```javascript
async function foo() {
  Deno.readTextFileSync("");
}

const fooFn = async function foo() {
  Deno.readTextFileSync("");
};

const fooFn = async () => {
  Deno.readTextFileSync("");
};
```

**有效示例：**

```javascript
async function foo() {
  await Deno.readTextFile("");
}

function foo() {
  Deno.readTextFileSync("");
}

const fooFn = function foo() {
  Deno.readTextFileSync("");
};

const fooFn = () => {
  Deno.readTextFileSync("");
};
```

---

# lint/rules/no-this-alias.md

URL: https://docs.deno.com/lint/rules/no-this-alias


不允许将变量赋值给 `this`。

在大多数情况下，通过正确使用箭头函数，可以避免将 `this` 存储在变量中，因为它们根据定义箭头函数的作用域确定 `this`。

让我们看一个具体的例子：

```typescript
const obj = {
  count: 0,
  doSomethingLater() {
    setTimeout(function () { // 这个函数在全局作用域中执行；`this` 评估为 `globalThis`
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater();
// 打印 `NaN`，因为属性 `count` 不在全局作用域中。
```

在上面的例子中，传递给 `setTimeout` 的函数中的 `this` 评估为 `globalThis`，这导致预期的值 `1` 没有被打印。

如果您想在不使用箭头函数的情况下解决这个问题，可以将 `this` 的引用存储在另一个变量中：

```typescript
const obj = {
  count: 0,
  doSomethingLater() {
    const self = this; // 将 `this` 存储在 `self` 中
    setTimeout(function () {
      // 使用 `self` 代替 `this`
      self.count++;
      console.log(self.count);
    }, 300);
  },
};

obj.doSomethingLater();
// 打印 `1`，如预期
```

但在这种情况下，箭头函数非常有用。使用箭头函数，代码变得更加清晰和易于理解：

```typescript
const obj = {
  count: 0,
  doSomethingLater() {
    setTimeout(() => { // 使用箭头函数
      // 此处 `this` 评估为 `obj`
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater();
// 打印 `1`，如预期
```

这个例子来自
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。

**无效的：**

```typescript
const self = this;

function foo() {
  const self = this;
}

const bar = () => {
  const self = this;
};
```

**有效的：**

```typescript
const self = "this";

const [foo] = this;
```

---

# lint/rules/no-this-before-super.md

URL: https://docs.deno.com/lint/rules/no-this-before-super


不允许在构造函数中调用 `super()` 前使用 `this` 或 `super`。

在派生类的构造函数中，调用 `super()` 前访问 `this` 或 `super` 会导致 [`ReferenceError`]。为了防止这种情况，这个 lint 规则检查构造函数中在调用 `super()` 之前是否访问了 `this` 或 `super`。

[`ReferenceError`]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError

**无效:**

```typescript
class A extends B {
  constructor() {
    this.foo = 0;
    super();
  }
}

class C extends D {
  constructor() {
    super.foo();
    super();
  }
}
```

**有效:**

```typescript
class A extends B {
  constructor() {
    super();
    this.foo = 0;
  }
}

class C extends D {
  constructor() {
    super();
    super.foo();
  }
}

class E {
  constructor() {
    this.foo = 0;
  }
}
```

---

# lint/rules/no-throw-literal.md

URL: https://docs.deno.com/lint/rules/no-throw-literal


禁止将文字量作为异常抛出。

仅`throw` `Error`对象本身或使用`Error`对象作为基类的自定义异常对象被认为是一种良好的实践。`Error`对象的根本好处在于它们自动跟踪它们的构建和来源位置。

**无效示例：**

```typescript
throw "error";
throw 0;
throw undefined;
throw null;
```

**有效示例：**

```typescript
throw new Error("error");
```

---

# lint/rules/no-top-level-await.md

URL: https://docs.deno.com/lint/rules/no-top-level-await


不允许使用顶级 await 表达式。

在通过 dnt 分发 CommonJS/UMD 时，无法使用顶级 await。

**无效示例：**

```typescript
await foo();
for await (item of items) {}
```

**有效示例：**

```typescript
async function foo() {
  await task();
}
async function bar() {
  for await (item of items) {}
}
```

---

# lint/rules/no-undef.md

URL: https://docs.deno.com/lint/rules/no-undef


不允许使用未声明的变量。

**无效:**

```typescript
const foo = someFunction();
const bar = a + 1;
```

---

# lint/rules/no-unreachable.md

URL: https://docs.deno.com/lint/rules/no-unreachable


禁止在控制流语句之后写无法到达的代码。

因为控制流语句（`return`、`throw`、`break` 和 `continue`）
会无条件地退出代码块，所以它们后面的任何语句都无法执行。

**无效示例:**

```typescript
function foo() {
  return true;
  console.log("完成");
}
```

```typescript
function bar() {
  throw new Error("哎呀！");
  console.log("完成");
}
```

```typescript
while (value) {
  break;
  console.log("完成");
}
```

```typescript
throw new Error("哎呀！");
console.log("完成");
```

```typescript
function baz() {
  if (Math.random() < 0.5) {
    return;
  } else {
    throw new Error();
  }
  console.log("完成");
}
```

```typescript
for (;;) {}
console.log("完成");
```

**有效示例:**

```typescript
function foo() {
  return bar();
  function bar() {
    return 1;
  }
}
```

---

# lint/rules/no-unsafe-finally.md

URL: https://docs.deno.com/lint/rules/no-unsafe-finally


不允许在 `finally` 块中使用控制流语句。

使用控制流语句（`return`、`throw`、`break` 和 `continue`）
会覆盖在 `try` 或 `catch` 块中可能使用的任何控制流语句，这通常不是期望的行为。

**无效示例：**

```typescript
let foo = function () {
  try {
    return 1;
  } catch (err) {
    return 2;
  } finally {
    return 3;
  }
};
```

```typescript
let foo = function () {
  try {
    return 1;
  } catch (err) {
    return 2;
  } finally {
    throw new Error();
  }
};
```

**有效示例：**

```typescript
let foo = function () {
  try {
    return 1;
  } catch (err) {
    return 2;
  } finally {
    console.log("hola!");
  }
};
```

---

# lint/rules/no-unsafe-negation.md

URL: https://docs.deno.com/lint/rules/no-unsafe-negation


禁止将否定运算符 `!` 作为关系运算符的左操作数。

出现在以下运算符左操作数中的 `!` 运算符有时会由于运算符优先级而导致意外行为：

- `in` 运算符
- `instanceof` 运算符

例如，当开发者编写代码 `!key in someObject` 时，他们最有可能希望它的行为与 `!(key in someObject)` 一致，但实际上它表现得像 `(!key) in someObject`。这个 lint 规则会警告这种 `!` 运算符的使用，以减少混淆。

**无效：**

<!-- deno-fmt-ignore -->

```typescript
if (!key in object) {}
if (!foo instanceof Foo) {}
```

**有效：**

```typescript
if (!(key in object)) {}
if (!(foo instanceof Foo)) {}
if ((!key) in object) {}
if ((!foo) instanceof Foo) {}
```

---

# lint/rules/no-unused-labels.md

URL: https://docs.deno.com/lint/rules/no-unused-labels


禁止未使用的标签。

声明但从未使用的标签很可能是开发者的错误。如果该标签是打算使用的，那么请编写代码以便使用它。否则，请删除该标签。

**无效：**

```typescript
LABEL1:
while (true) {
  console.log(42);
}

LABEL2:
for (let i = 0; i < 5; i++) {
  console.log(42);
}

LABEL3:
for (const x of xs) {
  console.log(x);
}
```

**有效：**

```typescript
LABEL1:
while (true) {
  console.log(42);
  break LABEL1;
}

LABEL2:
for (let i = 0; i < 5; i++) {
  console.log(42);
  continue LABEL2;
}

for (const x of xs) {
  console.log(x);
}
```

---

# lint/rules/no-unused-vars.md

URL: https://docs.deno.com/lint/rules/no-unused-vars


强制所有变量至少被使用一次。

如果有声明但在任何地方未使用的变量，很可能是因为重构不完整。此 lint 规则会检测并警告这些未使用的变量。

变量 `a` 被认为是“使用过的”，如果满足以下任何条件：

- 它的值被读取，例如 `console.log(a)` 或 `let otherVariable = a;`
- 它被调用或构造，例如 `a()` 或 `new a()`
- 它被导出，例如 `export const a = 42;`

如果一个变量只是被赋值但从未被读取，那么它被视为 _“未使用”_。

```typescript
let a;
a = 42;

// `a` 从未被读取
```

如果你想故意声明未使用的变量，可以在前面加上下划线字符 `_`，比如 `_a`。此规则会忽略以 `_` 开头的变量。

**无效的：**

```typescript
const a = 0;

const b = 0; // 这个 `b` 从未被使用
function foo() {
  const b = 1; // 这个 `b` 被使用
  console.log(b);
}
foo();

let c = 2;
c = 3;

// 递归函数调用不被视为已使用，因为只有在 `d`
// 从函数体外被调用时，我们才能说 `d` 实际上
// 被调用了。
function d() {
  d();
}

// `x` 从未被使用
export function e(x: number): number {
  return 42;
}

const f = "未使用的变量";
```

**有效的：**

```typescript
const a = 0;
console.log(a);

const b = 0;
function foo() {
  const b = 1;
  console.log(b);
}
foo();
console.log(b);

let c = 2;
c = 3;
console.log(c);

function d() {
  d();
}
d();

export function e(x: number): number {
  return x + 42;
}

export const f = "被导出的变量";
```

---

# lint/rules/no-unversioned-import.md

URL: https://docs.deno.com/lint/rules/no-unversioned-import


确保内联依赖导入包含版本号。

### 不正确示例：

```ts
import foo from "npm:chalk";
import foo from "jsr:@std/path";
```

### 正确示例：

```ts
import foo from "npm:chalk@5.3.0";
import foo from "npm:chalk@^5.3.0";
import foo from "jsr:@std/path@1.0.8";
import foo from "jsr:@std/path@^1.0.8";
```

---

# lint/rules/no-useless-rename.md

URL: https://docs.deno.com/lint/rules/no-useless-rename


禁止无用的重命名操作，当原始名称和新名称完全相同时。这通常是重构过程中留下的，可以安全地删除。

**无效：**

```ts
import { foo as foo } from "foo";
const { foo: foo } = obj;
export { foo as foo };
```

**有效：**

```ts
import { foo as bar } from "foo";
const { foo: bar } = obj;
export { foo as bar };
```

---

# lint/rules/no-var.md

URL: https://docs.deno.com/lint/rules/no-var


强制使用块作用域变量，而不是更容易出错的函数作用域变量。块作用域变量使用 `const` 和 `let` 关键字定义。

`const` 和 `let` 关键字确保使用这些关键字定义的变量在其块作用域之外不可访问。另一方面，使用 `var` 关键字定义的变量仅限于其函数作用域。

**无效：**

```typescript
var foo = "bar";
```

**有效：**

```typescript
const foo = 1;
let bar = 2;
```

---

# lint/rules/no-window-prefix.md

URL: https://docs.deno.com/lint/rules/no-window-prefix


禁止通过 `window` 对象使用 Web APIs。

在大多数情况下，全局变量 `window` 如同 `globalThis`。例如，你可以像 `window.fetch(..)` 这样调用 `fetch` API，而不是使用 `fetch(..)` 或 `globalThis.fetch(..)`。然而，在 Web Workers 中，`window` 是不可用的，而是可以使用 `self`、`globalThis`，或者不使用任何前缀。因此，为了在 Web Workers 和其他上下文之间实现兼容，强烈建议不要通过 `window` 访问全局属性。

一些 API，包括 `window.alert`、`window.location` 和 `window.history`，可以用 `window` 来调用，因为这些 API 在 Workers 中不被支持或有不同的含义。换句话说，这个 lint 规则只会对完全可以用 `self`、`globalThis` 或不使用前缀来替代的 `window` 使用进行投诉。

**无效：**

```typescript
const a = await window.fetch("https://deno.land");

const b = window.Deno.metrics();
```

**有效：**

```typescript
const a1 = await fetch("https://deno.land");
const a2 = await globalThis.fetch("https://deno.land");
const a3 = await self.fetch("https://deno.land");

const b1 = Deno.metrics();
const b2 = globalThis.Deno.metrics();
const b3 = self.Deno.metrics();

// `alert` 允许使用 `window` 调用，因为它在 Workers 中不被支持
window.alert("🍣");

// `location` 也被允许
window.location.host;
```

---

# lint/rules/no-window.md

URL: https://docs.deno.com/lint/rules/no-window


不允许使用 `window` 对象。

`window` 全局在 Deno 中不再可用。Deno 没有窗口，`typeof window === "undefined"` 通常用于判断代码是否在浏览器中运行。

**无效：**

```typescript
const a = await window.fetch("https://deno.land");

const b = window.Deno.metrics();
console.log(window);

window.addEventListener("load", () => {
  console.log("Loaded.");
});
```

**有效：**

```typescript
const a1 = await fetch("https://deno.land");
const a2 = await globalThis.fetch("https://deno.land");
const a3 = await self.fetch("https://deno.land");

const b1 = Deno.metrics();
const b2 = globalThis.Deno.metrics();
const b3 = self.Deno.metrics();
console.log(globalThis);

addEventListener("load", () => {
  console.log("Loaded.");
});
```

---

# lint/rules/no-with.md

URL: https://docs.deno.com/lint/rules/no-with


不允许使用 `with` 语句。

`with` 语句不被推荐，因为它可能是导致困惑的错误和兼容性问题的源头。有关更多详情，请参阅 [with - JavaScript | MDN]。

[with - JavaScript | MDN]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with

**无效示例：**

```typescript
with (someVar) {
  console.log("foo");
}
```

---

# lint/rules/prefer-as-const.md

URL: https://docs.deno.com/lint/rules/prefer-as-const


推荐使用常量断言（`as const`）而不是显式指定字面量类型或使用类型断言。

在声明一个新的原始字面量类型变量时，有三种方式：

1. 添加显式类型注解
2. 使用普通类型断言（如 `as "foo"` 或 `<"foo">`）
3. 使用常量断言（`as const`）

此 lint 规则建议使用常量断言，因为这通常会导致更安全的代码。有关常量断言的更多细节，请参见 [官方手册](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)。

**无效：**

```typescript
let a: 2 = 2; // 类型注解
let b = 2 as 2; // 类型断言
let c = <2> 2; // 类型断言
let d = { foo: 1 as 1 }; // 类型断言
```

**有效：**

```typescript
let a = 2 as const;
let b = 2 as const;
let c = 2 as const;
let d = { foo: 1 as const };

let x = 2;
let y: string = "hello";
let z: number = someVariable;
```

---

# lint/rules/prefer-ascii.md

URL: https://docs.deno.com/lint/rules/prefer-ascii


确保代码完全使用 ASCII 字符编写。

V8，Deno 依赖的 JavaScript 引擎，提供了一种方法，使字符串在 V8 的堆外分配内存。特别是，如果字符串只由单字节字符组成，V8 可以通过 [`v8::String::ExternalOneByteStringResource`] 更有效地处理它们。为了在 Deno 的内部利用这个 V8 特性，这条规则检查代码中的所有字符是否为 ASCII。

[`v8::String::ExternalOneByteStringResource`]: https://v8.github.io/api/head/classv8_1_1String_1_1ExternalOneByteStringResource.html

也就是说，您可以将此 lint 规则用于 Deno 的内部 JavaScript 代码之外的其他用途。如果您想确保代码库仅由 ASCII 字符组成（例如，出于某种原因想要禁止非 ASCII 标识符），那么这条规则将非常有帮助。

**无效：**

```typescript
const π = Math.PI;

// 字符串文字也会被检查
const ninja = "🥷";

function こんにちは(名前: string) {
  console.log(`こんにちは、${名前}さん`);
}

// “注释”也会被检查
// ^        ^
// |        U+201D
// U+201C
```

**有效：**

```typescript
const pi = Math.PI;

const ninja = "ninja";

function hello(name: string) {
  console.log(`Hello, ${name}`);
}

// "注释"也会被检查
```

---

# lint/rules/prefer-const.md

URL: https://docs.deno.com/lint/rules/prefer-const


建议使用 [`const`] 声明变量，而不是 [`let`]。

自 ES2015 起，JavaScript 支持使用 [`let`] 和 [`const`] 来声明变量。如果变量使用 [`let`] 声明，那么它们变得可变；我们可以在后面为它们赋值。与此同时，如果使用 [`const`] 声明，则它们是不可变的；我们不能对它们进行重新赋值。

一般来说，为了使代码库更加健壮、可维护和可读，强烈建议在可能的情况下使用 [`const`] 而不是 [`let`]。可变变量越少，跟踪变量状态就越容易，从而在阅读代码时发生错误的可能性就越小。因此，这个 lint 规则会检查是否存在可以使用 [`const`] 替代的 [`let`] 变量。

请注意，此规则不检查 [`var`] 变量。相反，[`no-var` 规则](/lint/rules/no-var) 负责检测和警告 [`var`] 变量。

[`let`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
[`const`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const
[`var`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var

**无效示例：**

```typescript
let a = 0;

let b = 0;
someOperation(b);

// 可以使用 `const` 来替代
for (let c in someObject) {}

// 可以使用 `const` 来替代
for (let d of someArray) {}

// 首先未初始化的变量然后在同一作用域中赋值是不允许的
// 因为我们可以简单地写成 `const e = 2;`
let e;
e = 2;
```

**有效示例：**

```typescript
// 未初始化的变量是允许的
let a;

let b = 0;
b += 1;

let c = 0;
c = 1;

// 首先未初始化的变量然后在同一作用域中 _赋值两次或多次_ 是允许的
// 因为我们无法使用 `const` 来表示它
let d;
d = 2;
d = 3;

const e = 0;

// `f` 通过 `f++` 进行变更
for (let f = 0; f < someArray.length; f++) {}

// 在另一个作用域中初始化（或赋值）的变量是允许的
let g;
function func1() {
  g = 42;
}

// 有条件初始化的变量是允许的
let h;
if (trueOrFalse) {
  h = 0;
}
```

---

# lint/rules/prefer-namespace-keyword.md

URL: https://docs.deno.com/lint/rules/prefer-namespace-keyword


建议在声明 TypeScript 模块时使用 `namespace` 关键字而不是 `module` 关键字。

TypeScript 支持 `module` 关键字用于组织代码，但这种表述可能会导致与 ECMAScript 模块的混淆。从 TypeScript v1.5 开始，它为我们提供了替代关键字 `namespace`，鼓励我们在编写 TypeScript 时始终使用 `namespace`。更多细节请参见 [TypeScript v1.5 发布说明](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html#namespace-keyword)。

**无效：**

```typescript
module modA {}

declare module modB {}
```

**有效：**

```typescript
namespace modA {}

// 允许使用 "ambient modules"
// https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules
declare module "modB";
declare module "modC" {}
```

---

# lint/rules/prefer-primordials.md

URL: https://docs.deno.com/lint/rules/prefer-primordials


建议使用来自 `primordials` 的冻结原语，而不是默认的全局对象。

这个 lint 规则旨在专门用于 Deno 的内部代码。普通用户无需对他们的代码运行此规则。

原语是运行时中所有内置对象的冻结集合，我们应该在 Deno 的内部使用它们，以避免原型污染的风险。此规则检测对全局原语的直接使用，并建议用 `primordials` 对象中的相应原语进行替换。

一个这样的例子是：

```javascript
const arr = getSomeArrayOfNumbers();
const evens = arr.filter((val) => val % 2 === 0);
```

该示例的第二行应该是：

```javascript
const evens = primordials.ArrayPrototypeFilter(arr, (val) => val % 2 === 0);
```

**无效：**

```javascript
const arr = new Array();

const s = JSON.stringify({});

const i = parseInt("42");

const { ownKeys } = Reflect;
```

**有效：**

```javascript
const { Array } = primordials;
const arr = new Array();

const { JSONStringify } = primordials;
const s = JSONStringify({});

const { NumberParseInt } = primordials;
const i = NumberParseInt("42");

const { ReflectOwnKeys } = primordials;
```

---

# lint/rules/react-no-danger-with-children.md

URL: https://docs.deno.com/lint/rules/react-no-danger-with-children


使用 JSX 子元素与 `dangerouslySetInnerHTML` 一起是无效的，因为它们将被忽略。

**无效：**

```tsx
<div dangerouslySetInnerHTML={{ __html: "<h1>hello</h1>" }}>
  <h1>这将永远不会被渲染</h1>
</div>;
```

**有效：**

```tsx
<div dangerouslySetInnerHTML={{ __html: "<h1>hello</h1>" }} />;
```

---

# lint/rules/react-no-danger.md

URL: https://docs.deno.com/lint/rules/react-no-danger


防止使用 `dangerouslySetInnerHTML`，如果使用不当可能导致 XSS 漏洞。

**无效：**

```tsx
const hello = <div dangerouslySetInnerHTML={{ __html: "Hello World!" }} />;
```

**有效：**

```tsx
const hello = <div>Hello World!</div>;
```

---

# lint/rules/react-rules-of-hooks.md

URL: https://docs.deno.com/lint/rules/react-rules-of-hooks


Ensure that hooks are called correctly in React/Preact components. They must be
called at the top level of a component and not inside a conditional statement or
a loop.

**Invalid:**

```tsx
// WRONG: Called inside condition
function MyComponent() {
  if (condition) {
    const [count, setCount] = useState(0);
  }
}

// WRONG: Called inside for loop
function MyComponent() {
  for (const item of items) {
    const [count, setCount] = useState(0);
  }
}

// WRONG: Called inside while loop
function MyComponent() {
  while (condition) {
    const [count, setCount] = useState(0);
  }
}

// WRONG: Called after condition
function MyComponent() {
  if (condition) {
    // ...
  }

  const [count, setCount] = useState(0);
}
```

**Valid:**

```tsx
function MyComponent() {
  const [count, setCount] = useState(0);
}
```


---

# lint/rules/require-await.md

URL: https://docs.deno.com/lint/rules/require-await


不允许没有 await 表达式或 await 使用声明的异步函数。

一般来说，使用异步函数的主要原因是在其中使用 await 表达式或 await 使用声明。如果一个异步函数两者都没有，那么它很可能是一个无意的错误。

**无效：**

```typescript
async function f1() {
  doSomething();
}

const f2 = async () => {
  doSomething();
};

const f3 = async () => doSomething();

const obj = {
  async method() {
    doSomething();
  },
};

class MyClass {
  async method() {
    doSomething();
  }
}
```

**有效：**

```typescript
await asyncFunction();

function normalFunction() {
  doSomething();
}

async function f1() {
  await asyncFunction();
}

const f2 = async () => {
  await asyncFunction();
};

const f3 = async () => await asyncFunction();

async function f4() {
  for await (const num of asyncIterable) {
    console.log(num);
  }
}

async function f5() {
  using = createResource();
}

// 空函数是有效的
async function emptyFunction() {}
const emptyArrowFunction = async () => {};

// 生成器也是有效的
async function* gen() {
  console.log(42);
}
```

---

# lint/rules/require-yield.md

URL: https://docs.deno.com/lint/rules/require-yield


不允许没有 `yield` 的生成器函数。

JavaScript 提供了生成器函数，表示为 `function*`，我们可以在中间暂停并稍后恢复函数执行。在这些点上，我们使用 `yield` 关键字。换句话说，创建不包含 `yield` 关键字的生成器函数是没有意义的，因为这样的函数可以作为普通函数来编写。

**无效：**

```typescript
function* f1() {
  return "f1";
}
```

**有效：**

```typescript
function* f1() {
  yield "f1";
}

// 允许生成器函数为空体
function* f2() {}

function f3() {
  return "f3";
}
```

---

# lint/rules/single-var-declarator.md

URL: https://docs.deno.com/lint/rules/single-var-declarator


不允许在同一声明语句中定义多个变量。

**无效：**

```typescript
const foo = 1, bar = "2";
```

**有效：**

```typescript
const foo = 1;
const bar = "2";
```

---

# lint/rules/triple-slash-reference.md

URL: https://docs.deno.com/lint/rules/triple-slash-reference


禁止使用某些三斜杠指令，优先使用 ES6 风格导入声明。

TypeScript 的 `///` 三斜杠引用是一种指示其他模块的类型在文件中可用的方法。一般不鼓励使用三斜杠引用类型指令，优先使用 ECMAScript 模块导入。该规则报告使用 `/// <reference path="..." />`、`/// <reference types="..." />` 或 `/// <reference lib="..." />` 指令的情况。

**无效：**

```typescript
/// <reference types="foo" />
import * as foo from "foo";
```

**有效：**

```typescript
import * as foo from "foo";
```

---

# lint/rules/use-isnan.md

URL: https://docs.deno.com/lint/rules/use-isnan


不允许与 `NaN` 进行比较。

因为 `NaN` 在 JavaScript 中是独特的，它不等于任何东西，包括它自己，所以与 `NaN` 的比较结果是令人困惑的：

- `NaN === NaN` 或 `NaN == NaN` 的结果为 `false`
- `NaN !== NaN` 或 `NaN != NaN` 的结果为 `true`

因此，这条规则要求使用 `isNaN()` 或 `Number.isNaN()` 来判断值是否为 `NaN`。

**无效示例：**

```typescript
if (foo == NaN) {
  // ...
}

if (foo != NaN) {
  // ...
}

switch (NaN) {
  case foo:
    // ...
}

switch (foo) {
  case NaN:
    // ...
}
```

**有效示例：**

```typescript
if (isNaN(foo)) {
  // ...
}

if (!isNaN(foo)) {
  // ...
}
```

---

# lint/rules/valid-typeof.md

URL: https://docs.deno.com/lint/rules/valid-typeof


将 `typeof` 运算符的使用限制为一组特定的字符串字面量。

当与一个值一起使用时，`typeof` 运算符返回以下字符串之一：

- `"undefined"`
- `"object"`
- `"boolean"`
- `"number"`
- `"string"`
- `"function"`
- `"symbol"`
- `"bigint"`

此规则不允许在使用 `typeof` 运算符时与除这些字符串字面量之外的任何内容进行比较，因为这很可能表示字符串中的打字错误。该规则还不允许将 `typeof` 操作的结果与任何非字符串字面量值进行比较，例如 `undefined`，这可能表示错误地使用了关键字而不是字符串。这也包括与字符串变量进行比较，即使它们包含上述值之一，因为这无法得到保证。对此的例外是比较两个 `typeof` 操作的结果，因为这些都保证返回上述字符串之一。

**无效：**

```typescript
// 打字错误
typeof foo === "strnig";
typeof foo == "undefimed";
typeof bar != "nunber";
typeof bar !== "fucntion";

// 与非字符串字面量比较
typeof foo === undefined;
typeof bar == Object;
typeof baz === anotherVariable;
typeof foo == 5;
```

**有效：**

```typescript
typeof foo === "undefined";
typeof bar == "object";
typeof baz === "string";
typeof bar === typeof qux;
```

---

# lint/rules/verbatim-module-syntax.md

URL: https://docs.deno.com/lint/rules/verbatim-module-syntax


强制类型导入声明为类型导入。

此规则确保当启用 `verbatimModuleSyntax` TypeScript 编译器选项时，代码能够正常工作。这在分发 TypeScript 代码的库中非常有用，以便在更多场景中工作。

**无效：**

```typescript
import { Person } from "./person.ts";

const person: Person = {
  name: "David",
};
console.log(person);
```

```typescript
import { output, Person } from "./person.ts";

const person: Person = {
  name: "David",
};
output(person);
```

**有效：**

```typescript
import type { Person } from "./person.ts";

const person: Person = {
  name: "David",
};
console.log(person);
```

```typescript
import { output, type Person } from "./person.ts";

const person: Person = {
  name: "David",
};
output(person);
```

---

# Architecture Overview

> Deep dive into Deno's internal architecture, explaining core components like the runtime, compiler, and security sandbox. Learn how Deno processes requests and executes JavaScript/TypeScript code.

URL: https://docs.deno.com/runtime/contributing/architecture


## Deno 和 Linux 类比

|                       **Linux** | **Deno**                           |
| ------------------------------: | :--------------------------------- |
|                       进程     | 网络工作者                          |
|                       系统调用 | 操作                                |
|           文件描述符 (fd)      | [资源 ID (rid)](#resources)       |
|                       调度器   | Tokio                              |
| 用户空间: libc++ / glib / boost | https://jsr.io/@std                |
|                 /proc/\$\$/stat | [Deno.metrics()](#metrics)         |
|                       手册页   | deno 类型 / https://docs.deno.com |

### 资源

资源（也称为 `rid`）是 Deno 的文件描述符版本。它们是用于引用打开的文件、套接字和其他概念的整数值。对于测试来说，能够查询系统中有多少个打开的资源将是有益的。

```ts
console.log(Deno.resources());
// { 0: "stdin", 1: "stdout", 2: "stderr" }
Deno.close(0);
console.log(Deno.resources());
// { 1: "stdout", 2: "stderr" }
```

### 指标

指标是 Deno 用于各种统计信息的内部计数器。

```shell
> console.table(Deno.metrics())
┌─────────────────────────┬───────────┐
│          (idx)          │  值       │
├─────────────────────────┼───────────┤
│      opsDispatched      │    9      │
│    opsDispatchedSync    │    0      │
│   opsDispatchedAsync    │    0      │
│ opsDispatchedAsyncUnref │    0      │
│      opsCompleted       │    9      │
│    opsCompletedSync     │    0      │
│    opsCompletedAsync    │    0      │
│ opsCompletedAsyncUnref  │    0      │
│    bytesSentControl     │   504     │
│      bytesSentData      │    0      │
│      bytesReceived      │   856     │
└─────────────────────────┴───────────┘
```

## 会议

- Ryan Dahl. (2020年5月27日).
  [关于 Deno 的一个有趣案例](https://www.youtube.com/watch?v=1b7FoBwxc7E)。
  Deno 以色列。
- Bartek Iwańczuk. (2020年10月6日).
  [Deno 内部 - 现代 JS/TS 运行时是如何构建的](https://www.youtube.com/watch?v=AOvg_GbnsbA&t=35m13s)。 巴黎 Deno。

---

# Documentation guidelines

> Guide for contributing to Deno's documentation. Learn our documentation standards, writing style, and how to submit 文档 changes.

URL: https://docs.deno.com/runtime/contributing/docs


我们欢迎并感谢对 Deno 文档的贡献。如果你发现了问题，或者想要添加内容，每个页面底部都有一个“编辑此页面”的按钮。点击此按钮将带你到该页面在 [Deno 文档库](https://github.com/denoland/docs/) 中的源文件。然后你可以进行更改并提交拉取请求。

Deno 文档中的某些页面是从 Deno 库中的源文件生成的。这些页面不能直接编辑：

- [API 参考](/api/deno/) 页面是从 Deno 库中的类型定义生成的。
- 每个单独命令的 [CLI 参考](/runtime/reference/cli/) 页面是从 Deno 库中的源文件生成的。

如果你发现这些页面中的问题，你可以向 Deno 库提交拉取请求，或者在 [Deno 文档库](https://github.com/denoland/docs/issues) 中提出问题，我们会对此进行修复。
## Running the docs locally

You can fork and clone the entire
[Deno docs repository](https://github.com/denoland/docs) to your local machine
and run the docs locally. This is useful if you want to see how your changes
will look before submitting a pull request.

1. Fork the [Deno docs repository](https://github.com/denoland/docs).
2. Clone your fork to your local machine with `git clone`.
3. Change directory into the `docs` directory you just cloned.
4. Run the docs repo locally with `deno task serve`.
5. Open your browser and navigate to `http://localhost:3000`.
6. Optionally, generate the API documentation with `deno task reference`.

To see a more detailed description of available tasks, check out the
[Deno docs README](https://github.com/denoland/docs?tab=readme-ov-file#deno-docs)


---

# 贡献一个示例

> Learn how to create and contribute meaningful examples to the Deno docs.

URL: https://docs.deno.com/runtime/contributing/examples


[Deno 示例](/examples/) 是一个展示如何使用 Deno 及其 API 的示例集合。如果您贡献一个示例，我们将送您一包免费的贴纸！

![Deno 贴纸铺在桌子上](./images/stickers.jpg)

## 贡献一个示例

如果您有一个 Deno 示例想要与社区分享，您可以将其贡献到
[Deno 文档库](https://github.com/denoland/docs?tab=readme-ov-file#examples)
或者提出一个问题，告诉我们您希望看到的示例。如果您的示例被合并，我们将以作者的名义给您致谢，并送您一些很棒的特别版 Deno 贴纸，以展示您作为贡献者的身份，作为我们感谢的象征。

## 获取您的贴纸

如果您贡献了一个示例，请通过电子邮件与我们联系，发至
[docs@deno.com](mailto:docs@deno.com)，告诉我们您以便我们能够将贴纸寄给您！

---

# 贡献与支持

> 关于如何为 Deno 项目和生态系统做出贡献的指南。了解不同的 Deno 仓库、贡献方针，以及如何提交高质量的拉取请求。

URL: https://docs.deno.com/runtime/contributing/


我们欢迎并感谢所有对 Deno 的贡献。

本页旨在帮助您开始贡献。

## 项目

在 [`denoland`](https://github.com/denoland) 组织中，存在许多属于 Deno 生态系统的代码库。

这些代码库的类型多样，使用不同的编程语言，贡献难度也各不相同。

为了帮助您决定哪个代码库可能是开始贡献的最佳选择（或最符合您的兴趣），以下是一个简短的对比（**主要由粗体字标注的语言**）：

### [deno](https://github.com/denoland/deno)

这是提供 `deno` 命令行工具的主仓库。

语言：**Rust**、**JavaScript**、**TypeScript**

### [deno_std](https://github.com/denoland/deno_std)

Deno 的标准库。

语言：**TypeScript**、WebAssembly

### [fresh](https://github.com/denoland/fresh)

下一代网页框架。

语言：**TypeScript**、TSX

### [deno_lint](https://github.com/denoland/deno_lint)

驱动 `deno lint` 子命令的代码质量检测工具。

语言：**Rust**

### [deno_doc](https://github.com/denoland/deno_doc)

文档生成器，支撑 `deno doc` 命令，以及 https://docs.deno.com/api 和 https://jsr.io 上的参考文档。

语言：**Rust**

### [rusty_v8](https://github.com/denoland/rusty_v8)

V8 JavaScript 引擎的 Rust 绑定，非常底层且技术性强。

语言：**Rust**

### [serde_v8](https://github.com/denoland/deno_core/tree/main/serde_v8)

提供 V8 与 Rust 对象之间相互转换的库，基于 [`serde`](https://crates.io/crates/serde)。技术性较强。

语言：**Rust**

### [deno_docker](https://github.com/denoland/deno_docker)

Deno 的官方 Docker 镜像。

## 一般注意事项

- 请阅读 [风格指南](/runtime/contributing/style_guide)。

- 请勿让 [基准测试](https://deno.land/benchmarks) 变得更差。

- 在 [社区聊天室](https://discord.gg/deno) 寻求帮助。

- 如果您准备处理某个问题，请在开始工作前在该问题的讨论中提及。

- 如果您准备开发新特性，请在开始工作前创建一个问题并与其他贡献者讨论；我们欢迎所有贡献，但并非所有提案都会被采纳。我们不希望您为可能不会被接受的代码花费数小时。

- 在论坛中保持专业。我们遵守 [Rust 的行为准则](https://www.rust-lang.org/policies/code-of-conduct)(CoC)。遇到问题？请联系邮箱 [ry@tinyclouds.org](mailto:ry@tinyclouds.org)。

## 提交拉取请求

在向任何仓库提交 PR 之前，请确保完成以下事项：

1. 给 PR 起一个描述性标题。

良好的 PR 标题示例：

- fix(std/http): 修复服务器中的竞争条件
- docs(console): 更新文档字符串
- feat(doc): 处理嵌套重新导出

不佳的 PR 标题示例：

- fix #7123
- update docs
- fix bugs

2. 确保关联了相关问题，并在 PR 内容中引用。

3. 确保有覆盖变更的测试。

## 文档化 API

详细记录所有公共 API 十分重要，我们希望尽可能在代码中进行文档注释。这有助于确保代码与文档紧密结合。

### JavaScript 与 TypeScript

所有公开暴露的 API 和类型，无论是通过 `deno` 模块还是全局/`window` 命名空间，都应有 JSDoc 注释。这些注释会被解析，并提供给 TypeScript 编译器，从而方便后续使用。JSDoc 注释块位于对应语句之前，以 `/**` 开始，以 `*/` 结束。例如：

```ts
/** 一个简单的 JSDoc 注释 */
export const FOO = "foo";
```

更多内容请参见：https://jsdoc.app/

### Rust

请按照 [该指南](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html) 编写 Rust 代码中的文档注释。

## 性能分析

在贡献性能敏感部分时，进行性能分析非常有帮助，可确保改动不带来负面影响或验证优化的效果。

### 使用 Samply

[Samply](https://github.com/mstange/samply) 是一款适用于 macOS 和 Linux 的采样剖析器，与 Deno 配合良好。它可以生成火焰图，帮助你可视化 CPU 时间的分布。

```sh
# 基本用法
samply record -r 20000 deno run -A main.js
```

生成的火焰图可以帮助你识别：

- CPU 时间主要花费的位置（热点）
- 异常的函数调用
- 潜在的优化空间

在提交涉及性能改进的贡献时，附上剖析数据可以帮助团队理解和验证你的改进效果。

---

# Release Schedule

> Overview of Deno's release cycle and versioning process. Learn about stable releases, canary builds, and how to manage different Deno versions including upgrading to specific builds.

URL: https://docs.deno.com/runtime/contributing/release_schedule


`deno` CLI 的新小版本计划每 12 周发布一次。

请查看 [Deno GitHub 的里程碑](https://github.com/denoland/deno/milestones) 了解即将发布的版本。

通常在小版本发布后会有几个补丁版本（每周进行一次）；之后，新的功能合并窗口将为即将到来的小版本发布打开。

稳定版本可以在 [GitHub 发布页面](https://github.com/denoland/deno/releases) 上找到。

## Canary 渠道

除了上述稳定渠道外，Canary 版本每天多次发布（针对每次主分支上的提交）。您可以通过运行以下命令升级到最新的 Canary 版本：

```console
deno upgrade --canary
```

要更新到特定的 Canary 版本，请在 `--version` 选项中传递提交哈希：

```console
deno upgrade --canary --version=973af61d8bb03c1709f61e456581d58386ed4952
```

要切换回稳定渠道，请运行 `deno upgrade`。

Canary 版本可以从 https://dl.deno.land 下载。

---

# Deno 风格指南

> 为 Deno 的内部运行时代码和标准库贡献提供的全面风格指南。涵盖编码约定、文档标准、测试要求及 TypeScript 和 Rust 开发的最佳实践。

URL: https://docs.deno.com/runtime/contributing/style_guide


:::note

请注意，这是 Deno 运行时和 Deno 标准库中**内部运行时代码**的风格指南。这并不是面向 Deno 用户的一般风格指南。

:::

### 版权头

大多数模块应包含以下版权头：

```ts
// 版权 2018-2024 Deno 作者。保留所有权利。MIT 许可证。
```

如果代码来源于其他地方，请确保文件包含适当的版权头。我们仅允许 MIT、BSD 和 Apache 许可代码。

### 文件名使用下划线而非破折号

示例：使用 `file_server.ts` 而不是 `file-server.ts`。

### 为新功能添加测试

每个模块应包含或伴随有其公共功能的测试。

### TODO 注释

TODO 注释通常应包含一个问题或作者的 GitHub 用户名在括号中。示例：

```ts
// TODO(ry): 添加测试。
// TODO(#123): 支持 Windows。
// FIXME(#349): 有时会崩溃。
```

### 不鼓励元编程，包括使用 Proxy

要明确，即使这意味着更多的代码。

在某些情况下，使用这种技术可能是合情合理的，但在绝大多数情况下并非如此。

### 包容性代码

请遵循在 https://chromium.googlesource.com/chromium/src/+/HEAD/styleguide/inclusive_code.md 中概述的包容性代码指南。

### Rust

遵循 Rust 约定，并与现有代码保持一致。

### TypeScript

代码库的 TypeScript 部分为标准库 `std`。

#### 使用 TypeScript 而不是 JavaScript

#### 不要使用文件名 `index.ts`/`index.js`

Deno 并不会以特殊方式处理 "index.js" 或 "index.ts"。使用这些文件名会暗示可以在模块说明符中省略它们，而实际上并不能。这是困惑的。

如果代码目录需要一个默认入口点，请使用文件名 `mod.ts`。文件名 `mod.ts` 遵循 Rust 的约定，比 `index.ts` 短，并且没有关于它工作方式的任何先入之见。

#### 导出的函数：最多 2 个参数，将其余参数放入选项对象中

设计函数接口时，遵循以下规则。

1. 作为公共 API 一部分的函数接受 0-2 个必需参数，另外（如果需要）一个选项对象（所以最多 3 个）。

2. 可选参数通常应放入选项对象中。

   如果可选参数不在选项对象中并且只有一个，且似乎不可能在未来添加更多可选参数，可能是可以接受的。

3. "options" 参数是唯一的常规 "Object" 参数。

   其他参数可以是对象，但它们必须通过以下方式可与 "plain" 对象运行时区分开：

   - 区分原型（例如 `Array`、`Map`、`Date`、`class MyThing`）。
   - 一个知名的符号属性（例如可迭代的 `Symbol.iterator`）。

   这允许 API 以向后兼容的方式演变，即使选项对象的位置发生变化。

```ts
// 不好：可选参数不在选项对象中。（#2）
export function resolve(
  hostname: string,
  family?: "ipv4" | "ipv6",
  timeout?: number,
): IPAddress[] {}
```

```ts
// 好。
export interface ResolveOptions {
  family?: "ipv4" | "ipv6";
  timeout?: number;
}
export function resolve(
  hostname: string,
  options: ResolveOptions = {},
): IPAddress[] {}
```

```ts
export interface Environment {
  [key: string]: string;
}

// 不好：`env` 可能是一个常规对象，因此无法区分
// 与选项对象。（#3）
export function runShellWithEnv(cmdline: string, env: Environment): string {}

// 好。
export interface RunShellOptions {
  env: Environment;
}
export function runShellWithEnv(
  cmdline: string,
  options: RunShellOptions,
): string {}
```

```ts
// 不好：超过 3 个参数。（#1），多个可选参数。（#2）。
export function renameSync(
  oldname: string,
  newname: string,
  replaceExisting?: boolean,
  followLinks?: boolean,
) {}
```

```ts
// 好。
interface RenameOptions {
  replaceExisting?: boolean;
  followLinks?: boolean;
}
export function renameSync(
  oldname: string,
  newname: string,
  options: RenameOptions = {},
) {}
```

```ts
// 不好：参数过多。（#1）
export function pwrite(
  fd: number,
  buffer: ArrayBuffer,
  offset: number,
  length: number,
  position: number,
) {}
```

```ts
// 更好。
export interface PWrite {
  fd: number;
  buffer: ArrayBuffer;
  offset: number;
  length: number;
  position: number;
}
export function pwrite(options: PWrite) {}
```

注意：当一个参数是函数时，您可以灵活调整顺序。请参见[Deno.serve](https://docs.deno.com/api/deno/~/Deno.serve)、[Deno.test](https://docs.deno.com/api/deno/~/Deno.test)、[Deno.addSignalListener](https://docs.deno.com/api/deno/~/Deno.addSignalListener)等示例。另见[this post](https://twitter.com/jaffathecake/status/1646798390355697664)。

#### 导出所有被用作导出成员参数的接口

每当您使用的接口包含在导出成员的参数或返回类型中时，您应该导出该接口。以下是一个示例：

```ts
// my_file.ts
export interface Person {
  name: string;
  age: number;
}

export function createPerson(name: string, age: number): Person {
  return { name, age };
}

// mod.ts
export { createPerson } from "./my_file.ts";
export type { Person } from "./my_file.ts";
```

#### 最小化依赖；不应产生循环导入

尽管 `std` 没有外部依赖，但我们仍然必须小心保持内部依赖关系简单且可管理。特别要小心不要引入循环导入。

#### 如果文件名以下划线开头：`_foo.ts`，请勿链接至此文件

在某些情况下，内部模块是必要的，但其 API 并不打算稳定或链接。在这种情况下，请以下划线作为前缀。按照约定，只有它自己目录中的文件应导入它。

#### 对导出的符号使用 JSDoc

我们追求完整的文档。每个导出的符号理想上都应有一个文档行。

如果可能，使用单行 JSDoc。示例：

```ts
/** foo 做 bar。 */
export function foo() {
  // ...
}
```

重要的是文档易于人们阅读，但也需要提供附加的样式信息，以确保生成的文档更丰富。因此 JSDoc 通常应遵循 markdown 标记以增强文本。

虽然 markdown 支持 HTML 标签，但在 JSDoc 块中是禁止使用的。

代码字符串文字应使用反引号 (\`) 括起来，而不是引号。
例如：

```ts
/** 从 `deno` 模块导入某些内容。 */
```

除非参数的意图不是很明显，否则请勿对函数参数进行文档化（尽管如果它们的意图不明显，则应考虑 API）。因此，`@param` 通常不应使用。如果使用 `@param`，则不应包含 `type`，因为 TypeScript 已经是强类型的。

```ts
/**
 * 带有不明显参数的函数。
 * @param foo 不明显参数的描述。
 */
```

在任何可能的情况下，垂直间距应最小化。因此，单行注释应写成：

```ts
/** 这是一个好的单行 JSDoc。 */
```

而不是：

```ts
/**
 * 这是一个坏的单行 JSDoc。
 */
```

代码示例应使用 markdown 格式，如下所示：

````ts
/** 一个简单的注释和示例：
 * ```ts
 * import { foo } from "deno";
 * foo("bar");
 * ```
 */
````

代码示例不应包含额外的注释，并且必须没有缩进。
它已经在注释内。如果需要进一步的注释，它就不是一个好的示例。

#### 使用指令解决 lint 问题

目前，构建过程使用 `dlint` 来检查代码中的 lint 问题。如果任务需要不符合 linter 的代码，请使用 `deno-lint-ignore <code>` 指令来抑制警告。

```typescript
// deno-lint-ignore no-explicit-any
let x: any;
```

这确保持续集成过程不会因 lint 问题而失败，但它应该被稀少使用。

#### 每个模块应配有测试模块

每个具有公共功能的模块 `foo.ts` 应配有测试模块 `foo_test.ts`。对于 `std` 模块的测试，应该放在 `std/tests` 中，由于它们的上下文不同；否则，它应与被测试模块同级。

#### 单元测试应明确

为了更好地理解测试，函数应被正确命名，因为它在测试命令中已提示。像是：

```console
foo() 返回 bar 对象 ... ok
```

测试示例：

```ts
import { assertEquals } from "@std/assert";
import { foo } from "./mod.ts";

Deno.test("foo() 返回 bar 对象", function () {
  assertEquals(foo(), { bar: "bar" });
});
```

注意：有关更多信息，请参见 [跟踪问题](https://github.com/denoland/deno_std/issues/3754)。

#### 顶级函数应使用 function 语法，而不是箭头语法

顶级函数应使用 `function` 关键字。箭头语法应限于闭包。

不好的：

```ts
export const foo = (): string => {
  return "bar";
};
```

好的：

```ts
export function foo(): string {
  return "bar";
}
```

常规函数和箭头函数在提升、绑定、参数和构造等方面的行为不同。`function` 关键字清楚地表明了定义函数的意图，提高了可读性和调试追踪能力。

#### 错误消息

从 JavaScript / TypeScript 抛出的面向用户的错误消息应清晰、简洁且一致。错误消息应采用句首字母大写的形式，但不应以句号结束。错误消息应避免语法错误和拼写错误，并应使用美式英语书写。

:::note

请注意，错误消息风格指南仍在进行中，并非所有错误消息都已更新以符合当前风格。

:::

应遵循的错误消息风格：

1. 消息应以大写字母开头：

```sh
不好的：无法解析输入
好的：无法解析输入
```

2. 消息不应以句号结束：

```sh
不好的：无法解析输入。
好的：无法解析输入
```

3. 消息应使用引号包裹字符串值：

```sh
不好的：无法解析输入 hello, world
好的：无法解析输入 "hello, world"
```

4. 消息应说明导致错误的操作：

```sh
不好的：无效输入 x
好的：无法解析输入 x
```

5. 应使用主动语态：

```sh
不好的：输入 x 无法被解析
好的：无法解析输入 x
```

6. 消息不应使用缩写：

```sh
不好的：无法解析输入 x
好的：无法解析输入 x
```

7. 消息在提供额外信息时应使用冒号。绝不要使用句号。可根据需要使用其他标点：

```sh
不好的：无法解析输入 x。值为空
好的：无法解析输入 x：值为空
```

8. 附加信息应描述当前状态，尽可能地，也应描述以肯定的声音所需的状态：

```sh
不好的：无法计算 x 的平方根：值不得为负
好的：无法计算 x 的平方根：当前值为 ${x}
更好：无法计算 x 的平方根，因为 x 必须 >= 0：当前值为 ${x}
```

### std

#### 不要依赖外部代码。

`https://jsr.io/@std` 旨在成为所有 Deno 程序可以依赖的基础功能。我们希望向用户保证，这段代码不包括潜在未经审查的第三方代码。

#### 记录并维护浏览器兼容性。

如果模块与浏览器兼容，请在模块顶部的 JSDoc 中包含以下内容：

```ts
// 此模块与浏览器兼容。
```

通过不使用全局的 `Deno` 命名空间或针对其进行特性检测来维护此类模块的浏览器兼容性。确保任何新的依赖项也与浏览器兼容。

#### 优先使用 # 而不是 private 关键字

我们更喜欢在标准模块代码库中使用私有字段（`#`）语法，而不是 TypeScript 的 `private` 关键字。私有字段使得属性和方法在运行时也保持私有。而 TypeScript 的 `private` 关键字仅保证在编译时私有，并且这些字段在运行时是可公开访问的。

好的：

```ts
class MyClass {
  #foo = 1;
  #bar() {}
}
```

不好的：

```ts
class MyClass {
  private foo = 1;
  private bar() {}
}
```

#### 命名约定

函数、方法、字段和局部变量使用 `camelCase`。类、类型、接口和枚举使用 `PascalCase`。静态顶级项目如 `string`、`number`、`bigint`、`boolean`、`RegExp`、静态项目数组、静态键值记录等使用 `UPPER_SNAKE_CASE`。

好的：

```ts
function generateKey() {}

let currentValue = 0;

class KeyObject {}

type SharedKey = {};

enum KeyType {
  PublicKey,
  PrivateKey,
}

const KEY_VERSION = "1.0.0";

const KEY_MAX_LENGTH = 4294967295;

const KEY_PATTERN = /^[0-9a-f]+$/;
```

不好的：

```ts
function generate_key() {}

let current_value = 0;

function GenerateKey() {}

class keyObject {}

type sharedKey = {};

enum keyType {
  publicKey,
  privateKey,
}

const key_version = "1.0.0";

const key_maxLength = 4294967295;

const KeyPattern = /^[0-9a-f]+$/;
```

当名称为 `camelCase` 或 `PascalCase` 时，请始终遵循它们的规则，即使它们的部分是首字母缩略词。

注意：Web API 使用大写缩略词（`JSON`、`URL`、`URL.createObjectURL()` 等）。Deno 标准库不遵循此约定。

好的：

```ts
class HttpObject {
}
```

不好的：

```ts
class HTTPObject {
}
```

好的：

```ts
function convertUrl(url: URL) {
  return url.href;
}
```

不好的：

```ts
function convertURL(url: URL) {
  return url.href;
}
```

---

# deno.json 和 package.json

> 配置您的 Deno 项目的指南。了解 TypeScript 设置、任务、依赖项、格式化、代码检查以及如何有效使用 deno.json 和/或 package.json。

URL: https://docs.deno.com/runtime/fundamentals/configuration


您可以使用 `deno.json` 文件来配置 Deno。该文件可用于配置 TypeScript 编译器、代码检查器、格式化工具以及其他 Deno 工具。

该配置文件支持 `.json` 和 [`.jsonc`](https://code.visualstudio.com/docs/languages/json#_json-with-comments) 扩展名。

如果在当前工作目录或父目录中检测到 `deno.json` 或 `deno.jsonc` 配置文件，Deno 将自动识别。可以使用 `--config` 标志指定不同的配置文件。

## package.json 支持

Deno 还支持 `package.json` 文件，以兼容 Node.js 项目。如果您有一个 Node.js 项目，则不必创建 `deno.json` 文件。Deno 将使用 `package.json` 文件来配置项目。

如果在同一目录中同时存在 `deno.json` 和 `package.json` 文件，Deno 将理解两个文件中指定的依赖项；并使用 `deno.json` 文件进行 Deno 特定配置。有关更多信息，请阅读 [Deno 中的 Node 兼容性](/runtime/fundamentals/node/#node-compatibility)。

## 依赖项

在您的 `deno.json` 文件中，`"imports"` 字段允许您指定项目中使用的依赖项。您可以使用它将简单的指定符映射到 URL 或文件路径，从而更轻松地管理依赖关系和模块解析。

例如，如果您想在项目中使用标准库中的 `assert` 模块，可以使用以下导入映射：

```json title="deno.json"
{
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.0",
    "chalk": "npm:chalk@5"
  }
}
```

然后，您的脚本可以使用简单的指定符 `std/assert`：

```js title="script.ts"
import { assertEquals } from "@std/assert";
import chalk from "chalk";

assertEquals(1, 2);
console.log(chalk.yellow("Hello world"));
```

您还可以在 `package.json` 中使用 `"dependencies"` 字段：

```json title="package.json"
{
  "dependencies": {
    "express": "^1.0.0"
  }
}
```

```js title="script.ts"
import express from "express";

const app = express();
```

请注意，这将要求您运行 `deno install`。

有关更多信息，请阅读 [模块导入和依赖项](/runtime/fundamentals/modules/)。

### 自定义路径映射

`deno.json` 中的导入映射可用于更一般的指定符路径映射。您可以将确切的指定符映射到第三方模块或文件，或将导入指定符的一部分映射到一个目录。

```jsonc title="deno.jsonc"
{
  "imports": {
    // 映射到一个确切的文件
    "foo": "./some/long/path/foo.ts",
    // 映射到一个目录，使用方法: "bar/file.ts"
    "bar/": "./some/folder/bar/"
  }
}
```

用法：

```ts
import * as foo from "foo";
import * as bar from "bar/file.ts";
```

导入路径映射在较大的代码库中通常用于简化代码。

要使用项目根目录进行绝对导入：

```json title="deno.json"
{
  "imports": {
    "/": "./",
    "./": "./"
  }
}
```

```ts title="main.ts"
import { MyUtil } from "/util.ts";
```

这会使以 `/` 开头的导入指定符相对于导入映射的 URL 或文件路径进行解析。

### 覆盖包

`deno.json` 中的 `links` 字段允许您用存储在磁盘上的本地包覆盖依赖项。这类似于 `npm link`。

```json title="deno.json"
{
  "links": [
    "../some-package"
  ]
}
```

此功能解决了几个常见的开发问题：

- 依赖项错误修复
- 私有本地库
- 兼容性问题

被引用的包不必发布。只需要在 `deno.json` 或 `package.json` 中具有正确的包名和元数据，Deno 就能识别它正在处理哪个包。这提供了更大的灵活性和模块化，保持主代码与外部包的清晰分离。

## 任务

您在 `deno.json` 文件中的 `tasks` 字段用于定义可以使用 `deno task` 命令执行的自定义命令，并允许您根据项目的具体需求调整命令和权限。

这与 `package.json` 文件中的 `scripts` 字段类似，也受支持。

```json title="deno.json"
{
  "tasks": {
    "start": "deno run --allow-net --watch=static/,routes/,data/ dev.ts",
    "test": "deno test --allow-net",
    "lint": "deno lint"
  }
}
```

```json title="package.json"
{
  "scripts": {
    "dev": "vite dev",
    "build": "vite build"
  }
}
```

要执行任务，请使用 `deno task` 命令后跟任务名称。例如：

```sh
deno task start
deno task test
deno task lint
deno task dev
deno task build
```

有关更多信息，请阅读 [`deno task`](/runtime/reference/cli/task_runner/)。

## 代码检查

`deno.json` 文件中的 `lint` 字段用于配置 Deno 内置代码检查器的行为。这允许您指定要包含或排除在哪些文件中进行代码检查，以及自定义代码检查规则以满足项目的需求。

例如：

```json title="deno.json"
{
  "lint": {
    "include": ["src/"],
    "exclude": ["src/testdata/", "src/fixtures/**/*.ts"],
    "rules": {
      "tags": ["recommended"],
      "include": ["ban-untagged-todo"],
      "exclude": ["no-unused-vars"]
    }
  }
}
```

此配置将：

- 仅检查 `src/` 目录中的文件，
- 排除检查 `src/testdata/` 目录中的文件或 `src/fixtures/` 目录中的任何 TypeScript 文件。
- 指定应应用推荐的代码检查规则，
- 添加对 `ban-untagged-todo` 规则的启用，
- 排除 `no-unused-vars` 规则。

您可以在 [规则列表](/lint/) 文档页面中找到所有可用的代码检查规则的完整列表。

有关更多信息，请阅读 [使用 Deno 进行代码检查](/runtime/reference/cli/linter/)。

## 格式化

`deno.json` 文件中的 `fmt` 字段用于配置 Deno 内置代码格式化程序的行为。这允许您自定义代码的格式，以确保项目的一致性，使其更易于阅读和协作。以下是您可以配置的关键选项：

```json title="deno.json"
{
  "fmt": {
    "useTabs": true,
    "lineWidth": 80,
    "indentWidth": 4,
    "semiColons": true,
    "singleQuote": true,
    "proseWrap": "preserve",
    "include": ["src/"],
    "exclude": ["src/testdata/", "src/fixtures/**/*.ts"]
  }
}
```

此配置将：

- 使用制表符而不是空格进行缩进，
- 将行限制为 80 个字符，
- 使用 4 个空格的缩进宽度，
- 在语句结束时添加分号，
- 使用单引号包裹字符串，
- 保留文本换行，
- 格式化 `src/` 目录中的文件，
- 排除 `src/testdata/` 目录中的文件和任何 TypeScript 文件。

有关更多信息，请阅读 [使用 Deno 格式化代码](/runtime/fundamentals/linting_and_formatting/)。

## 锁定文件

`deno.json` 文件中的 `lock` 字段用于指定 Deno 使用的锁定文件的配置，以 [确保依赖项的完整性](/runtime/fundamentals/modules/#integrity-checking-and-lock-files)。锁定文件记录了您的项目所依赖模块的确切版本和完整性哈希，确保在每次运行项目时使用相同的版本，即使依赖项被更新或远程更改。

```json title="deno.json"
{
  "lock": {
    "path": "./deno.lock",
    "frozen": true
  }
}
```

此配置将：

- 指定锁定文件位置为 `./deno.lock`（这是默认值，可以省略）
- 告诉 Deno 如果有任何依赖项更改则返回错误

Deno 默认使用锁定文件，您可以使用以下配置禁用它：

```json title="deno.json"
{
  "lock": false
}
```

## Node 模块目录

默认情况下，如果您的项目目录中有 `package.json` 文件，Deno 将使用本地 `node_modules` 目录。

您可以使用 `deno.json` 文件中的 `nodeModulesDir` 字段来控制此行为。

```json title="deno.json"
{
  "nodeModulesDir": "auto"
}
```

您可以将此字段设置为以下值：

| 值         | 行为                                                                                                                               |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `"none"`   | 不使用本地 `node_modules` 目录。改为使用 `$DENO_DIR` 中的全局缓存，Deno 会自动保持其最新。                                        |
| `"auto"`   | 使用本地 `node_modules` 目录。Deno 会自动创建并保持此目录的最新状态。                                                             |
| `"manual"` | 使用本地 `node_modules` 目录。用户必须手动保持此目录的最新状态，例如使用 `deno install` 或 `npm install`。                       |

不需要指定此设置，以下默认值会被应用：

- 如果您的项目目录中没有 `package.json` 文件，则为 `"none"`  
- 如果您的项目目录中有 `package.json` 文件，则为 `"manual"`

使用工作区时，此设置只能在工作区根目录中使用。在任何成员中指定此设置都会导致警告。只有在工作区根目录中有 `package.json` 文件时，`"manual"` 设置才会被自动应用。

## TypeScript 编译器选项

`deno.json` 文件中的 `compilerOptions` 字段用于配置 [TypeScript 编译器设置](https://www.typescriptlang.org/tsconfig) 以符合您的 Deno 项目。这允许您自定义 TypeScript 代码的编译方式，确保与项目的要求和编码标准一致。

:::info

Deno 推荐使用默认的 TypeScript 配置。这将有助于分享代码。

:::

另请参见 [在 Deno 中配置 TypeScript](/runtime/reference/ts_config_migration/)。

## 不稳定特性

`deno.json` 文件中的 `unstable` 字段用于启用 Deno 项目的特定不稳定特性。

这些特性仍在开发中，尚未成为稳定 API 的一部分。通过在 `unstable` 数组中列出特性，您可以在它们正式发布之前进行实验和使用这些新功能。

```json title="deno.json"
{
  "unstable": ["cron", "kv", "webgpu"]
}
```

[了解更多](/runtime/reference/cli/unstable_flags/)。

## include 和 exclude

许多配置（例如 `lint`, `fmt`）都有 `include` 和 `exclude` 属性来指定要包含的文件。

### include

这里指定的路径或模式仅会被包含。

```jsonc
{
  "lint": {
    // 仅格式化 src/ 目录
    "include": ["src/"]
  }
}
```

### exclude

这里指定的路径或模式将被排除。

```jsonc
{
  "lint": {
    // 不检查 dist/ 文件夹
    "exclude": ["dist/"]
  }
}
```

此项优先级高于 `include`，如果在 `include` 和 `exclude` 中都匹配路径，则以 `exclude` 为准。

您可能希望排除一个目录，但包含一个子目录。在 Deno 1.41.2 及更高版本中，可以通过在更一般的排除下指定否定通配符来取消排除更具体的路径：

```jsonc
{
  "fmt": {
    // 不格式化 "fixtures" 目录，
    // 但格式化 "fixtures/scripts"
    "exclude": [
      "fixtures",
      "!fixtures/scripts"
    ]
  }
}
```

### 顶级排除

如果有一个目录您永远不希望 Deno 格式化、检查、类型检查、分析等，则在顶级排除数组中指定它：

```jsonc
{
  "exclude": [
    // 从所有子命令和 LSP 中排除 dist 文件夹
    "dist/"
  ]
}
```

有时您可能会发现希望取消排除顶级排除中已排除的路径或模式。在 Deno 1.41.2 及更高版本中，可以在更具体的配置中通过指定否定通配符取消排除路径：

```jsonc
{
  "fmt": {
    "exclude": [
      // 格式化 dist 文件夹，即使在顶级被排除
      "!dist"
    ]
  },
  "exclude": [
    "dist/"
  ]
}
```

### 发布 - 覆盖 .gitignore

`.gitignore` 会被考虑在 `deno publish` 命令中。在 Deno 1.41.2 及更高版本中，您可以使用否定的排除通配符来选择不包含在 _.gitignore_ 中的排除文件：

```title=".gitignore"
dist/
.env
```

```jsonc title="deno.json"
{
  "publish": {
    "exclude": [
      // 包含被 git 忽略的 dist 文件夹
      "!dist/"
    ]
  }
}
```

另一种方法是将 git 忽略的路径明确指定在 `"include"` 中：

```json
{
  "publish": {
    "include": [
      "dist/",
      "README.md",
      "deno.json"
    ]
  }
}
```

## Exports

The `exports` field in the `deno.json` file allows you to define which paths of
your package should be publicly accessible. This is particularly useful for
controlling the API surface of your package and ensuring that only the intended
parts of your code are exposed to users.

```jsonc title="deno.json"
{
  "exports": "./src/mod.ts" // A default entry point
}
```

You can also define multiple entry points:

```json title="deno.json"
{
  "exports": {
    "./module1": "./src/module1.ts",
    "./module2": "./src/module2.ts",
    ".": "./src/mod.ts" // Default entry point
  }
}
```

This configuration will:

- expose `module1` and `module2` as entry points for your package,
- allow importing any file from the `utils` directory using a wildcard. This
  means users can import these modules using the specified paths, while other
  files in your package remain private.

To use the exports in your code, you can import them like this:

```ts title="example.ts"
import * as module_1 from "@example/my-package/module1";
import * as module_2 from "@example/my-package/module2";
```

## Permissions

Deno 2.5+ supports storing permission sets in the config file.

### Named permissions

Permissions can be defined in key value pairs under the `"permissions"` key:

```jsonc
{
  "permissions": {
    "read-data": {
      "read": "./data"
    },
    "read-and-write": {
      "read": true,
      "write": ["./data"]
    }
  }
}
```

Then used by specifying the `--permission-set=<name>` or `-P=<name>` flag:

```sh
$ deno run -P=read-data main.ts
```

### Default permission

A special `"default"` permission key allows excluding the name when using the
`--permission-set`/`-P` flag:

```jsonc
{
  "permissions": {
    "default": {
      "env": true
    }
  }
}
```

Then run with just `-P`:

```sh
$ deno run -P main.ts
```

### Test, bench, and compile permissions

Permissions can be optionally specified within the `"test"`, `"bench"`, or
`"compile"` keys.

```jsonc
{
  "test": {
    "permissions": {
      "read": ["./data"]
    }
  }
}
```

Or reference a permission set:

```jsonc
{
  "test": {
    "permissions": "read-data"
  },
  "permissions": {
    "read-data": {
      "read": ["./data"]
    }
  }
}
```

When this is defined, you must run `deno test` with `-P` or a permission flag:

```
> deno test
error: Test permissions were found in the config file. Did you mean to run with `-P`?
    at file:///Users/david/dev/example/deno.json
> deno test -P
...runs...
> deno test --allow-read
...runs...
> deno test -A
...runs...
```

This is to help prevent you waste your time wondering why something is not
working when you forget to run without permissions.

Note that test and bench files in a workspace will use the closest `deno.json`
for determining `test` and `bench` permissions. This allows giving different
permissions to different workspace members.

### Security risk

The threat model for permissions in the config file is similar to `deno task`,
in that a script could modify the `deno.json` to elevate permissions. That's why
this requires an explicit opt-in with `-P` and is not loaded by default.

If you're ok with this risk, then this feature will be useful for you.

## An example `deno.json` file

```json
{
  "compilerOptions": {
    "allowJs": true,
    "lib": ["deno.window"],
    "strict": true
  },
  "permissions": {
    "default": {
      "read": ["./src/testdata/"]
    }
  },
  "lint": {
    "include": ["src/"],
    "exclude": ["src/testdata/", "src/fixtures/**/*.ts"],
    "rules": {
      "tags": ["recommended"],
      "include": ["ban-untagged-todo"],
      "exclude": ["no-unused-vars"]
    }
  },
  "fmt": {
    "useTabs": true,
    "lineWidth": 80,
    "indentWidth": 4,
    "semiColons": false,
    "singleQuote": true,
    "proseWrap": "preserve",
    "include": ["src/"],
    "exclude": ["src/testdata/", "src/fixtures/**/*.ts"]
  },
  "lock": false,
  "nodeModulesDir": "auto",
  "unstable": ["webgpu"],
  "test": {
    "include": ["src/"],
    "exclude": ["src/testdata/", "src/fixtures/**/*.ts"]
  },
  "tasks": {
    "start": "deno run --allow-read main.ts"
  },
  "imports": {
    "oak": "jsr:@oak/oak"
  },
  "exclude": [
    "dist/"
  ]
}
```

这是一个配置了 TypeScript 编译器选项、代码检查器、格式化器、node_modules 目录等的 `deno.json` 文件示例。有关可用字段和配置的完整列表，请参阅
[Deno 配置文件模式](#json-schema)。

这是一个配置了 TypeScript 编译器选项、代码检查器、格式化器、node_modules 目录等的 `deno.json` 文件示例。有关可用字段和配置的完整列表，请参阅
[Deno 配置文件模式](#json-schema)。

## JSON 模式

可用于编辑器提供自动完成的 JSON Schema 文件可在以下位置获得： [https://github.com/denoland/deno/blob/main/cli/schemas/config-file.v1.json](https://github.com/denoland/deno/blob/main/cli/schemas/config-file.v1.json)

## 代理

Deno 支持用于模块下载和 fetch API 的代理。代理配置从 [环境变量](https://docs.deno.com/runtime/reference/env_variables/#special-environment-variables) 中读取：HTTP_PROXY，HTTPS_PROXY 和 NO_PROXY。

如果您使用的是 Windows - 如果未找到环境变量，Deno 将退回到从注册表读取代理。

---

# 调试

> Deno 应用调试完整指南。学习如何使用 Chrome DevTools、VS Code 调试器及其他调试技巧来调试 Deno 中的 TypeScript/JavaScript 代码。

URL: https://docs.deno.com/runtime/fundamentals/debugging


Deno 支持 [V8 Inspector Protocol](https://v8.dev/docs/inspector)，这是 Chrome、Edge 和 Node.js 使用的协议。这使得可以使用 Chrome DevTools 或其他支持该协议的客户端（例如 VSCode）调试 Deno 程序。

要激活调试功能，请使用以下标志之一运行 Deno：

- `--inspect`
- `--inspect-wait`
- `--inspect-brk`

## --inspect

使用 `--inspect` 标志将启动一个带有 inspector 服务器的程序，这样就可以从支持 V8 Inspector 协议的工具（例如 Chrome DevTools）连接客户端。

在 Chromium 兼容的浏览器中访问 `chrome://inspect` 以将 Deno 连接到 inspector 服务器。这允许您检查代码、添加断点并逐步执行代码。

```sh
deno run --inspect your_script.ts
```

:::note

如果您使用 `--inspect` 标志，代码将立即开始执行。如果您的程序较短，您可能没有足够的时间在程序完成执行之前连接调试器。

在这种情况下，请尝试使用 `--inspect-wait` 或 `--inspect-brk` 标志，或者在代码的结尾添加一个超时。

:::

## --inspect-wait

`--inspect-wait` 标志将在执行代码之前等待调试器连接。

```sh
deno run --inspect-wait your_script.ts
```

## --inspect-brk

`--inspect-brk` 标志将在执行代码之前等待调试器连接，然后在您连接后立即在您的程序中设置一个断点，允许您在继续执行之前添加额外的断点或评估表达式。

**这是最常用的 inspect 标志**。JetBrains 和 VSCode IDE 默认使用此标志。

```sh
deno run --inspect-brk your_script.ts
```

## 使用 Chrome DevTools 的示例

我们来尝试使用 Chrome DevTools 调试一个程序。为此，我们将使用 [@std/http/file-server](https://jsr.io/@std/http#file-server)，这是一个静态文件服务器。

使用 `--inspect-brk` 标志在第一行中暂停执行：

```sh
$ deno run --inspect-brk -RN jsr:@std/http/file-server
Debugger listening on ws://127.0.0.1:9229/ws/1e82c406-85a9-44ab-86b6-7341583480b1
...
```

在像 Google Chrome 或 Microsoft Edge 这样的 Chromium 兼容浏览器中，打开 `chrome://inspect` 并点击目标旁边的 `Inspect`：

![chrome://inspect](./images/debugger1.png)

打开 DevTools 后可能需要几秒钟才能加载所有模块。

![DevTools 已打开](./images/debugger2.jpg)

您可能会注意到 DevTools 在 `_constants.ts` 的第一行暂停执行，而不是在 `file_server.ts`。这是由于 JavaScript 中 ES 模块的评估方式造成的预期行为（`_constants.ts` 是 `file_server.ts` 的最左侧、最底部依赖项，因此它首先被评估）。

此时，所有源代码在 DevTools 中均可用，所以让我们打开 `file_server.ts` 并在此添加断点；转到 "Sources" 面板并展开树形结构：

![打开 file_server.ts](./images/debugger3.jpg)

_仔细查看您会发现每个文件都有重复条目；一个是常规写法，一个是斜体。前者是编译的源文件（因此在 `.ts` 文件的情况下，它将发出 JavaScript 源），而后者是该文件的源映射。_

接下来，在 `listenAndServe` 方法中添加一个断点：

![在 file_server.ts 中设置断点](./images/debugger4.jpg)

一旦添加了断点，DevTools 将自动打开源映射文件，这让我们可以逐步查看包含类型的实际源代码。

现在我们已经设置了断点，可以继续执行脚本，以便检查传入的请求。点击 "Resume script execution" 按钮来完成。您可能需要点击两次！

一旦我们的脚本在运行，尝试发送请求并在 DevTools 中检查它：

```sh
curl http://0.0.0.0:4507/
```

![在请求处理中设置断点](./images/debugger5.jpg)

此时我们可以检查请求的内容，并逐步调试代码。

## VSCode

可以使用 VSCode 调试 Deno。最好的方法是借助官方的 `vscode_deno` 扩展。有关此扩展的文档可以在 [这里](/runtime/reference/vscode#using-the-debugger) 找到。

## JetBrains IDEs

_**注意**：确保您已安装并在首选项/设置 | 插件中启用 [此 Deno 插件](https://plugins.jetbrains.com/plugin/14382-deno)。有关更多信息，请参见 [此博客文章](https://blog.jetbrains.com/webstorm/2020/06/deno-support-in-jetbrains-ides/)。_

您可以通过右键单击要调试的文件并选择 `Debug 'Deno: <file name>'` 选项来使用 JetBrains IDE 调试 Deno。

![调试文件](./images/jb-ide-debug.png)

这将创建一个没有权限标志的运行/调试配置。如果您想配置它们，请打开您的运行/调试配置并将所需标志添加到 `Command` 字段。

## --log-level=debug

如果您在连接 inspector 时遇到问题，可以使用 `--log-level=debug` 标志以获取有关发生情况的更多信息。这将显示例如模块解析、网络请求和其他权限检查等信息。

```sh
deno run --inspect-brk --log-level=debug your_script.ts
```

## --strace-ops

Deno ops 是一个 [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) 机制，用于在 JavaScript 和 Rust 之间提供功能，例如文件 I/O、网络和定时器。`--strace-ops` 标志将在程序运行时打印所有正在执行的 Deno ops 及其时序。

```sh
deno run --strace-ops your_script.ts
```

每个 op 都应包含一个 `Dispatch` 和一个 `Complete` 事件。这两个事件之间的时间即为执行该 op 所花费的时间。此标志对于性能分析、调试挂起的程序或了解 Deno 的底层工作原理非常有用。

## OpenTelemetry 集成

对于生产环境应用或复杂系统，OpenTelemetry 提供了更全面的可观察性和调试方案。Deno 内置支持 OpenTelemetry，允许您：

- 跟踪应用中的请求
- 监测应用性能指标
- 收集结构化日志
- 将遥测数据导出到监控系统

```sh
OTEL_DENO=true deno run your_script.ts
```

这将自动收集和导出运行时可观察性数据，包括：

- HTTP 请求跟踪
- 运行时指标
- 控制台日志和错误

有关 Deno 的 OpenTelemetry 集成的完整详细信息，包括自定义指标、跟踪和配置选项，请参见 [OpenTelemetry 文档](/runtime/fundamentals/open_telemetry)。

---

# Foreign Function Interface (FFI)

> Learn how to use Deno's Foreign Function Interface (FFI) to call native libraries directly from JavaScript or TypeScript. Includes examples, best practices, and security considerations.

URL: https://docs.deno.com/runtime/fundamentals/ffi


Deno's Foreign Function Interface (FFI) allows JavaScript and TypeScript code to
call functions in dynamic libraries written in languages like C, C++, or Rust.
This enables you to integrate native code performance and capabilities directly
into your Deno applications.

<a href="/api/deno/ffi" class="docs-cta runtime-cta">Deno FFI Reference Docs</a>

## Introduction to FFI

FFI provides a bridge between Deno's JavaScript runtime and native code. This
allows you to:

- Use existing native libraries within your Deno applications
- Implement performance-critical code in languages like Rust or C
- Access operating system APIs and hardware features not directly available in
  JavaScript

Deno's FFI implementation is based on the `Deno.dlopen` API, which loads dynamic
libraries and creates JavaScript bindings to the functions they export.

## Security considerations

FFI requires explicit permission using the
[`--allow-ffi`](/runtime/fundamentals/security#ffi-foreign-function-interface)
flag, as native code runs outside of Deno's security sandbox:

```sh
deno run --allow-ffi my_ffi_script.ts
```

:::info

<strong>Important security warning</strong>: Unlike JavaScript code running in
the Deno sandbox, native libraries loaded via FFI have the same access level as
the Deno process itself. This means they can:

- Access the filesystem
- Make network connections
- Access environment variables
- Execute system commands

Always ensure you trust the native libraries you're loading through FFI.

:::

## Basic usage

The basic pattern for using FFI in Deno involves:

1. Defining the interface for the native functions you want to call
2. Loading the dynamic library using `Deno.dlopen()`
3. Calling the loaded functions

Here's a simple example loading a C library:

```ts
const dylib = Deno.dlopen("libexample.so", {
  add: { parameters: ["i32", "i32"], result: "i32" },
});

console.log(dylib.symbols.add(5, 3)); // 8

dylib.close();
```

## Supported types

Deno's FFI supports a variety of data types for parameters and return values:

| FFI Type               | Deno                 | C                        | Rust                      |
| ---------------------- | -------------------- | ------------------------ | ------------------------- |
| `i8`                   | `number`             | `char` / `signed char`   | `i8`                      |
| `u8`                   | `number`             | `unsigned char`          | `u8`                      |
| `i16`                  | `number`             | `short int`              | `i16`                     |
| `u16`                  | `number`             | `unsigned short int`     | `u16`                     |
| `i32`                  | `number`             | `int` / `signed int`     | `i32`                     |
| `u32`                  | `number`             | `unsigned int`           | `u32`                     |
| `i64`                  | `bigint`             | `long long int`          | `i64`                     |
| `u64`                  | `bigint`             | `unsigned long long int` | `u64`                     |
| `usize`                | `bigint`             | `size_t`                 | `usize`                   |
| `isize`                | `bigint`             | `size_t`                 | `isize`                   |
| `f32`                  | `number`             | `float`                  | `f32`                     |
| `f64`                  | `number`             | `double`                 | `f64`                     |
| `void`[1]              | `undefined`          | `void`                   | `()`                      |
| `pointer`              | `{} \| null`         | `void *`                 | `*mut c_void`             |
| `buffer`[2]            | `TypedArray \| null` | `uint8_t *`              | `*mut u8`                 |
| `function`[3]          | `{} \| null`         | `void (*fun)()`          | `Option<extern "C" fn()>` |
| `{ struct: [...] }`[4] | `TypedArray`         | `struct MyStruct`        | `MyStruct`                |

As of Deno 1.25, the `pointer` type has been split into a `pointer` and a
`buffer` type to ensure users take advantage of optimizations for Typed Arrays,
and as of Deno 1.31 the JavaScript representation of `pointer` has become an
opaque pointer object or `null` for null pointers.

- [1] `void` type can only be used as a result type.
- [2] `buffer` type accepts TypedArrays as parameter, but it always returns a
  pointer object or `null` when used as result type like the `pointer` type.
- [3] `function` type works exactly the same as the `pointer` type as a
  parameter and result type.
- [4] `struct` type is for passing and returning C structs by value (copy). The
  `struct` array must enumerate each of the struct's fields' type in order. The
  structs are padded automatically: Packed structs can be defined by using an
  appropriate amount of `u8` fields to avoid padding. Only TypedArrays are
  supported as structs, and structs are always returned as `Uint8Array`s.

## Working with structs

You can define and use C structures in your FFI code:

```ts
// Define a struct type for a Point
const pointStruct = {
  fields: {
    x: "f64",
    y: "f64",
  },
} as const;

// Define the library interface
const signatures = {
  distance: {
    parameters: [
      { struct: pointStruct },
      { struct: pointStruct },
    ],
    result: "f64",
  },
} as const;

// Create struct instances
const point1 = new Deno.UnsafePointer(
  new BigUint64Array([
    BigInt(Float64Array.of(1.0).buffer),
    BigInt(Float64Array.of(2.0).buffer),
  ]).buffer,
);

const point2 = new Deno.UnsafePointer(
  new BigUint64Array([
    BigInt(Float64Array.of(4.0).buffer),
    BigInt(Float64Array.of(6.0).buffer),
  ]).buffer,
);

// Call the function with structs
const dist = dylib.symbols.distance(point1, point2);
```

## Working with callbacks

You can pass JavaScript functions as callbacks to native code:

```ts
const signatures = {
  setCallback: {
    parameters: ["function"],
    result: "void",
  },
  runCallback: {
    parameters: [],
    result: "void",
  },
} as const;

// Create a callback function
const callback = new Deno.UnsafeCallback(
  { parameters: ["i32"], result: "void" } as const,
  (value) => {
    console.log("Callback received:", value);
  },
);

// Pass the callback to the native library
dylib.symbols.setCallback(callback.pointer);

// Later, this will trigger our JavaScript function
dylib.symbols.runCallback();

// Always clean up when done
callback.close();
```

## Best practices with FFI

1. Always close resources. Close libraries with `dylib.close()` and callbacks
   with `callback.close()` when done.

2. Prefer TypeScript. Use TypeScript for better type-checking when working with
   FFI.

3. Wrap FFI calls in try/catch blocks to handle errors gracefully.

4. Be extremely careful when using FFI, as native code can bypass Deno's
   security sandbox.

5. Keep the FFI interface as small as possible to reduce the attack surface.

## Examples

### Using a Rust library

Here's an example of creating and using a Rust library with Deno:

First, create a Rust library:

```rust
// lib.rs
#[no_mangle]
pub extern "C" fn fibonacci(n: u32) -> u32 {
  if n <= 1 {
    return n;
  }
  fibonacci(n - 1) + fibonacci(n - 2)
}
```

Compile it as a dynamic library:

```sh
rustc --crate-type cdylib lib.rs
```

Then use it from Deno:

```ts
const libName = {
  windows: "./lib.dll",
  linux: "./liblib.so",
  darwin: "./liblib.dylib",
}[Deno.build.os];

const dylib = Deno.dlopen(
  libName,
  {
    fibonacci: { parameters: ["u32"], result: "u32" },
  } as const,
);

// Calculate the 10th Fibonacci number
const result = dylib.symbols.fibonacci(10);
console.log(`Fibonacci(10) = ${result}`); // 55

dylib.close();
```

### Examples

- [Netsaur](https://github.com/denosaurs/netsaur/blob/c1efc3e2df6e2aaf4a1672590a404143203885a6/packages/core/src/backends/cpu/mod.ts)
- [WebView_deno](https://github.com/webview/webview_deno/blob/main/src/ffi.ts)
- [Deno_sdl2](https://github.com/littledivy/deno_sdl2/blob/main/mod.ts)
- [Deno FFI examples repository](https://github.com/denoffi/denoffi_examples)

These community-maintained repos includes working examples of FFI integrations
with various native libraries across different operating systems.

## Related Approaches to Native Code Integration

While Deno's FFI provides a direct way to call native functions, there are other
approaches to integrate native code:

### Using Node-API (N-API) with Deno

Deno supports [Node-API (N-API)](https://nodejs.org/api/n-api.html) for
compatibility with native Node.js addons. This enables you to use existing
native modules written for Node.js.

Directly loading a Node-API addon:

```ts
import process from "node:process";
process.dlopen(module, "./native_module.node", 0);
```

Using an npm package that uses a Node-API addon:

```ts
import someNativeAddon from "npm:some-native-addon";
console.log(someNativeAddon.doSomething());
```

How is this different from FFI?

| **Aspect**  | **FFI**                | **Node-API Support**                        |
| ----------- | ---------------------- | ------------------------------------------- |
| Setup       | No build step required | Requires precompiled binaries or build step |
| Portability | Tied to library ABI    | ABI-stable across versions                  |
| Use Case    | Direct library calls   | Reuse Node.js addons                        |

Node-API support is ideal for leveraging existing Node.js native modules,
whereas FFI is best for direct, lightweight calls to native libraries.

## Alternatives to FFI

Before using FFI, consider these alternatives:

- [WebAssembly](/runtime/reference/wasm/), for portable native code that runs
  within Deno's sandbox.
- Use `Deno.command` to execute external binaries and subprocesses with
  controlled permissions.
- Check whether [Deno's native APIs](/api/deno) already provide the
  functionality you need.

Deno's FFI capabilities provide powerful integration with native code, enabling
performance optimizations and access to system-level functionality. However,
this power comes with significant security considerations. Always be cautious
when working with FFI and ensure you trust the native libraries you're using.


---

# 编写 HTTP 服务器

> 一份在 Deno 中创建 HTTP 服务器的指南。了解 Deno.serve API、请求处理、WebSocket 支持、响应流以及如何构建具备自动压缩功能的生产级 HTTP/HTTPS 服务器。

URL: https://docs.deno.com/runtime/fundamentals/http_server


HTTP 服务器是网络的支柱，使您能够访问网站、下载文件和与网络服务交互。它们监听来自客户端（例如网页浏览器）的传入请求并发送响应。

当您构建自己的 HTTP 服务器时，您可以完全控制它的行为，并根据您的特定需求进行调整。您可能会将其用于本地开发，以提供 HTML、CSS 和 JS 文件，或者构建 REST API - 拥有自己的服务器使您能够定义端点、处理请求和管理数据。

## Deno 的内置 HTTP 服务器

Deno 内置了一个 HTTP 服务器 API，使您能够编写 HTTP 服务器。 [`Deno.serve`](https://docs.deno.com/api/deno/~/Deno.serve) API 支持 HTTP/1.1 和 HTTP/2。

### 一个 “Hello World” 服务器

`Deno.serve` 函数接收一个处理函数，该函数将在每个传入请求时被调用，并且预计将返回一个响应（或一个解析为响应的 promise）。

以下是一个示例服务器，它对每个请求返回“Hello, World！”响应：

```ts title="server.ts"
Deno.serve((_req) => {
  return new Response("Hello, World!");
});
```

处理程序也可以返回 `Promise<Response>`，这意味着它可以是一个 `async` 函数。

要运行此服务器，您可以使用 `deno run` 命令：

```sh
deno run --allow-net server.ts
```

还有更多关于使用 `Deno.serve` 的示例，见
[示例集合](/examples/#network)。

### 监听特定端口

默认情况下，`Deno.serve` 将在端口 `8000` 上监听，但可以通过将端口号作为选项包的第一个或第二个参数传入来更改此行为：

```js title="server.ts"
// 在端口 4242 上监听。
Deno.serve({ port: 4242 }, handler);

// 在端口 4242 上监听并绑定到 0.0.0.0。
Deno.serve({ port: 4242, hostname: "0.0.0.0" }, handler);
```

### 检查传入请求

大多数服务器不会对每个请求都返回相同的响应。相反，它们会根据请求的各个方面（HTTP 方法、头部、路径或主体内容）来更改其回答。

请求作为处理函数的第一个参数传递。以下是一个示例，演示如何提取请求的各个部分：

```ts
Deno.serve(async (req) => {
  console.log("方法:", req.method);

  const url = new URL(req.url);
  console.log("路径:", url.pathname);
  console.log("查询参数:", url.searchParams);

  console.log("头部:", req.headers);

  if (req.body) {
    const body = await req.text();
    console.log("主体:", body);
  }

  return new Response("Hello, World!");
});
```

:::caution

请注意，如果用户在主体完全接收之前挂断连接，`req.text()` 调用可能会失败。确保处理此情况。请注意这可能发生在所有从请求主体读取的方法中，例如 `req.json()`、`req.formData()`、`req.arrayBuffer()`、`req.body.getReader().read()`、`req.body.pipeTo()` 等。

:::

### 用真实数据响应

大多数服务器不会对每个请求都响应“Hello, World！”相反，它们可能会返回不同的头部、状态码和主体内容（甚至主体流）。

以下是一个返回带有 404 状态码、JSON 主体和自定义头部的响应的示例：

```ts title="server.ts"
Deno.serve((req) => {
  const body = JSON.stringify({ message: "未找到" });
  return new Response(body, {
    status: 404,
    headers: {
      "content-type": "application/json; charset=utf-8",
    },
  });
});
```

### 用流响应

响应主体也可以是流。以下是一个返回每秒重复一次“Hello, World！”的响应示例：

```ts title="server.ts"
Deno.serve((req) => {
  let timer: number;
  const body = new ReadableStream({
    async start(controller) {
      timer = setInterval(() => {
        controller.enqueue("Hello, World!\n");
      }, 1000);
    },
    cancel() {
      clearInterval(timer);
    },
  });
  return new Response(body.pipeThrough(new TextEncoderStream()), {
    headers: {
      "content-type": "text/plain; charset=utf-8",
    },
  });
});
```

:::note

注意上面的 `cancel` 函数。当客户端挂断连接时会调用它。确保处理此情况，否则服务器将不断排队消息，最终会耗尽内存。

:::

请注意，当客户端挂断连接时，响应主体流会被“取消”。确保处理此情况。这可能会在附加到响应主体 `ReadableStream` 对象的 `WritableStream` 对象的 `write()` 调用中出现错误（例如通过 `TransformStream`）。

### HTTPS 支持

要使用 HTTPS，请在选项中传递两个额外的参数：`cert` 和 `key`。这些分别是证书和密钥文件的内容。

```js
Deno.serve({
  port: 443,
  cert: Deno.readTextFileSync("./cert.pem"),
  key: Deno.readTextFileSync("./key.pem"),
}, handler);
```

:::note

要使用 HTTPS，您需要为服务器提供有效的 TLS 证书和私钥。

:::

### HTTP/2 支持

在使用 Deno 的 HTTP 服务器 API 时，HTTP/2 支持是“自动”的。您只需创建服务器，它将无缝处理 HTTP/1 或 HTTP/2 请求。

HTTP/2 在明文下也支持预先知识。

### 自动主体压缩

HTTP 服务器具备自动压缩响应主体的功能。当响应发送到客户端时，Deno 会确定响应主体是否可以安全地进行压缩。此压缩在 Deno 的内部发生，因此速度快且高效。

目前 Deno 支持 gzip 和 brotli 压缩。如果满足以下条件，主体会自动压缩：

- 请求具有一个 [`Accept-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) 头，表明请求者支持 `br`（Brotli 压缩）或 `gzip`。Deno 会遵循头部中的 [质量值](https://developer.mozilla.org/en-US/docs/Glossary/Quality_values) 的优先级。
- 响应包含一个 [`Content-Type`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)，被认为是可压缩的。 （该列表源自 [`jshttp/mime-db`](https://github.com/jshttp/mime-db/blob/master/db.json)，并在
  [代码中](https://github.com/denoland/deno/blob/v1.21.0/ext/http/compressible.rs)）。
- 响应主体大于 64 字节。

当响应主体被压缩时，Deno 会设置 `Content-Encoding` 头以反映编码，并确保 `Vary` 头被调整或添加，以指示哪些请求头影响了响应。

除了上述逻辑，还有一些原因使得响应 **不会** 自动压缩：

- 响应包含 `Content-Encoding` 头。这表明您的服务器已经进行了某种编码。
- 响应包含一个 [`Content-Range`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range) 头。这表明您的服务器正在响应范围请求，其中字节和范围是在 Deno 内部的控制之外进行协商的。
- 响应具有一个 [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) 头，其中包含一个 [`no-transform`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#other) 值。这表明您的服务器不希望 Deno 或任何下游代理修改响应。

### 提供 WebSocket 服务

Deno 可以将传入的 HTTP 请求升级为 WebSocket。这使您能够在 HTTP 服务器上处理 WebSocket 端点。

要将传入的 `Request` 升级为 WebSocket，您可以使用 `Deno.upgradeWebSocket` 函数。这返回一个包含 `Response` 和一个 Web 标准 `WebSocket` 对象的对象。返回的响应应被用于响应传入的请求。

由于 WebSocket 协议是对称的，因此 `WebSocket` 对象与可用于客户端通信的对象是相同的。有关文档，可以在 [MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) 上找到。

```ts title="server.ts"
Deno.serve((req) => {
  if (req.headers.get("upgrade") != "websocket") {
    return new Response(null, { status: 426 });
  }

  const { socket, response } = Deno.upgradeWebSocket(req);
  socket.addEventListener("open", () => {
    console.log("一个客户端已连接!");
  });

  socket.addEventListener("message", (event) => {
    if (event.data === "ping") {
      socket.send("pong");
    }
  });

  return response;
});
```

在进行 WebSocket 升级后，创建 WebSocket 的连接无法再用于 HTTP 流量。

:::note

请注意，目前 WebSocket 仅在 HTTP/1.1 上受支持。

:::

## 默认的 fetch 导出

在 Deno 中创建 HTTP 服务器的另一种方法是导出一个默认的 `fetch` 函数。[fetch API](/api/web/~/fetch) 发起 HTTP 请求以从网络中获取数据，并且内置于 Deno 运行时中。

```ts title="server.ts"
export default {
  fetch(request) {
    const userAgent = request.headers.get("user-agent") || "未知";
    return new Response(`用户代理: ${userAgent}`);
  },
} satisfies Deno.ServeDefaultExport;
```

您可以通过 `deno serve` 命令运行此文件：

```sh
deno serve server.ts
```

服务器将启动并在控制台中显示消息。打开您的浏览器并导航到 [http://localhost:8000/](http://localhost:8000/) 以查看用户代理信息。

`Deno.ServeDefaultExport` 接口定义了可以与 `deno serve` 命令一起使用的默认导出的结构。为了确保您的代码经过正确的类型检查，请确保在 `export default { ... }` 中添加 `satisfies Deno.ServeDefaultExport`。

## 在这些示例基础上构建

您可能希望在这些示例的基础上扩展，创建更复杂的服务器。Deno 推荐使用 [Oak](https://jsr.io/@oak/oak) 来构建 web 服务器。Oak 是一个用于 Deno HTTP 服务器的中间件框架，旨在表达和易于使用。它提供了一个简单的方法来创建支持中间件的 web 服务器。查看 [Oak 文档](https://oakserver.github.io/oak/) 以获取有关如何定义路由的示例。

---

# 代码检查与格式化

> Deno 内置代码质量工具的指南。学习如何使用 deno lint 和 deno fmt 命令，配置规则，集成 CI/CD 管道，并在您的项目中保持一致的代码风格。

URL: https://docs.deno.com/runtime/fundamentals/linting_and_formatting


在理想的世界中，您的代码始终是干净、一致且没有令人烦恼的错误。这就是 Deno 内置的代码检查和格式化工具的承诺。通过将这些特性直接整合到运行时中，Deno 消除了对外部依赖和复杂配置的需求。这些内置工具快速且高效，不仅节省了时间，还确保每一行代码都遵循最佳实践。

使用 `deno fmt` 和 `deno lint`，您可以专注于编写出色的代码，知道 Deno 会为您保驾护航。就像有一个警惕的助手在维护您的代码库，让您能够专注于真正重要的事情：构建出色的应用程序。

## 代码检查

<a href="/lint/" type="docs-cta runtime-cta">查看所有 lint 规则</a>

代码检查是分析代码以寻找潜在错误、bug 和风格问题的过程。Deno 内置的代码检查工具 [`deno lint`](/runtime/reference/cli/linter/) 支持来自 [ESLint](https://eslint.org/) 的推荐规则集，为您的代码提供全面的反馈。这包括识别语法错误、强制编码规范以及突出可能导致 bug 的潜在问题。

要运行代码检查程序，请在终端中使用以下命令：

```bash
deno lint
```

默认情况下，`deno lint` 会分析当前目录及其子目录中的所有 TypeScript 和 JavaScript 文件。如果您想仅对特定文件或目录进行检查，可以将它们作为命令的参数传递。例如：

```bash
deno lint src/
```

此命令将对 `src/` 目录中的所有文件进行代码检查。

代码检查工具可以在 [`deno.json`](/runtime/fundamentals/configuration/#linting) 文件中进行配置。您可以指定自定义规则、插件和设置，以根据需要调整代码检查过程。

### 代码检查规则

您可以在 [规则列表](/lint/) 文档页面查看和搜索可用规则及其用法。

## 格式化

格式化是自动调整代码布局以遵循一致风格的过程。Deno 内置的格式化器 `deno fmt` 使用强大的 [dprint](https://dprint.dev/) 引擎来确保您的代码始终干净、可读且一致。

要格式化代码，只需在终端中执行以下命令：

```bash
deno fmt
```

默认情况下，`deno fmt` 会格式化当前目录及其子目录中的所有 TypeScript 和 JavaScript 文件。如果您想仅对特定文件或目录进行格式化，可以将它们作为命令的参数传递。例如：

```bash
deno fmt src/
```

此命令将格式化 `src/` 目录中的所有文件。

### 检查格式化

`deno fmt --check` 命令用于验证您的代码是否按照 Deno 的默认格式化规则正确格式化。它不会修改文件，而是检查它们并报告任何格式问题。这对于集成到持续集成（CI）管道或提交前钩子中尤其有用，以确保项目中的代码一致性。

如果存在格式问题，`deno fmt --check` 会列出需要格式化的文件。如果所有文件都已正确格式化，它将简单地退出而不输出任何内容。

### 在 CI 中集成

您可以将 `deno fmt --check` 添加到 CI 管道中，以自动检查格式问题。例如，在 GitHub Actions 工作流中：

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - run: deno fmt --check
```

这确保任何代码更改在合并之前都符合项目的格式化标准。

### 在 VS Code 中集成

要在 VS Code 中启用 Deno 作为格式化器，您需要将其设置为默认格式化工具，然后在项目根目录添加 `.vscode/settings.json` 文件，内容如下：

```json
{
  "deno.enablePaths": ["./deno.json"]
}
```

如果您的 `deno.json(c)` 文件位于项目的子目录，请提供相应的相对路径。

### 可用选项

#### `bracePosition`

定义代码块中大括号的位置

- **默认值：** `sameLine`
- **可选值：** `maintain`，`sameLine`，`nextLine`，`sameLineUnlessHanging`

#### `jsx.bracketPosition`

定义 JSX 中括号的位置

- **默认值：** `nextLine`
- **可选值：** `maintain`，`sameLine`，`nextLine`

#### `jsx.forceNewLinesSurroundingContent`

强制在 JSX 元素内容周围使用换行符

- **默认值：** `false`
- **可选值：** `true`，`false`

#### `jsx.multiLineParens`

当 JSX 元素或片段跨多行时，是否用括号包围最外层元素或片段

- **默认值：** `prefer`
- **可选值：** `never`，`prefer`，`always`

#### `indentWidth`

定义缩进宽度

- **默认值：** `2`
- **可选值：** 数字

#### `lineWidth`

定义最大行宽度

- **默认值：** `80`
- **可选值：** 数字

#### `newLineKind`

使用的换行符类型

- **默认值：** `lf`
- **可选值：** `auto`，`crlf`，`lf`，`system`

#### `nextControlFlowPosition`

定义后续控制流语句的位置

- **默认值：** `sameLine`
- **可选值：** `sameLine`，`nextLine`，`maintain`

#### `semiColons`

是否偏好使用分号

- **默认值：** `true`
- **可选值：** `true`，`false`

#### `operatorPosition`

多行表达式中运算符的位置

- **默认值：** `sameLine`
- **可选值：** `sameLine`，`nextLine`，`maintain`

#### `proseWrap`

定义如何换行文本内容

- **默认值：** `always`
- **可选值：** `always`，`never`，`preserve`

#### `quoteProps`

控制对象属性的引号使用

- **默认值：** `asNeeded`
- **可选值：** `asNeeded`，`consistent`，`preserve`

#### `singleBodyPosition`

单语句代码块中主体的位置

- **默认值：** `sameLineUnlessHanging`
- **可选值：** `sameLine`，`nextLine`，`maintain`，`sameLineUnlessHanging`

#### `singleQuote`

是否使用单引号

- **默认值：** `false`
- **可选值：** `true`，`false`

#### `spaceAround`

控制包围表达式的空格

- **默认值：** `false`
- **可选值：** `true`，`false`

#### `spaceSurroundingProperties`

控制单行对象属性周围的空白

- **默认值：** `true`
- **可选值：** `true`，`false`

#### `trailingCommas`

控制多行数组/对象中的尾随逗号

- **默认值：** `always`
- **可选值：** `always`，`never`

#### `typeLiteral.separatorKind`

定义类型字面量的分隔符类型

- **默认值：** `semiColon`
- **可选值：** `comma`，`semiColon`

#### `unstable-component`

启用格式化 Svelte、Vue、Astro 和 Angular 文件

#### `unstable-sql`

启用格式化 SQL 文件

#### `useTabs`

使用制表符代替空格进行缩进

- **默认值：** `false`
- **可选值：** `true`，`false`

#### `useBraces`

是否为 if 语句、for 语句和 while 语句使用大括号

- **默认值：** `whenNotSingleLine`
- **可选值：** `maintain`，`whenNotSingleLine`，`always`，`preferNone`

### 配置

格式化器可以在 [`deno.json`](/runtime/fundamentals/configuration/#formatting) 文件中进行配置。您可以指定自定义设置，以根据您的需求调整格式化过程。

## Deno 对其他 linter 和格式化工具的支持

### ESLint

要在您的 Deno 项目中使用 VSCode 的 ESLint 扩展，您的项目目录需要有一个 `node_modules` 文件夹，供 VSCode 扩展识别。

在您的 `deno.json` 中确保创建 `node_modules` 文件夹，以便编辑器能解析包：

```jsonc
{
  "nodeModulesDir": "auto"
}
```

（可选）运行 ESLint 命令下载它：

```sh
deno run -A npm:eslint --version
# 或者
deno run -A npm:eslint --init
```

创建一个 `eslint.config.js`：

```js
// eslint.config.js
import js from "@eslint/js";
import importPlugin from "eslint-plugin-import"; // 示例插件

export default [
  js.configs.recommended,
  {
    files: ["**/*.ts", "**/*.js"],
    languageOptions: { globals: { Deno: "readonly" } },
    plugins: { import: importPlugin },
    rules: {
      // 例如 "import/order": "warn"
    },
  },
];
```

运行 ESLint：

```sh
deno run -A npm:eslint .
```

您也可以在 `deno.json` 中添加任务来运行 ESLint：

```json
{
  "tasks": { "eslint": "eslint . --ext .ts,.js" }
}
```

然后通过以下命令运行：

```sh
deno task eslint
```

### Prettier

要在您的 Deno 项目中使用 Prettier，您的项目目录需要有一个 `node_modules` 文件夹，供 VSCode 扩展识别。

然后安装 VSCode 的 Prettier 扩展，并将其配置为您的默认格式化工具：

在 VSCode 中：

1. 打开命令面板（使用 <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>）
2. 选择 **使用其他格式化工具格式化文档...**
3. 选择 **配置默认格式化程序...**
4. 选择 **Prettier - Code formatter**

---

# 模块与依赖

> 管理 Deno 中模块与依赖的指南。了解 ECMAScript 模块、第三方包、导入映射、依赖管理、版本控制以及如何发布自己的模块。

URL: https://docs.deno.com/runtime/fundamentals/modules


Deno 使用
[ECMAScript 模块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)
作为其默认模块系统，以符合现代 JavaScript 标准并提升更高效和一致的开发体验。这是 JavaScript 模块的官方标准，允许更好的树摇优化，改进的工具集成，以及在不同环境中的原生支持。

通过采用 ECMAScript 模块，Deno 确保与不断发展的 JavaScript 生态系统的兼容性。对开发者而言，这意味着一个流畅且可预测的模块系统，避免了与遗留模块格式（如 CommonJS）相关的复杂性。

## 导入模块

在这个例子中，`add` 函数是从本地的 `calc.ts` 模块导入的。

```ts title="calc.ts"
export function add(a: number, b: number): number {
  return a + b;
}
```

```ts title="main.ts"
// 导入与此文件相邻的 `calc.ts` 模块
import { add } from "./calc.ts";

console.log(add(1, 2)); // 3
```

你可以在包含 `main.ts` 和 `calc.ts` 的目录中运行这个例子，通过调用 `deno run main.ts`。

使用 ECMAScript 模块时，本地导入规范必须始终包含完整的文件扩展名，不能省略。

```ts title="example.ts"
// 错误：缺少文件扩展名
import { add } from "./calc";

// 正确：包含文件扩展名
import { add } from "./calc.ts";
```

## 导入属性

Deno 支持 `with { type: "json" }` 导入属性语法以导入 JSON 文件：

```ts
import data from "./data.json" with { type: "json" };

console.log(data.property); // 访问 JSON 数据作为对象
```

从 Deno 2.4 开始，也可以导入 `text` 和 `bytes` 模块。

:::info

对导入 `text` 和 `bytes` 模块的支持尚属实验性功能，需通过以下方式启用：

在命令行中使用 `--unstable-raw-imports` 标志或在 `deno.json` 配置文件中设置 `unstable.raw-import` 选项

:::

```ts
import text from "./log.txt" with { type: "text" };

console.log(typeof text === "string");
// true
console.log(text);
// Hello from a text file
```

```ts
import bytes from "./image.png" with { type: "bytes" };

console.log(bytes instanceof Uint8Array);
// true
console.log(bytes);
Uint8Array(12) [
//    72, 101, 108, 108, 111,
//    44,  32,  68, 101, 110,
//   111,  33
// ]
```

## WebAssembly 模块

Deno 支持直接导入 Wasm 模块：

```ts
import { add } from "./add.wasm";

console.log(add(1, 2));
```

要了解更多信息，请访问 [WebAssembly 部分](/runtime/reference/wasm/#wasm-modules)

## 数据 URL 导入

Deno 支持导入数据 URL，这使您能够导入不在单独文件中的内容。这对于测试、原型设计或当您需要以编程方式生成模块时非常有用。

您可以使用 `data:` URL 方案动态创建模块：

```ts
// 从数据 URL 导入一个简单的 JavaScript 模块
import * as module from "data:application/javascript;base64,ZXhwb3J0IGNvbnN0IG1lc3NhZ2UgPSAiSGVsbG8gZnJvbSBkYXRhIFVSTCI7";
console.log(module.message); // 输出: Hello from data URL

// 你也可以使用非 base64 格式
const plainModule = await import(
  "data:application/javascript,export function greet() { return 'Hi there!'; }"
);
console.log(plainModule.greet()); // 输出: Hi there!

// 带有文本内容的简单示例
const textModule = await import(
  "data:text/plain,export default 'This is plain text'"
);
console.log(textModule.default); // 输出: This is plain text
```

数据 URL 格式遵循以下模式：

```sh
data:[<media type>][;base64],<data>
```

对于 JavaScript 模块，请使用 `application/javascript` 作为媒体类型。

TypeScript 也支持 `application/typescript`。此功能特别适用于在隔离环境中测试模块以及在测试期间创建模拟模块。

## 导入第三方模块和库

在 Deno 中使用第三方模块时，使用与本地代码相同的 `import` 语法。第三方模块通常从远程注册表导入，并以 `jsr:` 、 `npm:` 或 `https://` 开头。

```ts title="main.ts"
import { camelCase } from "jsr:@luca/cases@1.0.0";
import { say } from "npm:cowsay@1.6.0";
import { pascalCase } from "https://deno.land/x/case/mod.ts";
```

Deno 推荐使用 [JSR](https://jsr.io)，这是一个现代的 JavaScript 注册中心，用于第三方模块。在那里，你将会找到许多文档完善的 ES 模块供你的项目使用，包括
[Deno 标准库](/runtime/fundamentals/standard_library/)。

你可以
[在这里阅读更多关于 Deno 对 npm 包支持的内容](/runtime/fundamentals/node/#using-npm-modules)。

## 管理第三方模块和库

在多个文件中导入模块时，输入完整版本说明符的模块名称可能会变得繁琐。您可以通过在 `deno.json` 文件中使用 `imports` 字段来集中管理远程模块。我们称这个 `imports` 字段为 **导入映射**，它基于 [导入映射标准]。

[导入映射标准]: https://html.spec.whatwg.org/multipage/webappapis.html#import-maps

```json title="deno.json"
{
  "imports": {
    "@luca/cases": "jsr:@luca/cases@^1.0.0",
    "cowsay": "npm:cowsay@^1.6.0",
    "cases": "https://deno.land/x/case/mod.ts"
  }
}
```

使用重新映射的说明符，代码看起来更加简洁：

```ts title="main.ts"
import { camelCase } from "@luca/cases";
import { say } from "cowsay";
import { pascalCase } from "cases";
```

重新映射的名称可以是任何有效的说明符。这是 Deno 中非常强大的功能，可以重映射任何内容。了解更多信息，请参阅
[配置依赖部分](/runtime/fundamentals/configuration/#dependencies)。

## 区分 `deno.json` 中的 `imports` 或 `importMap` 和 `--import-map` 选项

根据 [导入映射标准]，每个模块需要两个条目：一个是模块说明符本身，另一个是带尾随 `/` 的说明符。这是因为该标准仅允许每个模块说明符有一个条目，而尾随的 `/` 表示该说明符指向一个目录。例如，在使用 `--import-map import_map.json` 选项时，`import_map.json` 文件必须为每个模块包含两个条目（注意这里使用 `jsr:/@std/async` 而非 `jsr:@std/async`）：

```json title="import_map.json"
{
  "imports": {
    "@std/async": "jsr:@std/async@^1.0.0",
    "@std/async/": "jsr:/@std/async@^1.0.0/"
  }
}
```

`deno.json` 中 `importMap` 字段引用的 `import_map.json` 文件行为与使用 `--import-map` 选项完全相同，对每个包含的模块条目要求相同。

相比之下，`deno.json` 扩展了导入映射标准。当你在 `deno.json` 中使用 `imports` 字段或通过 `importMap` 字段引用 `import_map.json` 文件时，只需要指定模块说明符而不带尾随 `/`：

```json title="deno.json"
{
  "imports": {
    "@std/async": "jsr:@std/async@^1.0.0"
  }
}
```

## 使用 `deno add` 添加依赖

使用 `deno add` 子命令可以轻松完成安装过程。它将自动将你请求的包的最新版本添加到 `deno.json` 的 `imports` 部分。

```sh
# 将模块的最新版本添加到 deno.json
$ deno add jsr:@luca/cases
Add @luca/cases - jsr:@luca/cases@1.0.0
```

```json title="deno.json"
{
  "imports": {
    "@luca/cases": "jsr:@luca/cases@^1.0.0"
  }
}
```

你也可以指定确切的版本：

```sh
# 传入确切版本
$ deno add jsr:@luca/cases@1.0.0
Add @luca/cases - jsr:@luca/cases@1.0.0
```

在 [`deno add` 参考文档](/runtime/reference/cli/add/) 中阅读更多内容。

你也可以使用 `deno remove` 移除依赖项：

```sh
$ deno remove @luca/cases
Remove @luca/cases
```

```json title="deno.json"
{
  "imports": {}
}
```

在 [`deno remove` 参考文档](/runtime/reference/cli/remove/) 中阅读更多内容。

## 包版本

你可以为正在导入的包指定一个版本范围。这通过 `@` 符号后跟版本范围说明符来完成，并遵循 [语义化版本控制 (semver)](https://semver.org/) 版本方案。

例如：

```bash
@scopename/mypackage           # 最新版本
@scopename/mypackage@16.1.0    # 精确版本
@scopename/mypackage@16        # 最新的 16.x 版本 >= 16.0.0
@scopename/mypackage@^16.1.0   # 最新的 16.x 版本 >= 16.1.0
@scopename/mypackage@~16.1.0   # 最新的 16.1.x 版本 >= 16.1.0
```

以下是所有你可以指定版本或范围的方式的概述：

| 符号      | 描述                                                                                                                                                             | 示例      |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| `1.2.3`   | 精确版本。仅使用此特定版本。                                                                                                                                   | `1.2.3`   |
| `^1.2.3`  | 兼容版本 1.2.3。允许更新而不改变最左侧的非零数字。<br>例如，`1.2.4` 和 `1.3.0` 是允许的，但 `2.0.0` 不是。                                                    | `^1.2.3`  |
| `~1.2.3`  | 大约等价于版本 1.2.3。允许对补丁版本进行更新。<br>例如，`1.2.4` 是允许的，但 `1.3.0` 不是。                                                                    | `~1.2.3`  |
| `>=1.2.3` | 大于或等于版本 1.2.3。任何版本 `1.2.3` 或更高的版本都是允许的。                                                                                                 | `>=1.2.3` |
| `<=1.2.3` | 小于或等于版本 1.2.3。任何版本 `1.2.3` 或更低的版本都是允许的。                                                                                                 | `<=1.2.3` |
| `>1.2.3`  | 大于版本 1.2.3。仅允许版本高于 `1.2.3` 的版本。                                                                                                                | `>1.2.3`  |
| `<1.2.3`  | 小于版本 1.2.3。仅允许低于 `1.2.3` 的版本。                                                                                                                    | `<1.2.3`  |
| `1.2.x`   | 在次版本 1.2 中的任何补丁版本。例如，`1.2.0`、`1.2.1` 等。                                                                                                     | `1.2.x`   |
| `1.x`     | 在主版本 1 中的任何次版本和补丁版本。例如，`1.0.0`、`1.1.0`、`1.2.0` 等。                                                                                      | `1.x`     |
| `*`       | 任何版本都是允许的。                                                                                                                                           | `*`       |

## HTTPS 导入

Deno 还支持引用 HTTP/HTTPS URL 的导入语句，可以直接：

```js
import { Application } from "https://deno.land/x/oak/mod.ts";
```

或作为你的 `deno.json` 导入映射的一部分：

```json
{
  "imports": {
    "oak": "https://deno.land/x/oak/mod.ts"
  }
}
```

支持 HTTPS 导入使我们能够支持以下 JavaScript CDN，因为它们提供对 JavaScript 模块的 URL 访问：

- [deno.land/x](https://deno.land/x)
- [esm.sh](https://esm.sh)
- [unpkg.com](https://unpkg.com)

HTTPS 导入对于小型且通常是单文件的 Deno 项目特别有用，这些项目不需要其他配置。使用 HTTPS 导入，你可以完全避免拥有 `deno.json` 文件。然而，在较大的应用程序中不建议使用这种导入风格，因为你可能会遇到版本冲突（不同文件使用不同的版本说明符）。HTTP 导入不支持 `deno add`/`deno install` 命令。

:::info

使用 HTTPS 导入时请谨慎，并且仅**从受信任的来源**。如果服务器被攻破，它可能会向你的应用程序提供恶意代码。如果你在不同的文件中导入不同版本，可能还会导致版本问题。HTTPS 导入仍然被支持，**但我们建议使用包注册中心以获得更好的体验。**

:::

## 覆写依赖

Deno 提供了覆盖依赖的机制，允许开发者在开发或测试期间使用自定义或本地版本的库。

注意：如果你需要缓存或本地修改依赖以用于多次构建，可以考虑[供应远程模块](#vendoring-远程模块)。

### 覆写本地包

对于熟悉 Node.js 中 `npm link` 的开发者，Deno 通过 `deno.json` 中的 `links` 字段提供了类似的功能。它允许你在开发阶段覆盖依赖，使用本地版本，而无需发布。

示例：

```json title="deno.json"
{
  "links": [
    "../some-package-or-workspace"
  ]
}
```

关键点：

- `links` 字段接受包含包或工作区的目录路径。如果你引用的是一个工作区中的单个包，则整个工作区都会被包括进来。
- 支持 JSR 和 npm 包。
- 此功能仅在工作区根目录生效。在其他位置使用 `links` 会触发警告。

限制：

- 不支持基于 Git 的依赖覆盖。
- `links` 字段需要在工作区根目录中正确配置。

### 覆写 NPM 包

Deno 支持类似地链接 npm 包的本地版本，类似于 JSR 包的链接。这样可以做到在开发时使用本地 npm 包版本，而无需发布。

要使用本地 npm 包，需要在 `deno.json` 中配置 `links` 字段：

```json
{
  "links": [
    "../path/to/local_npm_package"
  ]
}
```

此功能依赖于 `node_modules` 目录，并根据你的 `nodeModulesDir` 设置表现不同：

- 当 `"nodeModulesDir": "auto"`：目录会在每次运行时重建，启动时间稍有增加，但确保总是使用最新版本。
- 当 `"nodeModulesDir": "manual"`（使用 `package.json` 时的默认值）：更新包后，你必须运行 `deno install`，将更改同步到工作空间的 `node_modules` 目录。

限制：

- 指定本地 npm 包或更改其依赖会清除锁文件中的 npm 包，可能导致 npm 解析行为不同。
- npm 包名称必须存在于注册表中，即使你使用的是本地副本。

### 覆写 HTTPS 导入

Deno 也允许通过 `deno.json` 中的 `scopes` 字段覆盖 HTTPS 导入。这一功能在用本地修补版本替换远程依赖以调试或临时修复时特别有用。

示例：

```json title="deno.json"
{
  "imports": {
    "example/": "https://deno.land/x/example/"
  },
  "scopes": {
    "https://deno.land/x/example/": {
      "https://deno.land/x/my-library@1.0.0/mod.ts": "./patched/mod.ts"
    }
  }
}
```

关键点：

- 导入映射中的 `scopes` 字段允许你将特定导入重定向到其他路径。
- 这通常用于用本地文件覆盖远程依赖，用于测试或开发目的。
- Scopes 仅适用于项目的根目录。嵌套在依赖项中的 scopes 会被忽略。

## 供应远程模块

如果你的项目有外部依赖项，你可能希望将它们本地存储，以避免每次构建项目时都从互联网下载它们。在 CI 服务器或 Docker 容器中构建项目或修补或其他修改远程依赖项时，这尤其有用。

Deno 通过在 `deno.json` 文件中设置提供此功能：

```json
{
  "vendor": true
}
```

将上述代码段添加到你的 `deno.json` 文件中，Deno 将在项目运行时将所有依赖项缓存到 `vendor` 目录中，或者你可以选择运行 `deno install --entrypoint` 命令以立即缓存依赖项：

```bash
deno install --entrypoint main.ts
```

然后你可以像往常一样使用 `deno run` 运行应用程序：

```bash
deno run main.ts
```

在进行供应后，你可以使用 `--cached-only` 标志在没有互联网访问的情况下运行 `main.ts`，这会强制 Deno 仅使用本地可用的模块。

有关更加高级的覆盖，例如在开发期间替代依赖项，请参见 [覆写依赖](#覆写-依赖)。

## 发布模块

任何定义导出的 Deno 程序都可以作为模块发布。这允许其他开发人员在自己的项目中导入和使用你的代码。模块可以发布到：

- [JSR](https://jsr.io) - 推荐，原生支持 TypeScript，并为你自动生成文档
- [npm](https://www.npmjs.com/) - 使用 [dnt](https://github.com/denoland/dnt) 创建 npm 包
- [deno.land/x](https://deno.com/add_module) - 用于 HTTPS 导入，尽可能使用 JSR，而不是

## 重新加载模块

默认情况下，Deno 使用全局缓存目录（`DENO_DIR`）来存储下载的依赖项。这个缓存共享于所有项目。

你可以使用 `--reload` 标志强制 Deno 重新获取并重新编译模块到缓存中。

```bash
# 重新加载所有内容
deno run --reload my_module.ts

# 重新加载特定模块
deno run --reload=jsr:@std/fs my_module.ts
```

## 仅开发依赖

有时依赖项仅在开发期间需要，例如测试文件或构建工具的依赖。在 Deno 中，运行时不要求你区分开发和生产依赖，因为
[运行时只会加载和安装实际执行代码中使用的依赖](#为什么-deno-没有-devimports字段)。

然而，标记开发依赖对于阅读你包的用户来说是有帮助的。在使用 `deno.json` 时，约定是在任何“仅限开发”的依赖后添加 `// dev` 注释：

```json title="deno.json"
{
  "imports": {
    "@std/fs": "jsr:@std/fs@1",
    "@std/testing": "jsr:@std/testing@1" // dev
  }
}
```

当使用 `package.json` 文件时，开发依赖可以添加在单独的 `devDependencies` 字段中：

```json title="package.json"
{
  "dependencies": {
    "pg": "npm:pg@^8.0.0"
  },
  "devDependencies": {
    "prettier": "^3"
  }
}
```

### 为什么 Deno 没有 `devImports` 字段？

理解为什么 Deno 不在包清单中将开发依赖分离出来，重要的是理解开发依赖试图解决的问题。

在部署应用时，你经常只想安装实际执行代码中用到的依赖。这有助于加快启动时间并减小部署体积。

历史上，这通过在 `package.json` 中将开发依赖分离到 `devDependencies` 字段实现。当部署应用时，会跳过 `devDependencies`，只安装正式依赖。

然而，这种方法在实践中存在问题。很容易忘记将依赖从 `dependencies` 移到 `devDependencies`，当依赖从运行时变为仅开发时。此外，一些语义上的“开发时”依赖（如 `@types/*`），经常被放在 `dependencies` 中，导致它们被安装到生产环境，虽然没有用处。

因此，Deno 使用不同的方式来安装仅适用于生产的依赖：在执行 `deno install` 时，可以传入 `--entrypoint` 标志，让 Deno 只安装指定入口文件（及其递归导入）实际使用的依赖。因为这是自动完成的且基于实际执行的代码，所以不需要单独指定开发依赖字段。

## 仅使用缓存模块

为了强制 Deno 仅使用之前缓存的模块，请使用 `--cached-only` 标志：

```shell
deno run --cached-only mod.ts
```

如果 `mod.ts` 的依赖树中存在尚未缓存的依赖，此命令将失败。

## 完整性检查和锁文件

假设你的模块依赖于位于
<https://some.url/a.ts> 的远程模块。当你第一次编译模块时，`a.ts`
会被抓取、编译和缓存。此缓存版本将被使用，直到在另一个机器上运行该模块（如生产环境），或手动重新加载缓存（使用如
`deno install --reload` 的命令）。

但如果远程内容发生变化怎么办？这可能导致生产模块运行时和本地开发时的依赖代码不一致。为了解决这个问题，Deno 使用完整性检查和锁文件。

Deno 使用 `deno.lock` 文件来检测外部模块完整性。启用锁文件可以通过以下方式之一进行：

1. 在当前目录或其祖先目录创建 `deno.json` 文件，将自动创建附加式锁文件 `deno.lock`。

   注意你可以通过在 `deno.json` 中设置以下选项来禁用锁文件：

   ```json title="deno.json"
   {
     "lock": false
   }
   ```

2. 使用 `--lock` 标志启用并指定锁文件路径。

### 冻结锁文件

默认情况下，Deno 使用附加锁文件，即新依赖项会被添加到锁文件中，而不会报错。

但是在某些场景（例如 CI 流水线或生产环境），你可能希望对未在锁文件中存在的新依赖报错，而不是默默添加。此时可以使用 `--frozen` 标志，或者在 `deno.json` 中设置：

```json title="deno.json"
{
  "lock": {
    "frozen": true
  }
}
```

当启用冻结锁文件执行命令时，任何会修改锁文件的操作都会令命令失败，并显示变更的错误。

如果你想更新锁文件，可以临时在命令行指定 `--frozen=false`，解除冻结限制。

### 更改锁文件路径

你可以通过指定 `--lock=deps.lock` 或在 Deno 配置文件中这样设置锁文件路径：

```json title="deno.json"
{
  "lock": {
    "path": "deps.lock"
  }
}
```

## 私有仓库

:::note

如果你在寻找私有 npm 注册中心和 `.npmrc` 支持，请访问
[npm 支持](/runtime/fundamentals/node/#private-registries) 页面。

:::

有时你希望加载来自 _私有_ 仓库的远程模块，例如 GitHub 私有仓库。

Deno 支持在请求远程模块时发送 bearer token。Bearer tokens 是主流的 OAuth 2.0 访问令牌类型，且被托管服务广泛支持（如 GitHub、GitLab、Bitbucket、Cloudsmith 等）。

### DENO_AUTH_TOKENS

Deno CLI 会查找环境变量 `DENO_AUTH_TOKENS`，用于决定使用哪些身份验证令牌请求远程模块。其值为若干令牌（以分号 `;` 分隔），每个令牌格式可以是：

- `{token}@{hostname[:port]}` 格式的 bearer token，或者
- `{username}:{password}@{hostname[:port]}` 格式的基本认证数据

例如，对 `deno.land` 的单个令牌示例：

```sh
DENO_AUTH_TOKENS=a1b2c3d4e5f6@deno.land
```

或者：

```sh
DENO_AUTH_TOKENS=username:password@deno.land
```

多个令牌示例：

```sh
DENO_AUTH_TOKENS=a1b2c3d4e5f6@deno.land;f1e2d3c4b5a6@example.com:8080;username:password@deno.land
```

当 Deno 请求远程模块时，如果主机名与远程模块主机名匹配，Deno 会把请求的 `Authorization` 头设置成 `Bearer {token}` 或 `Basic {base64EncodedData}`。这让远程服务器能识别请求是否由已认证用户发出，进而访问相应资源。

### GitHub

要访问 GitHub 上的私有仓库，你需要获取一个 _个人访问令牌_。你可以登录 GitHub，然后进入
_设置 -> 开发者设置 -> 个人访问令牌_：

![GitHub 上的个人访问令牌设置](./images/private-pat.png)

点击 _生成新令牌_，给令牌命名并赋予 `repo` 权限。`repo` 权限允许读取文件内容（详见 [GitHub 的权限范围说明](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes)）：

![在 GitHub 上创建新的个人访问令牌](./images/private-github-new-token.png)

创建后，GitHub 只会显示一次新令牌，你需要将它设置到环境变量中：

![在 GitHub 上显示新生成的令牌](./images/private-github-token-display.png)

要访问 GitHub 私有仓库中的模块，你需将令牌放入环境变量 `DENO_AUTH_TOKENS`，作用域设置为 `raw.githubusercontent.com` 主机名，例如：

```sh
DENO_AUTH_TOKENS=a1b2c3d4e5f6@raw.githubusercontent.com
```

这将允许 Deno 访问该令牌拥有权限的所有模块。

当令牌错误或无权限访问时，GitHub 返回的是 `404 Not Found`，而非未授权错误。如果你收到未找到模块的错误，请检查令牌和环境变量配置。

另外，执行 `deno run -L debug` 会打印关于环境变量中解析的令牌数量的调试信息。如果格式有误，它会报错，但为了安全起见，不会显示令牌详情。

---

# Node 和 npm 兼容性

> 关于在 Deno 中使用 Node.js 模块和 npm 包的指南。了解兼容性功能、导入 npm 包以及 Node.js 和 Deno 环境之间的差异。

URL: https://docs.deno.com/runtime/fundamentals/node


- **Deno 兼容 Node**。大多数 Node 项目可以在 Deno 中运行，几乎不需要更改！

- **Deno 支持 npm 包**。只需在导入时使用 `npm:` 说明符，Deno 会处理其余部分。

例如，在 Deno 项目中，您可以这样从 npm 导入 Hono：

```ts
import { Hono } from "npm:hono";
```

这就是你开始所需了解的全部！但是，在这两个运行时之间有一些关键差异，你可以利用这些差异在将你的 Node.js 项目迁移到 Deno 时使代码更简单、更小。

## 使用 Node 的内置模块

Deno 提供了一个兼容层，允许在 Deno 程序中使用 Node.js 的内置 API。要使用它们，您需要在任何使用这些 API 的导入语句中添加 `node:` 前缀：

```js title=main.mjs
import * as os from "node:os";
console.log(os.cpus());
```

然后通过 `deno run main.mjs` 运行，您会注意到它与在 Node.js 中运行程序时输出相同。

更新您应用程序中的任何导入以使用 `node:` 前缀，应该能使任何使用 Node 内置 API 的代码照常工作。

为了方便更新现有代码，Deno 会为未使用 `node:` 前缀的导入提供有用的提示：

```js title="main.mjs"
import * as os from "os";
console.log(os.cpus());
```

```sh
$ deno run main.mjs
error: Relative import path "os" not prefixed with / or ./ or ../
  hint: If you want to use a built-in Node module, add a "node:" prefix (ex. "node:os").
    at file:///main.mjs:1:21
```

相同的提示和其他快速修复也由 Deno LSP 在您的编辑器中提供。

<a href="/api/node/" class="docs-cta runtime-cta">探索内置的 Node API</a>

## 使用 npm 包

Deno 原生支持通过使用 `npm:` 前缀导入 npm 包。例如：

```ts title="main.js"
import * as emoji from "npm:node-emoji";

console.log(emoji.emojify(`:sauropod: :heart:  npm`));
```

可以通过以下命令运行：

```sh
$ deno run main.js
🦕 ❤️ npm
```

在执行 `deno run` 命令之前，不需要 `npm install`，也无需创建 `node_modules` 文件夹。这些包同样受到与 Deno 中其他代码相同的[权限](/runtime/fundamentals/security/)约束。

npm 前缀的格式如下：

```console
npm:<package-name>[@<version-requirement>][/<sub-path>]
```

这也允许一些可能与 `npx` 命令相似的功能。

```console
# npx allows remote execution of a package from npm or a URL
$ npx create-next-app@latest

# deno run allows remote execution of a package from various locations,
# and can scoped to npm via the `npm:` specifier.
$ deno run -A npm:create-next-app@latest
```

有关流行库的示例，请参考 [教程部分](/runtime/tutorials)。

## CommonJS 支持

CommonJS 是一种在[ES 模块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)之前就存在的模块系统。尽管我们坚定地相信 ES 模块是 JavaScript 的未来，但依然存在数以百万计的使用 CommonJS 编写的 npm 库，而 Deno 提供了对它们的全面支持。Deno 将自动确定一个包是否使用 CommonJS，并在导入时无缝工作：

```js title="main.js"
import react from "npm:react";
console.log(react);
```

```shell
$ deno run -E main.js
18.3.1
```

_`npm:react` 是一个 CommonJS 包。Deno 允许您像导入 ES 模块一样导入它。_

Deno 强烈建议在您的代码中使用 ES 模块，但也支持 CommonJS，具有以下限制：

**在使用 CommonJS 模块时 Deno 的权限系统仍然有效。** 可能需要提供至少 `--allow-read` 权限，因为 Deno 将探测文件系统中的 `package.json` 文件和 `node_modules` 目录，以正确解析 CommonJS 模块。

### 使用 .cjs 扩展名

如果文件扩展名为 `.cjs`，Deno 将把该模块视为 CommonJS。

```js title="main.cjs"
const express = require("express");
```

Deno 不会查看 `package.json` 文件和 `type` 选项来判断文件是 CommonJS 还是 ESM。

在使用 CommonJS 时，Deno 期望依赖项将手动安装，并且将存在一个 `node_modules` 目录。最好在您的 `deno.json` 中设置 `"nodeModulesDir": "auto"` 以确保这一点。

```shell
$ cat deno.json
{
  "nodeModulesDir": "auto"
}

$ deno install npm:express
Add npm:express@5.0.0

$ deno run -R -E main.cjs
[Function: createApplication] {
  application: {
    init: [Function: init],
    defaultConfiguration: [Function: defaultConfiguration],
    ...
  }
}
```

`-R` 和 `-E` 标志用于允许权限读取文件和环境变量。

### package.json type 选项

如果存在与该文件相邻的 `package.json` 文件，并且具有选项 `"type": "commonjs"`，Deno 将尝试将 `.js`、`.jsx`、`.ts` 和 `.tsx` 文件作为 CommonJS 加载。

```json title="package.json"
{
  "type": "commonjs"
}
```

```js title="main.js"
const express = require("express");
```

像 Next.js 的打包工具等工具将自动生成这样的 `package.json` 文件。

如果您有一个已存在的使用 CommonJS 模块的项目，可以通过向 `package.json` 文件添加 `"type": "commonjs"` 选项，使其与 Node.js 和 Deno 一起工作。

### 始终检测文件是否可能是 CommonJS

通过在 Deno >= 2.1.2 中使用 `--unstable-detect-cjs` 运行，您可以告诉 Deno 分析模块是否可能是 CommonJS。除非存在一个带有 `{ "type": "module" }` 的 _package.json_ 文件，否则该设置将生效。

在文件系统中查找 package.json 文件并分析模块以检测它是否是 CommonJS 会比不这样做耗时。因此，为了避免使用 CommonJS，Deno 默认不执行此行为。

### 手动创建 require()

替代的方法是手动创建 `require()` 函数的实例：

```js title="main.js"
import { createRequire } from "node:module";
const require = createRequire(import.meta.url);
const express = require("express");
```

在这种情况下，将适用与运行 `.cjs` 文件时相同的要求——需要手动安装依赖项并授予适当的权限标志。

### require(ESM)

Deno 的 `require()` 实现支持要求 ES 模块。

这与 Node.js 中的工作方式相同，您只能 `require()` 其模块图中没有顶级 await 的 ES 模块——或者换句话说，您只能 `require()` “同步”的 ES 模块。

```js title="greet.js"
export function greet(name) {
  return `Hello ${name}`;
}
```

```js title="esm.js"
import { greet } from "./greet.js";

export { greet };
```

```js title="main.cjs"
const esm = require("./esm");
console.log(esm);
console.log(esm.greet("Deno"));
```

```shell
$ deno run -R main.cjs
[Module: null prototype] { greet: [Function: greet] }
Hello Deno
```

### 导入 CommonJS 模块

您还可以在 ES 模块中导入 CommonJS 文件。

```js title="greet.cjs"
module.exports = {
  hello: "world",
};
```

```js title="main.js"
import greet from "./greet.js";
console.log(greet);
```

```shell
$ deno run main.js
{
  "hello": "world"
}
```

**提示和建议**

Deno 会提供有用的提示和建议，指导您在处理 CommonJS 模块时如何编写有效代码。

例如，如果您尝试运行没有 `.cjs` 扩展名的 CommonJS 模块，或没有带有 `{ "type": "commonjs" }` 的 `package.json`，您可能会看到：

```js title="main.js"
module.exports = {
  hello: "world",
};
```

```shell
$ deno run main.js
error: Uncaught (in promise) ReferenceError: module is not defined
module.exports = {
^
    at file:///main.js:1:1

    info: Deno supports CommonJS modules in .cjs files, or when the closest
          package.json has a "type": "commonjs" option.
    hint: Rewrite this module to ESM,
          or change the file extension to .cjs,
          or add package.json next to the file with "type": "commonjs" option,
          or pass --unstable-detect-cjs flag to detect CommonJS when loading.
    docs: https://docs.deno.com/go/commonjs
```

## 条件导出（Conditional exports）

包的导出可以根据[解析模式进行条件判断](https://nodejs.org/api/packages.html#conditional-exports)。从 Deno ESM 模块导入满足的条件如下：

```json
["deno", "node", "import", "default"]
```

这意味着在包导出中键等于这些字符串中的任意一个时，将匹配第一个出现的条件。您可以使用 `--unstable-node-conditions` CLI 标志扩展此列表：

```shell
deno run --unstable-node-conditions development,react-server main.ts
```

```json
["development", "react-server", "deno", "node", "import", "default"]
```

## 导入类型

许多 npm 包带有类型，您可以导入这些类型并直接使用：

```ts
import chalk from "npm:chalk@5";
```

一些包不随附类型，但您可以使用 [`@ts-types`](/runtime/fundamentals/typescript) 指令指定它们的类型。例如，使用 [`@types`](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html#definitelytyped--types) 包：

```ts
// @ts-types="npm:@types/express@^4.17"
import express from "npm:express@^4.17";
```

**模块解析**

官方 TypeScript 编译器 `tsc` 支持不同的 [moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution) 设置。Deno 仅支持现代的 `node16` 解析。不幸的是，许多 npm 包在 node16 模块解析下未能正确提供类型，可能会导致 `deno check` 报告类型错误，而 `tsc` 不报告这些错误。

如果 `npm:` 导入的默认导出似乎具有错误类型（正确的类型似乎在 `.default` 属性下），很可能是该包在从 ESM 的 node16 模块解析下提供了错误的类型。您可以通过检查是否在 `tsc --module node16` 和 `package.json` 中 `"type": "module"` 时也发生错误来验证，或通过访问 [类型错误吗？](https://arethetypeswrong.github.io/) 网站（特别是在 “从 ESM 的 node16” 行）。

如果您想使用不支持 TypeScript node16 模块解析的包，您可以：

1. 在该包的问题跟踪器上打开一个问题报告。（或许可以贡献一个修复 :)）不幸的是，由于包需要支持 ESM 和 CJS 缺乏工具，默认导出需要不同的语法。参见 [microsoft/TypeScript#54593](https://github.com/microsoft/TypeScript/issues/54593)
2. 使用一个 [CDN](/runtime/fundamentals/modules/#url_imports)，该 CDN 为 Deno 支持重建包，而不是使用 `npm:` 标识。
3. 使用 `// @ts-expect-error` 或 `// @ts-ignore` 忽略您代码库中出现的类型错误。

## 包含 Node 类型

Node 附带许多内置类型，如 `Buffer`，这些类型可能在 npm 包的类型中引用。要加载这些类型，您必须向 `@types/node` 包添加类型引用指令：

```ts
/// <reference types="npm:@types/node" />
```

注意，在大多数情况下，不指定版本通常是可以的，因为 Deno 将尝试与其内部的 Node 代码保持同步，但如果必要，您可以始终覆盖使用的版本。

## 可执行的 npm 脚本

具有 `bin` 条目的 npm 包可通过以下格式的标识从命令行执行，而无需进行 `npm install`：

```console
npm:<package-name>[@<version-requirement>][/<binary-name>]
```

例如：

```sh
$ deno run --allow-read npm:cowsay@1.5.0 "Hello there!"
 ______________
< Hello there! >
 --------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

$ deno run --allow-read npm:cowsay@1.5.0/cowthink "What to eat?"
 ______________
( What to eat? )
 --------------
        o   ^__^
         o  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

## node_modules

当您运行 `npm install` 时，npm 会在您的项目中创建一个 `node_modules` 目录，其中存放 `package.json` 文件中指定的依赖项。

Deno 使用 [npm 指定符](/runtime/fundamentals/node/#using-npm-packages) 将 npm 包解析到中心的全局 npm 缓存，而不是在您的项目中使用 `node_modules` 文件夹。这是理想的，因为它占用更少的空间，并保持您的项目目录整洁。

然而，可能会有一些情况下，即使您没有 `package.json`，也需要在 Deno 项目中有一个本地的 `node_modules` 目录（例如，当使用像 Next.js 或 Svelte 这样的框架或依赖于使用 Node-API 的 npm 包时）。

#### 默认 Deno 依赖行为

默认情况下，当您使用 `deno run` 命令时，Deno 不会创建 `node_modules` 目录，依赖项将安装到全局缓存中。这是针对新的 Deno 项目推荐的设置。

#### 自动创建 node_modules

如果您需要在项目中创建 `node_modules` 目录，您可以使用 `--node-modules-dir` 标志或在配置文件中使用 `nodeModulesDir: auto` 选项，告诉 Deno 在当前工作目录中创建一个 `node_modules` 目录：

```sh
deno run --node-modules-dir=auto main.ts
```

或通过配置文件：

```json title="deno.json"
{
  "nodeModulesDir": "auto"
}
```

自动模式会自动将依赖项安装到全局缓存，并在项目根目录创建一个本地的 node_modules 目录。对于依赖于 node_modules 目录的 npm 依赖的项目（大多数使用打包器或有 npm 依赖的 postinstall 脚本的项目），这被推荐。

#### 手动创建 node_modules

如果您的项目中有 `package.json` 文件，您可以使用手动模式，该模式需要一个安装步骤来创建您的 `node_modules` 目录：

```sh
deno install
deno run --node-modules-dir=manual main.ts
```

或通过配置文件：

```json title="deno.json"
{ "nodeModulesDir": "manual" }
```

然后您可以运行 `deno install/npm install/pnpm install` 或其他任何包管理器来创建 `node_modules` 目录。

手动模式是使用 `package.json` 的项目的默认模式。您可能会从 Node.js 项目中识别出这种工作流。它对于使用像 Next.js、Remix、Svelte、Qwik 等框架的项目，或使用 Vite、Parcel 或 Rollup 等工具的项目推荐。

:::note

我们建议您使用默认的 `none` 模式，如果在 `node_modules` 目录中获取缺少包的错误，则回退到 `auto` 或 `manual` 模式。

:::

#### Deno 1.X 的 node_modules

使用 `--node-modules-dir` 标志。

例如，给定 `main.ts`：

```ts
import chalk from "npm:chalk@5";

console.log(chalk.green("Hello"));
```

```sh
deno run --node-modules-dir main.ts
```

运行上述命令时，加上 `--node-modules-dir` 标志，将在当前目录创建一个 `node_modules` 文件夹，具有类似 npm 的文件夹结构。

## Node.js 全局对象

在 Node.js 中，有一些 [全局对象](https://nodejs.org/api/globals.html) 可用于所有程序的范围，这些对象特定于 Node.js，例如 `process` 对象。

以下是您可能在实际使用中遇到的一些全局对象以及如何在 Deno 中使用它们：

- `process` - Deno 提供了 `process` 全局，这是最常用的全局对象，在流行的 npm 包中使用广泛。它对所有代码都是可用的。然而，Deno 会通过提供 lint 警告和快速修复指导您显式从 `node:process` 模块导入它：

```js title="process.js"
console.log(process.versions.deno);
```

```shell
$ deno run process.js
2.0.0
$ deno lint process.js
error[no-process-global]: NodeJS process global is discouraged in Deno
 --> /process.js:1:13
  |
1 | console.log(process.versions.deno);
  |             ^^^^^^^
  = hint: Add `import process from "node:process";`

  docs: https://docs.deno.com/lint/rules/no-process-global


Found 1 problem (1 fixable via --fix)
Checked 1 file
```

- `require()` - 请参见 [CommonJS 支持](#commonjs支持)

- `Buffer` - 要使用 `Buffer` API，必须显式从 `node:buffer` 模块导入：

```js title="buffer.js"
import { Buffer } from "node:buffer";

const buf = new Buffer(5, "0");
```

对于需要 Node.js 特定类型如 `BufferEncoding` 的 TypeScript 用户，使用 `@types/node` 时，这些类型可以通过 `NodeJS` 命名空间获取：

```ts title="buffer-types.ts"
/// <reference types="npm:@types/node" />

// Now you can use NodeJS namespace types
function writeToBuffer(data: string, encoding: NodeJS.BufferEncoding): Buffer {
  return Buffer.from(data, encoding);
}
```

更倾向于使用 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 或其他 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 子类。

- `__filename` - 使用 `import.meta.filename` 替代。

- `__dirname` - 使用 `import.meta.dirname` 替代。

## Node-API 插件

Deno 支持 [Node-API 插件](https://nodejs.org/api/n-api.html)，这些插件被流行的 npm 包使用，如 [`esbuild`](https://www.npmjs.com/package/esbuild)、[`npm:sqlite3`](https://www.npmjs.com/package/sqlite3) 或 [`npm:duckdb`](https://www.npmjs.com/package/duckdb)。

您可以期望所有使用公共和文档 Node-API 的包都能正常工作。

:::info

大多数使用 Node-API 插件的包依赖于 npm “生命周期脚本”，如 `postinstall`。

虽然 Deno 支持它们，但出于安全考虑，默认情况下不执行这些脚本。请阅读 [`deno install` 文档](/runtime/reference/cli/install/) 了解更多信息。

:::

自 Deno 2.0 以来，使用 Node-API 插件的 npm 包 **仅在存在 `node_modules/` 目录时支持**。添加 `"nodeModulesDir": "auto"` 或 `"nodeModulesDir": "manual"` 设置到您的 `deno.json` 文件，或者使用 `--node-modules-dir=auto|manual` 标志运行，以确保这些包正常工作。在配置错误的情况下，Deno 会提供提示以说明如何解决此情况。

## 从 Node 迁移到 Deno

在 Deno 中运行您的 Node.js 项目是一个简单的过程。在大多数情况下，您可以期望几乎不需要更改，如果您的项目使用 ES 模块编写。

需要注意的主要几点包括：

1. 导入 Node.js 内置模块需要 `node:` 前缀：

```js
// ❌
import * as fs from "fs";
import * as http from "http";

// ✅
import * as fs from "node:fs";
import * as http from "node:http";
```

:::tip

建议无论如何在您现有项目中更改这些导入前缀。这也是在 Node.js 中导入它们的推荐方式。

:::

2. 一些 [在 Node.js 中可用的全局对象](#nodejs-global-objects) 需要显式导入，例如 `Buffer`：

```js
import { Buffer } from "node:buffer";
```

3. `require()` 仅在扩展名为 `.cjs` 的文件中可用，在其他文件中必须手动创建 `require()` 实例 [需要创建](#nodejs-global-objects)。 npm 依赖可以在不考虑文件扩展名的情况下使用 `require()`。

### 运行脚本

Deno 原生支持运行 npm 脚本，通过 [`deno task`](/runtime/reference/cli/task_runner/) 子命令（如果您从 Node.js 迁移，这类似于 `npm run script` 命令）。考虑以下有一个名为 `start` 的脚本的 Node.js 项目，它在其 `package.json` 内：

```json title="package.json"
{
  "name": "my-project",
  "scripts": {
    "start": "eslint"
  }
}
```

您可以通过运行以下命令在 Deno 中执行此脚本：

```sh
deno task start
```

### 可选改进

Deno 的核心优势之一是统一的工具链，开箱即用地支持 TypeScript，和包括 linter、格式化程序以及测试运行器等工具。切换到 Deno 使您能够简化工具链，减少项目中动移动的部件数量。

**配置**

Deno 有自己的配置文件 `deno.json` 或 `deno.jsonc`，可用于[配置您的项目](/runtime/fundamentals/configuration/)。

您可以使用它来使用 `imports` 选项[定义依赖项](/runtime/fundamentals/configuration/) - 您可以逐个迁移 `package.json` 中的依赖项，或者选择在配置文件中完全不定义它们，而在代码中使用 `npm:` 前缀。

除了指定依赖项，您还可以使用 `deno.json` 定义任务、lint 和格式选项、路径映射以及其他运行时配置。

**Linting**

Deno 自带一个内置 linter，性能优先考虑。它与 ESlint 相似，虽然规则数量有限。如果您不依赖于 ESLint 插件，您可以从 `package.json` 的 `devDependencies` 部分删除 `eslint` 依赖，并改为使用 `deno lint`。

Deno 可以在几毫秒内 lint 大型项目。您可以通过运行以下命令在项目上尝试：

```sh
deno lint
```

这将对您项目中的所有文件进行 lint。 当 linter 检测到问题时，它将在您的编辑器和终端输出中显示该行。如下所示的示例：

```sh
error[no-constant-condition]: Use of a constant expressions as conditions is not allowed.
 --> /my-project/bar.ts:1:5
  |
1 | if (true) {
  |     ^^^^
  = hint: Remove the constant expression

  docs: https://docs.deno.com/lint/rules/no-constant-condition


Found 1 problem
Checked 4 files
```

许多 lint 问题可以通过传递 `--fix` 标志自动修复：

```sh
deno lint --fix
```

所有支持的 linting 规则的完整列表可以在 [https://docs.deno.com/lint/](https://docs.deno.com/lint/) 找到。要了解更多关于如何配置 linter 的信息，请查看 [deno lint 子命令](/runtime/reference/cli/linter/)。

**格式化**

Deno 配备了一个 [内置格式化工具](/runtime/reference/cli/formatter/)，可以选择根据 Deno 风格指南格式化您的代码。您可以取代将 `prettier` 添加到 `devDependencies`，而是使用 Deno 的内置零配置代码格式化器 `deno fmt`。

您可以通过运行以下命令在项目上运行格式化程序：

```sh
deno fmt
```

如果在 CI 中使用 `deno fmt`，也可以传递 `--check` 参数，当检测到格式不正确的代码时使格式化程序退出并显示错误。

```sh
deno fmt --check
```

格式化规则可以在您的 `deno.json` 文件中配置。要了解有关如何配置格式化程序的更多信息，请查看 [deno fmt 子命令](/runtime/reference/cli/formatter/)。

**测试**

Deno 鼓励为您的代码编写测试，并提供一个内置的测试运行器，使编写和运行测试变得容易。测试运行器与 Deno 紧密集成，因此您不需要额外的配置就能使 TypeScript 或其他功能正常工作。

```ts title="my_test.ts"
Deno.test("my test", () => {
  // Your test code here
});
```

```sh
deno test
```

传递 `--watch` 标志时，当导入的任何模块发生变化时，测试运行器将自动重新加载。

要了解有关测试运行器的更多信息以及如何配置它，请查看 [deno test 子命令](/runtime/reference/cli/test/) 文档。

## 私有仓库

:::caution

不要与 [私有仓库和模块](/runtime/fundamentals/modules/#private-repositories) 混淆。

:::

Deno 支持私有仓库，这允许您托管和共享自己的模块。这对于希望将其代码保持私密的组织或希望与特定人员分享代码的个人非常有用。

### 什么是私有仓库？

大型组织通常会托管自己的私有 npm 仓库，以安全地管理内部包。这些私有仓库作为存储库，通过它们组织可以发布和存储其专有或自定义包。与公共 npm 仓库不同，私有仓库仅对组织内的授权用户可访问。

### 如何在 Deno 中使用私有仓库

首先，配置您项目中的 [`.npmrc`](https://docs.npmjs.com/cli/v10/configuring-npm/npmrc) 文件，以指向您的私有仓库。 `.npmrc` 文件必须位于项目根目录或 `$HOME` 目录中。在 `.npmrc` 文件中添加以下内容：

```sh
@mycompany:registry=http://mycompany.com:8111/
//mycompany.com:8111/:_auth=secretToken
```

将 `http://mycompany.com:8111/` 替换为您的私有仓库的实际 URL，并将 `secretToken` 替换为您的身份验证令牌。

然后，更新您的 `deno.json` 或 `package.json` 以指定您私有包的导入路径。例如：

```json title="deno.json"
{
  "imports": {
    "@mycompany/package": "npm:@mycompany/package@1.0.0"
  }
}
```

或者如果您正在使用 `package.json`：

```json title="package.json"
{
  "dependencies": {
    "@mycompany/package": "1.0.0"
  }
}
```

现在您可以在 Deno 代码中导入您的私有包：

```typescript title="main.ts"
import { hello } from "@mycompany/package";

console.log(hello());
```

并通过以下命令运行：

```sh
deno run main.ts
```

## 从 Node 到 Deno 速查表

| Node.js                                | Deno                          |
| -------------------------------------- | ----------------------------- |
| `node file.js`                         | `deno file.js`                |
| `ts-node file.ts`                      | `deno file.ts`                |
| `nodemon`                              | `deno run --watch`            |
| `node -e`                              | `deno eval`                   |
| `npm i` / `npm install`                | `deno install`                |
| `npm install -g`                       | `deno install -g`             |
| `npm run`                              | `deno task`                   |
| `eslint`                               | `deno lint`                   |
| `prettier`                             | `deno fmt`                    |
| `package.json`                         | `deno.json` 或 `package.json` |
| `tsc`                                  | `deno check` ¹                |
| `typedoc`                              | `deno doc`                    |
| `jest` / `ava` / `mocha` / `tap` / 等 | `deno test`                   |
| `nexe` / `pkg`                         | `deno compile`                |
| `npm explain`                          | `deno info`                   |
| `nvm` / `n` / `fnm`                    | `deno upgrade`                |
| `tsserver`                             | `deno lsp`                    |
| `nyc` / `c8` / `istanbul`              | `deno coverage`               |
| benchmarks                             | `deno bench`                  |

¹ 类型检查是自动进行的，TypeScript 编译器已内置在 `deno` 二进制文件中。

---

# runtime/fundamentals/open_telemetry.md

> 学习如何在 Deno 应用程序中使用 OpenTelemetry 实现可观察性。涵盖追踪、指标收集和与监控系统的集成。

URL: https://docs.deno.com/runtime/fundamentals/open_telemetry


Deno 内置支持 [OpenTelemetry](https://opentelemetry.io/)。

> OpenTelemetry 是一组 API、SDK 和工具。使用它来对软件进行仪器化，生成、收集和导出遥测数据（指标、日志和追踪）以帮助您分析软件的性能和行为。
>
> <i>- https://opentelemetry.io/</i>

此集成让您能够使用 OpenTelemetry 的可观察性工具（如日志、指标和追踪）来监控您的 Deno 应用程序。

Deno 提供以下功能：

- 使用 OpenTelemetry 协议，将收集的指标、追踪和日志导出到服务器。
- 对 Deno 运行时进行[自动仪器化](#自动仪器化)，采集 OpenTelemetry 的指标、追踪和日志。
- [收集使用 `npm:@opentelemetry/api` 包创建的用户自定义指标、追踪和日志](#用户指标)。

## 快速开始

要启用 OpenTelemetry 集成，请设置环境变量 `OTEL_DENO=true`：

```sh
OTEL_DENO=true deno run my_script.ts
```

这将自动收集并通过 HTTP 的 Protobuf 格式（`http/protobuf`）将运行时可观察性数据导出到 `localhost:4318` 的 OpenTelemetry 端点。

:::tip

如果您还未搭建 OpenTelemetry 收集器，可以使用以下命令快速启动 [Docker 中的本地 LGTM 堆栈](https://github.com/grafana/docker-otel-lgtm/tree/main?tab=readme-ov-file)（Loki（日志）、Grafana（仪表盘）、Tempo（追踪）和 Prometheus（指标））：

```sh
docker run --name lgtm -p 3000:3000 -p 4317:4317 -p 4318:4318 --rm -ti \
	-v "$PWD"/lgtm/grafana:/data/grafana \
	-v "$PWD"/lgtm/prometheus:/data/prometheus \
	-v "$PWD"/lgtm/loki:/data/loki \
	-e GF_PATHS_DATA=/data/grafana \
	docker.io/grafana/otel-lgtm:0.8.1
```

然后，您可以使用用户名 `admin` 和密码 `admin` 登录 Grafana 仪表盘，地址为 `http://localhost:3000`。

:::

这将自动收集并导出运行时的可观察性数据，例如 `console.log`、HTTP 请求的追踪和 Deno 运行时指标。
[了解更多关于自动仪器化的信息](#自动仪器化)。

您也可以使用 `npm:@opentelemetry/api` 包创建自己的指标、追踪和日志。
[了解更多关于用户定义的指标](#用户指标)。

## 自动仪器化

Deno 会自动收集并将部分可观察性数据导出到 OTLP 端点。

这些数据通过名为 `deno` 的内置仪器化范围导出，该范围名称为 `deno`，版本即 Deno 运行时的版本。例如，`deno:2.1.4`。

### 追踪

Deno 会自动为多种操作创建跨度，例如：

- 使用 `Deno.serve` 提供的传入 HTTP 请求。
- 使用 `fetch` 发出的传出 HTTP 请求。

#### `Deno.serve`

当您使用 `Deno.serve` 创建 HTTP 服务器时，系统会为每个传入请求创建一个跨度。该跨度在响应头发送时自动结束（而非等待响应体完全发送）。

创建的跨度名称为 `${method}`，跨度类型为 `server`。

创建跨度时自动添加如下属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.full`：请求的完整 URL（等同于 `req.url`）。
- `url.scheme`：请求 URL 的协议（例如 `http` 或 `https`）。
- `url.path`：请求 URL 的路径部分。
- `url.query`：请求 URL 的查询字符串。

请求处理完成后，会添加下列属性：

- `http.response.status_code`：响应的状态码。

Deno 不会自动向跨度添加 `http.route` 属性，因为运行时无法知道路由细节，路由由用户处理函数中的逻辑决定。如需添加 `http.route`，请在处理函数中使用 `npm:@opentelemetry/api` 设置该属性，同时建议更新跨度名称以包含路由信息。

```ts
import { trace } from "npm:@opentelemetry/api@1";

const INDEX_ROUTE = new URLPattern({ pathname: "/" });
const BOOK_ROUTE = new URLPattern({ pathname: "/book/:id" });

Deno.serve(async (req) => {
  const span = trace.getActiveSpan();
  if (INDEX_ROUTE.test(req.url)) {
    span.setAttribute("http.route", "/");
    span.updateName(`${req.method} /`);

    // 处理首页路由
  } else if (BOOK_ROUTE.test(req.url)) {
    span.setAttribute("http.route", "/book/:id");
    span.updateName(`${req.method} /book/:id`);

    // 处理图书路由
  } else {
    return new Response("未找到", { status: 404 });
  }
});
```

#### `fetch`

当您使用 `fetch` 发出请求时，系统会为该请求创建一个跨度，且在收到响应头时自动结束。

创建的跨度名称为 `${method}`，跨度类型为 `client`。

创建跨度时自动添加如下属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.full`：请求的完整 URL。
- `url.scheme`：请求 URL 的协议。
- `url.path`：请求 URL 的路径部分。
- `url.query`：请求 URL 的查询字符串。

收到响应后，添加以下属性：

- `http.status_code`：响应的状态码。

### 指标

自动收集和导出的指标包括：

#### `Deno.serve` / `Deno.serveHttp`

##### `http.server.request.duration`

一个直方图，记录通过 `Deno.serve` 或 `Deno.serveHttp` 提供的传入 HTTP 请求的持续时间。测量时间为从请求接收至响应头发送的时间，不包含发送响应体的时间。单位为秒。该直方图的桶边界为：
`[0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0, 7.5, 10.0]`。

该指标记录以下属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.scheme`：请求 URL 的协议。
- `network.protocol.version`：请求所使用的 HTTP 协议版本（例如 `1.1` 或 `2`）。
- `server.address`：服务器监听的地址。
- `server.port`：服务器监听的端口。
- `http.response.status_code`：响应状态码（请求无致命错误时）。
- `error.type`：发生的错误类型（请求处理出现错误时）。

##### `http.server.active_requests`

一个量表，统计任意时刻由 `Deno.serve` 或 `Deno.serveHttp` 正在处理的活动请求数量，即已接收但尚未发送响应头的请求数。该指标记录以下属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.scheme`：请求 URL 的协议。
- `server.address`：服务器监听的地址。
- `server.port`：服务器监听的端口。

##### `http.server.request.body.size`

一个直方图，记录传入 HTTP 请求的请求体大小，单位为字节。直方图桶边界为：
`[0, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000]`。

记录属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.scheme`：请求 URL 的协议。
- `network.protocol.version`：请求所使用的 HTTP 协议版本。
- `server.address`：服务器监听的地址。
- `server.port`：服务器监听的端口。
- `http.response.status_code`：响应状态码（无致命错误时）。
- `error.type`：错误类型（处理异常时）。

##### `http.server.response.body.size`

一个直方图，记录传入 HTTP 请求的响应体大小，单位为字节。直方图桶边界同请求体大小指标。

记录属性：

- `http.request.method`：请求的 HTTP 方法。
- `url.scheme`：请求 URL 的协议。
- `network.protocol.version`：请求所使用的 HTTP 协议版本。
- `server.address`：服务器监听的地址。
- `server.port`：服务器监听的端口。
- `http.response.status_code`：响应状态码（无致命错误时）。
- `error.type`：错误类型（处理异常时）。

### 日志

自动收集并导出的日志包括：

- 使用 `console.*` 方法（如 `console.log`、`console.error`）产生的任意日志。
- 由 Deno 运行时产生的日志，如调试日志、下载日志等。
- 导致 Deno 运行时退出的任何错误（无论来自用户代码还是运行时本身）。

在 JavaScript 代码中发生的日志会携带相关的跨度上下文（如果日志发生在活跃跨度内）。

`console` 自动仪器化可以通过环境变量 `OTEL_DENO_CONSOLE` 配置：

- `capture`：日志既会输出到 stdout/stderr，也会被导出到 OpenTelemetry。（默认）
- `replace`：日志不输出到 stdout/stderr，只有导出到 OpenTelemetry。
- `ignore`：日志只输出到 stdout/stderr，不导出到 OpenTelemetry。

## 用户指标

除自动收集的遥测数据外，您还可以使用 `npm:@opentelemetry/api` 包创建自己的指标和追踪。

您无需特别配置 `npm:@opentelemetry/api` 包以便在 Deno 中使用，Deno 会自动完成配置。无需调用 `metrics.setGlobalMeterProvider()`、
`trace.setGlobalTracerProvider()` 或 `context.setGlobalContextManager()`。所有资源配置、导出设置等均通过环境变量实现。

Deno 与版本 `1.x` 的 `npm:@opentelemetry/api` 包兼容。您既可以直接从 `npm:@opentelemetry/api@1` 导入，也可以使用 `deno add` 本地安装该包后由 `@opentelemetry/api` 导入。

```sh
deno add npm:@opentelemetry/api@1
```

在追踪和指标中，您需要为跟踪器和仪表分别命名。如果您为库做仪器化，应使用库名（如 `my-awesome-lib`）；如果为应用程序做仪器化，应使用应用名（如 `my-app`）。版本应设置为库或应用的版本。

### 追踪

要创建新跨度，先从 `npm:@opentelemetry/api` 导入 `trace` 并获取一个跟踪器：

```ts
import { trace } from "npm:@opentelemetry/api@1";

const tracer = trace.getTracer("my-app", "1.0.0");
```

之后使用 `tracer.startActiveSpan` 创建一个新的跨度并传入回调。需在回调中手动调用 `span.end()` 结束该跨度。

```ts
function myFunction() {
  return tracer.startActiveSpan("myFunction", (span) => {
    try {
      // 执行 myFunction 的工作
    } catch (error) {
      span.recordException(error);
      span.setStatus({
        code: trace.SpanStatusCode.ERROR,
        message: (error as Error).message,
      });
      throw error;
    } finally {
      span.end();
    }
  });
}
```

应在 `finally` 中调用 `span.end()` 以保证跨度结束，无论是否发生异常。异常时调用 `span.recordException` 和 `span.setStatus` 以便于记录。

在回调内部，创建的跨度是“活动跨度”，可使用 `trace.getActiveSpan()` 访问。此“活动跨度”在回调及其调用函数内使用时会作为父跨度。
[了解更多关于上下文传播的信息](#上下文传播)。

`startActiveSpan` 返回回调函数的返回值。

在跨度生命周期内，您可以调用 `setAttribute` 和 `setAttributes` 添加属性，即结构化元数据键值对。

```ts
span.setAttribute("key", "value");
span.setAttributes({ success: true, "bar.count": 42n, "foo.duration": 123.45 });
```

属性值支持字符串、数字（浮点）、大整数（限制为 u64）、布尔值，或者这些类型的数组。其它类型会被忽略。

可以用 `updateName` 方法更改跨度名称：

```ts
span.updateName("new name");
```

且可用 `setStatus` 设置跨度状态。`recordException` 用于记录生命周期内的异常，创建带堆栈跟踪和名称的事件附加到跨度。**`recordException` 不会设置状态为 `ERROR`，需手动调用 `setStatus`**。

```ts
import { SpanStatusCode } from "npm:@opentelemetry/api@1";

span.setStatus({
  code: SpanStatusCode.ERROR,
  message: "发生了一个错误",
});
span.recordException(new Error("发生了一个错误"));

// 或

span.setStatus({
  code: SpanStatusCode.OK,
});
```

Spans can also have
[events](https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api._opentelemetry_api.Span.html#addevent)
and
[links](https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api._opentelemetry_api.Span.html#addlink)
added to them. Events are points in time that are associated with the span.
Links are references to other spans.

```ts
// 向跨度添加事件
span.addEvent("button_clicked", {
  id: "submit-button",
  action: "submit",
});

// 带时间戳的事件
span.addEvent("process_completed", { status: "success" }, Date.now());
```

事件可包含类似于跨度的可选属性。它们用于标记跨度生命周期内重要时刻，无需创建额外跨度。

您也可以用 `tracer.startSpan` 手动创建跨度，该方法返回跨度对象。此方法不会设置创建的跨度为活动跨度，故后续创建的跨度或 `console.log` 不会自动继承它。可配合 [上下文传播 API](#上下文传播) 手动将此跨度设置为活动跨度。

`tracer.startActiveSpan` 和 `tracer.startSpan` 可接受含以下任意属性的选项参数：

- `kind`: 跨度类型。可为 `SpanKind.CLIENT`、`SpanKind.SERVER`、`SpanKind.PRODUCER`、`SpanKind.CONSUMER` 或 `SpanKind.INTERNAL`。默认值为 `SpanKind.INTERNAL`。
- `startTime`：表示跨度开始时间的 `Date` 对象，或自 Unix 纪元起的毫秒数。如果未提供，则使用当前时间。
- `attributes`: 要添加到跨度的属性对象。
- `links`: 要添加到跨度的链接数组。
- `root`: 布尔值，表示跨度是否为根跨度。如果为 `true`，则该跨度没有父跨度（即使存在活动跨度）。

在选项参数之后，`tracer.startActiveSpan` 和 `tracer.startSpan` 还可以接收来自
[上下文传播 API](#上下文传播) 的 `context` 对象。

了解完整追踪 API 请参考
[OpenTelemetry JS API 文档](https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_api._opentelemetry_api.TraceAPI.html)。

### 指标

要创建指标，首先从 `npm:@opentelemetry/api` 导入 `metrics` 对象并创建一个仪表：

```ts
import { metrics } from "npm:@opentelemetry/api@1";

const meter = metrics.getMeter("my-app", "1.0.0");
```

然后用仪表创建仪器，用于记录数值：

```ts
const counter = meter.createCounter("my_counter", {
  description: "一个简单的计数器",
  unit: "1",
});

counter.add(1);
counter.add(2);
```

记录时也可附带属性：

```ts
counter.add(1, { color: "red" });
counter.add(2, { color: "blue" });
```

:::tip

OpenTelemetry 中建议指标属性保持低基数，即属性值的唯一组合数量不宜过多。例如，用户所属洲的属性是低基数，但用户的精确经纬度则属于高基数。高基数属性可能导致指标存储与导出问题，推荐通过跨度和日志处理高基数数据。

:::

常见仪器类型：

- **计数器**：单调递增的数值，只能增加。适合计数处理请求数等。
- **上下计数器**：可增可减，适合表示活动连接数、进行中请求数。
- **仪表**：可以任意设置值，适合非累积值，如当前温度。
- **直方图**：记录数值分布。例如请求响应时间（毫秒），用于计算百分位、平均等统计。预定义桶边界默认为 `[0.0, 5.0, 10.0, 25.0, 50.0, 75.0, 100.0, 250.0, 500.0, 750.0, 1000.0, 2500.0, 5000.0, 7500.0, 10000.0]`。

还有几类可观察（异步）仪器，没有同步记录方法，而是提供回调用于异步上报值，OpenTelemetry SDK 在导出前调用回调。

```ts
const counter = meter.createObservableCounter("my_counter", {
  description: "一个简单的计数器",
  unit: "1",
});
counter.addCallback((res) => {
  res.observe(1);
  // 或
  res.observe(1, { color: "red" });
});
```

存在三种可观察仪器类型：

- **ObservableCounter**：异步可观察的计数器。用于常增值，如处理的请求数。
- **ObservableUpDownCounter**：异步可观察的上下计数器。值能增减，如活动连接数或进行中请求数。
- **ObservableGauge**：异步可观察的仪表。用于任意值，如当前温度。

了解完整指标 API 请参考
[OpenTelemetry JS API 文档](https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_api._opentelemetry_api.MetricsAPI.html)。

### 实际示例

有关在 Deno 应用中实现 OpenTelemetry 的实际示例，请参见教程：

- [基础 OpenTelemetry 教程](/examples/basic_opentelemetry_tutorial/) - 一个带有自定义指标和追踪的简单 HTTP 服务器
- [分布式追踪教程](/examples/otel_span_propagation_tutorial/) - 跨服务边界追踪的高级技巧

## 上下文传播

在 OpenTelemetry 中，上下文传播是指将一些上下文信息（如当前跨度）从应用的一个部分传递到另一个部分，而无需手动将其作为参数传递给每个函数。

在 Deno 中，上下文传播遵循 TC39 提案的 `AsyncContext` 规则。`AsyncContext` API 尚未向用户公开，但内部用于在异步边界上传播活动跨度和其他上下文信息。

简要说明 AsyncContext 传播工作方式：

- 当启动一个新的异步任务（例如 Promise 或定时器）时，当前上下文会被保存。
- 其他代码可以在不同上下文中并发执行。
- 当异步任务完成时，保存的上下文被恢复。

这意味着异步上下文传播类似于一个全局变量，其作用域限定于当前异步任务，并自动拷贝到由当前任务启动的新异步任务中。

来自 `npm:@opentelemetry/api@1` 的 `context` API 向用户暴露此功能。用法如下：

```ts
import { context } from "npm:@opentelemetry/api@1";

// 获取当前活动上下文
const currentContext = context.active();

// 创建新的上下文并设值
const newContext = currentContext.setValue("id", 1);

// 设值不改变当前上下文
console.log(currentContext.getValue("id")); // undefined

// 在新上下文内执行
context.with(newContext, () => {
  console.log(context.active().getValue("id")); // 1

  function myFunction() {
    return context.active().getValue("id");
  }
  console.log(myFunction()); // 1

  setTimeout(() => {
    console.log(context.active().getValue("id")); // 1
  }, 10);
});

// 外部上下文未变
console.log(context.active().getValue("id")); // undefined
```

上下文 API 与跨度集成，您可以将跨度装入上下文并在上下文中执行函数：

```ts
import { context, trace } from "npm:@opentelemetry/api@1";

const tracer = trace.getTracer("my-app", "1.0.0");

const span = tracer.startSpan("myFunction");
const contextWithSpan = trace.setSpan(context.active(), span);

context.with(contextWithSpan, () => {
  const activeSpan = trace.getActiveSpan();
  console.log(activeSpan === span); // true
});

// 记得结束跨度！
span.end();
```

了解完整上下文 API 请参考
[OpenTelemetry JS API 文档](https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_api._opentelemetry_api.ContextAPI.html)。

## 配置

通过设置环境变量 `OTEL_DENO=true` 启用 OpenTelemetry 集成。

OTLP 导出端点和协议可通过环境变量 `OTEL_EXPORTER_OTLP_ENDPOINT` 和 `OTEL_EXPORTER_OTLP_PROTOCOL` 配置。

若端点需要身份验证，可使用环境变量 `OTEL_EXPORTER_OTLP_HEADERS` 设置请求头。

指标、追踪和日志导出的端点也可用以下专用变量分别覆盖，例如：

- `OTEL_EXPORTER_OTLP_METRICS_ENDPOINT`
- `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT`
- `OTEL_EXPORTER_OTLP_LOGS_ENDPOINT`

有关 OTLP 头部配置详情，请参考 [OpenTelemetry 官网](https://opentelemetry.io/docs/specs/otel/protocol/exporter/#configuration-options)。

遥测数据关联的资源属性通过环境变量 `OTEL_SERVICE_NAME` 和 `OTEL_RESOURCE_ATTRIBUTES` 配置。除 `OTEL_RESOURCE_ATTRIBUTES` 设置的属性外，自动添加：

- `service.name`：未设置 `OTEL_SERVICE_NAME` 时值为 `<unknown_service>`。
- `process.runtime.name`：`deno`。
- `process.runtime.version`：Deno 运行时版本。
- `telemetry.sdk.name`：`deno-opentelemetry`。
- `telemetry.sdk.language`：`deno-rust`。
- `telemetry.sdk.version`：Deno 版本与使用的 `opentelemetry` Rust crate 版本，通过 `-` 连接。

传播器可通过 `OTEL_PROPAGATORS` 环境变量配置，默认值为 `tracecontext,baggage`，用逗号分隔多项，目前支持：

- `tracecontext`：W3C Trace Context 格式。
- `baggage`：W3C Baggage 格式。

指标收集频率使用 `OTEL_METRIC_EXPORT_INTERVAL` 配置，默认 60000 毫秒（60 秒）。

跨度导出批处理配置参考
[OpenTelemetry 规范](https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#batch-span-processor)。

日志导出批处理配置参考
[OpenTelemetry 规范](https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#batch-log-record-processor)。

## 传播器

Deno 支持上下文传播器，用以自动跨进程边界传播追踪上下文，实现分布式追踪，跟踪请求在服务链中流转。

传播器负责在载体中编码（如 HTTP 头）并解码上下文信息（如追踪与跨度 ID），从而实现服务间追踪上下文传递。

默认支持以下传播器：

- `tracecontext`：W3C Trace Context 传播格式，是 HTTP 头传播追踪上下文的标准方式。
- `baggage`：W3C Baggage 格式，允许跨服务传递键值对。

:::note

这些传播器会自动与 Deno 的 `fetch` 和 `Deno.serve` 配合，使 HTTP 请求可以端到端自动传播追踪上下文，无需手动管理。

:::

您可以通过 `@opentelemetry/api` 包访问传播 API：

```ts
import { context, propagation, trace } from "npm:@opentelemetry/api@1";

// 从传入 HTTP 头提取上下文
function extractContextFromHeaders(headers: Headers) {
  const ctx = context.active();
  return propagation.extract(ctx, headers);
}

// 向传出 HTTP 头注入上下文
function injectContextIntoHeaders(headers: Headers) {
  const ctx = context.active();
  propagation.inject(ctx, headers);
  return headers;
}

// 示例：进行带有传播追踪上下文的 fetch 请求
async function tracedFetch(url: string) {
  const headers = new Headers();
  injectContextIntoHeaders(headers);

  return await fetch(url, { headers });
}
```

## 限制

Deno 的 OpenTelemetry 集成仍在开发中，存在以下限制：

- 追踪始终被采样（即 `OTEL_TRACE_SAMPLER=parentbased_always_on`）。
- 追踪只支持无属性的链接。
- 不支持指标采样。
- 不支持自定义日志流（仅支持 `console.log` 和 `console.error` 日志）。
- 唯一支持的导出器是 OTLP，其他导出器未支持。
- OTLP 仅支持 `http/protobuf` 和 `http/json` 协议，不支持 `grpc` 等。
- 可观察（异步）仪表采集的指标在进程退出或崩溃时不会被采集，故最后指标可能未导出。同步指标可正常导出。
- 追踪跨度不遵守环境变量中指定的 `OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT`、`OTEL_ATTRIBUTE_COUNT_LIMIT`、`OTEL_SPAN_EVENT_COUNT_LIMIT`、`OTEL_SPAN_LINK_COUNT_LIMIT`、`OTEL_EVENT_ATTRIBUTE_COUNT_LIMIT` 和 `OTEL_LINK_ATTRIBUTE_COUNT_LIMIT` 限制。
- 不尊重环境变量 `OTEL_METRIC_EXPORT_TIMEOUT`。
- 未知的 HTTP 方法不会在 `http.request.method` 跨度属性中标准化为 `_OTHER`，与 OpenTelemetry 语义约定不符。
- `Deno.serve` 的 HTTP 服务器跨度在处理程序抛出（调用 `onError`）时不会设置错误状态，错误也不通过事件附加到跨度。
- `fetch` 的 HTTP 客户端跨度中无机制添加 `http.route` 属性或更新跨度名称以包含路由信息。

---

# 安全性与权限

> Deno 安全模型和权限系统指南。了解安全默认设置、权限标志、运行时提示以及如何使用细粒度访问控制安全执行代码。

URL: https://docs.deno.com/runtime/fundamentals/security


Deno 默认是安全的。除非你特意启用，否则在 Deno 中运行的程序没有访问敏感 API 的权限，例如文件系统访问、网络连接或环境访问。你必须通过命令行标志或运行时权限提示明确授予对这些资源的访问。这与 Node 的一个主要区别是，Node 中的依赖项会自动获得对所有系统 I/O 的完全访问权限，这可能会将隐藏的漏洞引入你的项目。

在使用 Deno 运行完全不可信的代码之前，请阅读下面的 [执行不可信代码](#executing-untrusted-code) 部分。

## 关键原则

在深入了解权限的具体细节之前，了解 Deno 安全模型的关键原则是很重要的：

- **默认情况下没有 I/O 访问**：在 Deno 运行时中执行的代码没有权限读取或写入任意文件，在文件系统上进行网络请求或打开网络监听器，访问环境变量，或生成子进程。
- **同一特权级别下代码的执行没有限制**：Deno 允许通过多种方式执行任何代码（JS/TS/Wasm），包括 `eval`、`new Function`、动态导入和网页工作者，几乎不限制代码来源（网络、npm、JSR 等）。
- **同一应用程序的多次调用可以共享数据**：Deno 提供了一种机制，使同一应用程序的多次调用可以通过内置缓存和 KV 存储 API 共享数据。不同的应用程序不能看到彼此的数据。
- **所有在同一线程上执行的代码共享相同的特权级别**：所有在同一线程上执行的代码共享相同的特权级别。在同一线程内，不同模块不可能拥有不同的特权级别。
- **代码不能在未获得用户同意的情况下提升其特权**：在 Deno 运行时中执行的代码不能在未获得用户的明确同意（通过交互式提示或调用时间标志）提升其特权。
- **初始静态模块图可以不受限制地导入本地文件**：所有在初始静态模块图中导入的文件可以不受限制地导入，即使该文件未明确授予读取权限。这不适用于任何动态模块导入。

这些关键原则旨在提供一个用户可以以最低风险执行代码的环境，以免对主机计算机或网络造成伤害。安全模型旨在易于理解，并在运行时与执行其中的代码之间提供清晰的关注点分离。安全模型由 Deno 运行时强制执行，并不依赖于底层操作系统。

## 权限

默认情况下，对大多数系统 I/O 的访问是被拒绝的。即便如此，仍然有一些 I/O 操作在有限的范围内允许，这些将在下面描述。

为了启用这些操作，用户必须明确授予 Deno 运行时权限。这是通过将 `--allow-read`、`--allow-write`、`--allow-net`、`--allow-env` 和 `--allow-run` 标志传递给 `deno` 命令来完成的。

在执行脚本时，用户也可以在运行时提示时明确授予对特定文件、目录、网络地址、环境变量和子进程的访问权限。如果 stdout/stderr 不是 TTY，或者在 `deno` 命令中传递了 `--no-prompt` 标志，则不会显示提示。

用户还可以通过使用 `--deny-read`、`--deny-write`、`--deny-net`、`--deny-env` 和 `--deny-run` 标志明确拒绝对特定资源的访问。这些标志优先于许可标志。例如，如果你允许网络访问但拒绝访问特定域，则拒绝标志将优先。

Deno 还提供了 `--allow-all` 标志，该标志授予脚本所有权限。这将 **完全禁用** 安全沙箱，应该谨慎使用。`--allow-all` 具有与在 Node.js 中运行脚本相同的安全属性（即无安全性）。

定义：`-A, --allow-all`

```sh
deno run -A script.ts
deno run --allow-all script.ts
```

默认情况下，Deno 不会为权限请求生成堆栈跟踪，因为这会影响性能。用户可以通过将环境变量 `DENO_TRACE_PERMISSIONS` 设置为 `1` 来启用堆栈跟踪。

Deno 还可以生成所有访问权限的审计日志；这可以通过将环境变量 `DENO_AUDIT_PERMISSIONS` 设置为路径来实现。无论权限是否被允许，该功能都有效。输出格式为 JSONL，其中每行是一个包含以下键的对象：

- `v`：格式的版本号
- `datetime`：权限访问的时间，使用 RFC 3339 格式
- `permission`：权限的名称
- `value`：访问权限时使用的值，如果无值则为 `null`

该模式可参考  
[这里](https://deno.land/x/deno/cli/schemas/permission-audit.v1.json)。

此外，该环境变量可以与上述的 `DENO_TRACE_PERMISSIONS` 结合使用，这样每条记录将多一个 `stack` 字段，该字段为包含所有堆栈帧的数组。

### 配置文件

Deno 支持在 `deno.json` / `deno.jsonc` 文件中存储权限配置。更多信息请参见 [配置](/runtime/fundamentals/configuration/#Permissions)。

### 文件系统访问

默认情况下，执行的代码不能读取或写入任意文件系统上的文件。这包括列出目录内容、检查文件是否存在以及打开或连接 Unix 套接字。

读取文件的权限通过 `--allow-read`（或 `-R`）标志授予，写入权限通过 `--allow-write`（或 `-W`）标志授予。这些标志可以指定路径列表，以允许访问特定文件或目录及其所有子目录。

定义：`--allow-read[=<PATH>...]` 或 `-R[=<PATH>...]`

```sh
# 允许从文件系统读取所有文件
deno run -R script.ts
# 或 
deno run --allow-read script.ts

# 仅允许读取文件 foo.txt 和 bar.txt
deno run --allow-read=foo.txt,bar.txt script.ts

# 允许读取 ./node_modules 及其所有子目录中的任意文件
deno run --allow-read=node_modules script.ts
```

定义：`--deny-read[=<PATH>...]`

```sh
# 允许读取 /etc 中的文件，但不允许读取 /etc/hosts
deno run --allow-read=/etc --deny-read=/etc/hosts script.ts

# 拒绝所有对磁盘的读取访问，禁用读取权限提示。
deno run --deny-read script.ts
```

定义：`--allow-write[=<PATH>...]` 或 `-W[=<PATH>...]`

```sh
# 允许对文件系统的所有写入
deno run -W script.ts
# 或 
deno run --allow-write script.ts

# 仅允许写入文件 foo.txt 和 bar.txt
deno run --allow-write=foo.txt,bar.txt script.ts
```

定义：`--deny-write[=<PATH>...]`

```sh
# 允许写入当前工作目录中的文件 
# 但不允许写入 ./secrets 目录。
deno run --allow-write=./ --deny-write=./secrets script.ts

# 拒绝所有对磁盘的写入访问，禁用写入权限提示。
deno run --deny-write script.ts
```

Deno 中的一些 API 在后台使用文件系统操作实现，即使它们并不直接提供对特定文件的读/写访问。这些 API 会读取和写入磁盘，但不需要任何明确的读/写权限。这些 API 的一些例子包括：

- `localStorage`
- Deno KV
- `caches`
- `Blob`

由于这些 API 使用文件系统操作实现，用户可以使用它们来消耗存储空间等文件系统资源，即使他们没有对文件系统的直接访问权限。

在加载模块时，Deno 可以从磁盘加载文件。这有时需要明确的权限，有时则默认允许：

- 以可以静态分析的方式从入口模块导入的所有文件默认被允许读取。这包括静态 `import` 语句和动态 `import()` 调用，其中参数是指向特定文件或文件目录的字符串字面量。可以使用 `deno info <entrypoint>` 打印出这个列表中的文件的完整列表。
- 以不可以静态分析的方式动态导入的文件要求运行时读取权限。
- `node_modules/` 目录中的文件默认允许读取。

当从网络中获取模块或将 TypeScript 代码转译为 JavaScript 时，Deno 使用文件系统作为缓存。这意味着即使用户未明确授予读/写权限，Deno 仍然可以消耗像存储空间这样的文件系统资源。

### 网络访问

默认情况下，执行的代码不能进行网络请求、打开网络监听器或执行 DNS 解析。这包括发起 HTTP 请求、打开 TCP/UDP 套接字和监听 TCP 或 UDP 上的传入连接。

网络访问是通过 `--allow-net` 标志授予的。该标志可以通过指定 IP 地址或主机名的列表来允许访问特定的网络地址。

定义：`--allow-net[=<IP_OR_HOSTNAME>...]` 或 `-N[=<IP_OR_HOSTNAME>...]`

```sh
# 允许网络访问
deno run -N script.ts
# 或
deno run --allow-net script.ts

# 允许访问 github.com 和 jsr.io 的网络
deno run --allow-net=github.com,jsr.io script.ts

# 主机名在 80 端口：
deno run --allow-net=example.com:80 script.ts

# IPv4 地址在 443 端口
deno run --allow-net=1.1.1.1:443 script.ts

# 一个 IPv6 地址，所有端口都允许
deno run --allow-net=[2606:4700:4700::1111] script.ts
```

定义：`--deny-net[=<IP_OR_HOSTNAME>...]`

```sh
# 允许访问网络，但拒绝访问 
# github.com 和 jsr.io
deno run --allow-net --deny-net=github.com,jsr.io script.ts

# 拒绝所有网络访问，禁用权限提示。
deno run --deny-net script.ts
```

在加载模块时，Deno 可以从网络加载模块。默认情况下，Deno 允许使用静态和动态导入从以下位置加载模块，而不需要明确的网络访问：

- `https://deno.land/`
- `https://jsr.io/`
- `https://esm.sh/`
- `https://raw.githubusercontent.com`
- `https://gist.githubusercontent.com`

这些位置是受信任的「公益」注册表，预期不会通过 URL 路径启用数据外泄。你可以使用 `--allow-import` 标志添加更多受信任的注册表。

此外，Deno 允许通过 `npm:` 说明符导入任何 NPM 包。

Deno 还每天最多向 `https://dl.deno.land/` 发送一次请求，以检查 Deno CLI 的更新。这可以通过设置环境变量 `DENO_NO_UPDATE_CHECK=1` 来禁用。

### 环境变量

默认情况下，执行的代码不能读取或写入环境变量。这包括读取环境变量和设置新值。

访问环境变量的权限是通过 `--allow-env` 标志授予的。该标志可以通过指定允许访问特定环境变量的环境变量列表来使用。从 Deno v2.1 开始，你现在可以指定后缀通配符以允许对环境变量的“作用域”访问。

定义：`--allow-env[=<VARIABLE_NAME>...]` 或 `-E[=<VARIABLE_NAME>...]`

```sh
# 允许访问所有环境变量
deno run -E script.ts
# 或
deno run --allow-env script.ts

# 允许访问 HOME 和 FOO 环境变量
deno run --allow-env=HOME,FOO script.ts

# 允许访问所有以 AWS_ 开头的环境变量
deno run --allow-env="AWS_*" script.ts
```

定义：`--deny-env[=<VARIABLE_NAME>...]`

```sh
# 允许所有环境变量，但拒绝 
# AWS_ACCESS_KEY_ID 和 AWS_SECRET_ACCESS_KEY。
deno run \
  --allow-env \
  --deny-env=AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY \
  script.ts

# 拒绝所有对环境变量的访问，禁用权限提示。
deno run --deny-env script.ts
```

> Windows 用户注意：环境变量在 Windows 上不区分大小写，Deno 也会在 Windows 上不区分大小写地匹配它们。

Deno 在启动时读取某些环境变量，例如 `DENO_DIR` 和 `NO_COLOR`（[查看完整列表](/runtime/reference/cli/env_variables/)）。

`NO_COLOR` 环境变量的值对在 Deno 运行时中运行的所有代码都是可见的，无论该代码是否已被授予读取环境变量的权限。

### 系统信息

默认情况下，执行的代码不能访问系统信息，例如操作系统版本、系统正常运行时间、负载平均值、网络接口和系统内存信息。

访问系统信息的权限是通过 `--allow-sys` 标志授予的。该标志可以通过指定允许访问的接口列表来使用，接口可以包括：`hostname`、`osRelease`、`osUptime`、`loadavg`、`networkInterfaces`、`systemMemoryInfo`、`uid` 和 `gid`。这些字符串映射到 `Deno` 命名空间中的提供 OS 信息的函数，比如
[Deno.systemMemoryInfo](https://docs.deno.com/api/deno/~/Deno.SystemMemoryInfo)。

定义：`--allow-sys[=<API_NAME>...]` 或 `-S[=<API_NAME>...]`

```sh
# 允许所有系统信息 API
deno run -S script.ts
# 或
deno run --allow-sys script.ts

# 允许 systemMemoryInfo 和 osRelease APIs
deno run --allow-sys="systemMemoryInfo,osRelease" script.ts
```

定义：`--deny-sys[=<API_NAME>...]`

```sh
# 允许访问所有系统信息，但限制 "networkInterfaces"
deno run --allow-sys --deny-sys="networkInterfaces" script.ts

# 拒绝对系统信息的所有访问，禁用权限提示。
deno run --deny-sys script.ts
```

### 子进程

默认情况下，在 Deno 运行时中执行的代码不能生成子进程，因为这将构成违反不可以在未获得用户同意的情况下提升其特权的原则。

Deno 提供了一种执行子进程的机制，但这需要用户的明确权限。这是通过使用 `--allow-run` 标志来完成的。

从程序生成的任何子进程独立于父进程所授予的权限运行。这意味着子进程可以访问系统资源，而不考虑已授予生成它的 Deno 进程的权限。这通常被称为特权提升。

因此，请确保仔细考虑是否想要授予程序 `--allow-run` 访问权限：这本质上无效化了 Deno 的安全沙箱。如果你确实需要生成特定的可执行文件，可以通过将特定的可执行文件名称传递给 `--allow-run` 标志来降低风险。

定义：`--allow-run[=<PROGRAM_NAME>...]`

```sh
# 允许运行所有子进程
deno run --allow-run script.ts

# 允许运行 "curl" 和 "whoami" 子进程
deno run --allow-run="curl,whoami" script.ts
```

:::caution

除非父进程具有 `--allow-all`，否则你可能永远不想使用 `--allow-run=deno`，因为能够生成一个 `deno` 进程意味着该脚本可以生成另一个具有完全权限的 `deno` 进程。

:::

定义：`--deny-run[=<PROGRAM_NAME>...]`

```sh
# 允许运行所有程序，但 "whoami" 和 "ps"。
deno run --allow-run --deny-run="whoami,ps" script.ts

# 拒绝所有生成子进程的访问，禁用权限提示。
deno run --deny-run script.ts
```

默认情况下，`npm` 包的后安装脚本不会在安装期间执行（例如通过 `deno install`），因为这会允许任意代码执行。当使用 `--allow-scripts` 标志运行时，npm 包的后安装脚本将作为子进程执行。

### FFI（外部函数接口）

Deno 提供了一个
[用于执行其他语言编写代码的 FFI 机制](/runtime/fundamentals/ffi/)，
例如 Rust、C 或 C++，可以在 Deno 运行时内调用。这是通过
`Deno.dlopen` API 完成的，该 API 可以加载共享库并调用其中的函数。

默认情况下，执行的代码不能使用 `Deno.dlopen` API，因为这违反了代码不能在未获得用户同意的情况下提升其特权的原则。

除了 `Deno.dlopen`，FFI 也可以通过 Node-API (NAPI) 原生添加模块使用。这些默认情况下也不被允许。

`Deno.dlopen` 和 NAPI 原生添加模块都需要使用 `--allow-ffi` 标志明确授权。该标志可以通过指定允许访问特定动态库的文件或目录列表来使用。

_同子进程一样，动态库不会在沙箱中运行，因此没有与它们被加载到的 Deno 进程相同的安全限制。因此，请极其小心地使用。_

定义：`--allow-ffi[=<PATH>...]`

```sh
# 允许加载所有动态库
deno run --allow-ffi script.ts

# 允许从特定路径加载动态库
deno run --allow-ffi=./libfoo.so script.ts
```

定义：`--deny-ffi[=<PATH>...]`

```sh
# 允许加载所有动态库，但 ./libfoo.so
deno run --allow-ffi --deny-ffi=./libfoo.so script.ts

# 拒绝加载所有动态库，禁用权限提示。
deno run --deny-ffi script.ts
```

### 从 Web 导入

允许从 Web 导入代码。默认情况下，Deno 限制可以从中导入代码的主机。这对于静态和动态导入都是如此。

如果你想动态导入代码，无论是使用 `import()` 还是 `new Worker()` API，都需要授予额外的权限。从本地文件系统导入 [需要 `--allow-read`](#file-system-read-access)，但 Deno 也允许从 `http:` 和 `https:` URL 导入。在这种情况下，你需要指定一个明确的 `--allow-import` 标志：

```
# 允许从 `https://example.com` 导入代码
$ deno run --allow-import=example.com main.ts
```

默认情况下，Deno 允许从以下主机导入源：

- `deno.land`
- `esm.sh`
- `jsr.io`
- `cdn.jsdelivr.net`
- `raw.githubusercontent.com`
- `gist.githubusercontent.com`

**仅允许使用 HTTPS 进行导入**

此允许列表默认适用于静态导入，并在指定 `--allow-import` 标志时默认适用于动态导入。

```
# 允许从 `https://deno.land` 动态导入代码
$ deno run --allow-import main.ts
```

请注意，为 `--allow-import` 指定允许列表将覆盖默认主机列表。

## 代码评估

Deno 对同一特权级别下的代码执行没有限制。这意味着在 Deno 运行时中执行的代码可以使用 `eval`、`new Function`，甚至动态导入或 web 工作者，以相同的特权级别执行**任意**代码，与调用 `eval`、`new Function` 或动态导入或 web 工作者的代码相同。

这些代码可以托管在网络上，可以是本地文件（如果已授予读取权限），或以字符串形式在调用 `eval`、`new Function` 或动态导入或 web 工作者的代码中存储的纯文本。

## 执行不可信代码

虽然 Deno 提供了一些旨在保护主机计算机和网络免受伤害的安全功能，但不可信代码仍然令人害怕。在执行不可信代码时，确保拥有多层防御是很重要的。以下是一些执行不可信代码的建议，我们建议在执行任意不可信代码时使用以下所有建议：

- 限制权限运行 `deno`，并预先确定实际需要运行的代码（并通过使用 `--frozen` 锁定文件和 `--cached-only` 防止更多代码被加载）。
- 使用操作系统提供的沙箱机制，如 `chroot`、`cgroups`、`seccomp` 等。
- 使用虚拟机或 MicroVM（gVisor、Firecracker 等）等沙箱环境。

---

# Stability and releases

> Guide to Deno's stability guarantees and release process. Covering release channels, long-term support (LTS), unstable features, versioning policy, and how Deno maintains backward compatibility.

URL: https://docs.deno.com/runtime/fundamentals/stability_and_releases


截至 Deno 1.0.0，`Deno` 命名空间 API 是稳定的。这意味着我们将努力使在 1.0.0 下工作的代码在未来的版本中继续正常运行。

## 发布计划、渠道和长期支持

Deno 每 12 周发布一个新的稳定小版本（例如 v2.1.0，v2.0.0）。

补丁发布包括对最新小版本的bug修复，按需发布 - 您可以期待在新小版本发布前有几个补丁发布。

### 发布渠道

Deno 提供 4 种发布渠道：

- `stable` - 上述描述的语义化小版本/补丁发布。这是**默认**的发布渠道，建议大多数用户使用。
- `lts` - 对特定稳定版本的长期支持，建议不常升级的企业用户使用。详情见下文。
- `rc` - 下一语义化小版本的候选发布。
- `canary` - 不稳定的发布，每天更改多个版本，允许尝试最新的bug修复和可能最终进入 `stable` 渠道的新特性。

### 长期支持 (LTS)

从 Deno v2.1.0（2024年11月发布）开始，Deno 提供 LTS（长期支持）渠道。

LTS 渠道是一个小版本的语义化版本，我们只维护向后兼容的 bug 修复。

| LTS release version | LTS maintenance start | LTS maintenance end |
| ------------------- | --------------------- | ------------------- |
| v2.1                | Feb 1st, 2025         | Apr 30th, 2025      |
| v2.2                | May 1st, 2025         | Oct 31st, 2025      |
| v2.4                | Nov 1st, 2025         | Apr 30th, 2026      |

在我们完善此过程的同时，我们最初保持 LTS 支持窗口较短。**LTS 发布每六个月进行一次**，根据需要提供补丁发布以修复bug。我们计划在将来将此支持窗口延长至一年。

LTS 回溯包括：

- 安全补丁
- 关键bug修复（例如，崩溃、错误计算）
- **关键**性能改进_可能_根据严重性进行回溯。

**API 更改和重大新特性将不会进行回溯。**

## 不稳定的 API

在引入新 API 时，这些 API 首先被标记为不稳定。这意味着该 API 未来可能会发生变化。在显式传递不稳定标志（如 `--unstable-kv`）之前，这些 API 并不可用。
[了解有关 `--unstable-*` 标志的更多信息](/runtime/reference/cli/unstable_flags)。

还有一些被视为不稳定的非运行时功能，这些功能被锁定在不稳定标志后面。例如，`--unstable-sloppy-imports` 标志用于在不指定文件扩展名的情况下启用代码的 `import`。

## 标准库

Deno 标准库 (https://jsr.io/@std) 基本上是稳定的。所有版本为 1.0.0 或更高的标准库模块被视为稳定。所有其他模块（0.x）被视为不稳定，未来可能会发生变化。

不推荐在生产代码中使用不稳定的标准库模块，但这是实验新特性并向 Deno 团队提供反馈的好方法。使用不稳定标准库模块不需要使用任何不稳定标志。

---

# Standard Library

> An introduction to Deno's Standard Library. Learn about TypeScript-first modules, cross-platform compatibility, versioning, package management, and how to use standard modules in your Deno projects.

URL: https://docs.deno.com/runtime/fundamentals/standard_library


Deno 提供了一个用 TypeScript 编写的标准库。这是一组标准模块，可以被程序重用，使您能够专注于应用程序逻辑，而不是为常见任务“重复造轮子”。Deno 标准库中的所有模块都经过核心团队审计，并保证与 Deno 兼容，确保一致性和可靠性。

<a href="https://jsr.io/@std" class="docs-cta jsr-cta">See all packages on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

Deno 标准库中的许多包在 Node.js、Cloudflare Workers 和其他 JavaScript 环境中也兼容。这使您能够编写可以在多个环境中无须修改运行的代码。

标准库托管在 JSR 上，访问地址为：
[https://jsr.io/@std](https://jsr.io/@std)。包都经过文档记录、测试，并包括使用示例。您可以在 JSR 上浏览标准库包的完整列表，以下是一些示例：

- [@std/path](https://jsr.io/@std/path): 路径操作工具，类似于 Node.js 的 `path` 模块。
- [@std/jsonc](https://jsr.io/@std/jsonc): 带注释的 JSON 的（反）序列化
- [@std/encoding](https://jsr.io/@std/encoding): 用于编码和解码常见格式（如十六进制、base64 和变体）的工具

## 版本控制与稳定性

标准库的每个包都是独立版本化的。包遵循 [语义版本控制规则](https://jsr.io/@std/semver)。您可以使用 [版本锁定或版本范围](/runtime/fundamentals/modules/#package-versions) 来防止主要版本更新对您的代码造成影响。

## 导入标准库模块

要从 Deno 标准库安装包，您可以使用 `deno add` 子命令将包添加到您的 `deno.json` 导入映射中。

```sh
deno add jsr:@std/fs jsr:@std/path
```

`deno.json` 的 `imports` 字段将更新以包含这些导入：

```json
{
  "imports": {
    "@std/fs": "jsr:@std/fs@^1.0.2",
    "@std/path": "jsr:@std/path@^1.0.3"
  }
}
```

然后，您可以在源代码中导入这些包：

```ts
import { copy } from "@std/fs";
import { join } from "@std/path";

await copy("foo.txt", join("dist", "foo.txt"));
```

或者，您可以直接使用 `jsr:` 说明符导入模块：

```js
import { copy } from "jsr:@std/fs@^1.0.2";
import { join } from "jsr:@std/path@^1.0.3";

await copy("foo.txt", join("dist", "foo.txt"));
```

## Node.js 兼容性

Deno 标准库旨在与 Node.js、Cloudflare Workers 和其他 JavaScript 环境兼容。标准库用 TypeScript 编写并编译为 JavaScript，因此可以在任何 JavaScript 环境中使用。

```sh
npx jsr add @std/fs @std/path
```

运行此命令将这些包添加到您的 `package.json`：

```json
{
  "dependencies": {
    "@std/fs": "npm:@jsr/std__fs@^1.0.2",
    "@std/path": "npm:@jsr/std__path@^1.0.3"
  }
}
```

然后，您可以在源代码中导入它们，就像您使用任何其他 Node.js 包一样。TypeScript 会自动找到这些包的类型定义。

```ts
import { copy } from "@std/fs";
import { join } from "@std/path";

await copy("foo.txt", join("dist", "foo.txt"));
```

---

# 测试

> Deno 测试功能指南。了解内置测试运行器、断言、模拟、覆盖率报告、快照测试，以及如何为您的 Deno 应用程序编写有效测试。

URL: https://docs.deno.com/runtime/fundamentals/testing


Deno 提供了一个内置的测试运行器，可以用来编写和运行 JavaScript 和 TypeScript 中的测试。这使得确保代码可靠并按预期运行变得简单，无需安装任何额外的依赖项或工具。`deno test` 运行器允许您对每个测试的权限进行细粒度控制，确保代码没有执行任何意外的操作。

除了内置的测试运行器，您还可以使用来自 JS 生态系统的其他测试运行器，如 Jest、Mocha 或 AVA 来与 Deno 一起使用。不过本文件将不讨论这些内容。

## 编写测试

在 Deno 中定义测试，您可以使用 `Deno.test()` 函数。以下是一些示例：

```ts title="my_test.ts"
import { assertEquals } from "jsr:@std/assert";

Deno.test("简单测试", () => {
  const x = 1 + 2;
  assertEquals(x, 3);
});

import { delay } from "jsr:@std/async";

Deno.test("异步测试", async () => {
  const x = 1 + 2;
  await delay(100);
  assertEquals(x, 3);
});

Deno.test({
  name: "读取文件测试",
  fn: () => {
    const data = Deno.readTextFileSync("./somefile.txt");
    assertEquals(data, "预期内容");
  },
});
```

如果您更喜欢类似于“jest”的 `expect` 风格的断言，Deno 标准库提供了一个 [`expect`](https://jsr.io/@std/expect) 函数，可以替代 `assertEquals`：

```ts title="my_test.ts"
import { expect } from "jsr:@std/expect";
import { add } from "./add.js";

Deno.test("add 函数正确相加两个数字", () => {
  const result = add(2, 3);
  expect(result).toBe(5);
});
```

## 运行测试

要运行测试，请使用 [`deno test`](/runtime/reference/cli/test/) 子命令。

如果没有传入文件名或目录名，该子命令将自动查找并执行当前目录中（递归地）所有匹配 glob `{*_,*.,}test.{ts, tsx, mts, js, mjs, jsx}` 的测试。

```sh
# 运行当前目录及所有子目录中的所有测试
deno test

# 运行 util 目录中的所有测试
deno test util/

# 仅运行 my_test.ts
deno test my_test.ts

# 并行运行测试模块
deno test --parallel

# 传递额外参数给测试文件，这些参数在 `Deno.args` 中可见
deno test my_test.ts -- -e --foo --bar

# 提供文件系统的读取权限，这对于上面的最终测试是必要的
deno test --allow-read=. my_test.ts
```

## 测试步骤

Deno 还支持测试步骤，这允许您将测试细分为更小、可管理的部分。这在测试中的设置和拆除操作时非常有用：

```ts
Deno.test("数据库操作", async (t) => {
  using db = await openDatabase();
  await t.step("插入用户", async () => {
    // 插入用户逻辑
  });
  await t.step("插入书籍", async () => {
    // 插入书籍逻辑
  });
});
```

## 测试钩子

Deno 提供了测试钩子，允许您在测试运行之前和之后运行设置和拆卸代码。这些钩子对于初始化资源、测试后清理以及确保测试环境一致非常有用。

### 可用的钩子

- `Deno.test.beforeAll(fn)` - 在当前范围内的所有测试之前运行一次
- `Deno.test.beforeEach(fn)` - 在每个单独测试之前运行
- `Deno.test.afterEach(fn)` - 在每个单独测试之后运行
- `Deno.test.afterAll(fn)` - 在当前范围内的所有测试之后运行一次

### 钩子执行顺序

- **beforeAll/beforeEach**: 按先进先出（FIFO）顺序执行
- **afterEach/afterAll**: 按后进先出（LIFO）顺序执行

如果任何钩子中抛出异常，同类型的剩余钩子将不会被执行，且当前测试将被标记为失败。

### 示例

```ts
import { DatabaseSync } from "node:sqlite";
import { assertEquals } from "jsr:@std/assert";

let db: DatabaseSync;

Deno.test.beforeAll(() => {
  console.log("Setting up test database...");
  db = new DatabaseSync(":memory:");
  db.exec(`
    CREATE TABLE users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT NOT NULL UNIQUE
    ) STRICT
  `);
});

Deno.test.beforeEach(() => {
  console.log("Clearing database for clean test state...");
  db.exec("DELETE FROM users");
});

Deno.test.afterEach(() => {
  console.log("Test completed, cleaning up resources...");
  // 每个测试后的额外清理
});

Deno.test.afterAll(() => {
  console.log("Tearing down test database...");
  db.close();
});

Deno.test("user creation", () => {
  const stmt = db.prepare(
    "INSERT INTO users (name, email) VALUES (?, ?) RETURNING *",
  );
  const user = stmt.get("alice", "alice@example.com");
  assertEquals(user!.name, "alice");
});

Deno.test("user deletion", () => {
  const insertStmt = db.prepare(
    "INSERT INTO users (name, email) VALUES (?, ?) RETURNING *",
  );
  const user = insertStmt.get("bob", "bob@example.com");

  const deleteStmt = db.prepare("DELETE FROM users WHERE id = ?");
  deleteStmt.run(user!.id);

  const selectStmt = db.prepare("SELECT * FROM users WHERE id = ?");
  const deletedUser = selectStmt.get(user!.id);
  assertEquals(deletedUser, undefined);
});
```

### 多个钩子

您可以注册多个相同类型的钩子，它们将按照上述顺序依次执行：

```ts
Deno.test.beforeEach(() => {
  console.log("First beforeEach hook");
});

Deno.test.beforeEach(() => {
  console.log("Second beforeEach hook");
});

// 输出：
// First beforeEach hook
// Second beforeEach hook
// （测试执行）
```

## 命令行筛选

Deno 允许您使用命令行上的 `--filter` 选项运行特定的测试或测试组。该选项接受字符串或模式用于匹配测试名称。筛选不会影响步骤；如果测试名称匹配筛选条件，则其所有步骤将被执行。

考虑以下测试：

```ts
Deno.test("my-test", () => {});
Deno.test("test-1", () => {});
Deno.test("test-2", () => {});
```

### 通过字符串过滤

要运行所有名称中包含“my”的测试，请使用：

```sh
deno test --filter "my" tests/
```

该命令将执行 `my-test`，因为它包含单词“my”。

### 通过模式过滤

要运行与特定模式匹配的测试，请使用：

```sh
deno test --filter "/test-*\d/" tests/
```

该命令将运行 `test-1` 和 `test-2`，因为它们匹配模式 `test-*` 后跟数字。

要表示您使用的是正则表达式模式，请使用斜杠 `/` 将过滤值括起来，就像 JavaScript 的正则表达式语法一样。

### 在配置文件中包含和排除测试文件

您还可以通过在 [Deno 配置文件](/runtime/fundamentals/configuration) 中指定要包含或排除的路径来过滤测试。

例如，如果您只想测试 `src/fetch_test.ts` 和 `src/signal_test.ts` 并排除 `out/` 目录中所有文件：

```json
{
  "test": {
    "include": [
      "src/fetch_test.ts",
      "src/signal_test.ts"
    ]
  }
}
```

或者更常见的配置是：

```json
{
  "test": {
    "exclude": ["out/"]
  }
}
```

## 测试定义选择

Deno 提供了两种选择测试的方法：忽略测试和专注于特定测试。

### 忽略/跳过测试

您可以根据特定条件使用测试定义中的 `ignore` 布尔值来忽略某些测试。如果 `ignore` 设置为 `true`，该测试将被跳过。这在您希望测试仅在特定操作系统上运行时非常有用。

```ts
Deno.test({
  name: "执行 macOS 功能",
  ignore: Deno.build.os !== "darwin", // 如果不在 macOS 上运行，则该测试将被忽略
  fn() {
    // 在这里执行 MacOS 功能
  },
});
```

如果您想要在没有条件的情况下忽略测试，可以使用 `Deno.test` 对象中的 `ignore()` 函数：

```ts
Deno.test.ignore("我的测试", () => {
  // 您的测试代码
});
```

### 仅运行特定测试

如果您想专注于特定测试并忽略其他测试，可以使用 `only` 选项。这告诉测试运行器仅运行设置为 `only` 的测试。多个测试可以设置此选项。然而，如果任何测试标记为 only，则整体测试运行将始终失败，因为这被视为临时调试措施。

```ts
Deno.test.only("我的测试", () => {
  // 一些测试代码
});
```

或者

```ts
Deno.test({
  name: "仅关注此测试",
  only: true, // 仅此测试将运行
  fn() {
    // 在这里测试复杂的内容
  },
});
```

## 快速失败

如果您有一个长时间运行的测试套件，并希望在第一次失败时停止，可以在运行套件时指定 `--fail-fast` 标志。

```shell
deno test --fail-fast
```

这将导致测试运行器在第一次测试失败后停止执行。

## 报告工具

Deno 包含三种内置报告工具来格式化测试输出：

- `pretty`（默认）：提供详细且可读的输出。
- `dot`：提供简洁的输出，便于快速查看测试结果。
- `junit`：以 JUnit XML 格式生成输出，可用于与 CI/CD 工具集成。

您可以使用 `--reporter` 标志指定要使用的报告工具：

```sh
# 使用默认的漂亮报告工具
deno test

# 使用 dot 报告工具获得简洁输出
deno test --reporter=dot

# 使用 JUnit 报告工具
deno test --reporter=junit
```

此外，您可以使用 `--junit-path` 标志将 JUnit 报告写入文件，同时在终端中获得可读的输出：

```sh
deno test --junit-path=./report.xml
```

## 监视、模拟（测试替身）、存根和时间伪造

[Deno 标准库](/runtime/fundamentals/standard_library/) 提供了一组函数，帮助您编写涉及监视、模拟和存根的测试。有关这些工具的更多信息，请查看 [JSR 上的 @std/testing 文档](https://jsr.io/@std/testing) 或我们的 [使用 deno 进行测试的模拟和监视教程](/examples/mocking_tutorial/)。

## 覆盖率

如果您在启动 `deno test` 时指定 `--coverage` 标志，Deno 将收集代码的测试覆盖率信息。此覆盖信息直接从 V8 JavaScript 引擎获取，确保高准确度。

然后，您可以使用 [`deno coverage`](/runtime/reference/cli/coverage/) 工具将其从内部格式进一步处理为常用格式，如 `lcov`。

## 行为驱动开发

使用 [@std/testing/bdd](https://jsr.io/@std/testing/doc/bdd/~) 模块，您可以以简化的格式编写测试，以分组测试和添加其他 JavaScript 测试框架（如 Jasmine、Jest 和 Mocha）使用的设置/拆卸钩子。

`describe` 函数创建一个块，以将多个相关测试分组。`it` 函数注册一个单个测试用例。例如：

```ts
import { describe, it } from "jsr:@std/testing/bdd";
import { expect } from "jsr:@std/expect";
import { add } from "./add.js";

describe("add 函数", () => {
  it("正确相加两个数字", () => {
    const result = add(2, 3);
    expect(result).toBe(5);
  });

  it("处理负数", () => {
    const result = add(-2, -3);
    expect(result).toBe(-5);
  });
});
```

请查看 [JSR 的文档](https://jsr.io/@std/testing/doc/bdd/~) 获取有关这些函数和钩子的更多信息。

- [BDD 测试教程](/examples/bdd_tutorial/)

## 文档测试

Deno 允许您评估用 JSDoc 或 markdown 文件编写的代码片段。这确保了文档中的示例是最新且可运行的。

### 示例代码块

````ts title="example.ts"
/**
 * # 示例
 *
 * ```ts
 * import { assertEquals } from "jsr:@std/assert/equals";
 *
 * const sum = add(1, 2);
 * assertEquals(sum, 3);
 * ```
 */
export function add(a: number, b: number): number {
  return a + b;
}
````

三重反引号标记代码块的开始和结束，语言由语言标识符属性确定，该属性可以是以下之一：

- `js`
- `javascript`
- `mjs`
- `cjs`
- `jsx`
- `ts`
- `typescript`
- `mts`
- `cts`
- `tsx`

如果未指定语言标识符，则从提取代码块的源文档的媒体类型推断语言。

```sh
deno test --doc example.ts
```

上述命令将提取此示例，并将其转换为看似以下的伪测试用例：

```ts title="example.ts$4-10.ts" ignore
import { assertEquals } from "jsr:@std/assert/equals";
import { add } from "file:///path/to/example.ts";

Deno.test("example.ts$4-10.ts", async () => {
  const sum = add(1, 2);
  assertEquals(sum, 3);
});
```

然后将其作为一个独立模块运行，该模块位于与被记录模块相同的目录中。

:::tip 想只进行类型检查？

如果您想对 JSDoc 和 markdown 文件中的代码片段进行类型检查，而不实际运行它们，您可以使用 [`deno check`](/runtime/reference/cli/check/) 命令与 `--doc` 选项（用于 JSDoc）或 `--doc-only` 选项（用于 markdown）代替。

:::

### 导出的项会自动导入

查看上面生成的测试代码，您会注意到它包含 `import` 语句以导入 `add` 函数，即使原始代码块没有。这是因为在记录模块时，所有从模块导出的项都会自动包括在生成的测试代码中，使用相同的名称。

假设我们有以下模块：

````ts title="example.ts"
/**
 * # 示例
 *
 * ```ts
 * import { assertEquals } from "jsr:@std/assert/equals";
 *
 * const sum = add(ONE, getTwo());
 * assertEquals(sum, 3);
 * ```
 */
export function add(a: number, b: number): number {
  return a + b;
}

export const ONE = 1;
export default function getTwo() {
  return 2;
}
````

这将转换为以下测试用例：

```ts title="example.ts$4-10.ts" ignore
import { assertEquals } from "jsr:@std/assert/equals";
import { add, ONE }, getTwo from "file:///path/to/example.ts";

Deno.test("example.ts$4-10.ts", async () => {
  const sum = add(ONE, getTwo());
  assertEquals(sum, 3);
});
```

### 跳过代码块

您可以通过添加 `ignore` 属性来跳过代码块的评估。

````ts
/**
 * 该代码块将不会被运行。
 *
 * ```ts ignore
 * await sendEmail("deno@example.com");
 * ```
 */
export async function sendEmail(to: string) {
  // 向指定地址发送电子邮件...
}
````

## 消毒器

测试运行器提供了多种消毒器，以确保测试以合理和预期的方式运行。

### 资源消毒器

资源消毒器确保在测试过程中创建的所有 I/O 资源都被关闭，以防止资源泄漏。

I/O 资源是指 `Deno.FsFile` 句柄、网络连接、`fetch` 体、定时器等不自动进行垃圾回收的其他资源。

完成操作后，您应始终关闭资源。例如，要关闭一个文件：

```ts
const file = await Deno.open("hello.txt");
// 对文件执行某些操作
file.close(); // <- 始终在完成后关闭文件
```

要关闭网络连接：

```ts
const conn = await Deno.connect({ hostname: "example.com", port: 80 });
// 对连接执行某些操作
conn.close(); // <- 始终在完成后关闭连接
```

要关闭一个 `fetch` 体：

```ts
const response = await fetch("https://example.com");
// 对响应执行某些操作
await response.body?.cancel(); // <- 如果不以其他方式使用它，请始终在完成后取消主体
```

此消毒器默认启用，但可以在此测试中使用 `sanitizeResources: false` 进行禁用：

```ts
Deno.test({
  name: "泄漏资源测试",
  async fn() {
    await Deno.open("hello.txt");
  },
  sanitizeResources: false,
});
```

### 异步操作消毒器

异步操作消毒器确保在测试中启动的所有异步操作都在测试结束前完成。这很重要，因为如果异步操作没有被等待，测试将在操作完成之前结束，并且即使操作可能实际上失败，测试也会被标记为成功。

在测试中，您应始终等待所有异步操作。例如：

```ts
Deno.test({
  name: "异步操作测试",
  async fn() {
    await new Promise((resolve) => setTimeout(resolve, 1000));
  },
});
```

此消毒器默认启用，但可以使用 `sanitizeOps: false` 进行禁用：

```ts
Deno.test({
  name: "泄漏操作测试",
  fn() {
    crypto.subtle.digest(
      "SHA-256",
      new TextEncoder().encode("a".repeat(100000000)),
    );
  },
  sanitizeOps: false,
});
```

### 退出消毒器

退出消毒器确保被测试的代码不会调用 `Deno.exit()`，因为这可能会导致假测试成功。

此消毒器默认启用，但可以使用 `sanitizeExit: false` 进行禁用。

```ts
Deno.test({
  name: "假成功",
  fn() {
    Deno.exit(0);
  },
  sanitizeExit: false,
});

// 此测试永远不会运行，因为进程在“假成功”测试期间退出
Deno.test({
  name: "失败的测试",
  fn() {
    throw new Error("该测试失败");
  },
});
```

## 快照测试

[Deno 标准库](/runtime/fundamentals/standard_library/) 包含一个 [快照模块](https://jsr.io/@std/testing/doc/snapshot/~)，允许开发者通过将值与参考快照进行比较来编写测试。这些快照是原始值的序列化表示，存储在测试文件旁边。

快照测试能够通过极少的代码捕捉到广泛的错误。在难以准确表达应该断言什么的情况下非常有用，而不需要过多的代码，或者在预期测试所做的断言经常变化的情况下也特别有帮助。
- [快照测试教程](/examples/snapshot_tutorial/)

## 测试和权限

`Deno.test` 配置中的 `permissions` 属性允许您具体拒绝权限，但不授予权限。运行测试命令时必须提供权限。当构建健壮的应用程序时，您通常需要处理权限被拒绝的情况（例如，您可能希望编写测试以检查回退是否已正确设置）。

考虑一种情况，您正在从文件中读取，您可能希望在函数没有读取权限的情况下提供一个回退值：

```ts
import { assertEquals } from "jsr:@std/assert";
import getFileText from "./main.ts";

Deno.test({
  name: "File reader gets text with permission",
  // no `permissions` means "inherit"
  fn: async () => {
    const result = await getFileText();
    console.log(result);
    assertEquals(result, "the content of the file");
  },
});

Deno.test({
  name: "File reader falls back to error message without permission",
  permissions: { read: false },
  fn: async () => {
    const result = await getFileText();
    console.log(result);
    assertEquals(result, "oops don't have permission");
  },
});
```

```sh
# 运行带有读取权限的测试
deno test --allow-read
```

权限对象支持详细配置：

```ts
Deno.test({
  name: "permission configuration example",
  // permissions: { read: true } // 授予所有读取权限，拒绝其他所有权限
  // OR
  permissions: {
    read: ["./data", "./config"], // 仅授予对特定路径的读取权限
    write: false, // 明确拒绝写权限
    net: ["example.com:443"], // 允许特定的 host:port 组合
    env: ["API_KEY"], // 允许访问特定的环境变量
    run: false, // 拒绝子进程执行权限
    ffi: false, // 拒绝加载动态库
    hrtime: false, // 拒绝高分辨率时间权限
  },
  fn() {
    // 遵守这些权限边界的测试代码
  },
});
```

请记住，任何在命令行中未明确授予的权限将被拒绝，无论测试配置中指定的内容是什么。

---

# TypeScript support

> Learn how to use TypeScript with Deno. Covers configuration options, type checking, and best practices for writing type-safe Deno applications.

URL: https://docs.deno.com/runtime/fundamentals/typescript


TypeScript 是 Deno 中的一种一流语言，就像 JavaScript 或 WebAssembly 一样。您只需安装 Deno CLI，就可以运行或导入 TypeScript，而无需安装其他任何东西。凭借其内置的 TypeScript 编译器，Deno 将直接把您的 TypeScript 代码编译为 JavaScript，无需额外配置。Deno 还可以对您的 TypeScript 代码进行类型检查，无需像 `tsc` 这样的单独类型检查工具。

## 类型检查

TypeScript 的主要优势之一是它可以使您的代码类型安全，捕获开发过程中而非运行时的错误。TypeScript 是 JavaScript 的超集，这意味着语法上有效的 JavaScript 会变成 TypeScript，并发出“安全性”警告。

:::note

**Deno 默认在 `strict mode` 下对 TypeScript 进行类型检查**，TypeScript 核心团队
[建议将严格模式作为合理的默认值](https://www.typescriptlang.org/play/?#example/new-compiler-defaults)。

:::

Deno 允许您使用 [`deno check`](/runtime/reference/cli/check/) 子命令对代码进行类型检查（而不执行它）：

```shell
# Check the current directory/module
deno check

# Check a specific TypeScript file
deno check module.ts

# Include remote modules and npm packages in the check
deno check --all module.ts

# Check code snippets in JSDoc comments
deno check --doc module.ts

# Check code snippets in markdown files
deno check --doc-only markdown.md
```

:::note

类型检查可能会花费大量时间，尤其是在您对代码库进行大量更改时。Deno 优化了类型检查，但这仍然是有成本的。因此，**默认情况下，TypeScript 模块在执行之前不会进行类型检查**。

:::

在使用 `deno run` 命令时，Deno 将跳过类型检查并直接运行代码。如果您希望在执行代码之前对模块进行类型检查，可以使用 `--check` 标志与 `deno run` 一起使用：

```shell
deno run --check module.ts
# 也可以对远程模块和 npm 包进行类型检查
deno run --check=all module.ts
```

当 Deno 在使用此标志时遇到类型错误时，过程将在执行代码之前退出。

为了避免这种情况，您需要：

- 解决问题
- 使用 `// @ts-ignore` 或 `// @ts-expect-error` 指令来忽略错误
- 或者完全跳过类型检查

在测试您的代码时，类型检查默认是启用的。如果您希望跳过类型检查，可以使用 `--no-check` 标志：

```shell
deno test --no-check
```

## 与 JavaScript 一起使用

Deno 可以运行 JavaScript 和 TypeScript 代码。然而，在类型检查期间，Deno 默认只对 TypeScript 文件进行类型检查。如果您想对 JavaScript 文件进行类型检查，可以在文件顶部添加 `// @ts-check` 指令，或在 `deno.json` 文件中添加 `compilerOptions.checkJs`。

```ts title="main.js"
// @ts-check

let x = "hello";
x = 42; // 类型 'number' 不能赋值给类型 'string'。
```

```json title="deno.json"
{
  "compilerOptions": {
    "checkJs": true
  }
}
```

在 JavaScript 文件中，您不能使用 TypeScript 语法，例如类型注解或导入类型。不过，您可以使用 [TSDoc](https://tsdoc.org/) 注释向 TypeScript 编译器提供类型信息。

```ts title="main.js"
// @ts-check

/**
 * @param a {number}
 * @param b {number}
 * @returns {number}
 */
function add(a, b) {
  return a + b;
}
```

## 提供声明文件

在从 TypeScript 代码导入未标注类型的 JavaScript 模块时，您可能需要为 JavaScript 模块提供类型信息。如果 JavaScript 使用 TSDoc 注释进行了注解，则不需要此操作。如果没有此额外的类型信息（以 `.d.ts` 声明文件的形式），TypeScript 将假定从 JavaScript 模块导出的所有内容都是 `any` 类型。

`tsc` 会自动识别与 `js` 文件同级且具有相同基本名称的 `d.ts` 文件。**Deno 并不这样做。**您必须在 `.js` 文件（源文件）或 `.ts` 文件（导入者）中显式指定 `.d.ts` 文件的位置。

### 在源文件中提供类型

在 `.js` 文件中指定 `.d.ts` 文件应该是首选，因为这样使得从多个 TypeScript 模块使用 JavaScript 模块变得更容易：您无需在每个导入 JavaScript 模块的 TypeScript 模块中指定 `.d.ts` 文件。

```ts title="add.js"
// @ts-self-types="./add.d.ts"

export function add(a, b) {
  return a + b;
}
```

```ts title="add.d.ts"
export function add(a: number, b: number): number;
```

### 在导入者中提供类型

如果您无法修改 JavaScript 源代码，可以在导入 JavaScript 模块的 TypeScript 模块中指定 `.d.ts` 文件。

```ts title="main.ts"
// @ts-types="./add.d.ts"
import { add } from "./add.js";
```

这对于不提供类型信息的 NPM 包也很有用：

```ts title="main.ts"
// @ts-types="npm:@types/lodash"
import * as _ from "npm:lodash";
```

### 为 HTTP 模块提供类型

通过 HTTP 托管 JavaScript 模块的服务器也可以在 HTTP 头中提供这些模块的类型信息。Deno 将在对模块进行类型检查时使用此信息。

```http
HTTP/1.1 200 OK
Content-Type: application/javascript; charset=UTF-8
Content-Length: 648
X-TypeScript-Types: ./add.d.ts
```

`X-TypeScript-Types` 头指定提供 JavaScript 模块类型信息的 `.d.ts` 文件的位置。它是相对于 JavaScript 模块的 URL 进行解析的，类似于 `Location` 头。

## 浏览器和 web worker 的类型检查

默认情况下，Deno 对 TypeScript 模块进行类型检查，就好像它们在 Deno 运行时的主线程中运行一样。然而，Deno 还支持浏览器的类型检查、web worker 的类型检查，以及在使用 SSR（服务器端渲染）与 Deno 时结合的浏览器-Deno 环境的类型检查。

这些环境具有不同的全局对象和可用的 API。Deno 提供了这些环境的类型定义，形式为库文件。这些库文件由 TypeScript 编译器使用，以提供这些环境中可用的全局对象和 API 的类型信息。

通过 `deno.json` 配置文件中的 `compilerOptions.lib` 选项或通过 TypeScript 文件中的 `/// <reference lib="..." />` 注释，可以更改加载的库文件。建议使用 `deno.json` 配置文件中的 `compilerOptions.lib` 选项来指定要使用的库文件。

要启用对 **浏览器环境** 的类型检查，您可以在 `deno.json` 配置文件的 `compilerOptions.lib` 选项中指定 `dom` 库文件：

```json title="deno.json"
{
  "compilerOptions": {
    "lib": ["dom"]
  }
}
```

这将启用对浏览器环境的类型检查，为全局对象（如 `document`）提供类型信息。但是，这将禁用 Deno 特定 API（如 `Deno.readFile`）的类型信息。

要启用对 **浏览器和 Deno 环境** 的组合类型检查，例如在使用 Deno 进行 SSR 时，您可以在 `deno.json` 配置文件的 `compilerOptions.lib` 选项中指定 `dom` 和 `deno.ns`（Deno 命名空间）库文件：

```json title="deno.json"
{
  "compilerOptions": {
    "lib": ["dom", "deno.ns"]
  }
}
```

这将同时启用对浏览器和 Deno 环境的类型检查，为全局对象（如 `document`）和 Deno 特定 API（如 `Deno.readFile`）提供类型信息。

要启用对 **Deno 中 web worker 环境** 的类型检查（即用 `new Worker` 运行的代码），您可以在 `deno.json` 的 `compilerOptions.lib` 选项中指定 `deno.worker` 库文件：

```json title="deno.json"
{
  "compilerOptions": {
    "lib": ["deno.worker"]
  }
}
```

要在 TypeScript 文件中指定要使用的库文件，您可以使用 `/// <reference lib="..." />` 注释：

```ts
/// <reference no-default-lib="true" />
/// <reference lib="dom" />
```

## 扩展全局类型

Deno 支持 TypeScript 中的环境（ambient）或全局类型。当填充全局对象或用附加属性扩展全局作用域时，这非常有用。**您应该尽可能避免使用环境或全局类型**，因为它们会导致命名冲突，并使您更难理解代码。在发布到 JSR 时也不支持它们。

要在 Deno 中使用环境或全局类型，您可以使用 `declare global` 语法，或加载一个扩展了全局作用域的 `.d.ts` 文件。

### 使用 declare global 扩展全局作用域

您可以在项目中导入的任何 TypeScript 文件中使用 `declare global` 语法，以将附加属性扩展到全局作用域。例如：

```ts
declare global {
  interface Window {
    polyfilledAPI(): string;
  }
}
```

这使得在导入类型定义时全局可用 `polyfilledAPI` 函数。

### 使用 .d.ts 文件扩展全局作用域

您还可以使用 `.d.ts` 文件扩展全局作用域。例如，您可以创建一个包含以下内容的 `global.d.ts` 文件：

```ts
interface Window {
  polyfilledAPI(): string;
}
```

然后您可以在您的 TypeScript 中通过 `/// <reference types="./global.d.ts" />` 加载此 `.d.ts` 文件。这将用 `polyfilledAPI` 函数扩展全局作用域。

或者，您可以在 `deno.json` 配置文件中的 `compilerOptions.types` 数组中指定 `.d.ts` 文件：

```json
{
  "compilerOptions": {
    "types": ["./global.d.ts"]
  }
}
```

这也将用 `polyfilledAPI` 函数扩展全局作用域。

---

# Web 开发

> Deno 的 Web 开发指南。了解支持的框架如 Fresh、Next.js 和 Astro，以及用于构建现代 Web 应用的内置功能。

URL: https://docs.deno.com/runtime/fundamentals/web_dev


Deno 提供了一个安全且友好的开发环境来构建 web 应用程序，让你的网页开发体验愉悦。

1. Deno 拥有[安全默认设置](/runtime/fundamentals/security/)，这意味着它
   需要明确的权限才能访问文件、网络和环境，降低了安全漏洞的风险。
2. Deno 内置了[TypeScript 支持](/runtime/fundamentals/typescript/)，
   允许你无需额外配置或工具即可书写 TypeScript 代码。
3. Deno 附带了[标准库](/runtime/fundamentals/standard_library/)，
   包含了处理 HTTP 服务器、文件系统操作等常见任务的模块。

对于你的原生 TypeScript 或 JavaScript web 应用，你可以使用内置的 Deno [HTTP 服务器](/runtime/fundamentals/http_server/)。这是一种很好上手 Deno 并构建简单 web 应用的方式，无需任何额外依赖。

如果你构建的是更复杂的应用，极有可能会通过 web 框架与 Deno 进行交互。

## React/Next

[React](https://reactjs.org/) 是一个流行的构建用户界面的 JavaScript 库。要在 Deno 中使用 React，你可以采用流行的 Web 框架 [Next.js](https://nextjs.org/)。

要在 Deno 中开始使用 Next.js，你可以创建一个新的 next 应用并立即运行它：

```sh
deno run -A npm:create-next-app@latest my-next-app
cd my-next-app
deno task dev
```

这将创建一个新的 Next.js 应用并使用 Deno 运行它。你可以打开浏览器访问 `http://localhost:3000` 以查看你的新应用，并开始编辑 `page.tsx` 以实时查看你的更改。

要更好地理解 JSX 和 Deno 在底层如何交互，可以阅读[这里](/runtime/reference/jsx/)。

## Fresh

[Fresh](https://fresh.deno.dev/) 是 Deno 中最流行的 Web 框架。它采用默认不会向客户端发送任何 JavaScript 的模型。

要开始使用 Fresh 应用，你可以使用以下命令并按照 CLI 提示创建你的应用：

```sh
deno run -A -r https://fresh.deno.dev
cd my-fresh-app
deno task start
```

这将创建一个新的 Fresh 应用并使用 Deno 运行它。你可以打开浏览器访问 `http://localhost:8000` 以查看你的新应用。编辑 `/routes/index.tsx` 以实时查看你的更改。

Fresh 在服务器上执行大多数渲染，客户端仅负责重新渲染少量[互动岛屿](https://jasonformat.com/islands-architecture/)。这意味着开发者可以明确选择为特定组件启用客户端渲染。

## Astro

[Astro](https://astro.build/) 是一个静态网站生成器，帮助开发者创建快速且轻量的网站。

要开始使用 Astro，你可以使用以下命令创建一个新的 Astro 网站：

```sh
deno run -A npm:create-astro my-astro-site
cd my-astro-site
deno task dev
```

这将创建一个新的 Astro 网站并使用 Deno 运行它。你可以打开浏览器访问 `http://localhost:4321` 以查看你的网站。编辑 `/src/pages/index.astro` 以实时查看你的更改。

## Vite

[Vite](https://vitejs.dev/) 是一款 Web 开发构建工具，通过原生 ES 模块提供代码，这些代码可以直接在浏览器中运行。Vite 是构建现代 Web 应用的绝佳选择，适合 Deno。

要开始使用 Vite，你可以使用以下命令创建一个新的 Vite 应用：

```sh
deno run -A npm:create-vite@latest
cd my-vite-app
deno install
deno task dev
```

## Lume

[Lume](https://lume.land/) 是一个受 Jekyll 或 Eleventy 等其他静态网站生成器启发的静态网站生成器。

要开始使用 Lume，你可以使用以下命令创建一个新的 Lume 网站：

```sh
mkdir my-lume-site
cd my-lume-site
deno run -A https://lume.land/init.ts
deno task serve
```

## Docusaurus

[Docusaurus](https://docusaurus.io/) 是一个针对技术文档网站优化的静态网站生成器。

要开始使用 Docusaurus，你可以使用以下命令创建一个新的 Docusaurus 网站：

```sh
deno run -A npm:create-docusaurus@latest my-website classic
cd my-website
deno task start
```

## Hono

[Hono](https://hono.dev) 是一个轻量级 Web 应用框架，继承了 Express 和 Sinatra 的传统。

要开始使用 Hono，你可以使用以下命令创建一个新的 Hono 应用：

```sh
deno run -A npm:create-hono@latest
cd my-hono-app
deno task start
```

这将创建一个新的 Hono 应用并使用 Deno 运行它。你可以打开浏览器访问 `http://localhost:8000` 以查看你的新应用。

## Oak

[Oak](https://jsr.io/@oak/oak) 是在 Deno 中处理 HTTP 的中间件框架。Oak 是你的前端应用与潜在数据库或其他数据源（如 REST API、GraphQL API）之间的桥梁。

Oak 提供了比原生 Deno HTTP 服务器更丰富的功能，包括基本路由器、JSON 解析器、中间件、插件等。

要开始使用 Oak，创建一个名为 `server.ts` 的文件并添加以下内容：

```ts
import { Application } from "jsr:@oak/oak/application";
import { Router } from "jsr:@oak/oak/router";

const router = new Router();
router.get("/", (ctx) => {
  ctx.response.body = `<!DOCTYPE html>
    <html>
      <head><title>你好，oak!</title><head>
      <body>
        <h1>你好，oak!</h1>
      </body>
    </html>
  `;
});

const app = new Application();
const port = 8080;

app.use(router.routes());
app.use(router.allowedMethods());
console.log(`服务器运行在 http://localhost:${port}`);

app.listen({ port: port });
```

使用以下命令运行服务器：

```sh
deno run --allow-net server.ts
```

## Node 项目

Deno 可以直接运行你的 Node.js 项目。请查看我们关于[将你的 Node.js 项目迁移到 Deno]( /runtime/fundamentals/node/#migrating-from-node.js-to-deno)的指南。

---

# 工作区和单体仓库

> 关于在 Deno 中管理工作区和单体仓库的指南。了解工作区配置、包管理、依赖解析以及如何有效地构建多包项目结构。

URL: https://docs.deno.com/runtime/fundamentals/workspaces


Deno 支持工作区，也称为“单体仓库”，允许您同时管理多个相关且相互依赖的包。

“工作区”是一个包含 `deno.json` 或 `package.json` 配置文件的文件夹集合。根 `deno.json` 文件定义了工作区：

```json title="deno.json"
{
  "workspace": ["./add", "./subtract"]
}
```

这配置了一个包含 `add` 和 `subtract` 成员的工作区，这些成员是在预期中应具有 `deno.json(c)` 和/或 `package.json` 文件的目录。

:::info 命名

Deno 使用 `workspace` 而不是 npm 的 `workspaces` 来表示一个包含多个成员的单一工作区。

:::

## 示例

让我们扩展 `deno.json` 工作区示例，看看它的功能。文件层次结构如下所示：

```sh
/
├── deno.json
├── main.ts
├── add/
│     ├── deno.json
│     └── mod.ts
└── subtract/
      ├── deno.json
      └── mod.ts
```

有两个工作区成员（add 和 subtract），每个成员都有 `mod.ts` 文件。还有一个根 `deno.json` 和一个 `main.ts`。

顶级 `deno.json` 配置文件定义了工作区和应用于所有成员的顶级导入映射：

```json title="deno.json"
{
  "workspace": ["./add", "./subtract"],
  "imports": {
    "chalk": "npm:chalk@5"
  }
}
```

根 `main.ts` 文件使用导入映射中的 `chalk` 裸标识符，并从工作区成员导入 `add` 和 `subtract` 函数。请注意，它是通过 `@scope/add` 和 `@scope/subtract` 导入它们，即使这些不是正确的 URL 并且不在导入映射中。它们是如何被解析的呢？

```ts title="main.ts"
import chalk from "chalk";
import { add } from "@scope/add";
import { subtract } from "@scope/subtract";

console.log("1 + 2 =", chalk.green(add(1, 2)));
console.log("2 - 4 =", chalk.red(subtract(2, 4)));
```

在 `add/` 子目录中，我们定义了一个具有 `"name"` 字段的 `deno.json`，这对于引用工作区成员是重要的。该 `deno.json` 文件还包含示例配置，例如在使用 `deno fmt` 时关闭分号。

```json title="add/deno.json"
{
  "name": "@scope/add",
  "version": "0.1.0",
  "exports": "./mod.ts",
  "fmt": {
    "semiColons": false
  }
}
```

```ts title="add/mod.ts"
export function add(a: number, b: number): number {
  return a + b;
}
```

`subtract/` 子目录类似，但没有相同的 `deno fmt` 配置。

```json title="subtract/deno.json"
{
  "name": "@scope/subtract",
  "version": "0.3.0",
  "exports": "./mod.ts"
}
```

```ts title="subtract/mod.ts"
import { add } from "@scope/add";

export function subtract(a: number, b: number): number {
  return add(a, b * -1);
}
```

让我们运行它：

```sh
> deno run main.ts
1 + 2 = 3
2 - 4 = -2
```

这里有很多内容可以展开，展示了 Deno 工作区的一些特性：

1. 这个单体仓库由两个包组成，放置在 `./add` 和 `./subtract` 目录中。

1. 通过在成员的 `deno.json` 文件中使用 `name` 和 `version` 选项，可以通过 “裸标识符” 在整个工作区中引用它们。在这种情况下，包的名称为 `@scope/add` 和 `@scope/subtract`，其中 `scope` 是您可以选择的“范围”名称。使用这两个选项后，无需在导入语句中使用长的和相对的文件路径。

1. `npm:chalk@5` 包是整个工作区的共享依赖。工作区成员“继承”工作区根的 `imports`，可以轻松管理整个代码库中的单个版本的依赖。

1. `add` 子目录在其 `deno.json` 中指定 `deno fmt` 应在格式化代码时不应用分号。这使得现有项目的过渡更加顺畅，无需一次性更改数十个或数百个文件。

---

Deno 工作区具有灵活性且可以与 Node 包协同工作。为了更方便地迁移现有的 Node.js 项目，您可以在单个工作区中同时拥有以 Deno 优先和以 Node 优先的包。

## 工作区路径模式

Deno 支持工作区成员文件夹的模式匹配，这让管理包含大量成员或特定目录结构的工作区变得更简单。您可以使用通配符模式一次性包含多个目录：

```json title="deno.json"
{
  "workspace": [
    "some-dir/*",
    "other-dir/*/*"
  ]
}
```

模式匹配语法遵循关于文件夹深度的特定规则：

`some-path/*` 匹配位于 `some-path` 目录下的文件和文件夹（仅第一层级）。例如，使用 `packages/*` 时，包括 `packages/foo` 和 `packages/bar`，但不包括 `packages/foo/subpackage`。

`some-path/*/*` 匹配位于 `some-path` 子目录中的文件和文件夹（第二层级）。它不匹配直接位于 `some-path` 里的项目。例如，使用 `examples/*/*`，包括 `examples/basic/demo` 和 `examples/advanced/sample`，但不包括 `examples/basic`。

模式中的每个 `/*` 段对应相对于基础路径的特定文件夹深度。这允许您精确指定目录结构中不同层级的工作区成员。

## Deno 如何解析工作区依赖

在运行一个从另一个工作区成员导入的项目时，Deno 按以下步骤解析依赖：

1. Deno 从执行项目的目录开始（例如项目 A）

2. 向上查找父目录中的根 `deno.json` 文件

3. 如果找到，会检查该文件中的 `workspace` 属性

4. 对于项目 A 中的每个导入语句，Deno 检查它是否匹配任何工作区成员 `deno.json` 中定义的包名称

5. 如果找到匹配的包名，Deno 确认所在目录列在根工作区配置中

6. 然后根据工作区成员 `deno.json` 中的 `exports` 字段解析导入到正确文件

例如，假设结构如下：

```sh
/
├── deno.json         # workspace: ["./project-a", "./project-b"]
├── project-a/
│   ├── deno.json     # name: "@scope/project-a"
│   └── mod.ts        # 从 "@scope/project-b" 导入
└── project-b/
    ├── deno.json     # name: "@scope/project-b"
    └── mod.ts
```

当 `project-a/mod.ts` 导入 `"@scope/project-b"` 时，Deno 的解析流程是：

1. 看到导入语句

2. 检查父目录的 `deno.json`

3. 在工作区数组中找到 `project-b`

4. 验证 `project-b/deno.json` 存在且包名匹配

5. 使用 `project-b` 的 exports 解析该导入

### 容器化的重要提示

在将依赖其他工作区成员的工作区成员容器化时，您必须包括：

1. 根目录的 `deno.json` 文件

2. 所有相关依赖的工作区包

3. 与开发环境相同的目录结构

例如，如果要将上述的 `project-a` 制作为 Docker 镜像，Dockerfile 应该：

```dockerfile
COPY deno.json /app/deno.json
COPY project-a/ /app/project-a/
COPY project-b/ /app/project-b/
```

这样确保了 Deno 用于查找和导入工作区依赖的解析机制得以保留。

### 多个包条目

`exports` 属性详述入口点并指示包用户应导入哪些模块。

目前我们的包只有单一条目。虽然这适合简单包，通常您希望有多个条目，把包的相关部分分组。这可以通过将 `exports` 设置为对象（而非字符串）实现：

```json title="my-package/deno.json"
{
  "name": "@scope/my-package",
  "version": "0.3.0",
  "exports": {
    ".": "./mod.ts",
    "./foo": "./foo.ts",
    "./other": "./dir/other.ts"
  }
}
```

`"."` 条目是导入 `@scope/my-package` 时默认使用的入口点。因此，上述示例提供了以下入口：

- `@scope/my-package`

- `@scope/my-package/foo`

- `@scope/my-package/other`

### 发布工作区包到注册表

工作区简化了向如 JSR 或 NPM 等注册表发布包的流程。您可以发布单个工作区成员，同时保持它们在单体仓库中的开发联系。

#### 发布到 JSR

发布工作区包到 JSR，请按以下步骤操作：

1. 确保每个包的 `deno.json` 文件包含适当的元数据：

```json title="my-package/deno.json"
{
  "name": "@scope/my-package",
  "version": "1.0.0",
  "exports": "./mod.ts",
  "publish": {
    "exclude": ["tests/", "*.test.ts", "examples/"]
  }
}
```

2. 进入特定包目录并发布：

```sh
cd my-package
deno publish
```

#### 管理相互依赖的包

发布相互依赖的工作区包时，请在相关包之间保持一致的版本策略。先发布被依赖的包，再发布依赖它们的包。发布后，验证发布包是否正常工作：

```sh
# 测试已发布的包
deno add jsr:@scope/my-published-package
deno test integration-test.ts
```

发布依赖其他工作区成员的包时，Deno 会自动将工作区引用替换为发布代码中的正确注册表引用。

### 从 npm 工作区迁移

Deno 工作区支持从现有 npm 包中使用 Deno 优先的包。在此示例中，我们混用名为 `@deno/hi` 的 Deno 库和几年前开发的 Node.js 库 `@deno/log`。

根目录包含如下 `deno.json` 配置文件：

```json title="deno.json"
{
  "workspace": {
    "members": ["hi"]
  }
}
```

以及现有的 `package.json` 工作区配置：

```json title="package.json"
{
  "workspaces": ["log"]
}
```

该工作区目前包含一个日志 npm 包：

```json title="log/package.json"
{
  "name": "@deno/log",
  "version": "0.5.0",
  "type": "module",
  "main": "index.js"
}
```

```js title="log/index.js"
export function log(output) {
  console.log(output);
}
```

现在我们创建一个导入 `@deno/log` 的 Deno 优先包 `@deno/hi`：

```json title="hi/deno.json"
{
  "name": "@deno/hi",
  "version": "0.2.0",
  "exports": "./mod.ts",
  "imports": {
    "log": "npm:@deno/log@^0.5"
  }
}
```

```ts title="hi/mod.ts"
import { log } from "log";

export function sayHiTo(name: string) {
  log(`Hi, ${name}!`);
}
```

现在我们编写一个导入并调用 `hi` 的 `main.ts` 文件：

```ts title="main.ts"
import { sayHiTo } from "@deno/hi";

sayHiTo("friend");
```

运行它：

```sh
$ deno run main.ts
Hi, friend!
```

您甚至可以在现有的 Node.js 包中同时拥有 `deno.json` 和 `package.json`。此外，您还可以移除根目录中的 `package.json`，并在 `deno.json` 工作区成员中指定 npm 包。这使您能够逐步迁移到 Deno，而无需进行大量前期工作。

例如，您可以为 `log` 包添加 `deno.json` 来配置 Deno 的 linter 和格式化工具：

```jsonc
{
  "fmt": {
    "semiColons": false
  },
  "lint": {
    "rules": {
      "exclude": ["no-unused-vars"]
    }
  }
}
```

在工作区运行 `deno fmt` 时，会将 `log` 包格式化为不带分号；运行 `deno lint` 时，如果代码中存在未使用的变量，将不会报错。

## 配置内置 Deno 工具

有些配置只在工作区根部设置才有意义，例如在成员中指定 `nodeModulesDir` 选项不可用，Deno 会警告需要在工作区根部应用该选项。

下面是工作区根及其成员中各种 `deno.json` 选项的完整矩阵：

| 选项                | 工作区 | 包     | 说明                                                                                                                                                             |
| ------------------ | ------ | ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| compilerOptions    | ✅     | ✅     |                                                                                                                                                                |
| importMap          | ✅     | ❌     | 与每个配置文件的 imports 和 scopes 互斥。此外，工作区配置中不支持 importMap，包配置中不支持 imports。                                                           |
| imports            | ✅     | ✅     | 与每个配置文件的 importMap 互斥。                                                                                                                              |
| scopes             | ✅     | ❌     | 与每个配置文件的 importMap 互斥。                                                                                                                              |
| exclude            | ✅     | ✅     |                                                                                                                                                                |
| lint.include       | ✅     | ✅     |                                                                                                                                                                |
| lint.exclude       | ✅     | ✅     |                                                                                                                                                                |
| lint.files         | ⚠️     | ❌     | 已弃用                                                                                                                                                          |
| lint.rules.tags    | ✅     | ✅     | 标签通过追加包到工作区列表进行合并，重复项被忽略。                                                                                                              |
| lint.rules.include |        |        |                                                                                                                                                                |
| lint.rules.exclude | ✅     | ✅     | 规则按包合并，包的优先级高于工作区（包的 include 比工作区的 exclude 权重更强）。                                                                              |
| lint.report        | ✅     | ❌     | 一次只能激活一个报告器，因此在跨多个包 lint 文件时，不支持每个工作区使用不同报告器。                                                                            |
| fmt.include        | ✅     | ✅     |                                                                                                                                                                |
| fmt.exclude        | ✅     | ✅     |                                                                                                                                                                |
| fmt.files          | ⚠️     | ❌     | 已弃用                                                                                                                                                          |
| fmt.useTabs        | ✅     | ✅     | 包优先级高于工作区。                                                                                                                                             |
| fmt.indentWidth    | ✅     | ✅     | 包优先级高于工作区。                                                                                                                                             |
| fmt.singleQuote    | ✅     | ✅     | 包优先级高于工作区。                                                                                                                                             |
| fmt.proseWrap      | ✅     | ✅     | 包优先级高于工作区。                                                                                                                                             |
| fmt.semiColons     | ✅     | ✅     | 包优先级高于工作区。                                                                                                                                             |
| fmt.options.*      | ⚠️     | ❌     | 已弃用                                                                                                                                                          |
| nodeModulesDir     | ✅     | ❌     | 解析行为必须在整个工作区保持一致。                                                                                                                             |
| vendor             | ✅     | ❌     | 解析行为必须在整个工作区保持一致。                                                                                                                             |
| tasks              | ✅     | ✅     | 包任务优先于工作区。cwd 是包含任务配置文件的目录的工作目录。                                                                                                   |
| test.include       | ✅     | ✅     |                                                                                                                                                                |
| test.exclude       | ✅     | ✅     |                                                                                                                                                                |
| test.files         | ⚠️     | ❌     | 已弃用                                                                                                                                                          |
| publish.include    | ✅     | ✅     |                                                                                                                                                                |
| publish.exclude    | ✅     | ✅     |                                                                                                                                                                |
| bench.include      | ✅     | ✅     |                                                                                                                                                                |
| bench.exclude      | ✅     | ✅     |                                                                                                                                                                |
| bench.files        | ⚠️     | ❌     | 已弃用                                                                                                                                                          |
| lock               | ✅     | ❌     | 每个解析器只能存在一个锁定文件，且每个工作区只能有一个解析器，所以不支持为包单独启用锁文件。                                                                      |
| unstable           | ✅     | ❌     | 为简化操作，不允许使用 unstable 标志，因为 CLI 假设该标志为全局且不可变，这也避免了与 DENO_UNSTABLE_* 标志的奇怪交互。                                        |
| name               | ❌     | ✅     |                                                                                                                                                                |
| version            | ❌     | ✅     |                                                                                                                                                                |
| exports            | ❌     | ✅     |                                                                                                                                                                |
| workspace          | ✅     | ❌     | 不支持嵌套工作区。                                                                                                                                               |

## 跨工作区运行命令

Deno 提供多种方式在所有或特定工作区成员中运行命令：

### 运行测试

要在所有工作区成员中运行测试，只需在工作区根目录执行：

```sh
deno test
```

这将基于每个成员的测试配置执行测试。

若要运行特定工作区成员的测试，可以：

1. 进入该成员目录，运行测试命令：

```sh
cd my-directory
deno test
```

2. 或从根目录指定路径：

```sh
deno test my-directory/
```

### 格式化和 lint

与测试类似，格式化和 lint 命令默认在所有工作区成员中运行：

```sh
deno fmt
deno lint
```

每个成员遵循其 `deno.json` 中配置的格式化和 lint 规则，某些设置从根配置继承（如上述表格所示）。

### 使用工作区任务

您可以在工作区根目录和单个成员中定义任务：

```json title="deno.json"
{
  "workspace": ["./add", "./subtract"],
  "tasks": {
    "build": "echo '构建所有包'",
    "test:all": "deno test"
  }
}
```

```json title="add/deno.json"
{
  "name": "@scope/add",
  "version": "0.1.0",
  "exports": "./mod.ts",
  "tasks": {
    "build": "echo '构建 add 包'",
    "test": "deno test"
  }
}
```

运行某个包内定义的任务：

```sh
deno task --cwd=add build
```

## 共享和管理依赖

工作区提供强大的方法来共享和管理跨项目依赖：

### 共享开发依赖

通常的开发依赖（如测试库）可在工作区根部定义：

```json title="deno.json"
{
  "workspace": ["./add", "./subtract"],
  "imports": {
    "@std/testing/": "jsr:@std/testing@^0.218.0/",
    "chai": "npm:chai@^4.3.7"
  }
}
```

这使得所有工作区成员都可以使用这些依赖，无需重新定义。

### 管理版本冲突

解析依赖时，工作区成员可覆盖根部分定义的依赖。如果根和成员指定同一依赖的不同版本，解析成员文件夹内依赖时使用成员的版本。这样允许单个包按需使用特定的依赖版本。

但是，成员特定依赖仅在该成员文件夹内生效。成员文件夹外，或根级文件操作时，依赖解析使用工作区根部的导入映射（包括 JSR 和 HTTPS 依赖）。

### 互相依赖的工作区成员

如之前 `add` 与 `subtract` 模块示例，工作区成员间可互为依赖。这方便实现职责清晰的拆分，且可共同开发和测试互依模块。

`subtract` 模块导入 `add` 模块功能，示范工作区成员如何基于彼此构建：

```ts title="subtract/mod.ts"
import { add } from "@scope/add";

export function subtract(a: number, b: number): number {
  return add(a, b * -1);
}
```

此方法允许您：

1. 将复杂项目拆分成职责单一的包

2. 在包间共享代码，无需发布到注册表

3. 共同开发、测试相互依赖模块

4. 逐步将单体代码库迁移为模块化架构

## 在 package.json 中使用工作区协议

Deno 支持在 `package.json` 中使用工作区协议说明符，非常适合依赖工作区内其他包的 npm 包：

```json title="package.json"
{
  "name": "my-npm-package",
  "dependencies": {
    "another-workspace-package": "workspace:*"
  }
}
```

支持的工作区协议说明符包括：

- `workspace:*` —— 使用工作区中可用的最新版

- `workspace:~` —— 使用工作区版本，且仅允许补丁级变更

- `workspace:^` —— 使用与语义版本兼容的工作区版本

## npm 和 pnpm 工作区兼容性

Deno 能无缝兼容使用 `package.json` 中定义的标准 npm 工作区：

```json title="package.json"
{
  "workspaces": ["packages/*"]
}
```

对于 pnpm 用户，Deno 支持典型 pnpm 工作区配置。然而，若您使用 `pnpm-workspace.yaml`，需将其迁移到 `deno.json` 工作区配置：

```yaml title="pnpm-workspace.yaml (应替换)"
packages:
  - "packages/*"
```

应转换为：

```json title="deno.json"
{
  "workspace": ["packages/*"]
}
```

这样，在迁移或混合项目中，Deno 与 npm／pnpm 生态系统能实现顺畅集成。

有关配置项目的更多信息，请查看 [使用 deno.json 进行配置](/examples/configuration_with_deno_json/) 教程。

---

# 好的。我们为 net_client.ts 授予网络权限。

> A comprehensive guide to using Deno's command-line interface (CLI). Learn about running scripts, managing permissions, using watch mode, and configuring Deno's runtime behavior through command-line flags and options.

URL: https://docs.deno.com/runtime/getting_started/command_line_interface


Deno 是一个命令行程序。Deno 的命令行接口（CLI）可以用于运行脚本、管理依赖关系，甚至将你的代码编译成独立的可执行文件。到目前为止，经过这些示例，你可能已经熟悉了一些简单的命令。此页面将提供 Deno CLI 更详细的概述。

Deno CLI 具有多个子命令（如 `run`、`init` 和 `test` 等）。它们用于在 Deno 运行时环境中执行不同的任务。每个子命令都有自己的一组标志和选项（例如 --version），可以用于自定义其行为。

你可以通过在终端中运行 `deno help` 子命令或使用 `-h` 或 `--help` 标志来查看所有可用的命令和标志。

查看 [CLI 参考指南](/runtime/reference/cli/) 以获取所有可用子命令和标志的进一步文档。我们将在下面更详细地看几个命令，以查看它们如何被使用和配置。

## 示例子命令 - `deno run`

你可以通过指定其相对于当前工作目录的路径来运行本地 TypeScript 或 JavaScript 文件：

```shell
deno run main.ts
```

Deno 支持直接从 URL 运行脚本。这在快速测试或运行代码而无需先下载它时特别有用：

```shell
deno run https://docs.deno.com/examples/scripts/hello_world.ts
```

你还可以通过标准输入将脚本通过管道传递。这对于与其他命令行工具集成或动态生成脚本很有用：

```shell
cat main.ts | deno run -
```

## 传递脚本参数

脚本参数是在从命令行运行脚本时可以传递给脚本的附加参数。这些参数可以用于根据运行时提供的输入自定义程序的行为。参数应在脚本名称 **之后** 传递。

为了测试这一点，我们可以制作一个将记录传递给它的参数的脚本：

```ts title="main.ts"
console.log(Deno.args);
```

当我们运行该脚本并传递一些参数时，它将记录这些参数到控制台：

```shell
$ deno run main.ts arg1 arg2 arg3
[ "arg1", "arg2", "arg3" ]
```

## 参数和标志的顺序

_注意，任何在脚本名称之后传递的内容将作为脚本参数传递，而不是作为 Deno 运行时标志消耗。_ 这导致以下陷阱：

```shell
# 好的。我们为 net_client.ts 授予网络权限。
deno run --allow-net net_client.ts

# 不好的！--allow-net 被传递给 Deno.args，抛出网络权限错误。
deno run net_client.ts --allow-net
```

## 常见标志

某些标志可以与多个相关的子命令一起使用。我们在下面讨论这些标志。

### 观察模式

你可以将 `--watch` 标志提供给 `deno run`、`deno test`、`deno compile` 和 `deno fmt` 来启用内置的文件监视器。监视器在检测到源文件中的更改时启用应用程序的自动重载。在开发过程中这特别有用，因为它允许你立即看到更改的效果，而无需手动重启应用程序。

所监视的文件将取决于使用的子命令：

- 对于 `deno run`、`deno test` 和 `deno compile`，将监视入口文件及其静态导入的所有本地文件。
- 对于 `deno fmt`，将监视作为命令行参数指定的所有本地文件和目录（如果未传递特定文件/目录，则监视工作目录）。

```shell
deno run --watch main.ts
deno test --watch
deno fmt --watch
```

你可以通过提供 `--watch-exclude` 标志来排除路径或模式被监视。语法为 `--watch-exclude=path1,path2`。例如：

```shell
deno run --watch --watch-exclude=file1.ts,file2.ts main.ts
```

这将排除 file1.ts 和 file2.ts 被监视。

要排除一个模式，请记得将其用引号括起来，以防止你的 shell 展开通配符：

```shell
deno run --watch --watch-exclude='*.js' main.ts
```

### 热模块替换模式

你可以使用 `--watch-hmr` 标志与 `deno run` 一起启用热模块替换模式。运行时将在不重启程序的情况下尝试就地更新程序。如果就地更新失败，程序仍然会被重启。

```sh
deno run --watch-hmr main.ts
```

当热模块替换被触发时，运行时将分派一个类型为 `hmr` 的 `CustomEvent`，在其 `detail` 对象中包含 `path` 属性。你可以监听此事件并执行任何在模块更新时需要执行的额外逻辑（例如，通过 WebSocket 连接通知浏览器）。

```ts
addEventListener("hmr", (e) => {
  console.log("HMR 触发", e.detail.path);
});
```

### 完整性标志（锁文件）

影响可以将资源下载到缓存的命令：`deno install`、`deno run`、`deno test`、`deno doc` 和 `deno compile`。

```sh
--lock <FILE>    检查指定的锁文件
--frozen[=<BOOLEAN>] 如果锁文件过期则出错
```

了解更多信息请查看
[这里](/runtime/fundamentals/modules/#integrity-checking-and-lock-files)。

### 缓存和编译标志

影响可以填充缓存的命令：`deno install`、`deno run`、`deno test`、`deno doc` 和 `deno compile`。除了上述标志，这还包括那些影响模块解析、编译配置等的标志。

```sh
--config <FILE>               加载配置文件
--import-map <FILE>           加载导入映射文件
--no-remote                   不解析远程模块
--reload=<CACHE_BLOCKLIST>    重新加载源代码缓存（重新编译 TypeScript）
--unstable                    启用不稳定的 API
```

### 运行时标志

影响执行用户代码的命令：`deno run` 和 `deno test`。这些包括上述所有内容以及以下内容。

### 类型检查标志

你可以使用以下命令对代码进行类型检查（不执行）：

```shell
> deno check main.ts
```

你还可以在执行之前使用 `--check` 参数对代码进行类型检查：

```shell
> deno run --check main.ts
```

<<<<<<< HEAD
此标志影响 `deno run`、`deno eval`、`deno repl`。下面的表格描述了各种子命令的类型检查行为。在此，“本地”意味着只有本地代码中的错误会导致类型错误，从 https URL 导入的模块（远程）可能有未报告的类型错误。（要打开所有模块的类型检查，请使用 `--check=all`。）
=======
This flag affects `deno run` and `deno eval`. The following table describes the
type-checking behavior of various subcommands. Here "Local" means that only
errors from local code will induce type-errors, modules imported from https URLs
(remote) may have type errors that are not reported. (To turn on type-checking
for all modules, use `--check=all`.)
>>>>>>> origin/upstream

| 子命令         | 类型检查模式 |
| -------------- | ------------------ |
| `deno bench`   | 📁 本地           |
| `deno check`   | 📁 本地           |
| `deno compile` | 📁 本地           |
| `deno eval`    | ❌ 无            |
| `deno repl`    | ❌ 无            |
| `deno run`     | ❌ 无            |
| `deno test`    | 📁 本地           |

### 权限标志

这些在 [这里](/runtime/fundamentals/security/) 列出。

### 其他运行时标志

更多影响执行环境的标志。

```sh
--cached-only                要求远程依赖项已缓存
--inspect=<HOST:PORT>        在 host:port 上激活检查器 ...
--inspect-brk=<HOST:PORT>    在 host:port 上激活检查器并在 ... 处中断
--inspect-wait=<HOST:PORT>   在 host:port 上激活检查器并等待 ...
--location <HREF>            一些 Web API 使用的 'globalThis.location' 的值
--prompt                     如果未传递所需权限，则回退到提示
--seed <NUMBER>              随机生成 Math.random()
--v8-flags=<v8-flags>        设置 V8 命令行选项。帮助参见 ...
```

---

# runtime/getting_started/first_project.md

> Step-by-step guide to creating your first Deno project. Learn how to initialize a project, understand the basic file structure, run TypeScript code, and execute tests using Deno's built-in test runner.

URL: https://docs.deno.com/runtime/getting_started/first_project


Deno 拥有许多 [内置工具](/runtime/reference/cli/) 使您的开发体验尽可能顺畅。其中一个工具是 [项目初始化器](/runtime/reference/cli/init)，它创建一个具有基本文件结构和配置的新 Deno 项目。

虽然您可以使用 JavaScript，但 Deno 也内置支持 [TypeScript](https://www.typescriptlang.org/)，因此我们在本指南中将使用 TypeScript。如果您更愿意使用 JavaScript，可以将文件重命名为 `.js` 并删除类型注解。

## 初始化新项目

要初始化一个新的 Deno 项目，请在终端中运行以下命令：

```bash
deno init my_project
```

这将创建一个名为 `my_project` 的新目录，结构如下：

```plaintext
my_project
├── deno.json
├── main_test.ts
└── main.ts
```

创建一个 `deno.json` 文件以 [配置您的项目](/runtime/fundamentals/configuration/)，并创建两个 TypeScript 文件；`main.ts` 和 `main_test.ts`。`main.ts` 文件是您编写应用程序代码的地方，初始创建时它将包含一个简单的程序，用于将两个数字相加。`main_test.ts` 文件是您可以编写测试的地方，初始时它将包含一个用于您的加法程序的测试。

## 运行您的项目

您可以使用以下命令运行该程序：

```bash
$ deno main.ts
Add 2 + 3 = 5
```

## 运行您的测试

Deno 有一个 [内置测试运行器](/runtime/fundamentals/testing/)。您可以为您的代码编写测试，并使用 `deno test` 命令运行它们。使用以下命令在您的新项目中运行测试：

```bash
$ deno test
running 1 test from ./main_test.ts     
addTest ... ok (1ms)

ok | 1 passed | 0 failed (3ms)
```

现在您已经设置了一个基本项目，可以开始构建您的应用程序。查看我们的 [示例和教程](/examples/) 获取有关使用 Deno 构建的更多想法。

您可以 [在这里了解更多关于在 Deno 中使用 TypeScript 的信息](/runtime/fundamentals/typescript)。

---

# 下载并安装 Deno 的最新版本

> A Guide to installing Deno on different operating systems. Includes instructions for Windows, macOS, and Linux using various package managers, manual installation methods, and Docker containers.

URL: https://docs.deno.com/runtime/getting_started/installation


Deno 可以在 macOS、Linux 和 Windows 上运行。Deno 是一个单一的二进制可执行文件。它没有外部依赖。在 macOS 上，同时提供 M1（arm64）和 Intel（x64）可执行文件。在 Linux 和 Windows 上，仅支持 x64。

## 下载和安装

[deno_install](https://github.com/denoland/deno_install) 提供了方便的脚本来下载和安装二进制文件。

<deno-tabs group-id="operating-systems">
<deno-tab value="mac" label="macOS" default>

使用 Shell:

```shell
curl -fsSL https://deno.land/install.sh | sh
```

使用 [npm](https://npmjs.com/package/deno):

```shell
npm install -g deno
```

> <small>如果通过 npm 安装，Deno 命令的启动时间会受到影响。我们建议使用 shell 安装脚本以获得更好的性能。</small>

使用 [Homebrew](https://formulae.brew.sh/formula/deno):

```shell
brew install deno
```

使用 [MacPorts](https://ports.macports.org/port/deno/):

```shell
sudo port install deno
```

使用 [Nix](https://nixos.org/download.html):

```shell
nix-shell -p deno
```

使用 [asdf](https://asdf-vm.com/):

```shell
asdf plugin add deno https://github.com/asdf-community/asdf-deno.git

# 下载并安装 Deno 的最新版本
asdf install deno latest

# 将其设置为全局默认的 Deno 版本
asdf set -u deno latest

# 将其设置为本地（仅当前项目）的默认 Deno 版本
asdf set deno latest
```

使用 [vfox](https://vfox.dev/):

```shell
vfox add deno

# 下载并安装 Deno 的最新版本
vfox install deno@latest

# 将 Deno 的版本设置为全局
vfox use --global deno
```

</deno-tab>
<deno-tab value="windows" label="Windows">

使用 PowerShell（Windows）:

```powershell
irm https://deno.land/install.ps1 | iex
```

使用 [npm](https://npmjs.com/package/deno):

```shell
npm install -g deno
```

> <small>如果通过 npm 安装，Deno 命令的启动时间会受到影响。我们建议使用 PowerShell 安装脚本以获得更好的性能。</small>

使用 [Scoop](https://scoop.sh/):

```shell
scoop install deno
```

使用 [Chocolatey](https://chocolatey.org/packages/deno):

```shell
choco install deno
```

使用 [Winget](https://github.com/microsoft/winget-cli):

```shell
winget install DenoLand.Deno
```

使用 [vfox](https://vfox.dev/):

```shell
vfox add deno

# 下载并安装 Deno 的最新版本
vfox install deno@latest

# 将 Deno 的版本设置为全局
vfox use --global deno
```

</deno-tab>
<deno-tab value="linux" label="Linux">

使用 Shell:

```shell
curl -fsSL https://deno.land/install.sh | sh
```

使用 [npm](https://npmjs.com/package/deno):

```shell
npm install -g deno
```

> <small>如果通过 npm 安装，Deno 命令的启动时间会受到影响。我们建议使用 shell 安装脚本以获得更好的性能。</small>

使用 [Nix](https://nixos.org/download.html):

```shell
nix-shell -p deno
```

使用 [asdf](https://asdf-vm.com/):

```shell
asdf plugin add deno https://github.com/asdf-community/asdf-deno.git

# 下载并安装 Deno 的最新版本
asdf install deno latest

# 将其设置为全局默认的 Deno 版本
asdf set -u deno latest

# 将其设置为本地（仅当前项目）的默认 Deno 版本
asdf set deno latest
```

使用 [vfox](https://vfox.dev/):

```shell
vfox add deno

# 下载并安装 Deno 的最新版本
vfox install deno@latest

# 将 Deno 的版本设置为全局
vfox use --global deno
```

</deno-tab>
</deno-tabs>

您也可以使用 [Cargo](https://crates.io/crates/deno) 从源代码构建和安装：

```shell
cargo install deno --locked
```

Deno 二进制文件也可以手动安装，通过在 [github.com/denoland/deno/releases](https://github.com/denoland/deno/releases) 下载 zip 文件。这些包仅包含一个可执行文件。您将需要在 macOS 和 Linux 上设置可执行位。

## Docker

有关官方 Docker 镜像的更多信息和说明：
[https://github.com/denoland/deno_docker](https://github.com/denoland/deno_docker)

## 测试您的安装

要测试您的安装，运行 `deno --version`。如果在控制台打印 Deno 版本，则表示安装成功。

使用 `deno help` 查看有关 Deno 标志和用法的帮助文本。获取 CLI 的详细指南
[这里](/runtime/getting_started/command_line_interface/)。

## 更新

要更新之前安装的 Deno 版本，您可以运行：

```shell
deno upgrade
```

或者使用 [Winget](https://github.com/microsoft/winget-cli)（Windows）:

```shell
winget upgrade DenoLand.Deno
```

这将从 [github.com/denoland/deno/releases](https://github.com/denoland/deno/releases) 获取最新版本，解压缩并用其替换您当前的可执行文件。

您也可以使用此工具安装特定版本的 Deno：

```shell
deno upgrade --version 1.0.1
```

## 从源代码构建

有关如何从源代码构建的信息可以在 [`从源代码构建`](https://github.com/denoland/deno/blob/main/.github/CONTRIBUTING.md#building-from-source) 指南中找到。

---

# 设置你的环境

> Deno 开发环境搭建指南。学习如何配置流行编辑器如 VS Code，设置语言服务器支持，并启用 shell 自动补全以提升工作效率。

URL: https://docs.deno.com/runtime/getting_started/setup_your_environment


Deno 附带许多在应用程序开发中常用的工具，包括完整的
[语言服务 (LSP)](/runtime/reference/cli/lsp/)，以支持你选择的 IDE。本页面将帮助你配置环境，以便在开发时充分利用 Deno。

我们将涵盖：

- 如何在你喜欢的编辑器/IDE 中使用 Deno
- 如何生成 shell 自动补全

## 设置你的编辑器/IDE

### Visual Studio Code

如果你尚未安装，请从 [官方网站](https://code.visualstudio.com/) 下载并安装 Visual Studio Code。

在扩展视图中搜索 "Deno" 并安装
[Denoland 的扩展](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno)。

接下来，按下 `Ctrl+Shift+P` 打开命令面板，输入
`Deno: Initialize Workspace Configuration`，选择该选项以配置 Deno
以适配你的工作区。

![VSCode 命令面板，选中 Deno: Initialize Workspace Configuration 选项。](./images/vscode-setup.png)

一个名为 `.vscode/settings.json` 的文件会在你的工作区中创建，内容如下：

```json
{
  "deno.enable": true
}
```

就这样！你已经成功设置了 VSCode 的 Deno 开发环境。现在你可以享受 Deno LSP 提供的所有功能，包括智能感知（IntelliSense）、代码格式化、代码检查等。

### JetBrains IDEs

要安装 Deno 插件，打开你的 IDE 并前往 **File** > **Settings**。
导航至 **Plugins**，搜索 `Deno`，并安装官方的 Deno 插件。

![WebStorm 插件设置](./images/webstorm_setup.png)

要配置插件，返回到 **File** > **Settings**，导航到
**Languages & Frameworks** > **Deno**。勾选 **Enable Deno for your project**，
并指定 Deno 可执行文件的路径（如果未自动检测）。

查看
[这篇博客文章](https://blog.jetbrains.com/webstorm/2020/06/deno-support-in-jetbrains-ides/)
以了解如何在 JetBrains IDE 中开始使用 Deno 的更多信息。

### Vim/Neovim 通过插件

Deno 在 [Vim](https://www.vim.org/) 和 [Neovim](https://neovim.io/) 上有良好支持，可以通过
[coc.nvim](https://github.com/neoclide/coc.nvim)、[vim-easycomplete](https://github.com/jayli/vim-easycomplete)、[ALE](https://github.com/dense-analysis/ale) 和 [vim-lsp](https://github.com/prabirshrestha/vim-lsp) 插件实现。coc.nvim 提供与 Deno 语言服务器集成的插件，而 ALE 开箱即用支持 Deno。

### Neovim 0.6+ 使用内置语言服务器

要使用 Deno 语言服务器，请安装
[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig/) 并按照说明启用
[所提供的 Deno 配置](https://github.com/neovim/nvim-lspconfig/blob/master/doc/configs.md#denols)。

请注意，如果你同时使用 `ts_ls` 作为 LSP 客户端，可能会出现 `ts_ls` 和 `denols` 同时附加到当前缓冲区的问题。为解决此问题，请确保为 `ts_ls` 和 `denols` 设置不同的 `root_dir`。你可能还需将 `ts_ls` 的 `single_file_support` 设置为 `false`，以防其在单文件模式下运行。以下是示例配置：

```lua
vim.lsp.config('denols', {
    on_attach = on_attach,
    root_markers = {"deno.json", "deno.jsonc"},
})

vim.lsp.config('ts_ls', {
    on_attach = on_attach,
    root_markers = {"package.json"},
    single_file_support = false,
})
```

对于 Deno，上述示例假设项目根目录下存在 `deno.json` 或 `deno.jsonc` 文件。

##### Kickstart.nvim 和 Mason LSP

如果你使用 [kickstart.nvim](https://github.com/nvim-lua/kickstart.nvim)，可以将上述配置以如下方式添加至你的 `init.lua` 配置中的服务器表：

```lua
local servers = {
        -- ... 一些配置
        ts_ls = {
            root_dir = require("lspconfig").util.root_pattern({ "package.json", "tsconfig.json" }),
            single_file_support = false,
            settings = {},
        },
        denols = {
            root_dir = require("lspconfig").util.root_pattern({"deno.json", "deno.jsonc"}),
            single_file_support = false,
            settings = {},
        },
    }
```

#### coc.nvim

安装
[coc.nvim](https://github.com/neoclide/coc.nvim/wiki/Install-coc.nvim) 后，你需要通过命令 `:CocInstall coc-deno` 安装
[coc-deno](https://github.com/fannheyward/coc-deno) 插件。

插件安装完毕后，如想在某个工作区启用 Deno，可以运行命令 `:CocCommand deno.initializeWorkspace`，然后即可使用 `gd`（跳转到定义）、`gr`（查找引用）等命令。

#### ALE

ALE 原生支持 Deno 语言服务器，许多情况下无需额外配置。安装
[ALE](https://github.com/dense-analysis/ale#installation) 后，执行
[`:help ale-typescript-deno`](https://github.com/dense-analysis/ale/blob/master/doc/ale-typescript.txt)
以获取可用配置选项信息。

有关如何设置 ALE（如键绑定）的更多信息，请参考
[官方文档](https://github.com/dense-analysis/ale#usage)。

#### Vim-EasyComplete

Vim-EasyComplete 默认支持 Deno，无需额外配置。安装
[vim-easycomplete](https://github.com/jayli/vim-easycomplete#installation) 后，若尚未安装 Deno，需通过 `:InstallLspServer deno` 安装。更多信息详见
[官方文档](https://github.com/jayli/vim-easycomplete)。

#### Vim-Lsp

通过
[vim-plug](https://github.com/prabirshrestha/vim-lsp?tab=readme-ov-file#installing)
或 vim 包管理器安装 Vim-Lsp 后，在你的 `.vimrc` 添加以下配置：

```vim
if executable('deno')
  let server_config = {
    \ 'name': 'deno',
    \ 'cmd': {server_info->['deno', 'lsp']},
    \ 'allowlist': ['typescript', 'javascript', 'javascriptreact', 'typescriptreact'],
    \ }

  if exists('$DENO_ENABLE')
    let deno_enabled = $DENO_ENABLE == '1'
    let server_config['workspace_config'] = { 'deno': { 'enable': deno_enabled ? v:true : v:false } }
  endif

  au User lsp_setup call lsp#register_server(server_config)
endif
```

启用 LSP 服务器有两种方式：一种是在当前工作目录下存在 `deno.json` 或 `deno.jsonc` 文件，另一种是通过环境变量 `DENO_ENABLE=1` 强制启用。如果你想让 IntelliSense 中的工具提示高亮语法，也可在 `.vimrc` 中添加：

```vim
let g:markdown_fenced_languages = ["ts=typescript"]
```

### Emacs

#### lsp-mode

Emacs 通过 Deno 语言服务器使用
[lsp-mode](https://emacs-lsp.github.io/lsp-mode/) 支持 Deno。安装
[lsp-mode](https://emacs-lsp.github.io/lsp-mode/page/installation/) 后，默认支持 Deno，可进行
[配置](https://emacs-lsp.github.io/lsp-mode/page/lsp-deno/) 来自定义设置。

#### eglot

你也可以使用内置 Deno 语言服务器的 [`eglot`](https://github.com/joaotavora/eglot)。

以下是通过 eglot 配置 Deno 的示例：

```elisp
(add-to-list 'eglot-server-programs '((js-mode typescript-mode) . (eglot-deno "deno" "lsp")))

  (defclass eglot-deno (eglot-lsp-server) ()
    :documentation "Deno LSP 的自定义类。")

  (cl-defmethod eglot-initialization-options ((server eglot-deno))
    "传递必要的 deno 初始化选项"
    (list
      :enable t
      :unstable t
      :typescript
        (:inlayHints
          (:variableTypes
            (:enabled t))
          (:parameterTypes
            (:enabled t)))))
```

这相当于 VSCode 中 `settings.json` 的以下配置：

```jsonc
{
  "deno.enable": true,
  "deno.unstable": true,
  "typescript.inlayHints.variableTypes.enabled": true,
  "typescript.inlayHints.parameterTypes.enabled": true
}
```

### Pulsar

[Pulsar 编辑器，前身为 Atom](https://pulsar-edit.dev/) 支持通过
[atom-ide-deno](https://web.pulsar-edit.dev/packages/atom-ide-deno) 包集成 Deno 语言服务器。
`atom-ide-deno` 需要安装 Deno CLI，并依赖
[atom-ide-base](https://web.pulsar-edit.dev/packages/atom-ide-base) 包。

### Sublime Text

[Sublime Text](https://www.sublimetext.com/) 通过 [LSP 插件](https://packagecontrol.io/packages/LSP) 连接到 Deno 语言服务器。你可能还需要安装
[TypeScript 插件](https://packagecontrol.io/packages/TypeScript) 以获得完整语法高亮。

安装 LSP 插件后，在 `.sublime-project` 文件中添加以下配置：

```jsonc
{
  "settings": {
    "LSP": {
      "deno": {
        "command": ["deno", "lsp"],
        "initializationOptions": {
          // "config": "", // 设置项目中配置文件路径
          "enable": true,
          // "importMap": "", // 设置项目导入映射路径
          "lint": true,
          "unstable": false
        },
        "enabled": true,
        "languages": [
          {
            "languageId": "javascript",
            "scopes": ["source.js"],
            "syntaxes": [
              "Packages/Babel/JavaScript (Babel).sublime-syntax",
              "Packages/JavaScript/JavaScript.sublime-syntax"
            ]
          },
          {
            "languageId": "javascriptreact",
            "scopes": ["source.jsx"],
            "syntaxes": [
              "Packages/Babel/JavaScript (Babel).sublime-syntax",
              "Packages/JavaScript/JavaScript.sublime-syntax"
            ]
          },
          {
            "languageId": "typescript",
            "scopes": ["source.ts"],
            "syntaxes": [
              "Packages/TypeScript-TmLanguage/TypeScript.tmLanguage",
              "Packages/TypeScript Syntax/TypeScript.tmLanguage"
            ]
          },
          {
            "languageId": "typescriptreact",
            "scopes": ["source.tsx"],
            "syntaxes": [
              "Packages/TypeScript-TmLanguage/TypeScriptReact.tmLanguage",
              "Packages/TypeScript Syntax/TypeScriptReact.tmLanguage"
            ]
          }
        ]
      }
    }
  }
}
```

### Nova

[Nova 编辑器](https://nova.app) 可通过
[Deno 扩展](https://extensions.panic.com/extensions/co.gwil/co.gwil.deno/) 集成 Deno 语言服务器。

### GitHub Codespaces

[GitHub Codespaces](https://github.com/features/codespaces) 允许你完全在线或远程在本地机器上开发，无需额外配置或安装 Deno。目前处于早期访问阶段。

如果项目启用了 Deno，并包含 `.devcontainer` 配置作为库的一部分，则在 Codespaces 中打开项目应可“开箱即用”。若创建新项目或想为现有环境添加 Deno 支持，可通过命令面板选择 `Codespaces: Add Development Container Configuration Files...`，然后选择 `Show All Definitions...` 并搜索 `Deno` 定义。

选中后需要重建容器，容器内会添加 Deno CLI。重建后，代码空间即可支持 Deno。

### Kakoune

[Kakoune](https://kakoune.org/) 通过 [kak-lsp](https://github.com/kak-lsp/kak-lsp) 客户端支持连接 Deno 语言服务器。安装
[kak-lsp](https://github.com/kak-lsp/kak-lsp#installation) 后，可在 `kak-lsp.toml` 中添加如下配置示例：

```toml
[language.typescript]
filetypes = ["typescript", "javascript"]
roots = [".git"]
command = "deno"
args = ["lsp"]
[language.typescript.settings.deno]
enable = true
lint = true
```

### Helix

[Helix](https://helix-editor.com) 内建语言服务器支持。启用连接 Deno 语言服务器，需要在 `languages.toml` 配置文件中做如下修改：

```toml
[[language]]
name = "typescript"
roots = ["deno.json", "deno.jsonc", "package.json"]
file-types = ["ts", "tsx"]
auto-format = true
language-servers = ["deno-lsp"]

[[language]]
name = "javascript"
roots = ["deno.json", "deno.jsonc", "package.json"]
file-types = ["js", "jsx"]
auto-format = true
language-servers = ["deno-lsp"]

[language-server.deno-lsp]
command = "deno"
args = ["lsp"]
config.deno.enable = true
```

### Zed

[Zed 编辑器](https://zed.dev) 可通过
[Deno 扩展](https://zed.dev/extensions?query=deno&filter=language-servers) 集成 Deno 语言服务器。

## Shell 自动补全

Deno CLI 内置支持为自身生成 shell 补全脚本。使用 `deno completions <shell>` 命令，Deno CLI 会将补全内容输出到 stdout。目前支持的 shell 如下：

- bash
- elvish
- fish
- powershell
- zsh

### bash 示例

输出补全脚本并加载到环境中：

```shell
> deno completions bash > /usr/local/etc/bash_completion.d/deno.bash
> source /usr/local/etc/bash_completion.d/deno.bash
```

### PowerShell 示例

输出补全脚本：

```shell
> deno completions powershell >> $profile
> .$profile
```

这会在 `$HOME\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1` 创建 PowerShell 配置文件，并在每次启动 PowerShell 时自动运行。

### zsh 示例

你应有一个目录用来存放补全脚本：

```shell
> mkdir ~/.zsh
```

然后输出补全：

```shell
> deno completions zsh > ~/.zsh/_deno
```

确保你的 `~/.zshrc` 中加载补全：

```shell
fpath=(~/.zsh $fpath)
autoload -Uz compinit
compinit -u
```

若重新加载 shell 后补全仍未生效，尝试删除 `~/.zcompdump/` 目录清除旧补全缓存，再次运行 `compinit`。

### 使用 ohmyzsh 和 antigen 的 zsh 示例

[ohmyzsh](https://github.com/ohmyzsh/ohmyzsh) 是 zsh 配置框架，方便管理 shell 配置，
[antigen](https://github.com/zsh-users/antigen) 是 zsh 插件管理器。

创建目录并输出补全：

```shell
> mkdir ~/.oh-my-zsh/custom/plugins/deno
> deno completions zsh > ~/.oh-my-zsh/custom/plugins/deno/_deno
```

你的 `.zshrc` 可能如下：

```shell
source /path-to-antigen/antigen.zsh

# 加载 oh-my-zsh。
antigen use oh-my-zsh

antigen bundle deno
```

### fish 示例

将补全脚本输出至 fish 配置目录中的文件：

```shell
> deno completions fish > ~/.config/fish/completions/deno.fish
```

## 其他工具

如果你正在开发或支持使用 Deno 语言服务器的社区集成，请参考
[更多关于与 Deno LSP 集成的信息](/runtime/reference/lsp_integration/)，并欢迎随时加入我们的 [Discord 社区](https://discord.gg/deno) 的 `#dev-lsp` 频道交流。

---

# Where to get help

> Guide to getting help with Deno. Find community resources, support channels, discussion forums, and how to engage with the Deno community for troubleshooting and assistance.

URL: https://docs.deno.com/runtime/help


Stuck? Lost? Get Help from the Deno Community.

## [社区 Discord](https://discord.gg/deno)

实时向社区成员提问和聊天。

## [Stack Overflow](https://stackoverflow.com/questions/tagged/deno)

Stack Overflow 是一个流行的论坛，可以询问代码相关的问题或如果你在特定错误上遇到困难。
[问你自己的问题！](https://stackoverflow.com/questions/ask?tags=deno)

## [DEV 的 Deno 社区](https://dev.to/t/deno)

一个很棒的地方，可以找到关于最佳实践、应用架构和新学习的有趣文章。使用标签 `deno` 发布你的文章。

## 示例和教程

Deno 提供了广泛的示例和教程，可能解决您的问题：

- [Deno 示例](/examples/): 常见任务的实用代码片段


---

# 欢迎使用 Deno

> 学习 Deno 的基础知识，一个安全的 JavaScript、TypeScript 和 WebAssembly 运行时。

URL: https://docs.deno.com/runtime/


[Deno](https://deno.com)
([/ˈdiːnoʊ/](https://ipa-reader.com/?text=%CB%88di%CB%90no%CA%8A)，发音为
`dee-no`) 是一个
[开源](https://github.com/denoland/deno/blob/main/LICENSE.md) 的 JavaScript、
TypeScript 和 WebAssembly 运行时，具备安全默认设置和出色的开发者体验。它基于 [V8](https://v8.dev/),
[Rust](https://www.rust-lang.org/) 和 [Tokio](https://tokio.rs/) 构建。

## 为什么选择 Deno？

- Deno 是
  **[开箱即用支持 TypeScript](/runtime/fundamentals/typescript/)。** 无需额外配置或步骤。
- Deno 默认 **[安全](/runtime/fundamentals/security/)。** 其他运行时通常给予其执行的脚本完全访问权限，而 Deno 允许你强制执行细粒度的权限控制。
- Deno 拥有 **强大的内置工具链。** 与 Node 或浏览器 JavaScript 不同，Deno 包含一个 [标准库](/runtime/fundamentals/standard_library/)，
  以及一流的
  [代码检查/格式化工具](/runtime/fundamentals/linting_and_formatting/)，
  [测试运行器](/runtime/fundamentals/testing/) 等等。
- Deno **与 [Node 和 npm](/runtime/fundamentals/node/) 完全兼容。**
- Deno 运行 **快速且可靠**。
- **[Deno 是开源项目](https://github.com/denoland/deno)。**

## 快速安装

通过以下终端命令之一在你的系统上安装 Deno 运行时：

<deno-tabs group-id="operating-systems">
<deno-tab value="mac" label="macOS" default>

```sh
curl -fsSL https://deno.land/install.sh | sh
```

</deno-tab>
<deno-tab value="windows" label="Windows">

Windows PowerShell 中执行：

```powershell
irm https://deno.land/install.ps1 | iex
```

</deno-tab>
<deno-tab value="linux" label="Linux">

```sh
curl -fsSL https://deno.land/install.sh | sh
```

</deno-tab>
</deno-tabs>

[更多安装选项请见此处](/runtime/getting_started/installation/)。安装完成后，你的系统路径中应该有 `deno` 可执行文件。你可以通过运行以下命令来验证安装是否成功：

```sh
deno --version
```

## 初学者入门

Deno 可以运行 JavaScript 和 [TypeScript](https://www.typescriptlang.org/)，无需任何额外工具或配置，
并且提供一个安全且开箱即用的运行环境。

- [创建你的第一个 Deno 项目](/runtime/getting_started/first_project/)
- [设置开发环境](/runtime/getting_started/setup_your_environment/)
- [使用命令行界面](/runtime/getting_started/command_line_interface)

---

# 打包

> `deno bundle` 子命令的概述，可用于生成一个单文件应用程序，由多个源文件创建以实现优化执行。

URL: https://docs.deno.com/runtime/reference/bundling


:::caution

这是一个实验性功能，要求 Deno 版本为 `2.4.0` 或更高。

:::

`deno bundle` 命令输出一个包含所有依赖的单个 JavaScript 文件。

`deno bundle` 在内部由 [ESBuild](https://esbuild.github.io/) 提供支持。

该工具适用于将项目打包或分发成单个优化的 JS 文件。

## 支持的功能

- 解析并内联所有依赖
- 支持 JSX/TSX、TypeScript 和现代 JavaScript，包括
  [导入属性](/runtime/fundamentals/modules/#import-attributes) 和 CSS
- 支持 HTML 入口点（Deno 2.5 及以上）
- 可选的代码压缩（`--minify`）和源码映射（`--sourcemap`）
- 代码拆分
- 平台目标设置（`--platform`，支持 Deno 和浏览器）
- 配置时支持 JSX

## 基本示例

```ts title="main.ts"
import chalk from "npm:chalk";

console.log(chalk.red("Hello from `deno bundle`!"));
```

```bash
$ deno bundle main.ts > bundle.js

# 或者显式指定输出文件：

$ deno bundle -o bundle.js main.ts
```

以上命令会生成一个包含所有依赖的单一 `bundle.js` 文件，成为一个自包含的应用文件：

```bash
$ deno bundle.js
Hello from `deno bundle`!
```

你可以在打包文件中使用 JSR、npm、http(s) 以及本地导入，
`deno bundle` 会负责收集所有源文件并生成单个输出文件。

## 选项概览

| 标志                     | 描述                                                  |
| ----------------------- | ---------------------------------------------------- |
| `-o`, `--output <file>` | 将打包输出写入文件                                   |
| `--outdir <dir>`        | 将打包输出写入指定目录                               |
| `--minify`              | 进行生产环境代码压缩                                 |
| `--format <format>`     | 输出格式（默认 `esm`）                               |
| `--code-splitting`      | 启用代码拆分                                        |
| `--platform <platform>` | 为 `browser` 或 `deno` 打包（默认: `deno`）         |
| `--sourcemap`           | 包含源码映射（支持 `linked`、`inline`、`external`） |
| `--watch`               | 文件更改时自动重建                                  |
| `--inline-imports`      | 内联导入模块（`true` 或 `false`）                    |

---

## 运行时 API

除了命令行工具外，您还可以使用 `Deno.bundle()` 来以编程方式打包您的 JavaScript 或 TypeScript 文件。这使得您能够将打包过程集成到构建流程和工作流中。

:::note

该 API 从 Deno v2.5 开始提供，属于实验性功能，使用时必须添加 `--unstable-bundle` 标志。

:::

### 基本用法

```ts
const result = await Deno.bundle({
  entrypoints: ["./index.tsx"],
  outputDir: "dist",
  platform: "browser",
  minify: true,
});
console.log(result);
```

### 在内存中处理输出

你也可以选择不将输出写入磁盘，而是在内存中处理打包结果：

```ts
const result = await Deno.bundle({
  entrypoints: ["./index.tsx"],
  output: "dist",
  platform: "browser",
  minify: true,
  write: false,
});

for (const file of result.outputFiles!) {
  console.log(file.text());
}
```

这种方式为将打包过程集成到各种工作流中提供了更大灵活性，比如直接从内存中提供打包文件，或对输出执行额外处理。

---

## 支持 HTML 入口点

从 Deno 2.5 起，`deno bundle` 支持以 HTML 文件作为入口点。之前仅支持 `.js`、`.ts`、`.jsx` 和 `.tsx` 文件作为入口点。

```bash
deno bundle --outdir dist index.html
```

当你使用 HTML 文件作为入口点时，`deno bundle` 会：

1. 查找 HTML 文件中的所有脚本引用
2. 打包这些脚本及其依赖
3. 更新 HTML 文件中的路径指向打包后的脚本文件
4. 打包并注入所有导入的 CSS 文件到 HTML 输出中

### 示例

假设有如下 `index.tsx` 文件：

```tsx title="index.tsx"
import { render } from "npm:preact";
import "./styles.css";

const app = (
  <div>
    <p>Hello World!</p>
  </div>
);

render(app, document.body);
```

以及一个引用该文件的 HTML 文件：

```html title="index.html"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example</title>
    <script src="./index.tsx" type="module"></script>
  </head>
</html>
```

执行 `deno bundle --outdir dist index.html` 后输出：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Example</title>
    <script src="./index-2TFDJWLF.js" type="module" crossorigin></script>
    <link rel="stylesheet" crossorigin href="./index-EWSJYQGA.css">
  </head>
</html>
```

打包输出文件名包含基于内容的哈希，用于缓存破坏和指纹识别。

HTML 入口点在以上命令行工具和运行时 API 中均得到完整支持。

### 何时使用 HTML 打包

- **`deno bundle index.html`** — 非常适合对小型静态应用进行快速打包构建
- **Vite** — 适合需要更复杂生态支持的项目

两种方式在 Deno 上均可无缝使用，您可以根据工作流选择适合的方案。

---

## 为网页打包 React 页面

从 `app.jsx` 和 `index.html` 文件开始：

```jsx
import React from "npm:react";
import { createRoot } from "npm:react-dom/client";

function App() {
  return <h1>Hello, React!</h1>;
}

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

```html
<!DOCTYPE html>
<html lang="en">
  <body>
    <div id="root"></div>
    <script type="module" src="/bundle.js"></script>
  </body>
</html>
```

现在，我们开始打包：

```bash
$ deno bundle --platform=browser app.jsx -o bundle.js
⚠️ deno bundle 是实验性功能，可能会发生变化
Bundled 9 modules in 99ms
  app.bundle.js 874.67KB
```

至此，我们准备好提供页面服务，使用
[`@std/http/file-server` 来自 JSR](https://jsr.io/@std/http/file-server) 进行服务：

```bash
$ deno run -ENR jsr:@std/http/file-server
Listening on http://127.0.0.1:8000
```

在浏览器中访问页面应显示：

![Image of serving bundled React app](./images/bundled_react.png)

---

# deno add

> Add and manage project dependencies with Deno.

URL: https://docs.deno.com/runtime/reference/cli/add



---

# `deno bench`，基准测试工具

> 使用 Deno 内置的 bench 工具运行基准测试。

URL: https://docs.deno.com/runtime/reference/cli/bench


## 快速开始

首先，创建一个文件 `url_bench.ts` 并使用 `Deno.bench()` 函数注册一个基准测试。

```ts
// url_bench.ts
Deno.bench("URL 解析", () => {
  new URL("https://deno.land");
});
```

其次，使用 `deno bench` 子命令运行基准测试。

```shell
$ deno bench url_bench.ts
Check file:///path/to/url_bench.ts
    CPU | 12th Gen Intel(R) Core(TM) i3-12100
Runtime | Deno 2.4.2 (x86_64-unknown-linux-gnu)

file:///path/to/url_bench.ts

| benchmark     | time/iter (avg) |        iter/s |      (min … max)      |      p75 |      p99 |     p995 |
| ------------- | --------------- | ------------- | --------------------- | -------- | -------- | -------- |
| URL parsing   |        345.8 ns |     2,892,000 | (325.4 ns … 497.2 ns) | 346.9 ns | 443.2 ns | 497.2 ns |
```

## 编写基准测试

要定义一个基准测试，你需要通过调用 `Deno.bench` API 来注册它。这个 API 有多个重载，可以提供最大的灵活性，并在不同形式之间轻松切换（例如，当需要快速关注单个基准进行调试时，使用 `only: true` 选项）：

```ts
// 紧凑形式：名称和函数
Deno.bench("你好，世界 #1", () => {
  new URL("https://deno.land");
});

// 紧凑形式：命名函数。
Deno.bench(function helloWorld3() {
  new URL("https://deno.land");
});

// 较长形式：基准定义。
Deno.bench({
  name: "你好，世界 #2",
  fn: () => {
    new URL("https://deno.land");
  },
});

// 与紧凑形式相似，第二个参数是额外配置。
Deno.bench("你好，世界 #4", { permissions: { read: true } }, () => {
  new URL("https://deno.land");
});

// 与较长形式相似，第二个参数是基准函数。
Deno.bench(
  { name: "你好，世界 #5", permissions: { read: true } },
  () => {
    new URL("https://deno.land");
  },
);

// 与较长形式相似，第二个参数是命名基准函数。
Deno.bench({ permissions: { read: true } }, function helloWorld6() {
  new URL("https://deno.land");
});
```

### 异步函数

你还可以通过传递一个返回 Promise 的基准函数来基准化异步代码。为此，可以在定义函数时使用 `async` 关键字：

```ts
Deno.bench("异步你好，世界", async () => {
  await 1;
});
```

### 关键部分

有时基准测试用例需要包括设置和拆卸代码，这可能会影响基准结果。例如，如果你想测量读取小文件的时间，你需要打开文件、读取它，然后关闭它。如果文件足够小，打开和关闭文件所需的时间可能会超过读取文件本身所需的时间。

为帮助处理此类情况，你可以使用 `Deno.BenchContext.start` 和 `Deno.BenchContext.end` 来告诉基准测试工具你想要测量的关键部分。在这两个调用之间的所有部分将被排除在测量之外。

```ts
Deno.bench("foo", async (b) => {
  // 打开一个我们将要操作的文件。
  using file = await Deno.open("a_big_data_file.txt");

  // 告诉基准测试工具这是你想测量的唯一部分。
  b.start();

  // 现在让我们测量从文件中读取所有数据需要多长时间。
  await new Response(file.readable).arrayBuffer();

  // 在这里结束测量。
  b.end();
});
```

上述示例需要 `--allow-read` 标志来运行基准测试：
`deno bench --allow-read file_reading.ts`。

## 分组与基准线

在注册基准测试用例时，可以使用 `Deno.BenchDefinition.group` 选项将其分配到一个组中：

```ts
// url_bench.ts
Deno.bench("url 解析", { group: "url" }, () => {
  new URL("https://deno.land");
});
```

将多个用例分配到单个组中并比较它们的表现相对于“基准线”用例是非常有用的。

在这个示例中，我们将检查 `Date.now()` 相对于 `performance.now()` 的性能如何，为此，我们将第一个用例标记为“基准线”，使用 `Deno.BenchDefinition.baseline` 选项：

```ts
// time_bench.ts
Deno.bench("Date.now()", { group: "timing", baseline: true }, () => {
  Date.now();
});

Deno.bench("performance.now()", { group: "timing" }, () => {
  performance.now();
});
```

```shell
$ deno bench time_bench.ts
    CPU | 12th Gen Intel(R) Core(TM) i3-12100
Runtime | Deno 2.4.2 (x86_64-unknown-linux-gnu)

file:///path/to/time_bench.ts

| benchmark           | time/iter (avg) |        iter/s |      (min … max)      |      p75 |      p99 |     p995 |
| ------------------- | --------------- | ------------- | --------------------- | -------- | -------- | -------- |

group timing
| Date.now()          |         44.2 ns |    22,630,000 | ( 42.3 ns …  73.4 ns) |  44.0 ns |  54.1 ns |  55.1 ns |
| performance.now()   |         59.9 ns |    16,700,000 | ( 56.0 ns …  94.8 ns) |  60.7 ns |  76.6 ns |  79.5 ns |

summary
  Date.now()
     1.35x faster than performance.now()
```

你可以在同一个文件中指定多个组。

## 运行基准测试

要运行基准测试，请使用包含基准函数的文件作为参数调用 `deno bench`。你也可以省略文件名，这时会运行当前目录（递归）下所有匹配通配符 `{*_,*.,}bench.{ts, tsx, mts, js, mjs, jsx}` 的基准测试。如果你传入一个目录，则该目录中所有匹配该通配符的文件都会被运行。

该通配符匹配：

- 名称为 `bench.{ts, tsx, mts, js, mjs, jsx}` 的文件，
- 或以 `.bench.{ts, tsx, mts, js, mjs, jsx}` 结尾的文件，
- 或以 `_bench.{ts, tsx, mts, js, mjs, jsx}` 结尾的文件

```bash
# 运行当前目录及所有子目录中的所有基准测试
deno bench

# 运行 util 目录中的所有基准测试
deno bench util/

# 仅运行 my_bench.ts
deno bench my_bench.ts
```

> ⚠️ 如果你想向基准测试文件传递其他 CLI 参数，请使用 `--` 来告知 Deno 剩余的参数是脚本参数。

```bash
# 向基准测试文件传递额外参数
deno bench my_bench.ts -- -e --foo --bar
```

`deno bench` 使用与 `deno run` 相同的权限模型，例如，在基准测试期间写入文件系统时，将需要 `--allow-write`。

要查看与 `deno bench` 相关的所有运行时选项，可以参考命令行帮助：

```bash
deno help bench
```

## 过滤

有多种方式可以过滤你正在运行的基准测试。

### 命令行过滤

基准测试可以单独运行或按组运行，通过命令行的 `--filter` 选项实现。

`--filter` 接受字符串或模式作为值。

假设有以下基准测试：

```ts
Deno.bench({
  name: "my-bench",
  fn: () => {/* 基准函数零 */},
});
Deno.bench({
  name: "bench-1",
  fn: () => {/* 基准函数一 */},
});
Deno.bench({
  name: "bench2",
  fn: () => {/* 基准函数二 */},
});
```

此命令将运行所有这些基准测试，因为它们都包含单词“bench”。

```bash
deno bench --filter "bench" benchmarks/
```

反之，以下命令使用模式，会运行第二个和第三个基准测试。

```bash
deno bench --filter "/bench-*\d/" benchmarks/
```

_为了让 Deno 知道你想使用正则表达式模式，请用斜杠将你的过滤器括起来，就像 JavaScript 的正则表达式字面量语法一样。_

### 基准定义过滤

在基准测试本身内，有两种过滤选项。

#### 过滤掉（忽略这些基准测试）

有时你想根据某种条件跳过基准测试（例如，只想在 Windows 上运行基准）。为此，可以在基准定义中设置 `ignore` 布尔值。如果为 true，该基准测试将被跳过。

```ts
Deno.bench({
  name: "基准 Windows 特性",
  ignore: Deno.build.os !== "windows",
  fn() {
    // 执行 Windows 特性
  },
});
```

#### 过滤进（仅运行这些基准测试）

有时你可能遇到性能问题，只想聚焦于单个基准测试，暂时忽略其余基准。为此，可以使用 `only` 选项，让基准测试工具仅运行设置为 true 的基准。多个基准可以设置此选项。虽然基准测试运行会报告每个基准的成功或失败，但如果任何基准标记为 `only`，则整体基准测试运行将始终以失败告终，因为这是一个临时措施，几乎禁用所有其他基准测试。

```ts
Deno.bench({
  name: "仅关注此基准",
  only: true,
  fn() {
    // 基准复杂内容
  },
});
```

## JSON 输出

要以 JSON 格式检索输出，请使用 `--json` 标志：

```shell
$ deno bench my_bench.ts --json
{
  "version": 1,
  "runtime": "Deno/2.4.2 x86_64-unknown-linux-gnu",
  "cpu": "12th Gen Intel(R) Core(TM) i3-12100",
  "benches": [
    {
      "origin": "file:///path/to/my_bench.ts",
      "group": null,
      "name": "Test",
      "baseline": false,
      "results": [
        {
          "ok": {
            "n": 51,
            "min": 946.7129,
            "max": 3024.3281,
            "avg": 1241.3926823529412,
            "p75": 1174.9718,
            "p99": 3024.3281,
            "p995": 3024.3281,
            "p999": 3024.3281,
            "highPrecision": false,
            "usedExplicitTimers": false
          }
        }
      ]
    }
  ]
}
```

---

# runtime/reference/cli/bundle.md

URL: https://docs.deno.com/runtime/reference/cli/bundle

---
title: "捆绑器"
oldUrl: /runtime/manual/cli/bundler/
command: bundle
openGraphLayout: "/open_graph/cli-commands.jsx"
openGraphTitle: "deno bundle"
info: "`deno bundle` 目前是一个实验性子命令，可能会有所更改。"
---

---

# deno check

> Download and type-check code without execution

URL: https://docs.deno.com/runtime/reference/cli/check


## 示例

进行类型检查而不执行。

```ts title="example.ts"
const x: string = 1 + 1n;
```

```bash
deno check example.ts
```

---

# deno clean

> Remove cached dependencies for a clean start

URL: https://docs.deno.com/runtime/reference/cli/clean



---

# `deno compile`，独立可执行文件

> Compile your code into a standalone executable

URL: https://docs.deno.com/runtime/reference/cli/compile


## 标志

与 [`deno install`](/runtime/reference/cli/install/) 一样，执行脚本时使用的运行时标志必须在编译时指定。这包括权限标志。

```sh
deno compile --allow-read --allow-net jsr:@std/http/file-server
```

[脚本参数](/runtime/getting_started/command_line_interface/#passing-script-arguments) 可以部分嵌入。

```console
deno compile --allow-read --allow-net jsr:@std/http/file-server -p 8080

./file_server --help
```

## 交叉编译

您可以使用 `--target` 标志为其他平台进行交叉编译二进制文件。

```
# 为 Apple Silicon 进行交叉编译
deno compile --target aarch64-apple-darwin main.ts

# 为 Windows 进行交叉编译并添加图标
deno compile --target x86_64-pc-windows-msvc --icon ./icon.ico main.ts
```

### 支持的目标

Deno 支持针对所有目标的交叉编译，而不管主机平台。

| 操作系统 | 架构      | 目标                          |
| -------- | --------- | ----------------------------- |
| Windows  | x86_64    | `x86_64-pc-windows-msvc`      |
| macOS    | x86_64    | `x86_64-apple-darwin`         |
| macOS    | ARM64     | `aarch64-apple-darwin`        |
| Linux    | x86_64    | `x86_64-unknown-linux-gnu`    |
| Linux    | ARM64     | `aarch64-unknown-linux-gnu`   |

## 图标

可以通过在目标为 Windows 时使用 `--icon` 标志来为可执行文件添加图标。图标必须为 `.ico` 格式。

```
deno compile --icon icon.ico main.ts

# 带有图标的交叉编译
deno compile --target x86_64-pc-windows-msvc --icon ./icon.ico main.ts
```

## 动态导入

默认情况下，可静态分析的动态导入（在 `import("...")` 调用表达式中包含字符串字面量的导入）会被包含在输出中。

```ts
// calculator.ts 及其依赖将包含在二进制文件中
const calculator = await import("./calculator.ts");
```

但不可静态分析的动态导入则不会：

```ts
const specifier = condition ? "./calc.ts" : "./better_calc.ts";
const calculator = await import(specifier);
```

要包含不可静态分析的动态导入，请指定 `--include <path>` 标志。

```shell
deno compile --include calc.ts --include better_calc.ts main.ts
```

## 包含数据文件或目录

从 Deno 2.1 开始，您可以通过 `--include <path>` 标志在可执行文件中包含文件或目录。

```shell
deno compile --include names.csv --include data main.ts
```

然后通过 `import.meta.dirname` 相对于当前模块的目录路径读取文件：

```ts
// main.ts
const names = Deno.readTextFileSync(import.meta.dirname + "/names.csv");
const dataFiles = Deno.readDirSync(import.meta.dirname + "/data");

// 在这里使用 names 和 dataFiles
```

请注意，这目前仅适用于文件系统上的文件，不适用于远程文件。

## Worker

与不可静态分析的动态导入类似，默认情况下，`[workers](../web_platform_apis/#web-workers)` 的代码不会包含在编译后的可执行文件中。有两种方法可以包含 workers：

1. 使用 `--include <path>` 标志包含工作代码。

```shell
deno compile --include worker.ts main.ts
```

2. 使用可静态分析的导入导入工作模块。

```ts
// main.ts
import "./worker.ts";
```

```shell
deno compile main.ts
```

## 代码签名

### macOS

默认情况下，在 macOS 上，编译后的可执行文件将使用临时签名签名，等同于运行 `codesign -s -`：

```shell
$ deno compile -o main main.ts
$ codesign --verify -vv ./main

./main: 磁盘上的有效
./main: 满足其指定要求
```

您可以在对可执行文件进行代码签名时指定签名身份，就像您对任何其他 macOS 可执行文件所做的那样：

```shell
codesign -s "Developer ID Application: Your Name" ./main
```

有关 macOS 上代码签名和公证的更多信息，请参考 [官方文档](https://developer.apple.com/documentation/security/notarizing-macos-software-before-distribution)。

### Windows

在 Windows 上，可以使用 `SignTool.exe` 工具对编译后的可执行文件进行签名。

```shell
$ deno compile -o main.exe main.ts
$ signtool sign /fd SHA256 main.exe
```

## 在可执行文件中不可用

- [Web 存储 API](/runtime/reference/web_platform_apis/#web-storage)
- [Web 缓存](/api/web/~/Cache)


---

# deno completions

> Generate shell completions for Deno

URL: https://docs.deno.com/runtime/reference/cli/completions


您可以使用输出脚本来配置 `deno` 命令的自动补全。

例如：`deno un` -> <kbd>Tab</kbd> -> `deno uninstall`。

## 示例

### 配置 Bash shell 完成

```bash
deno completions bash > deno.bash

if [ -d "/usr/local/etc/bash_completion.d/" ]; then
  sudo mv deno.bash /usr/local/etc/bash_completion.d/
  source /usr/local/etc/bash_completion.d/deno.bash
elif [ -d "/usr/share/bash-completion/completions/" ]; then
  sudo mv deno.bash /usr/share/bash-completion/completions/
  source /usr/share/bash-completion/completions/deno.bash
else
  echo "Please move deno.bash to the appropriate bash completions directory"
fi
```

### 配置 PowerShell shell 完成

```bash
deno completions powershell | Out-String | Invoke-Expression
```

### 配置 zsh shell 完成

首先将以下内容添加到你的 `.zshrc` 文件中：

```bash
fpath=(~/.zsh/completion $fpath)
autoload -U compinit
compinit
```

然后运行以下命令：

```bash
deno completions zsh > _deno
mv _deno ~/.zsh/completion/_deno
autoload -U compinit && compinit
```

### 配置 fish shell 完成

```bash
deno completions fish > completions.fish
chmod +x ./completions.fish
```

---

# deno coverage

> Generate a coverage report for your code

URL: https://docs.deno.com/runtime/reference/cli/coverage


## 包含和排除

默认情况下，覆盖率包括您本地文件系统中存在的任何代码及其导入。

您可以通过使用 `--include` 和 `--exclude` 选项来自定义包含和排除。

您可以通过使用 `--include` 选项并自定义正则表达式模式来扩展覆盖率，以包括不在本地文件系统上的文件。

```bash
deno coverage --include="^file:|https:"
```

默认的包含模式应足以满足大多数用例，但您可以自定义它以更具体地指定哪些文件包含在您的覆盖率报告中。

文件名中包含 `test.js`、`test.ts`、`test.jsx` 或 `test.tsx` 的文件默认被排除。

这相当于：

```bash
deno coverage --exclude="test\.(js|mjs|ts|jsx|tsx)$"
```

此默认设置防止您的测试代码为您的覆盖率报告做出贡献。URL 要匹配，它必须与包含模式匹配，且不与排除模式匹配。

## 忽略代码

通过添加覆盖忽略注释，可以在生成的覆盖率报告中忽略代码。被忽略代码中的分支和行将被排除在报告之外。被忽略的分支和行不计算为覆盖行。相反，被忽略的代码行被视为空行。

要忽略整个文件，请在文件顶部添加 `// deno-coverage-ignore-file` 注释。

```ts
// deno-coverage-ignore-file

// 此文件中的所有代码被忽略
```

被忽略的文件将不会出现在覆盖率报告中。

要忽略单行，请在您想要忽略的代码上方添加 `// deno-coverage-ignore` 注释。

```ts
// deno-coverage-ignore
console.log("this line is ignored");
```

要忽略多行，请在要忽略的代码上方添加 `// deno-coverage-ignore-start` 注释，并在下方添加 `// deno-coverage-ignore-stop` 注释。

```ts
// deno-coverage-ignore-start
if (condition) {
  console.log("分支和行都被忽略");
}
// deno-coverage-ignore-stop
```

所有在 `// deno-coverage-ignore-start` 注释之后的代码会被忽略，直到 `// deno-coverage-ignore-stop` 被遇到。

每个 `// deno-coverage-ignore-start` 注释必须以 `// deno-coverage-ignore-stop` 注释结束，并且忽略的范围不能嵌套。

当这些要求没有满足时，某些行可能会在覆盖率报告中意外包含。`deno coverage` 命令会对任何无效注释记录警告。

```ts
// deno-coverage-ignore-start
if (condition) {
  // deno-coverage-ignore-start - A warning will be logged because the previous
  //                              coverage range is unterminated.
  console.log("this code is ignored");
  // deno-coverage-ignore-stop
}
// deno-coverage-ignore-stop

// ...

// deno-coverage-ignore-start - This comment will be ignored and a warning will
//                              be logged, because this range is unterminated.
console.log("this code is not ignored");
```

在覆盖注释中，只有空格可以位于覆盖指令之前。然而，任何文本可以跟随该指令。

```ts
// deno-coverage-ignore Trailing text is allowed.
console.log("This line is ignored");

// But leading text isn't. deno-coverage-ignore
console.log("This line is not ignored");
```

覆盖注释必须以 `//` 开头。以 `/*` 开头的注释不是有效的覆盖注释。

```ts
// deno-coverage-ignore
console.log("This line is ignored");

/* deno-coverage-ignore */
console.log("This line is not ignored");
```

## 输出格式

默认情况下，我们支持 Deno 自己的覆盖率格式 - 但您也可以输出覆盖率报告为 [lcov 格式](https://github.com/linux-test-project/lcov?tab=readme-ov-file)（一种用于描述代码覆盖率数据的标准文件格式），或以 html 格式。

```bash
deno coverage --lcov --output=cov.lcov
```

此 lcov 文件可与支持 lcov 格式的其他工具一起使用。

```bash
deno coverage --html
```

这将输出一个覆盖率报告作为 html 文件。

## 示例

从工作区的默认覆盖配置生成覆盖率报告。

```bash
deno test --coverage
deno coverage
```

从具有自定义名称的覆盖配置生成覆盖率报告。

```bash
deno test --coverage=custom_profile_name
deno coverage custom_profile_name
```

> 注意：您也可以通过 `DENO_COVERAGE_DIR` 环境变量设置覆盖目录。
>
> ```
> DENO_COVERAGE_DIR=custom_profile_name deno test
> deno coverage custom_profile_name
> ```


仅包括匹配特定模式的覆盖率 - 在这种情况下，仅包括 main.ts 的测试。

```bash
deno coverage --include="main.ts"
```

将默认覆盖配置中的测试覆盖率导出到 lcov 文件。

```bash
deno test --coverage
deno coverage --lcov --output=cov.lcov
```

---

# deno deploy

> Manage and publish your projects on the web

URL: https://docs.deno.com/runtime/reference/cli/deploy


The `deno deploy` command provides a command line interface for managing and
deploying applications to [Deno Deploy EA](https://deno.com/deploy), Deno's
platform for hosting JavaScript, TypeScript, and WebAssembly applications.

When called without any subcommands, `deno deploy` will deploy your local
directory to the specified application.

## Authentication

The deploy command uses secure token-based authentication stored in your
system's keyring:

- **Automatic Authentication**: The CLI will prompt for authentication when
  needed
- **Token Storage**: Deploy tokens are securely stored using the system keyring
- **Token Management**: The CLI provides operations to get, set, and delete
  authentication tokens.

## Global options

- `-h, --help` - Show help information
- `--org <name>` - Specify the organization name
- `--app <name>` - Specify the application name
- `--prod` - Deploy directly to production

## Subcommands

### Create application

Creates a new application in Deno Deploy.

```bash
deno deploy create [root-path]
```

**Options:**

- `-h, --help` - Show help information
- `--org <name>` - The name of the organization to create the application for

```bash
deno deploy create --org my-organization
```

### Environment variables management

Manage environment variables for your deployed applications.

```bash
deno deploy env
```

**Options:**

- `-h, --help` - Show help information
- `--org <name>` - The name of the organization
- `--app <name>` - The name of the application

#### List environment variables

```bash
deno deploy env list
```

Lists all environment variables in an application.

#### Add environment variable

```bash
deno deploy env add <variable> <value>
```

Adds an environment variable to the application.

```bash
deno deploy env add DATABASE_URL "postgresql://user:pass@localhost/db"
```

#### Update environment variable value

```bash
deno deploy env update-value <variable> <value>
```

Updates the value of an existing environment variable.

```bash
deno deploy env update-value API_KEY "new-api-key-value"
```

#### Specifying environment variable contexts

Environment variables can be made available to specific contexts such as
Production, Preview, Local, and Build.

```bash
deno deploy env update-contexts <variable> [contexts...]
```

Updates the contexts of an environment variable in the application:

#### Delete environment variable

```bash
deno deploy env delete <variable>
```

Deletes an environment variable from the application.

```bash
deno deploy env delete OLD_API_KEY
```

#### Load environment variables from file

```bash
deno deploy env load <file>
```

Loads environment variables from a `.env` file into the application.

```bash
deno deploy env load .env.production
```

### Application logs

Stream logs from a deployed application.

```bash
deno deploy logs
```

**Options:**

- `-h, --help` - Show help information
- `--org <name>` - The name of the organization
- `--app <name>` - The name of the application
- `--start <date>` - The starting timestamp of the logs
- `--end <date>` - The ending timestamp of the logs (requires --start)

```bash
deno deploy logs --org my-org --app my-app --start "2024-01-01T00:00:00Z"
```

### Configure cloud connections

The `deploy` command includes tools to help you configure integrations for use
as [Cloud Connections](/deploy/early-access/reference/cloud-connections/) in
your applications.

#### AWS integration setup

[Configure AWS integration](/deploy/early-access/reference/cloud-connections/#aws%3A-easy-setup-with-deno-deploy-setup-aws)
for use as a Cloud Connection in your application.

```bash
deno deploy setup-aws --org <name> --app <name>
```

**Options:**

- `-h, --help` - Show help information
- `--org <name>` - The name of the organization (required)
- `--app <name>` - The name of the application (required)

```bash
deno deploy setup-aws --org my-org --app my-app
```

### Google Cloud Platform integration setup

[Configure Google Cloud Platform integration](/deploy/early-access/reference/cloud-connections/#setting-up-gcp)
for use as a Cloud Connection in your application.

```bash
deno deploy setup-gcp --org <name> --app <name>
```

**Options:**

- `-h, --help` - Show help information
- `--org <name>` - The name of the organization (required)
- `--app <name>` - The name of the application (required)

```bash
deno deploy setup-gcp --org my-org --app my-app
```

## Usage examples

### Basic deployment

```bash
# Deploy current directory to production
deno deploy --prod

# Deploy with specific org and app
deno deploy --org my-company --app my-api --prod
```

### Environment setup

```bash
# Create a new application
deno deploy create --org my-company

# Set up environment variables
deno deploy env add DATABASE_URL "postgresql://..."
deno deploy env add API_KEY "your-api-key"

# Load from .env file
deno deploy env load .env.production
```

### Monitoring

```bash
# View recent logs
deno deploy logs --org my-company --app my-api

# View logs for specific time range
deno deploy logs --org my-company --app my-api \
  --start "2024-01-01T00:00:00Z" \
  --end "2024-01-01T23:59:59Z"
```

### Cloud integration

```bash
# Set up AWS integration
deno deploy setup-aws --org my-company --app my-api

# Set up GCP integration
deno deploy setup-gcp --org my-company --app my-api
```

## Getting help

- Use `deno deploy --help` for general help
- Use `deno deploy <subcommand> --help` for specific subcommand help
- Check the
  [Deno Deploy EA documentation](https://docs.deno.com/deploy/early-access/) for
  platform-specific information


---

# `deno doc`, 文档生成器

> Generate documentation from your code

URL: https://docs.deno.com/runtime/reference/cli/doc


## 示例

`deno doc` 后接一个或多个源文件的列表，将打印该模块的 **导出** 成员的 JSDoc 文档。

例如，给定一个文件 `add.ts`，其内容为：

```ts
/**
 * 将 x 和 y 相加。
 * @param {number} x
 * @param {number} y
 * @returns {number} x 和 y 的和
 */
export function add(x: number, y: number): number {
  return x + y;
}
```

运行 Deno 的 `doc` 命令，将函数的 JSDoc 注释输出到 `stdout`：

```shell
deno doc add.ts
function add(x: number, y: number): number
  将 x 和 y 相加。 @param {number} x @param {number} y @returns {number} x 和 y 的和
```

## 检查

您可以使用 `--lint` 标志在生成文档时检查文档中的问题。`deno doc` 将指出三种类型的问题：

1. 从根模块导出的类型引用未导出的类型的错误。
   - 确保 API 使用者可以访问 API 使用的所有类型。如果根模块（在命令行中指定给 `deno doc` 的文件之一）导出了该类型，或者使用 `@internal` jsdoc 标签标记该类型，可以抑制此警告。
2. **公共** 类型上缺少返回类型或属性类型的错误。
   - 确保 `deno doc` 显示返回/属性类型，并帮助提高类型检查性能。
3. **公共** 类型上缺少 JS 文档注释的错误。
   - 确保代码得到了文档。如果添加 jsdoc 注释，或者通过 `@ignore` jsdoc 标签将其排除在文档之外，可以抑制此警告。或者，添加 `@internal` 标签以将其保留在文档中，但表示它是内部的。

例如：

```ts title="/mod.ts"
interface Person {
  name: string;
  // ...
}

export function getName(person: Person) {
  return person.name;
}
```

```shell
$ deno doc --lint mod.ts
类型 'getName' 引用了未从根模块导出的类型 'Person'。
缺少 JS 文档注释。
缺少返回类型。
    at file:///mod.ts:6:1
```

这些检查旨在帮助您编写更好的文档，并加速项目中的类型检查。如果发现任何问题，程序将以非零退出代码退出，输出将报告到标准错误。

## 支持的 JSDoc 特性和标签

Deno 实现了一大套 JSDoc 标签，但并不严格遵循 JSDoc 标准，而是与同一特性空间中广泛使用的工具和生态系统提供的合理标准和特性保持一致，如 [TSDoc](https://tsdoc.org/) 和 [TypeDoc](https://typedoc.org/)。

对于任何自由文本的地方，即 JSDoc 评论的主描述、参数的描述等，接受 markdown。

### 支持的标签

以下标签是支持的，是 JSDoc、TSDoc 和 TypeDoc 使用和指定的标签的选择：

- [`constructor`/`class`](https://jsdoc.app/tags-class): 标记一个函数为构造函数。
- [`ignore`](https://jsdoc.app/tags-ignore): 忽略一个符号以从输出中包含。
- internal: 将符号标记为仅用于内部。在 HTML 生成器中，该符号不会得到列出的条目，但它仍然会被生成，并且可以通过非内部符号链接到它。
- [`public`](https://jsdoc.app/tags-public): 将符号视为公共 API。相当于 TypeScript 的 `public` 关键字。
- [`private`](https://jsdoc.app/tags-private): 将符号视为私有 API。相当于 TypeScript 的 `private` 关键字。
- [`protected`](https://jsdoc.app/tags-protected): 将属性或方法视为受保护的 API。相当于 TypeScript 的 `protected` 关键字。
- [`readonly`](https://jsdoc.app/tags-readonly): 将符号标记为只读，意味着它不能被重写。
- [`experimental`](https://tsdoc.org/pages/tags/experimental): 将符号标记为实验性，意味着 API 可能会更改或被删除，或行为不明确。
- [`deprecated`](https://jsdoc.app/tags-deprecated): 将符号标记为不推荐使用，意味着不再支持，并可能在未来版本中被移除。
- [`module`](https://jsdoc.app/tags-module): 此标签可以在顶级 JSDoc 注释中定义，将使该注释用于该文件而不是后续符号。可以指定一个值，该值将用作模块的标识符（即用于默认导出）。
- `category`/`group`: 将符号标记为特定的类别/组。这对于将各种符号归类在一起非常有用。
- [`see`](https://jsdoc.app/tags-see): 定义与符号相关的外部参考。
- [`example`](https://jsdoc.app/tags-example): 为符号定义一个示例。与 JSDoc 不同，代码示例需要用三个反引号（markdown 风格代码块）包裹，这更符合 TSDoc 而非 JSDoc。
- `tags`: 为符号定义额外的自定义标签，通过逗号分隔的列表。
- [`since`](https://jsdoc.app/tags-since): 定义该符号从何时可用。
- [`callback`](https://jsdoc.app/tags-callback): 定义一个回调。
- [`template`/`typeparam`/`typeParam`](https://tsdoc.org/pages/tags/typeparam): 定义一个通用参数。
- [`prop`/`property`](https://jsdoc.app/tags-property): 在符号上定义一个属性。
- [`typedef`](https://jsdoc.app/tags-typedef): 定义一种类型。
- [`param`/`arg`/`argument`](https://jsdoc.app/tags-param): 在函数上定义一个参数。
- [`return`/`returns`](https://jsdoc.app/tags-returns): 定义函数的返回类型和/或注释。
- [`throws`/`exception`](https://jsdoc.app/tags-throws): 定义当调用函数时会抛出的内容。
- [`enum`](https://jsdoc.app/tags-enum): 将对象定义为枚举。
- [`extends`/`augments`](https://jsdoc.app/tags-augments): 定义一个函数扩展的类型。
- [`this`](https://jsdoc.app/tags-this): 定义函数中 `this` 关键字所指的内容。
- [`type`](https://jsdoc.app/tags-type): 定义符号的类型。
- [`default`](https://jsdoc.app/tags-default): 定义变量、属性或字段的默认值。

### 内联链接

内联链接允许您指定指向页面其他部分、其他符号或模块的链接。除了支持 markdown 风格的链接外，
还支持 [JSDoc 风格的内联链接](https://jsdoc.app/tags-inline-link)。

例如，您可以这样做 `{@link https://docs.deno.com}`，其将渲染为以下 'https://docs.deno.com'。也可以使用 `{@linkcode https://docs.deno.com}`，以便使用等宽字体渲染，大致渲染为： '`https://docs.deno.com`'。

您还可以通过 `{@link https://docs.deno.com | Deno Docs}` 指定替换标签，这将使用 `|` 后的文本作为要显示的文本，而不是链接。前面的示例将渲染为 '[Deno Docs](https://docs.deno.com)'。

您可以在描述中添加指向其他符号的内联链接，例如 `{@link MySymbol}`。

对于模块链接，同样适用，但您使用 `{@link [myModule]}` 语法。您还可以通过 `{@link [myModule].mysymbol}` 链接到不同模块中的符号。

## HTML 输出

使用 `--html` 标志生成带有文档的静态站点。

```console
$ deno doc --html --name="我的库" ./mod.ts

$ deno doc --html --name="我的库" --output=./documentation/ ./mod.ts

$ deno doc --html --name="我的库" ./sub1/mod.ts ./sub2/mod.ts
```

生成的文档是一个静态网站，包含多个页面，可以部署到任何静态网站托管服务。

生成的网站中包含客户端搜索，但如果用户的浏览器禁用了 JavaScript，则不可用。

## JSON 输出

使用 `--json` 标志将文档以 JSON 格式输出。此 JSON 格式由
[deno doc 网站](https://github.com/denoland/docland) 消费，并用于生成模块文档。

---

# 配置 Deno 行为

URL: https://docs.deno.com/runtime/reference/cli/env_variables


有几个环境变量可以影响 Deno 的行为：

### DENO_AUTH_TOKENS

一个授权令牌的列表，可以用来允许 Deno 访问远程私有代码。有关更多详细信息，请参阅
[私有模块和仓库](/runtime/reference/private_repositories) 部分。

### DENO_TLS_CA_STORE

一系列在建立 TLS 连接时使用的证书存储。可用的存储有 `mozilla` 和 `system`。您可以指定一个、两个或都不指定。证书链的解析尝试按照您指定的顺序进行。默认值为 `mozilla`。`mozilla` 存储将使用由 [`webpki-roots`](https://crates.io/crates/webpki-roots) 提供的捆绑 Mozilla 证书。`system` 存储将使用您平台的
[本机证书存储](https://crates.io/crates/rustls-native-certs)。确切的 Mozilla 证书集将依赖于您使用的 Deno 版本。如果您不指定证书存储，则不会对任何 TLS 连接给予信任，除非同时指定 `DENO_CERT` 或 `--cert`，或者为每个 TLS 连接指定特定证书。

### DENO_CERT

从 PEM 编码文件加载证书颁发机构。这“覆盖”了 `--cert` 选项。有关更多信息，请参阅 [代理](#proxies) 部分。

### DENO_DIR

设置缓存 CLI 信息的目录。这包括诸如缓存的远程模块、缓存的转译模块、语言服务器缓存信息和来自本地存储的持久数据等项目。默认值为操作系统的默认缓存位置，然后在 `deno` 路径下。

### DENO_INSTALL_ROOT

当使用 `deno install` 时，已安装的脚本存储的位置。默认值为 `$HOME/.deno/bin`。

### DENO_NO_PACKAGE_JSON

设置以禁用 package.json 文件的自动解析。

### DENO_NO_PROMPT

设置以禁用访问时的权限提示（替代在调用中传递 `--no-prompt`）。

### DENO_NO_UPDATE_CHECK

设置以禁用检查是否有更新的 Deno 版本可用。

### DENO_WEBGPU_TRACE

用于 WebGPU 跟踪的目录。

### HTTP_PROXY

用于 HTTP 请求的代理地址。有关更多信息，请参阅 [代理](#proxies) 部分。

### HTTPS_PROXY

用于 HTTPS 请求的代理地址。有关更多信息，请参阅 [代理](#proxies) 部分。

### NO_COLOR

如果设置，此选项将阻止 Deno CLI 在写入 stdout 和 stderr 时发送 ANSI 颜色代码。有关此 _事实_ 标准的更多信息，请参见网站 [https://no-color.org](https://no-color.org/)。此标志的值可以在运行时访问，而无需读取环境变量的权限，方法是检查 `Deno.noColor` 的值。

### NO_PROXY

指示应绕过在其他环境变量中设置的代理的主机。有关更多信息，请参阅 [代理](#proxies) 部分。

### NPM_CONFIG_REGISTRY

在通过
[npm 说明符](/runtime/fundamentals/node/#using-npm-packages) 加载模块时使用的 npm 注册表。

## 代理

Deno 能够通过代理服务器处理网络请求，这在安全性、缓存或访问防火墙后面的资源等各种原因中非常有用。运行时支持模块下载和 Web 标准 `fetch` API 的代理。

Deno 从环境变量中读取代理配置：`HTTP_PROXY`、`HTTPS_PROXY` 和 `NO_PROXY`。

在 Windows 上，如果找不到环境变量，Deno 将回退到从注册表中读取代理设置。

---

# runtime/reference/cli/eval.md

URL: https://docs.deno.com/runtime/reference/cli/eval

---
title: "deno eval"
oldUrl: /runtime/manual/tools/eval/
command: eval
openGraphLayout: "/open_graph/cli-commands.jsx"
openGraphTitle: "deno eval"
description: "Evaluate JavaScript and TypeScript code in the command line"
---

---

# `deno fmt`, 代码格式化

> Format your code with Deno's built-in formatter

URL: https://docs.deno.com/runtime/reference/cli/fmt


## 支持的文件类型

Deno 带有内置的代码格式化工具，可以自动格式化以下文件：

<!-- 本列表需要与 https://github.com/denoland/deno/blob/main/cli/tools/fmt.rs 一起更新 -->

| 文件类型            | 扩展名                                              | 备注                                                                                          |
| -------------------- | -------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| JavaScript           | `.js`, `.cjs`, `.mjs`                              |                                                                                                |
| TypeScript           | `.ts`, `.mts`, `.cts`                              |                                                                                                |
| JSX                  | `.jsx`                                             |                                                                                                |
| TSX                  | `.tsx`                                             |                                                                                                |
| Markdown             | `.md`, `.mkd`, `.mkdn`, `.mdwn`, `.mdown`, `.markdown` |                                                                                                |
| JSON                 | `.json`                                            |                                                                                                |
| JSONC                | `.jsonc`                                           |                                                                                                |
| CSS                  | `.css`                                             |                                                                                                |
| HTML                 | `.html`                                            |                                                                                                |
| [Nunjucks][Nunjucks] | `.njk`                                           |                                                                                                |
| [Vento][Vento]       | `.vto`                                             |                                                                                                |
| YAML                 | `.yml`, `.yaml`                                    |                                                                                                |
| Sass                 | `.sass`                                           |                                                                                                |
| SCSS                 | `.scss`                                           |                                                                                                |
| LESS                 | `.less`                                           |                                                                                                |
| Jupyter Notebook     | `.ipynb`                                          |                                                                                                |
| Astro                | `.astro`                                           | 需要 `--unstable-component` 标志或 `"unstable": ["fmt-component"]` 配置选项。                  |
| Svelte               | `.svelte`                                          | 需要 `--unstable-component` 标志或 `"unstable": ["fmt-component"]` 配置选项。                  |
| Vue                  | `.vue`                                             | 需要 `--unstable-component` 标志或 `"unstable": ["fmt-component"]` 配置选项。                  |
| SQL                  | `.sql`                                            | 需要 `--unstable-sql` 标志或 `"unstable": ["fmt-sql"]` 配置选项。                            |

[Nunjucks]: https://mozilla.github.io/nunjucks/
[Vento]: https://github.com/ventojs/vento

:::note

**`deno fmt` 可以格式化 Markdown 文件中的代码块。** 代码块必须用三重反引号括起来，并具有语言属性。

:::

## 忽略代码

### JavaScript / TypeScript / JSONC

通过在代码前加上 `// deno-fmt-ignore` 注释来忽略格式化：

```ts
// deno-fmt-ignore
export const identity = [
    1, 0, 0,
    0, 1, 0,
    0, 0, 1,
];
```

或者在文件顶部添加 `// deno-fmt-ignore-file` 注释以忽略整个文件。

### Markdown / HTML / CSS

通过在接下来的项目前加上 `<!--- deno-fmt-ignore -->` 注释来忽略格式化：

```html
<html>
  <body>
    <p>
      Hello there
      <!-- deno-fmt-ignore -->
    </p>
  </body>
</html>
```

要忽略一段代码，将代码用 `<!-- deno-fmt-ignore-start -->` 和 `<!-- deno-fmt-ignore-end -->` 注释包围。

或者在文件顶部添加 `<!-- deno-fmt-ignore-file -->` 注释以忽略整个文件。

### YAML

通过在接下来的项目前加上 `# deno-fmt-ignore` 注释来忽略格式化：

```html
# deno-fmt-ignore aaaaaa: bbbbbbb
```
## 关于代码检查和格式化的更多信息

有关 Deno 中代码检查和格式化的更多信息，以及这两个工具之间的区别，请访问我们基础知识部分的 [代码检查和格式化](/runtime/fundamentals/linting_and_formatting/) 页面。

---

# Deno CLI 子命令

URL: https://docs.deno.com/runtime/reference/cli/


Deno CLI（命令行接口）允许你通过终端或命令提示符与 Deno 运行时环境进行交互。CLI 具有一些子命令，可以用于执行不同的任务，下面的链接提供有关每个子命令的更多信息。

## 执行

- [deno run](/runtime/reference/cli/run/) - 运行一个脚本
- [deno serve](/runtime/reference/cli/serve/) - 运行一个 web 服务器
- [deno task](/runtime/reference/cli/task/) - 运行一个任务
- [deno repl](/runtime/reference/cli/repl/) - 启动一个读取-评估-打印循环
- [deno eval](/runtime/reference/cli/eval/) - 评估提供的脚本

## 依赖管理

- [deno add](/runtime/reference/cli/add) - 添加依赖
- [deno install](/runtime/reference/cli/install/) - 安装依赖或脚本
- [deno uninstall](/runtime/reference/cli/uninstall/) - 卸载依赖或脚本
- [deno remove](/runtime/reference/cli/remove) - 移除依赖
- [deno outdated](/runtime/reference/cli/outdated) - 查看或更新过时的依赖

## 工具

- [deno bench](/runtime/reference/cli/bench/) - 基准测试工具
- [deno check](/runtime/reference/cli/check/) - 在不运行程序的情况下进行类型检查
- [deno compile](/runtime/reference/cli/compile/) - 将程序编译为独立的可执行文件
- [deno completions](/runtime/reference/cli/completions/) - 生成 shell 补全
- [deno coverage](/runtime/reference/cli/coverage/) - 生成测试覆盖率报告
- [deno doc](/runtime/reference/cli/doc/) - 为一个模块生成文档
- [deno deploy](/runtime/reference/cli/deploy) - 管理和发布您的项目到网络
- [deno fmt](/runtime/reference/cli/fmt/) - 格式化你的代码
- [deno info](/runtime/reference/cli/info/) - 检查一个 ES 模块及其所有依赖
- [deno init](/runtime/reference/cli/init/) - 创建一个新项目
- [deno jupyter](/runtime/reference/cli/jupyter/) - 运行 Jupyter 笔记本
- [deno lint](/runtime/reference/cli/lint/) - 代码检测
- [deno lsp](/runtime/reference/cli/lsp/) - 语言服务器协议集成
- [deno publish](/runtime/reference/cli/publish/) - 将模块发布到 JSR
- [deno test](/runtime/reference/cli/test/) - 运行你的测试
- [deno types](/runtime/reference/cli/types/) - 打印运行时类型
- [deno upgrade](/runtime/reference/cli/upgrade/) - 升级 Deno 到最新版本

## 其他

- [不稳定功能标志](/runtime/reference/cli/unstable_flags/)
- [集成 Deno LSP](/runtime/reference/lsp_integration/)

---

# `deno info`, 依赖检查器

> Inspect the dependencies of your project

URL: https://docs.deno.com/runtime/reference/cli/info


## 示例

```shell
$ deno info jsr:@std/http@1.0.0-rc.5/file-server
本地: /home/lucacasonato/.cache/deno/deps/https/jsr.io/3a0e5ef03d2090c75c81daf771ed9a73009518adfe688c333dc11d8006dc3598
输出: /home/lucacasonato/.cache/deno/gen/https/jsr.io/3a0e5ef03d2090c75c81daf771ed9a73009518adfe688c333dc11d8006dc3598.js
类型: TypeScript
依赖项: 40 个唯一
大小: 326.42KB

https://jsr.io/@std/http/1.0.0-rc.5/file_server.ts (24.74KB)
├─┬ https://jsr.io/@std/path/1.0.1/posix/join.ts (862B)
│ ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts (307B)
│ └─┬ https://jsr.io/@std/path/1.0.1/posix/normalize.ts (1.31KB)
│   ├─┬ https://jsr.io/@std/path/1.0.1/_common/normalize.ts (263B)
│   │ └── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│   ├─┬ https://jsr.io/@std/path/1.0.1/_common/normalize_string.ts (2.25KB)
│   │ └── https://jsr.io/@std/path/1.0.1/_common/constants.ts (1.97KB)
│   └─┬ https://jsr.io/@std/path/1.0.1/posix/_util.ts (391B)
│     └── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
├── https://jsr.io/@std/path/1.0.1/posix/normalize.ts *
├─┬ https://jsr.io/@std/path/1.0.1/extname.ts (906B)
│ ├── https://jsr.io/@std/path/1.0.1/_os.ts (736B)
│ ├─┬ https://jsr.io/@std/path/1.0.1/posix/extname.ts (2.28KB)
│ │ ├── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
│ │ ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│ │ └── https://jsr.io/@std/path/1.0.1/posix/_util.ts *
│ └─┬ https://jsr.io/@std/path/1.0.1/windows/extname.ts (2.5KB)
│   ├── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
│   ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│   └─┬ https://jsr.io/@std/path/1.0.1/windows/_util.ts (828B)
│     └── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
├─┬ https://jsr.io/@std/path/1.0.1/join.ts (926B)
│ ├── https://jsr.io/@std/path/1.0.1/_os.ts *
│ ├── https://jsr.io/@std/path/1.0.1/posix/join.ts *
│ └─┬ https://jsr.io/@std/path/1.0.1/windows/join.ts (2.41KB)
│   ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│   ├── https://jsr.io/@std/path/1.0.1/windows/_util.ts *
│   └─┬ https://jsr.io/@std/path/1.0.1/windows/normalize.ts (3.84KB)
│     ├── https://jsr.io/@std/path/1.0.1/_common/normalize.ts *
│     ├── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
│     ├── https://jsr.io/@std/path/1.0.1/_common/normalize_string.ts *
│     └── https://jsr.io/@std/path/1.0.1/windows/_util.ts *
├─┬ https://jsr.io/@std/path/1.0.1/relative.ts (1.08KB)
│ ├── https://jsr.io/@std/path/1.0.1/_os.ts *
│ ├─┬ https://jsr.io/@std/path/1.0.1/posix/relative.ts (3.25KB)
│ │ ├── https://jsr.io/@std/path/1.0.1/posix/_util.ts *
│ │ ├─┬ https://jsr.io/@std/path/1.0.1/posix/resolve.ts (1.84KB)
│ │ │ ├── https://jsr.io/@std/path/1.0.1/_common/normalize_string.ts *
│ │ │ ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│ │ │ └── https://jsr.io/@std/path/1.0.1/posix/_util.ts *
│ │ └─┬ https://jsr.io/@std/path/1.0.1/_common/relative.ts (287B)
│ │   └── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│ └─┬ https://jsr.io/@std/path/1.0.1/windows/relative.ts (4.24KB)
│   ├── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
│   ├─┬ https://jsr.io/@std/path/1.0.1/windows/resolve.ts (5.02KB)
│   │ ├── https://jsr.io/@std/path/1.0.1/_common/constants.ts *
│   │ ├── https://jsr.io/@std/path/1.0.1/_common/normalize_string.ts *
│   │ ├── https://jsr.io/@std/path/1.0.1/_common/assert_path.ts *
│   │ └── https://jsr.io/@std/path/1.0.1/windows/_util.ts *
│   └── https://jsr.io/@std/path/1.0.1/_common/relative.ts *
├─┬ https://jsr.io/@std/path/1.0.1/resolve.ts (1.02KB)
│ ├── https://jsr.io/@std/path/1.0.1/_os.ts *
│ ├── https://jsr.io/@std/path/1.0.1/posix/resolve.ts *
│ └── https://jsr.io/@std/path/1.0.1/windows/resolve.ts *
├─┬ https://jsr.io/@std/path/1.0.1/constants.ts (705B)
│ └── https://jsr.io/@std/path/1.0.1/_os.ts *
├─┬ https://jsr.io/@std/media-types/1.0.2/content_type.ts (3.09KB)
│ ├─┬ https://jsr.io/@std/media-types/1.0.2/parse_media_type.ts (3.54KB)
│ │ └── https://jsr.io/@std/media-types/1.0.2/_util.ts (3.18KB)
│ ├─┬ https://jsr.io/@std/media-types/1.0.2/get_charset.ts (1.45KB)
│ │ ├── https://jsr.io/@std/media-types/1.0.2/parse_media_type.ts *
│ │ ├── https://jsr.io/@std/media-types/1.0.2/_util.ts *
│ │ └─┬ https://jsr.io/@std/media-types/1.0.2/_db.ts (1.34KB)
│ │   ├── https://jsr.io/@std/media-types/1.0.2/vendor/db.ts (190.69KB)
│ │   └── https://jsr.io/@std/media-types/1.0.2/_util.ts *
│ ├─┬ https://jsr.io/@std/media-types/1.0.2/format_media_type.ts (2.45KB)
│ │ └── https://jsr.io/@std/media-types/1.0.2/_util.ts *
│ ├── https://jsr.io/@std/media-types/1.0.2/_db.ts *
│ └─┬ https://jsr.io/@std/media-types/1.0.2/type_by_extension.ts (1.15KB)
│   └── https://jsr.io/@std/media-types/1.0.2/_db.ts *
├─┬ https://jsr.io/@std/http/1.0.0-rc.5/etag.ts (6.46KB)
│ └─┬ https://jsr.io/@std/encoding/1.0.1/base64.ts (3.18KB)
│   └── https://jsr.io/@std/encoding/1.0.1/_validate_binary_like.ts (798B)
├── https://jsr.io/@std/http/1.0.0-rc.5/status.ts (13.39KB)
├── https://jsr.io/@std/streams/1.0.0-rc.4/byte_slice_stream.ts (2.57KB)
├── https://jsr.io/@std/cli/1.0.0/parse_args.ts (21.94KB)
├── https://jsr.io/@std/http/1.0.0-rc.5/deno.json (415B)
├── https://jsr.io/@std/fmt/1.0.0-rc.1/bytes.ts (5.3KB)
└── https://jsr.io/@std/net/1.0.0-rc.2/get_network_address.ts (1.68KB)
```

依赖检查器支持任何本地或远程的 ES 模块。

## 缓存位置

`deno info` 可以用来显示缓存位置的信息：

```shell
deno info
DENO_DIR 位置: "/Users/deno/Library/Caches/deno"
远程模块缓存: "/Users/deno/Library/Caches/deno/deps"
TypeScript 编译器缓存: "/Users/deno/Library/Caches/deno/gen"
```

---

# `deno init`，启动一个新项目

> Scaffold a new Deno project with tests and configuration

URL: https://docs.deno.com/runtime/reference/cli/init


## 示例

```sh
$ deno init
✅ 项目初始化完成
运行以下命令开始

  // 运行程序
  deno run main.ts

  // 运行程序并监听文件变化
  deno task dev

  // 运行测试
  deno test

$ deno run main.ts
添加 2 + 3 = 5

$ deno test
检查 file:///dev/main_test.ts
从 main_test.ts 运行 1 个测试
addTest ... ok (6ms)

ok | 1 通过 | 0 失败 (29ms)
```

`init` 子命令将创建两个文件（`main.ts` 和 `main_test.ts`）。这些文件提供了如何编写 Deno 程序和如何为其编写测试的基本示例。`main.ts` 文件导出了一个 `add` 函数，该函数将两个数字相加，而 `main_test.ts` 文件则包含了对此函数的测试。

您还可以为 `deno init` 指定一个参数，以在特定目录中初始化项目：

```sh
$ deno init my_deno_project
✅ 项目初始化完成

运行以下命令开始

  cd my_deno_project

  // 运行程序
  deno run main.ts

  // 运行程序并监听文件变化
  deno task dev

  // 运行测试
  deno test
```

## 初始化一个 JSR 包

通过运行 `deno init --lib`，Deno 将引导一个准备好在 [JSR](https://jsr.io/) 上发布的项目。

```sh
$ deno init --lib
✅ 项目初始化完成

运行以下命令开始

  # 运行测试
  deno test

  # 运行测试并监听文件变化
  deno task dev

  # 发布到 JSR（干运行）
  deno publish --dry-run
```

在 `deno.json` 中，您会看到 `name`、`exports` 和 `version` 的条目已预填充。

```json
{
  "name": "my-lib",
  "version": "0.1.0",
  "exports": "./mod.ts",
  "tasks": {
    "dev": "deno test --watch mod.ts"
  },
  "imports": {
    "@std/assert": "jsr:@std/assert@1"
  }
}
```

## 初始化一个 Web 服务器

运行 `deno init --serve` 将引导一个与 [`deno serve`](./serve) 一起工作的 Web 服务器。

```sh
$ deno init --serve
✅ 项目初始化完成

运行以下命令开始

  # 运行服务器
  deno serve -R main.ts

  # 运行服务器并监听文件变化
  deno task dev

  # 运行测试
  deno -R test
```

您的 [`deno.json`](/runtime/fundamentals/configuration/) 文件将如下所示：

```json
{
  "tasks": {
    "dev": "deno serve --watch -R main.ts"
  },
  "imports": {
    "@std/assert": "jsr:@std/assert@1",
    "@std/http": "jsr:@std/http@1"
  }
}
```

现在，您可以通过运行 `deno task dev` 启动您的 Web 服务器，该服务器
[监听变更](/runtime/getting_started/command_line_interface/#watch-mode)。

```sh
$ deno task dev
任务 dev deno serve --watch -R main.ts
监视器进程已启动。
deno serve: 正在监听 http://0.0.0.0:8000/
```

## 生成一个库项目

您可以附加一个 `--lib` 标志，以向您的 `deno.json` 添加额外的参数，例如 "name"、"version" 和 "exports" 字段。

```sh
$ deno init my_deno_project --lib
✅ 项目初始化完成
```

生成的 `deno.json` 将如下所示：

```jsonc
{
  "name": "my_deno_project",
  "version": "0.1.0",
  "exports": "./mod.ts",
  "tasks": {
    "dev": "deno test --watch mod.ts"
  },
  "license": "MIT",
  "imports": {
    "@std/assert": "jsr:@std/assert@1"
  }
}
```

---

# `deno install`

> Install and cache dependencies for your project

URL: https://docs.deno.com/runtime/reference/cli/install


## 示例

### deno install

使用此命令安装 `deno.json` 和/或 `package.json` 中定义的所有依赖项。

依赖项将被安装在全局缓存中，但如果您的项目有 `package.json` 文件，本地的 `node_modules` 目录也会被创建。

### deno install [PACKAGES]

使用此命令安装特定的软件包，并将其添加到 `deno.json` 或 `package.json` 中。

```shell
$ deno install jsr:@std/testing npm:express
```

:::tip

您也可以使用 `deno add`，它是 `deno install [PACKAGES]` 的别名。

:::

如果您的项目有 `package.json` 文件，来自 npm 的软件包将被添加到 `package.json` 的 `dependencies` 中。否则，所有软件包将被添加到 `deno.json` 中。

### deno install --entrypoint [FILES]

使用此命令安装提供文件及其依赖项中使用的所有依赖项。

如果您在代码中使用 `jsr:`、`npm:`、`http:` 或 `https:` 指定符，并希望在部署项目之前缓存所有依赖项，这尤其有用。

```js title="main.js"
import * as colors from "jsr:@std/fmt/colors";
import express from "npm:express";
```

```shell
$ deno install -e main.js
下载 jsr:@std/fmt
下载 npm:express
```

:::tip

如果您想设置本地的 `node_modules` 目录，可以传递 `--node-modules-dir=auto` 选项。

某些依赖项可能在没有本地 `node_modules` 目录的情况下无法正确工作。

:::

### deno install --global [PACKAGE_OR_URL]

使用此命令安装提供的软件包或脚本，使其作为系统中的全局可用二进制文件。

此命令创建一个瘦的可执行 shell 脚本，该脚本使用指定的 CLI 标志和主模块调用 `deno`。它被放置在安装根目录中。

示例：

```shell
$ deno install --global --allow-net --allow-read jsr:@std/http/file-server
下载 jsr:@std/http/file-server...

✅ 成功安装 file-server.
/Users/deno/.deno/bin/file-server
```

要更改可执行文件的名称，使用 `-n`/`--name`：

```shell
deno install -g -N -R -n serve jsr:@std/http/file-server
```

可执行文件名称默认推断：

- 尝试获取 URL 路径的文件名根。这上面的示例将变为 'file-server'。
- 如果文件名根是 'main'、'mod'、'index' 或 'cli' 这样的通用名称，并且路径没有父级，则采用父路径的文件名。否则，采用通用名称。
- 如果结果名称有 '@...' 后缀，则去掉它。

要更改安装根目录，请使用 `--root`：

```shell
deno install -g -N -R --root /usr/local/bin jsr:@std/http/file-server
```

安装根目录的确定顺序如下：

- `--root` 选项
- `DENO_INSTALL_ROOT` 环境变量
- `$HOME/.deno/bin`

如果需要，必须手动将这些添加到路径中。

```shell
echo 'export PATH="$HOME/.deno/bin:$PATH"' >> ~/.bashrc
```

您必须在安装时指定运行脚本所需的权限。

```shell
deno install -g -N -R jsr:@std/http/file-server -- -p 8080
```

上述命令创建一个名为 `file_server` 的可执行文件，该文件在网络和读取权限下运行，并绑定到端口 8080。

出于良好实践，请使用
[`import.meta.main`](/runtime/tutorials/module_metadata/) 习语在可执行脚本中指定入口点。

示例：

```ts
// https://example.com/awesome/cli.ts
async function myAwesomeCli(): Promise<void> {
  // -- 省略 --
}

if (import.meta.main) {
  myAwesomeCli();
}
```

当您创建可执行脚本时，请确保通过向您的存储库添加示例安装命令来通知用户：

```shell
# 使用 deno install 安装

$ deno install -n awesome_cli https://example.com/awesome/cli.ts
```

## 原生 Node.js 附加模块

许多流行的 npm 软件包，如 [`npm:sqlite3`](https://www.npmjs.com/package/sqlite3) 或 [`npm:duckdb`](https://www.npmjs.com/package/duckdb)，依赖于 ["生命周期脚本"](https://docs.npmjs.com/cli/v10/using-npm/scripts#life-cycle-scripts)，例如 `preinstall` 或 `postinstall` 脚本。通常，运行这些脚本是软件包正常工作的必要条件。

与 npm 不同，Deno 默认不运行这些脚本，因为它们可能会带来安全漏洞。

您仍然可以通过在运行 `deno install` 时传递 `--allow-scripts=<packages>` 选项来运行这些脚本：

```shell
deno install --allow-scripts=npm:sqlite3
```

_安装所有依赖项，并允许 `npm:sqlite3` 软件包运行其生命周期脚本_。

## --quiet 标志

`--quiet` 标志在安装依赖项时抑制诊断输出。

与 `deno install` 一起使用时，它将隐藏进度指示器、下载信息和成功消息。

```shell
$ deno install --quiet jsr:@std/http/file-server
```

这对于脚本环境或当您希望在 CI 管道中获得更清晰的输出时非常有用。

## 卸载

您可以使用 `deno uninstall` 命令卸载依赖项或二进制脚本：

```shell
$ deno uninstall express
删除 express
```

```shell
$ deno uninstall -g file-server
删除 /Users/deno/.deno/bin/file-server
✅ 成功卸载 file-server
```

有关更多详细信息，请参见 [`deno uninstall` 页面](/runtime/reference/cli/uninstall/)。

---

# Deno 的 Jupyter 内核

> Write JavaScript and TypeScript in Jupyter notebooks thanks to Deno's built-in Jupyter kernel

URL: https://docs.deno.com/runtime/reference/cli/jupyter


Deno 附带一个内置的 Jupyter 内核，允许你在交互式笔记本中编写 JavaScript 和 TypeScript；使用 Web 和 Deno API，并直接导入 `npm` 包。

:::caution `deno jupyter` 总是以 `--allow-all` 选项运行

目前，在 Jupyter 内核中执行的所有代码均以 `--allow-all` 标志运行。这是一个临时限制，将在未来解决。

:::

## 快速入门

运行 `deno jupyter --unstable` 并按照说明操作。

你可以运行 `deno jupyter --unstable --install` 来强制安装内核。Deno 假设 `jupyter` 命令在你的 `PATH` 中可用。

完成安装过程后，Deno 内核将在 JupyterLab 和经典笔记本的笔记本创建对话框中可用：

![Jupyter 笔记本内核选择](../images/jupyter_notebook.png)

你可以在任何支持 Jupyter 笔记本的编辑器中使用 Deno Jupyter 内核。

### VS Code

- 安装
  [VSCode Jupyter 扩展](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter)
- 通过打开命令面板（Ctrl+Shift+P）并选择“创建：新建 Jupyter 笔记本”来打开或创建一个笔记本文件。你也可以手动通过创建一个扩展名为 ".ipynb" 的文件来完成此操作。
- 在新建或现有笔记本上，点击创建新的 Jupyter 笔记本，选择“Jupyter 内核”，然后选择 Deno

![在 VS Code 中选择 Deno](https://github.com/denoland/deno-docs/assets/836375/32f0ccc3-35f7-47e5-84f4-17c20a5b5732)

### JetBrains IDEs

Jupyter 笔记本开箱即用。

## 丰富内容输出

`Deno.jupyter` 命名空间提供了用于在笔记本中显示丰富内容的辅助函数，
[使用 Jupyter 支持的 MIME 类型](https://docs.jupyter.org/en/latest/reference/mimetype.html)。

---

提供丰富输出的最简单方法是返回一个具有 `[Symbol.for("Jupyter.display")]` 方法的对象。

此方法应返回一个将 MIME 类型映射到应显示的值的字典。

```ts
{
  [Symbol.for("Jupyter.display")]() {
    return {
      // 普通文本内容
      "text/plain": "Hello world!",

      // HTML 输出
      "text/html": "<h1>Hello world!</h1>",
    }
  }
}
```

_返回普通文本和 HTML 输出的对象示例。_

:::info

你也可以使用 `Deno.jupyter.$display`，而无需输入
`Symbol.for("Jupyter.display")`

:::

这是一个常规函数，因此你可以使用任何库来格式化输出 —— 例如，使用 `@std/fmt/colors` 提供彩色输出：

```ts
import * as colors from "jsr:@std/fmt/colors";

{
  [Deno.jupyter.$display]() {
    return {
      "text/plain": colors.green("Hello world"),
    }
  }
}
```

你还可以使用 `Deno.jupyter.display` 函数直接显示 MIME 集合：

```js
await Deno.jupyter.display({
  "text/plain": "Hello, world!",
  "text/html": "<h1>Hello, world!</h1>",
  "text/markdown": "# Hello, world!",
}, { raw: true });
```

![`Deno.jupyter.display` API 示例](../images/jupyter-display.png)

你的笔记本前端将自动根据其能力选择“最丰富”的 MIME 类型进行显示。

---

`Deno.jupyter` 提供了若干用于常见媒体类型的丰富输出的辅助方法。

`Deno.jupyter.html` 是一个标记模板，将提供的字符串作为 HTML 渲染在笔记本中。

```js
Deno.jupyter.html`<h1>Hello, world!</h1>
<h2>来自 Deno 内核</h2>
<p>Lorem ipsum <i>dolor</i> <b>sit</b> <u>amet</u></p>`;
```

![`Deno.jupyter.html` API 示例](../images/jupyter-html.png)

`Deno.jupyter.md` 是一个标记模板，将提供的字符串作为 Markdown 文档在笔记本中渲染。

```js
Deno.jupyter
  .md`# 使用 Deno 的 TypeScript 笔记本 ![Deno logo](https://github.com/denoland.png?size=32)

**与 Jupyter 的交互式计算 _内置于 Deno_！**`;
```

![`Deno.jupyter.md` API 示例](../images/jupyter-md.png)

`Deno.jupyter.svg` 是一个标记模板，将提供的字符串作为 SVG 图形在笔记本中渲染。

```js
Deno.jupyter.svg`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
    </svg>`;
```

![`Deno.jupyter.svg` API 示例](../images/jupyter-svg.png)

`Deno.jupyter.image` 是一个函数，将渲染 JPG 或 PNG 图像。你可以传入文件路径或已读取的字节：

```js
Deno.jupyter.image("./cat.jpg");

const data = Deno.readFileSync("./dog.png");
Deno.jupyter.image(data);
```

## prompt 和 confirm APIs

你可以使用 `prompt` 和 `confirm` Web API 在笔记本中等待用户输入。

<figure>

<video class="w-full" alt="`confirm` 和 `prompt` APIs 示例" autoplay muted loop playsinline controls src="../images/jupyter-confirm-prompt.mp4"></video>

<figcaption><span style="font-family: monospace;">confirm</span> 和 <span style="font-family: monospace;">prompt</span> APIs 示例</figcaption>

</figure>

## IO pub 通道广播

`Deno.jupyter.broadcast` 允许将消息发布到 IO pub 通道，允许在单元格被评估时提供实时更新。

考虑以下示例，该示例在开始计算之前打印一条消息，计算完成时再打印另一条消息：

```js
await Deno.jupyter.broadcast("display_data", {
  data: { "text/html": "<b>处理中...</b>" },
  metadata: {},
  transient: { display_id: "progress" },
});

// 假装我们正在进行一个耗时的计算
await new Promise((resolve) => setTimeout(resolve, 1500));

await Deno.jupyter.broadcast("update_display_data", {
  data: { "text/html": "<b>完成</b>" },
  metadata: {},
  transient: { display_id: "progress" },
});
```

<figure>

<video class="w-full" alt="`Deno.jupyter.broadcast` API 示例" autoplay muted loop playsinline controls src="../images/jupyter-broadcast.mp4"></video>

<figcaption><span style="font-family: monospace;">Deno.jupyter.broadcast</span> API 示例</figcaption>

</figure>

## 示例

以下是使用 `@observablehq/plot` 生成图表的示例：

```ts
import { document, penguins } from "jsr:@ry/jupyter-helper";
import * as Plot from "npm:@observablehq/plot";

let p = await penguins();

Plot.plot({
  marks: [
    Plot.dot(p.toRecords(), {
      x: "culmen_depth_mm",
      y: "culmen_length_mm",
      fill: "species",
    }),
  ],
  document,
});
```

![使用 `@observablehq/plot` 库生成的示例图](../images/jupyter-plot.png)

请参阅 https://github.com/rgbkrk/denotebooks 以获取利用数据分析和可视化库（如 Polars、Observable 和 d3）的更高级示例。

## `jupyter console` 集成

你还可以在 `jupyter console` REPL 中使用 Deno Jupyter 内核。为此，你应该通过 `jupyter console --kernel deno` 启动控制台。

![在 CLI 中使用 Deno 内核](../images/jupyter-cli.gif)

---

# `deno lint`, 检查工具

> Run the Deno linter to check your code for errors and apply automated fixes

URL: https://docs.deno.com/runtime/reference/cli/lint


## 可用规则

要查看支持的规则的完整列表，请访问 [规则列表](/lint/) 文档页面。

## 忽略指令

### 文件级别

要忽略整个文件，请在文件开头使用 `// deno-lint-ignore-file`：

```ts
// deno-lint-ignore-file

function foo(): any {
  // ...
}
```

您还可以指定忽略该文件的原因：

```ts
// deno-lint-ignore-file -- 忽略的原因

function foo(): any {
  // ...
}
```

忽略指令必须放在第一个语句或声明之前：

```ts
// 版权所有 2018-2024 Deno 作者。保留所有权利。MIT 许可证.

/**
 * 一些 JS 文档
 */

// deno-lint-ignore-file

import { bar } from "./bar.js";

function foo(): any {
  // ...
}
```

您还可以在整个文件中忽略某些诊断：

```ts
// deno-lint-ignore-file no-explicit-any no-empty

function foo(): any {
  // ...
}
```

如果存在多个 `// deno-lint-ignore-file` 指令，除了第一个以外的指令将被忽略：

```ts
// 这是有效的
// deno-lint-ignore-file no-explicit-any no-empty

// 但是这个无效
// deno-lint-ignore-file no-debugger

function foo(): any {
  debugger; // 未被忽略！
}
```

### 行级别

要忽略特定的诊断，请在有问题的行前使用 `// deno-lint-ignore <codes...>`。

```ts
// deno-lint-ignore no-explicit-any
function foo(): any {
  // ...
}

// deno-lint-ignore no-explicit-any explicit-function-return-type
function bar(a: any) {
  // ...
}
```

您必须指定要忽略的规则的名称。

您还可以指定忽略诊断的原因：

```ts
// deno-lint-ignore no-explicit-any -- 忽略的原因
function foo(): any {
  // ...
}
```

## 忽略 `ban-unused-ignore` 本身

`deno lint` 提供了 [`ban-unused-ignore` 规则](/lint/rules/ban-unused-ignore/)，
该规则会检测不再抑制某些诊断的忽略指令。当您希望发现代码重构后不再必要的忽略指令时，这非常有用。

然而，在某些情况下，您可能希望忽略 `ban-unused-ignore` 规则本身。一个典型的情况是在处理自动生成的文件时；对某些规则添加文件级忽略指令是有意义的，这样在这种情况下几乎不需要通过 `ban-unused-ignore` 检测未使用的指令。

如果您希望抑制整个文件的规则，可以像往常一样使用 `// deno-lint-ignore-file ban-unused-ignore`：

```ts
// deno-lint-ignore-file ban-unused-ignore no-explicit-any

// `no-explicit-any` 没有使用，但由于忽略了 `ban-unused-ignore`，
// 所以不会返回任何诊断
console.log(42);
```

请注意，忽略 `ban-unused-ignore` 本身仅通过文件级忽略指令有效。这意味着像 `// deno-lint-ignore ban-unused-ignore` 这样的行级指令完全无效。如果您出于某些特殊原因想要忽略 `ban-unused-ignore`，请确保将其作为文件级忽略指令添加。

## 更多关于 linting 和格式化的信息

有关 Deno 中 linting 和格式化的更多信息，以及这两种工具之间的差异，请访问我们基础部分的 [Linting 和格式化](/runtime/fundamentals/linting_and_formatting/) 页面。


---

# deno lsp

URL: https://docs.deno.com/runtime/reference/cli/lsp


:::info

通常情况下，用户不会直接使用此子命令。`deno lsp` 可以为IDE提供跳转到定义的支持以及自动代码格式化。

:::

启动 Deno 语言服务器。语言服务器被编辑器用来提供诸如智能提示、代码格式化等功能。阅读更多关于 [与 Deno LSP 集成](/runtime/reference/lsp_integration/)的信息。

## 描述

`deno lsp` 子命令为代码编辑器和IDE提供了一种与 Deno 互动的方式，使用语言服务器协议。

阅读更多关于 [如何将编辑器和IDE连接到 `deno lsp`](https://deno.land/manual@v1.42.4/getting_started/setup_your_environment#editors-and-ides)。

---

# deno outdated

> Check for outdated dependencies in your project and safely update them with an interactive CLI

URL: https://docs.deno.com/runtime/reference/cli/outdated


## 检查过期依赖

`outdated` 子命令检查 `deno.json` 或 `package.json` 文件中列出的 NPM 和 JSR 依赖的最新版本，并显示可以更新的依赖。工作区完全支持，包括一些成员使用 `package.json` 而其他成员使用 `deno.json` 的工作区。

例如，考虑一个包含 `deno.json` 文件的项目：

```json
{
  "imports": {
    "@std/fmt": "jsr:@std/fmt@^1.0.0",
    "@std/async": "jsr:@std/async@1.0.1",
    "chalk": "npm:chalk@4"
  }
}
```

以及一个将 `@std/fmt` 锁定为 `1.0.0` 的锁定文件。

```bash
$ deno outdated
┌────────────────┬─────────┬────────┬────────┐
│ 包名称          │ 当前版本  │ 更新版本  │ 最新版本  │
├────────────────┼─────────┼────────┼────────┤
│ jsr:@std/fmt   │ 1.0.0   │ 1.0.3  │ 1.0.3  │
├────────────────┼─────────┼────────┼────────┤
│ jsr:@std/async │ 1.0.1   │ 1.0.1  │ 1.0.8  │
├────────────────┼─────────┼────────┼────────┤
│ npm:chalk      │ 4.1.2   │ 4.1.2  │ 5.3.0  │
└────────────────┴─────────┴────────┴────────┘
```

`更新版本` 列显示最新的 semver 兼容版本，而 `最新版本` 列显示最新版本。

注意，尽管没有可以更新到的 semver 兼容版本，`jsr:@std/async` 仍然被列出。如果您希望仅显示具有新兼容版本的包，可以传递 `--compatible` 标志。

```bash
$ deno outdated --compatible
┌────────────────┬─────────┬────────┬────────┐
│ 包名称          │ 当前版本  │ 更新版本  │ 最新版本  │
├────────────────┼─────────┼────────┼────────┤
│ jsr:@std/fmt   │ 1.0.0   │ 1.0.3  │ 1.0.3  │
└────────────────┴─────────┴────────┴────────┘
```

`jsr:@std/fmt` 仍然被列出，因为它可以安全地更新到 `1.0.3`，但 `jsr:@std/async` 不再显示。

## 更新依赖

`outdated` 子命令还可以通过 `--update` 标志更新依赖。
默认情况下，它只会将依赖更新到 semver 兼容版本（即不会更新到不兼容的版本）。

```bash
$ deno outdated --update
更新了 1 个依赖：
 - jsr:@std/fmt 1.0.0 -> 1.0.3
```

要更新到最新版本（无论是否兼容 semver），请传递 `--latest` 标志。

```bash
$ deno outdated --update --latest
更新了 3 个依赖：
 - jsr:@std/async 1.0.1 -> 1.0.8
 - jsr:@std/fmt   1.0.0 -> 1.0.3
 - npm:chalk      4.1.2 -> 5.3.0
```

## 选择包

`outdated` 子命令还支持选择要操作的包。这可以在有或没有 `--update` 标志的情况下工作。

```bash
$ deno outdated --update --latest chalk
更新了 1 个依赖：
 - npm:chalk 4.1.2 -> 5.3.0
```

可以传递多个选择器，并且也支持通配符（`*`）或排除（`!`）。

例如，要更新所有具有 `@std` 范围的包，除了 `@std/fmt`：

```bash
$ deno outdated --update --latest "@std/*" "!@std/fmt"
更新了 1 个依赖：
 - jsr:@std/async 1.0.1 -> 1.0.8
```

请注意，如果您使用通配符，您可能需要用引号将参数包围，以防止 shell 尝试展开它们。

### 更新到特定版本

除了选择要更新的包外，`--update` 标志还支持选择新的 _版本_，在 `@` 后指定版本。

```bash
❯ deno outdated --update chalk@5.2 @std/async@1.0.6
更新了 2 个依赖：
 - jsr:@std/async 1.0.1 -> 1.0.6
 - npm:chalk      4.1.2 -> 5.2.0
```

## 工作区

在工作区设置中，默认情况下，`outdated` 只会在 _当前_ 工作区成员上操作。

例如，给定一个工作区：

```json
{
  "workspace": ["./member-a", "./member-b"]
}
```

从 `./member-a` 目录运行

```bash
deno outdated
```

将仅检查 `./member-a/deno.json` 或 `./member-a/package.json` 中列出的过期依赖。

要包括所有工作区成员，请传递 `--recursive` 标志（`-r` 简写也被接受）

```bash
deno outdated --recursive
deno outdated --update --latest -r
```

---

# deno publish

> Publish your package or workspace to the JSR registry

URL: https://docs.deno.com/runtime/reference/cli/publish


## 包要求

您的包必须在其 `deno.json` 或 `jsr.json` 文件中具有 `name`、 `version` 和 `exports` 字段。

- `name` 字段必须是唯一的，并遵循 `@<scope_name>/<package_name>` 约定。
- `version` 字段必须是有效的 semver 版本。
- `exports` 字段必须指向包的主要入口点。`exports` 字段可以指定为一个字符串，或者作为一个对象，将入口点名称映射到您包中的路径。

示例：

```json title="deno.json"
{
  "name": "@scope_name/package_name",
  "version": "1.0.0",
  "exports": "./main.ts"
}
```

在您发布包之前，您必须通过访问 [JSR - 发布一个包](https://jsr.io/new) 在注册表中创建它。

## 示例

发布您当前的工作区

```bash
deno publish
```

使用特定令牌发布您当前的工作区，跳过交互式身份验证

```bash
deno publish --token c00921b1-0d4f-4d18-b8c8-ac98227f9275
```

发布并检查远程模块中的错误

```bash
deno publish --check=all
```

执行干运行以模拟发布。

```bash
deno publish --dry-run
```

使用特定配置文件中的设置发布

```bash
deno publish --config custom-config.json
```

---

# runtime/reference/cli/remove.md

URL: https://docs.deno.com/runtime/reference/cli/remove

---
title: "deno remove"
command: remove
openGraphLayout: "/open_graph/cli-commands.jsx"
openGraphTitle: "deno remove"
description: "Remove a dependency from your project"
---

---

# `deno repl`，交互式脚本提示

> 在 REPL 环境中与 Deno 运行时交互

URL: https://docs.deno.com/runtime/reference/cli/repl


## 特殊变量

REPL 提供了一些特殊变量，始终可用：

| 标识符    | 描述                             |
| -------- | --------------------------------- |
| _        | 返回最后评估的表达式              |
| _error   | 返回最后抛出的错误                 |

```console
Deno 1.14.3
使用 ctrl+d 或 close() 退出
> "hello world!"
"hello world!"
> _
"hello world!"
> const foo = "bar";
undefined
> _
undefined
```

## 特殊函数

REPL 在全局作用域提供了几个函数：

| 函数     | 描述                           |
| -------- | ------------------------------- |
| clear()  | 清除整个终端屏幕                 |
| close()  | 关闭当前 REPL 会话               |

## `--eval` 标志

`--eval` 标志允许您在进入 REPL 之前运行一些代码。这对于导入您在 REPL 中常用的一些代码或以某种方式修改运行时尤其有用：

```console
$ deno repl --allow-net --eval 'import { assert } from "jsr:@std/assert@1"'
Deno 1.45.3
使用 ctrl+d、ctrl+c 或 close() 退出
> assert(true)
undefined
> assert(false)
未捕获 AssertionError
    at assert (https://jsr.io/@std/assert/1.0.0/assert.ts:21:11)
    at <anonymous>:1:22
```

## `--eval-file` 标志

`--eval-file` 标志允许您在进入 REPL 之前从指定文件运行代码。与 `--eval` 标志类似，这对于导入您在 REPL 中常用的代码或以某种方式修改运行时也很有用。

可以将文件指定为路径或 URL。URL 文件会被缓存，并可以通过 `--reload` 标志重新加载。

如果同时指定了 `--eval`，则 `--eval-file` 文件将在 `--eval` 代码之前运行。

```console
$ deno repl --eval-file=https://docs.deno.com/examples/welcome.ts,https://docs.deno.com/examples/local.ts
下载 https://docs.deno.com/examples/welcome.ts
欢迎使用 Deno！
下载 https://docs.deno.com/examples/local.ts
Deno 1.45.3
使用 ctrl+d 或 close() 退出
> local // 这个变量在 local.ts 中被本地定义，但未被导出
"This is a local variable inside of local.ts"
```

### 相对导入路径解析

如果 `--eval-file` 指定的代码文件包含相对导入，则运行时将尝试将导入相对于当前工作目录解析。它不会尝试相对于代码文件的位置解析。这可能导致使用模块文件时出现 "Module not found" 错误：

```console
$ deno repl --eval-file=https://jsr.io/@std/encoding/1.0.0/ascii85.ts
--eval-file 文件 https://jsr.io/@std/encoding/1.0.0/ascii85.ts 中出错。未捕获 TypeError: 找不到模块 "file:///home/_validate_binary_like.ts"。
    at async <anonymous>:2:13
Deno 1.45.3
使用 ctrl+d 或 close() 退出
>
```

## Tab 补全

Tab 补全是 REPL 中快速导航的重要功能。在按下 `tab` 键后，Deno 会显示所有可能补全的列表。

```console
$ deno repl
Deno 1.45.3
使用 ctrl+d 或 close() 退出
> Deno.read
readTextFile      readFile          readDirSync       readLinkSync      readAll           read
readTextFileSync  readFileSync      readDir           readLink          readAllSync       readSync
```

## 快捷键

| 按键                 | 操作                                                                                                                                                                                                                                                |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Ctrl-A, Home          | 将光标移动到行首                                                                                                                                                                                                                                     |
| Ctrl-B, Left          | 将光标向左移动一个字符                                                                                                                                                                                                                               |
| Ctrl-C                | 中断并取消当前编辑                                                                                                                                                                                                                                   |
| Ctrl-D                | 如果当前行为空，发送结束信号                                                                                                                                                                                                                         |
| Ctrl-D, Del           | 如果当前行非空，删除光标下的字符                                                                                                                                                                                                                     |
| Ctrl-E, End           | 将光标移动到行尾                                                                                                                                                                                                                                     |
| Ctrl-F, Right         | 将光标向右移动一个字符                                                                                                                                                                                                                               |
| Ctrl-H, Backspace     | 删除光标前的字符                                                                                                                                                                                                                                     |
| Ctrl-I, Tab           | 下一个补全选项                                                                                                                                                                                                                                       |
| Ctrl-J, Ctrl-M, Enter | 完成当前行输入                                                                                                                                                                                                                                       |
| Ctrl-K                | 删除从光标到行尾的内容                                                                                                                                                                                                                               |
| Ctrl-L                | 清屏                                                                                                                                                                                                                                                |
| Ctrl-N, Down          | 历史记录中下一个匹配项                                                                                                                                                                                                                               |
| Ctrl-P, Up            | 历史记录中上一个匹配项                                                                                                                                                                                                                               |
| Ctrl-R                | 反向搜索历史记录（Ctrl-S 向前搜索，Ctrl-G 取消）                                                                                                                                                                                                    |
| Ctrl-T                | 交换光标前后两个字符                                                                                                                                                                                                                                 |
| Ctrl-U                | 删除从行首到光标的内容                                                                                                                                                                                                                               |
| Ctrl-V, Ctrl-Q        | 逐字插入后续字符而非执行其快捷操作。例如，编辑多行历史记录时插入换行，先按 Ctrl-V 再按 Ctrl-J （Ctrl-J 为 ASCII 控制字符“换行”）                                                                                                                   |
| Ctrl-W                | 删除光标前的单词（以空白符作为单词边界）                                                                                                                                                                                                             |
| Ctrl-X Ctrl-U         | 撤销操作                                                                                                                                                                                                                                            |
| Ctrl-Y                | 从剪切缓冲区粘贴                                                                                                                                                                                                                                    |
| Ctrl-Y                | 从剪切缓冲区粘贴（Meta-Y 粘贴下一个剪切内容）                                                                                                                                                                                                        |
| Ctrl-Z                | 挂起（仅限 Unix）                                                                                                                                                                                                                                     |
| Ctrl-_                | 撤销操作                                                                                                                                                                                                                                            |
| Meta-0, 1, ..., -     | 指定参数数字。`–` 表示负数参数。                                                                                                                                                                                                                    |
| Meta &lt;             | 移动到历史记录的第一个条目                                                                                                                                                                                                                             |
| Meta &gt;             | 移动到历史记录的最后一个条目                                                                                                                                                                                                                           |
| Meta-B, Alt-Left      | 将光标移动到前一个单词                                                                                                                                                                                                                               |
| Meta-Backspace        | 删除当前单词起始到光标位置的内容，或在单词间时删除到上一个单词的起始                                                                                                                                                                                |
| Meta-C                | 将当前单词首字母大写                                                                                                                                                                                                                                 |
| Meta-D                | 向前删除一个单词                                                                                                                                                                                                                                     |
| Meta-F, Alt-Right     | 将光标移动到下一个单词                                                                                                                                                                                                                               |
| Meta-L                | 将接下来的单词改为小写                                                                                                                                                                                                                               |
| Meta-T                | 交换相邻单词位置                                                                                                                                                                                                                                     |
| Meta-U                | 将接下来的单词改为大写                                                                                                                                                                                                                               |
| Meta-Y                | 同 Ctrl-Y                                                                                                                                                                                                                                            |
| Ctrl-S                | 插入换行符                                                                                                                                                                                                                                          |

## `DENO_REPL_HISTORY`

默认情况下，Deno 将 REPL 历史存储在 `deno_history.txt` 文件中，该文件位于 `DENO_DIR` 目录内。您可以通过运行 `deno info` 找到您的 `DENO_DIR` 目录及其他资源的位置。

您可以使用 `DENO_REPL_HISTORY` 环境变量来控制 Deno 存储 REPL 历史文件的位置。您可以将其设置为空值，Deno 将不会存储历史文件。

---

# `deno run`，运行一个文件

> Run a JavaScript or TypeScript program from a file or URL with Deno's runtime

URL: https://docs.deno.com/runtime/reference/cli/run


## 用法

要运行 [这个文件](https://docs.deno.com/examples/scripts/hello_world.ts)，使用：

```console
deno run https://docs.deno.com/examples/scripts/hello_world.ts
```

你也可以在本地运行文件。确保你在正确的目录下并使用：

```console
deno run hello-world.ts
```

默认情况下，Deno 在一个沙箱中运行程序，没有访问磁盘、网络或生成子进程的能力。这是因为 Deno 运行时是 
[默认安全](/runtime/fundamentals/security/)。你可以使用
[`--allow-*` 和 `--deny-*` 标志](/runtime/fundamentals/security/#permissions-list) 来授予或拒绝所需的权限。

### 权限示例

授予从磁盘读取和监听网络的权限：

```console
deno run --allow-read --allow-net server.ts
```

授予从磁盘读取允许列出的文件的权限：

```console
deno run --allow-read=/etc server.ts
```

授予所有权限 _这不推荐，应该仅用于测试_：

```console
deno run -A server.ts
```

如果你的项目需要多个安全标志，你应该考虑使用 [`deno task`](/runtime/reference/cli/task/) 来执行它们。

## 监听文件变化

要监视文件变化并自动重启进程，使用 `--watch` 标志。Deno 内置的应用程序监视器会在文件更改时立即重启你的应用程序。

_确保在文件名之前放置标志_，例如：

```console
deno run --allow-net --watch server.ts
```

Deno 的监视器会在控制台通知你文件的变化，并在工作时如果出现错误会警告你。

## 运行 package.json 脚本

`package.json` 脚本可以使用 [`deno task`](/runtime/reference/cli/task/) 命令执行。

## 从 stdin 运行代码

你可以从 stdin 管道发送代码并立即运行它，使用：

```console
curl https://docs.deno.com/examples/scripts/hello_world.ts | deno run -
```

## 终止运行

要停止运行命令，使用 `ctrl + c`。

---

# deno serve

> 一个灵活且可配置的 Deno HTTP 服务器

URL: https://docs.deno.com/runtime/reference/cli/serve


## 示例

这是一个如何使用声明式 fetch 创建简单 HTTP 服务器的示例：

```typescript title="server.ts"
export default {
  async fetch(_req) {
    return new Response("Hello world!");
  },
} satisfies Deno.ServeDefaultExport;
```

`satisfies Deno.ServeDefaultExport` 类型断言确保您导出的对象符合 Deno HTTP 服务器的预期接口。这提供了类型安全性和更好的编辑器自动完成功能，同时允许您保持实现的推断类型。

然后，您可以使用 `deno serve` 命令运行服务器：

```bash
deno serve server.ts
```

`fetch` 函数中的逻辑可以根据不同类型的请求进行自定义，并相应地提供内容：

```typescript title="server.ts"
export default {
  async fetch(request) {
    if (request.url.endsWith("/json")) {
      return Response.json({ hello: "world" });
    }

    return new Response("Hello world!");
  },
} satisfies Deno.ServeDefaultExport;
```

---

# `deno task`

> A configurable task runner for Deno

URL: https://docs.deno.com/runtime/reference/cli/task


## 描述

`deno task` 提供了一种跨平台的方式来定义和执行特定于代码库的自定义命令。

要开始使用，请在代码库的
[Deno 配置文件](/runtime/fundamentals/configuration/) 中定义您的命令，位于一个
`"tasks"` 键下。

例如：

```jsonc
{
  "tasks": {
    "data": "deno task collect && deno task analyze",
    "collect": "deno run --allow-read=. --allow-write=. scripts/collect.js",
    "analyze": {
      "description": "运行分析脚本",
      "command": "deno run --allow-read=. scripts/analyze.js"
    }
  }
}
```

## 指定当前工作目录

默认情况下，`deno task` 使用 Deno 配置文件（例如 _deno.json_）的目录作为当前工作目录来执行命令。这允许任务使用相对路径，并继续工作，无论您从目录树的何处执行 deno task。在某些情况下，这可能不是所期望的，这种行为可以使用 `INIT_CWD` 环境变量覆盖。

如果没有设置，`INIT_CWD` 将被设为任务运行所在目录的完整路径。这与 `npm run` 的行为一致。

例如，以下任务将更改任务的当前工作目录，使之位于用户运行任务的相同目录，然后输出当前工作目录，现在就是该目录（请记住，这在 Windows 上也有效，因为 `deno task` 是跨平台的）。

```json
{
  "tasks": {
    "my_task": "cd $INIT_CWD && pwd"
  }
}
```

## 获取 `deno task` 运行的目录

由于任务使用 Deno 配置文件的目录作为当前工作目录，因此了解 `deno task` 是从哪个目录执行的可能会很有用。这可以通过在任务中或从 `deno task` 启动的脚本中使用 `INIT_CWD` 环境变量来实现（此方式与 `npm run` 的方式相同，但以跨平台方式实现）。

例如，要将该目录提供给任务中的脚本，请执行以下操作（注意，目录用双引号括起来，以便在包含空格的情况下将其作为单个参数保持）：

```json
{
  "tasks": {
    "start": "deno run main.ts \"$INIT_CWD\""
  }
}
```

## 通配符匹配任务

`deno task` 命令可以通过传递通配符模式并行运行多个任务。通配符模式用 `*` 字符指定。

```json title="deno.json"
{
  "tasks": {
    "build-client": "deno run -RW client/build.ts",
    "build-server": "deno run -RW server/build.ts"
  }
}
```

运行 `deno task "build-*"` 将同时运行 `build-client` 和 `build-server` 任务。

:::note

**使用通配符时** 确保引用任务名称（例如 `"build-*"`），否则您的 shell 可能会尝试扩展通配符字符，从而导致意外错误。

:::

## 任务依赖

您可以为任务指定依赖项：

```json title="deno.json"
{
  "tasks": {
    "build": "deno run -RW build.ts",
    "generate": "deno run -RW generate.ts",
    "serve": {
      "command": "deno run -RN server.ts",
      "dependencies": ["build", "generate"]
    }
  }
}
```

在上面的示例中，运行 `deno task serve` 将首先并行执行 `build` 和 `generate` 任务，一旦它们都成功完成，`serve` 任务将被执行：

```bash
$ deno task serve
Task build deno run -RW build.ts
Task generate deno run -RW generate.ts
Generating data...
Starting the build...
Build finished
Data generated
Task serve deno run -RN server.ts
Listening on http://localhost:8000/
```

依赖任务是并行执行的，默认的并行限制等于您机器上的核心数量。要更改此限制，请使用 `DENO_JOBS` 环境变量。

依赖项会被跟踪，如果多个任务依赖同一任务，该任务只会运行一次：

```jsonc title="deno.json"
{
  //   a
  //  / \
  // b   c
  //  \ /
  //   d
  "tasks": {
    "a": {
      "command": "deno run a.js",
      "dependencies": ["b", "c"]
    },
    "b": {
      "command": "deno run b.js",
      "dependencies": ["d"]
    },
    "c": {
      "command": "deno run c.js",
      "dependencies": ["d"]
    },
    "d": "deno run d.js"
  }
}
```

```bash
$ deno task a
Task d deno run d.js
Running d
Task c deno run c.js
Running c
Task b deno run b.js
Running b
Task a deno run a.js
Running a
```

如果发现依赖之间存在循环，将返回错误：

```jsonc title="deno.json"
{
  "tasks": {
    "a": {
      "command": "deno run a.js",
      "dependencies": ["b"]
    },
    "b": {
      "command": "deno run b.js",
      "dependencies": ["a"]
    }
  }
}
```

```bash
$ deno task a
Task cycle detected: a -> b -> a
```

您还可以指定没有 `command` 的依赖任务。这对于逻辑上将几个任务分组在一起很有用：

```json title="deno.json"
{
  "tasks": {
    "dev-client": "deno run --watch client/mod.ts",
    "dev-server": "deno run --watch sever/mod.ts",
    "dev": {
      "dependencies": ["dev-client", "dev-server"]
    }
  }
}
```

运行 `deno task dev` 将并行运行 `dev-client` 和 `dev-server`。

## Node 和 npx 二进制支持

默认情况下，`deno task` 将使用 `deno` 二进制执行命令。如果您需要确保命令使用 `npm` 或 `npx` 二进制运行，您可以通过分别调用 `npm` 或 `npx` 的 `run` 命令来实现。例如：

```json
{
  "tasks": {
    "test:node": "npm run test"
  }
}
```

## 工作空间支持

`deno task` 可用于工作空间，从多个成员目录并行运行任务。要执行所有工作空间成员的 `dev` 任务，请使用 `--recursive` 标志：

```jsonc title="deno.json"
{
  "workspace": [
    "client",
    "server"
  ]
}
```

```jsonc title="client/deno.json"
{
  "name": "@scope/client",
  "tasks": {
    "dev": "deno run -RN build.ts"
  }
}
```

```jsonc title="server/deno.json"
{
  "name": "@scope/server",
  "tasks": {
    "dev": "deno run -RN server.ts"
  }
}
```

```bash
$ deno task --recursive dev
Task dev deno run -RN build.ts
Task dev deno run -RN server.ts
Bundling project...
Listening on http://localhost:8000/
Project bundled
```

要运行的任务可以根据工作空间成员进行过滤：

```bash
$ deno task --filter "client" dev
Task dev deno run -RN build.ts
Bundling project...
Project bundled
```

请注意，过滤器是根据每个成员的 `deno.json` 文件中的 `name` 字段指定的工作空间成员名称进行匹配的。

## 语法

`deno task` 使用一个跨平台的 shell，这是一个 sh/bash 的子集，用于执行定义的任务。

### 布尔列表

布尔列表提供了一种根据初始命令的退出代码执行额外命令的方法。它们使用 `&&` 和 `||` 运算符分隔命令。

`&&` 运算符提供了一种执行命令的方法，如果它 _成功_（退出码为 `0`），则执行下一个命令：

```sh
deno run --allow-read=. --allow-write=. collect.ts && deno run --allow-read=. analyze.ts
```

`||` 运算符正好相反。它提供了一种执行命令的方法，仅在 _失败_（退出码非零）时执行下一个命令：

```sh
deno run --allow-read=. --allow-write=. collect.ts || deno run play_sad_music.ts
```

### 顺序列表

顺序列表类似于布尔列表，但无论列表中前一个命令是否通过，都将执行。命令用分号 (`;`) 分隔。

```sh
deno run output_data.ts ; deno run --allow-net server.ts
```

### 异步命令

异步命令提供了一种使命令异步执行的方法。这在启动多个进程时可能很有用。要使命令异步，请在命令末尾添加 `&`。例如，以下命令将在同一时间执行
`sleep 1 && deno run --allow-net server.ts` 和 `deno run --allow-net client.ts`：

```sh
sleep 1 && deno run --allow-net server.ts & deno run --allow-net client.ts
```

与大多数 shell 不同，第一个失败的异步命令将导致所有其他命令立即失败。在上面的例子中，这意味着如果服务器命令失败，则客户端命令也会失败并退出。您可以通过在命令末尾添加 `|| true` 来选择退出此行为，这将强制返回 `0` 的退出代码。例如：

```sh
deno run --allow-net server.ts || true & deno run --allow-net client.ts || true
```

### 环境变量

环境变量的定义方式如下：

```sh
export VAR_NAME=value
```

以下是如何在任务中使用一个环境变量的示例，使用 shell 变量替换，然后将其作为启动 Deno 进程的环境的一部分导出（注意，在 JSON 配置文件中，双引号需要用反斜杠转义）：

```sh
export VAR=hello && echo $VAR && deno eval "console.log('Deno: ' + Deno.env.get('VAR'))"
```

将输出：

```console
hello
Deno: hello
```

#### 为命令设置环境变量

要在命令之前指定环境变量，请像下面这样列出：

```console
VAR=hello VAR2=bye deno run main.ts
```

这将仅为以下命令使用这些环境变量。

### Shell 变量

Shell 变量与环境变量类似，但不会导出到已生成的命令中。它们使用以下语法定义：

```sh
VAR_NAME=value
```

如果我们在之前的 "环境变量" 部分的类似示例中使用 shell 变量而不是环境变量：

```sh
VAR=hello && echo $VAR && deno eval "console.log('Deno: ' + Deno.env.get('VAR'))"
```

我们将得到以下输出：

```console
hello
Deno: undefined
```

Shell 变量在我们想重用某个值但又不希望在任何生成的进程中可用时非常有用。

### 退出状态变量

以前运行命令的退出码在 `$?` 变量中可用。

```sh
# 输出 10
deno eval 'Deno.exit(10)' || echo $?
```

### 管道

管道提供了一种将一个命令的输出管道到另一个命令的方法。

以下命令将标准输出 "Hello" 管道到启动的 Deno 进程的标准输入：

```sh
echo Hello | deno run main.ts
```

要管道标准输出和标准错误，请使用 `|&`：

```sh
deno eval 'console.log(1); console.error(2);' |& deno run main.ts
```

### 命令替换

`$(command)` 语法提供了一种在执行的其他命令中使用命令输出的方法。

例如，要将获取最新 git 修订版的输出提供给另一个命令，您可以这样做：

```sh
deno run main.ts $(git rev-parse HEAD)
```

另一个示例使用 shell 变量：

```sh
REV=$(git rev-parse HEAD) && deno run main.ts $REV && echo $REV
```

### 取反退出码

要取反退出码，请在命令前添加感叹号和空格：

```sh
# 将退出码从 1 改为 0
! deno eval 'Deno.exit(1);'
```

### 重定向

重定向提供了一种将标准输出和/或标准错误管道到文件的方法。

例如，以下命令将 `deno run main.ts` 的 _标准输出_ 重定向到文件系统中的 `file.txt`：

```sh
deno run main.ts > file.txt
```

要重定向 _标准错误_，请使用 `2>`：

```sh
deno run main.ts 2> file.txt
```

要同时重定向标准输出 _和_ 标准错误，请使用 `&>`：

```sh
deno run main.ts &> file.txt
```

要追加到文件，而不是覆盖现有文件，请使用两个右尖括号而不是一个：

```sh
deno run main.ts >> file.txt
```

抑制命令的标准输出、标准错误或两者的可能性，通过重定向到 `/dev/null`。这在包含 Windows 的跨平台方式下有效。

```sh
# 抑制标准输出
deno run main.ts > /dev/null
# 抑制标准错误
deno run main.ts 2> /dev/null
# 同时抑制标准输出和标准错误
deno run main.ts &> /dev/null
```

或者将标准输出重定向到标准错误，反之亦然：

```sh
# 将标准输出重定向到标准错误
deno run main.ts >&2
# 将标准错误重定向到标准输出
deno run main.ts 2>&1
```

输入重定向也被支持：

```sh
# 将 file.txt 重定向到 gzip 的标准输入
gzip < file.txt
```

请注意，当前不支持多重重定向。

### 跨平台 Shebang

从 Deno 1.42 开始，`deno task` 将以相同的方式执行以 `#!/usr/bin/env -S` 开头的脚本，适用于所有平台。

例如：

```ts title="script.ts"
#!/usr/bin/env -S deno run
console.log("Hello there!");
```

```json title="deno.json"
{
  "tasks": {
    "hi": "./script.ts"
  }
}
```

然后在 Windows 机器上：

```sh
> pwd
C:\Users\david\dev\my_project
> deno task hi
Hello there!
```

### Glob 扩展

在 Deno 1.34 及以上版本中支持 glob 扩展。这允许以跨平台方式指定 glob 来匹配文件。

```console
# 匹配当前及其子目录中的 .ts 文件
echo **/*.ts
# 匹配当前目录中的 .ts 文件
echo *.ts
# 匹配以 "data" 开头，后跟一个数字，然后以 .csv 结尾的文件
echo data[0-9].csv
```

支持的 glob 字符包括 `*`、`?` 和 `[`/`]`。

## 内置命令

`deno task` 附带多个内置命令，在 Windows、Mac 和 Linux 上默认工作相同。

- [`cp`](https://man7.org/linux/man-pages/man1/cp.1.html) - 复制文件。
- [`mv`](https://man7.org/linux/man-pages/man1/mv.1.html) - 移动文件。
- [`rm`](https://man7.org/linux/man-pages/man1/rm.1.html) - 删除文件或目录。
  - 例如: `rm -rf [FILE]...` - 通常用于递归删除文件或目录。
- [`mkdir`](https://man7.org/linux/man-pages/man1/mkdir.1.html) - 创建目录。
  - 例如. `mkdir -p DIRECTORY...` - 通常用于创建目录及其所有父级，且如果已存在则不报错。
- [`pwd`](https://man7.org/linux/man-pages/man1/pwd.1.html) - 打印当前/工作目录的名称。
- [`sleep`](https://man7.org/linux/man-pages/man1/sleep.1.html) - 延迟指定时间。
  - 例如. `sleep 1` 以暂停 1 秒，`sleep 0.5` 以暂停半秒，或者 `sleep 1m` 以暂停一分钟。
- [`echo`](https://man7.org/linux/man-pages/man1/echo.1.html) - 显示一行文本。
- [`cat`](https://man7.org/linux/man-pages/man1/cat.1.html) - 连接文件并将其输出到标准输出。没有提供参数时读取和输出标准输入。
- [`exit`](https://man7.org/linux/man-pages/man1/exit.1p.html) - 导致 shell 退出。
- [`head`](https://man7.org/linux/man-pages/man1/head.1.html) - 输出文件的第一部分。
- [`unset`](https://man7.org/linux/man-pages/man1/unset.1p.html) - 取消设置环境变量。
- [`xargs`](https://man7.org/linux/man-pages/man1/xargs.1p.html) - 从标准输入构建参数并执行命令。

如果您发现缺少某个命令的有用标志或有任何应该支持的其他命令的建议，请
[报告问题](https://github.com/denoland/deno_task_shell/issues) 到
[deno_task_shell](https://github.com/denoland/deno_task_shell/) 仓库。

请注意，如果您希望通过非跨平台方式在 Mac 或 Linux 上执行任何这些命令，则可以通过 `sh` 运行它：`sh -c <command>`（例如 `sh -c cp source destination`）。

## package.json 支持

如果发现 `deno task` 将回退到读取 package.json 文件中的 `"scripts"` 条目。请注意，Deno 不尊重或支持任何 npm 生命周期事件，如 `preinstall` 或 `postinstall`——您必须显式运行您想要执行的脚本条目（例如：
`deno install --entrypoint main.ts && deno task postinstall`）。


---

# deno test

> Run tests for your project with Deno's built-in test runner

URL: https://docs.deno.com/runtime/reference/cli/test


## 额外信息

它可以在观察模式下执行（`--watch`），支持并行执行（`--parallel`），并且可以配置为以随机顺序运行测试（`--shuffle`）。此外，还内置了代码覆盖率支持（`--coverage`）和泄漏检测（`--trace-leaks`）。

## 示例

运行测试

```bash
deno test
```

在特定文件中运行测试

```bash
deno test src/fetch_test.ts src/signal_test.ts
```

在 glob 匹配的情况下运行测试

```bash
deno test src/*.test.ts
```

运行测试，并跳过类型检查

```bash
deno test --no-check
```

运行测试，在文件更改时重新运行

```bash
deno test --watch
```

---

# runtime/reference/cli/types.md

URL: https://docs.deno.com/runtime/reference/cli/types

---
title: "deno types"
oldUrl: /runtime/manual/tools/types/
command: types
openGraphLayout: "/open_graph/cli-commands.jsx"
openGraphTitle: "deno types"
description: "Generate TypeScript types from your code"
---

---

# deno uninstall

> Remove a dependency from your project or from your global cache

URL: https://docs.deno.com/runtime/reference/cli/uninstall


## `deno uninstall [PACKAGES]`

移除在 `deno.json` 或 `package.json` 中指定的依赖：

```shell
$ deno add npm:express
添加 npm:express@5.0.0

$ cat deno.json
{
  "imports": {
    "express": "npm:express@5.0.0"
  }
}
```

```shell
$ deno uninstall express
已移除 express

$ cat deno.json
{
  "imports": {}
}
```

:::tip

你也可以使用 `deno remove`，这是 `deno uninstall [PACKAGES]` 的别名。

:::

你可以一次性移除多个依赖：

```shell
$ deno add npm:express jsr:@std/http
添加 npm:express@5.0.0
添加 jsr:@std/http@1.0.7

$ cat deno.json
{
  "imports": {
    "@std/http": "jsr:@std/http@^1.0.7",
    "express": "npm:express@^5.0.0"
  }
}
```

```shell
$ deno remove express @std/http
已移除 express
已移除 @std/http

$ cat deno.json
{
  "imports": {}
}
```

:::info

虽然依赖已经从 `deno.json` 和 `package.json` 中移除，但它们仍然保留在全局缓存中以供将来使用。

:::

如果你的项目包含 `package.json`，`deno uninstall` 也可以与之一起工作：

```shell
$ cat package.json
{
  "dependencies": {
    "express": "^5.0.0"
  }
}

$ deno remove express
已移除 express

$ cat package.json
{
  "dependencies": {}
}
```

## `deno uninstall --global [SCRIPT_NAME]`

卸载 `serve`

```bash
deno uninstall --global serve
```

从特定的安装根目录卸载 `serve`

```bash
deno uninstall -g --root /usr/local/bin serve
```

---

# 不稳定功能标志

URL: https://docs.deno.com/runtime/reference/cli/unstable_flags


Deno 运行时的新功能通常会在功能标志后发布，因此用户可以在功能最终确定之前尝试新的 API 和功能。当前的不稳定功能标志列在此页面上，也可以通过运行以下命令在 CLI 帮助文本中找到：

```sh
deno --help
```

## 在命令行中使用标志

您可以通过将标志作为选项传递给 CLI 来在从命令行运行 Deno 程序时启用功能标志。以下是启用 `--unstable-node-globals` 标志运行程序的示例：

```sh
deno run --unstable-node-globals main.ts
```

## 在 `deno.json` 中配置标志

您可以使用 [`deno.json`](/runtime/fundamentals/configuration/) 中的配置选项指定要为项目启用的哪些不稳定功能。

```json title="deno.json"
{
  "unstable": ["bare-node-builtins", "webgpu"]
}
```

`unstable` 数组中的可能值是标志名称，去掉了 `--unstable-` 前缀。

## 通过环境变量配置

有些标志可以通过为特定名称的环境变量设置一个值（任何值）来启用，而不是作为标志或 `deno.json` 配置选项传递。可以通过环境变量设置的标志将在下面进行说明。

以下是通过环境变量设置 `--unstable-bare-node-builtins` 标志的示例：

```sh
export DENO_UNSTABLE_BARE_NODE_BUILTINS=true
```

## `--unstable-bare-node-builtins`

**环境变量：** `DENO_UNSTABLE_BARE_NODE_BUILTINS`

此标志允许您
[导入 Node.js 内置模块](/runtime/fundamentals/node/#node-built-in-modules)
而不使用 `node:` 说明符，如下面的示例所示。您还可以使用此标志在手动管理 Node.js 依赖项时启用 npm 包，而不使用 `npm:` 说明符（[参见 `byonm` 标志](#--unstable-byonm)）。

```ts title="example.ts"
import { readFileSync } from "fs";

console.log(readFileSync("deno.json", { encoding: "utf8" }));
```

## `--unstable-detect-cjs`

**环境变量：** `DENO_UNSTABLE_DETECT_CJS`

在以下附加场景中，将 `.js`、`.jsx`、`.ts` 和 `.tsx` 模块加载为可能的 CommonJS：

1. _package.json_ 没有 `"type"` 字段。
2. 不存在 _package.json_。

默认情况下，Deno 仅在您处于具有 _package.json_ 且最近的 _package.json_ 拥有 `{ "type": "commonjs" }` 时，将这些模块加载为可能的 CommonJS。

需要 Deno >= 2.1.2

## `--unstable-node-globals`

此标志将 Node 特定的全局变量注入到全局作用域中。注入的全局变量包括：

- `Buffer`
- `global`
- `setImmediate`
- `clearImmediate`

请注意，从 Deno 2.0 开始，`process` 已作为全局变量可用。

需要 Deno >= 2.1.0

## `--unstable-sloppy-imports`

**环境变量：** `DENO_UNSTABLE_SLOPPY_IMPORTS`

此标志启用一种行为，推断导入中缺少的文件扩展名。通常，下面的导入语句将产生错误：

```ts title="foo.ts"
import { Example } from "./bar";
console.log(Example);
```

```ts title="bar.ts"
export const Example = "Example";
```

在启用不严格导入的情况下执行脚本将消除错误，但会提供指导，建议使用更高效的语法。

不严格导入将允许（但会打印警告）以下内容：

- 从导入中省略文件扩展名
- 使用不正确的文件扩展名（例如，当实际文件为 `.ts` 时，使用 `.js` 扩展名导入）
- 导入目录路径，并自动使用 `index.js` 或 `index.ts` 作为该目录的导入

[`deno compile`](/runtime/reference/cli/compile/) 不支持不严格导入。

## `--unstable-unsafe-proto`

Deno 出于安全原因做出了不支持 `Object.prototype.__proto__` 的明确决定。然而，仍然有许多依赖于此属性正常工作的 npm 包。

此标志启用此属性。请注意，不建议使用此选项，但如果您确实需要使用依赖于它的包，现在可以使用解除限制的功能。

## `--unstable-webgpu`

在全局作用域中启用 [`WebGPU` API](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API)，类似于浏览器。以下是使用此 API 获取 GPU 基本信息的简单示例：

```ts
// 尝试从用户代理获取适配器。
const adapter = await navigator.gpu.requestAdapter();
if (adapter) {
  // 打印适配器的一些基本信息。
  const adapterInfo = await adapter.requestAdapterInfo();

  // 在某些系统上，这将是空白...
  console.log(`找到适配器: ${adapterInfo.device}`);

  // 打印 GPU 功能列表
  const features = [...adapter.features.values()];
  console.log(`支持的功能: ${features.join(", ")}`);
} else {
  console.error("未找到适配器");
}
```

查看 [这个仓库](https://github.com/denoland/webgpu-examples) 获取更多使用 WebGPU 的示例。

## `--unstable-broadcast-channel`

启用此标志将使 [`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) Web API 可在全局作用域中使用，类似于浏览器。

## `--unstable-worker-options`

启用不稳定的 [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) API 选项。具体而言，它允许您指定可用的权限给工作者：

```ts
new Worker(`data:application/javascript;base64,${btoa(`postMessage("ok");`)}`, {
  type: "module",
  deno: {
    permissions: {
      read: true,
    },
  },
}).onmessage = ({ data }) => {
  console.log(data);
};
```

## `--unstable-cron`

启用此标志将使 [`Deno.cron`](/deploy/kv/manual/cron) API 可用于 `Deno` 命名空间。

## `--unstable-kv`

启用此标志将使 [Deno KV](/deploy/kv/manual) API 可用于 `Deno` 命名空间。

## `--unstable-net`

在 `Deno` 命名空间中启用不稳定网络 API。这些 API 包括：

- [`WebSocketStream`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocketStream)
- [`Deno.DatagramConn`](https://docs.deno.com/api/deno/~/Deno.DatagramConn)

## `--unstable-otel`

启用 [OpenTelemetry 集成用于 Deno](/runtime/fundamentals/open_telemetry)。此功能现在已稳定，因此在 [Deno 2.4](https://deno.com/blog/v2.4)+ 中不再需要此标志。

## `--unstable`

:::caution

**`--unstable` 已被弃用 - 请改用更细粒度的标志。**

`--unstable` 标志不再用于新功能，并将在未来的版本中移除。通过此标志可以使用的所有不稳定功能现在都作为独立的不稳定标志可用，特别是：

- `--unstable-kv`
- `--unstable-cron`

请在今后使用这些功能标志。

:::

在较早的 Deno 版本（1.38+）之前，不稳定 API 是通过 `--unstable` 标志一次性提供的。值得注意的是，[Deno KV](/deploy/kv/manual) 和其他云原语 API 是通过此标志提供的。要运行一个具有访问这些不稳定功能的程序，您可以运行你的脚本：

```sh
deno run --unstable your_script.ts
```

建议您改用更细粒度的不稳定标志，`--unstable` 标志现已弃用，并将在 Deno 2 中被移除。

## `--unstable-temporal`

启用全局作用域中的实验性 [Temporal API](https://tc39.es/proposal-temporal/docs/)。Temporal API 是正在开发中的现代日期和时间 API，旨在替代 JavaScript 中的传统 `Date` 对象。它提供了更好的时区、日历支持以及更精确的日期/时间计算。

要在 Deno 程序中使用 Temporal API，请使用以下标志运行：

```sh
deno run --unstable-temporal your_script.ts
```

或在您的 `deno.json` 中配置：

```json title="deno.json"
{
  "unstable": ["temporal"]
}
```

```ts title="example.ts"
// 使用 Temporal API 的示例
const now = Temporal.Now.plainDateTimeISO();
console.log(`当前日期和时间: ${now}`);

const date = Temporal.PlainDate.from("2025-07-10");
const nextWeek = date.add({ days: 7 });
console.log(`下一周: ${nextWeek}`);

// 处理时区
const zonedDateTime = Temporal.Now.zonedDateTimeISO("America/New_York");
console.log(`纽约时间: ${zonedDateTime}`);
```

请注意，Temporal API 仍处于实验阶段，规范可能在稳定之前发生变化。仅用于测试和试验目的使用此标志。

---

# deno update

> 通过交互式 CLI 更新过时的依赖项

URL: https://docs.deno.com/runtime/reference/cli/update


## 更新依赖项

默认情况下，`update` 子命令只会更新到符合 semver 兼容的版本（即不会更新到破坏性版本）。

```bash
$ deno update
更新了 1 个依赖项：
 - jsr:@std/fmt 1.0.0 -> 1.0.3
```

如果要更新到最新版本（无论是否符合 semver 兼容），请添加 `--latest` 标志。

```bash
$ deno update --latest
更新了 3 个依赖项：
 - jsr:@std/async 1.0.1 -> 1.0.8
 - jsr:@std/fmt   1.0.0 -> 1.0.3
 - npm:chalk      4.1.2 -> 5.3.0
```

## 选择包

`update` 子命令也支持选择要操作的包。

```bash
$ deno update --latest chalk
更新了 1 个依赖项：
 - npm:chalk 4.1.2 -> 5.3.0
```

可以传入多个选择器，并且支持通配符 (`*`) 和排除 (`!`)。

例如，要更新所有带有 `@std` 作用域的包，除了 `@std/fmt`：

```bash
$ deno update --latest "@std/*" "!@std/fmt"
更新了 1 个依赖项：
 - jsr:@std/async 1.0.1 -> 1.0.8
```

注意，如果使用通配符，通常需要用引号将参数括起来，以防止 shell 尝试展开它们。

### 更新到特定版本

除了选择要更新的包之外，`--update` 标志还支持选择新的 _版本_，通过在版本号前添加 `@` 指定。

```bash
❯ deno update chalk@5.2 @std/async@1.0.6
更新了 2 个依赖项：
 - jsr:@std/async 1.0.1 -> 1.0.6
 - npm:chalk      4.1.2 -> 5.2.0
```

## 工作区

在工作区环境中，默认情况下，`update` 只会操作 _当前_ 工作区成员。

例如，给定如下工作区：

```json
{
  "workspace": ["./member-a", "./member-b"]
}
```

从 `./member-a` 目录运行

```bash
deno update
```

将只更新 `./member-a/deno.json` 或 `./member-a/package.json` 中列出的依赖项。

要包含所有工作区成员，请传入 `--recursive` 标志（也接受 `-r` 简写）

```bash
deno update --recursive
deno update --latest -r
```

---

# deno 升级

> 将 Deno 升级到最新版本，或升级到指定版本

URL: https://docs.deno.com/runtime/reference/cli/upgrade


## 示例

### 升级到最新版本

使用此命令且不带任何选项即可将 Deno 升级到可用的最新版本：

```shell
$ deno upgrade
Checking for latest version
Version has been found
Deno is upgrading to version 1.38.5
downloading https://github.com/denoland/deno/releases/download/v1.38.5/deno-x86_64-apple-darwin.zip
downloading 100%
Upgrade done successfully
```

### 升级到指定版本

你可以指定要升级到的特定版本：

```shell
$ deno upgrade --version 1.37.0
Checking for version 1.37.0
Version has been found
Deno is upgrading to version 1.37.0
downloading https://github.com/denoland/deno/releases/download/v1.37.0/deno-x86_64-apple-darwin.zip
downloading 100%
Upgrade done successfully
```

### 检查可用升级但不安装

使用 `--dry-run` 标志可以查看将会升级到哪个版本，而不实际进行升级：

```shell
$ deno upgrade --dry-run
Checking for latest version
Version has been found
Would upgrade to version 1.38.5
```

## --quiet 标志

`--quiet` 标志在升级过程中抑制诊断输出。用在 `deno upgrade` 时，它将隐藏进度指示、下载信息和成功消息。

```shell
$ deno upgrade --quiet
```

这对于脚本环境或在 CI 流水线中想要更简洁的输出非常有用。

## Canary 构建

默认情况下，Deno 会从官方的 GitHub 发行版升级。你可以使用 `--canary` 构建标志来升级到最新的 canary 版本：

```shell
# 升级到最新的 canary 构建
$ deno upgrade --canary
```

---

# Continuous integration

> Guide to setting up continuous integration (CI) pipelines for Deno projects. Learn how to configure GitHub Actions workflows, run tests and linting in CI, handle cross-platform builds, and optimize pipeline performance with caching.

URL: https://docs.deno.com/runtime/reference/continuous_integration


Deno 的内置工具使得为您的项目设置持续集成（CI）管道变得简单。您可以使用相应的命令 `deno test`、`deno lint` 和 `deno fmt` 对您的代码进行 [测试](/runtime/fundamentals/testing)、[代码检查和格式化](/runtime/fundamentals/linting_and_formatting/)。此外，您还可以在管道中使用 `deno coverage` 从测试结果中生成代码覆盖率报告。

## 设置基本管道

您可以在 GitHub Actions 中为 Deno 项目设置基本管道。本页面上解释的概念在其他 CI 提供商中也适用，例如 Azure Pipelines、CircleCI 或 GitLab。

为 Deno 构建管道通常从签出代码库和安装 Deno 开始：

```yaml
name: Build

on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x # 使用最新的稳定版 Deno 运行。
```

要扩展工作流程，添加您可能需要的任何 `deno` 子命令：

```yaml
# 检查代码是否按照 Deno 的默认格式化约定进行格式化。
- run: deno fmt --check

# 扫描代码中的语法错误和风格问题。如果
# 您想使用自定义的 linter 配置，可以使用 --config <myconfig> 添加配置文件。
- run: deno lint

# 运行代码库中的所有测试文件并收集代码覆盖率。示例
# 使用所有权限运行，但建议使用您的程序所需的最小权限运行（例如 --allow-read）。
- run: deno test --allow-all --coverage=cov/

# 这会从 `deno test --coverage` 中收集的覆盖率生成报告。它会
# 存储为 .lcov 文件，可以很好地与像 Codecov、Coveralls 和 Travis CI 这样的服务集成。
- run: deno coverage --lcov cov/ > cov.lcov
```

## 跨平台工作流程

作为 Deno 模块的维护者，您可能希望知道您的代码是否在今天使用的所有主要操作系统上运行正常：Linux、MacOS 和 Windows。通过运行一个并行作业的矩阵，可以实现跨平台工作流程，每个作业在不同的操作系统上运行构建：

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - run: deno test --allow-all --coverage cov/
```

:::caution

注意：GitHub Actions 在处理 Windows 风格的行结束符（CRLF）时存在一个已知 [问题](https://github.com/actions/checkout/issues/135)。这可能导致在管道中运行 `deno fmt` 时出现问题，而该管道的作业在 `windows` 上运行。为防止此情况发生，请在运行 `actions/checkout@v4` 步骤之前，将 Actions 运行器配置为使用 Linux 风格的行结束符：

```sh
git config --system core.autocrlf false
git config --system core.eol lf
```

:::

如果您正在使用实验性或不稳定的 Deno API，可以添加一个矩阵作业来运行 Deno 的金丝雀版本。这可以帮助及早发现重大更改：

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.canary }} # 如果金丝雀运行不成功，则继续
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        deno-version: [v1.x]
        canary: [false]
        include:
          - deno-version: canary
            os: ubuntu-latest
            canary: true
```

## 加速 Deno 管道

### 减少重复

在跨平台运行中，管道的某些步骤并不一定需要针对每个操作系统运行。例如，在 Linux、MacOS 和 Windows 上生成相同的测试覆盖率报告是有点冗余的。在这些情况下，您可以使用 GitHub Actions 的 `if` 条件关键字。下面的示例展示了如何仅在 `ubuntu`（Linux）运行器上运行代码覆盖率生成和上传步骤：

```yaml
- name: Generate coverage report
  if: matrix.os == 'ubuntu-latest'
  run: deno coverage --lcov cov > cov.lcov

- name: Upload coverage to Coveralls.io
  if: matrix.os == 'ubuntu-latest'
  # 可以使用任何代码覆盖率服务，Coveralls.io 这里作为示例使用。
  uses: coverallsapp/github-action@master
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }} # 由 GitHub 生成。
    path-to-lcov: cov.lcov
```

### 缓存依赖

随着项目规模的扩大，通常会包含越来越多的依赖。Deno 在测试期间会下载这些依赖，如果一个工作流程一天运行多次，这可能会变得耗时。加快速度的一个常见解决方案是缓存依赖，这样就不需要重新下载。

Deno 将依赖项存储在本地缓存目录中。在管道中，可以通过在 `denoland/setup-deno` 上启用 `cache: true` 选项来保留工作流之间的缓存。

```yaml
steps:
  - uses: actions/checkout@v4
  - uses: denoland/setup-deno@v2
    with:
      cache: true
```

最初，当这个工作流程运行时，缓存仍然是空的，像 `deno test` 这样的命令仍然需要下载依赖项，但当作业成功时，缓存的依赖项内容会被保存，任何后续运行都可以从缓存中恢复它们，而不是重新下载。

为了演示，假设你有一个使用来自 [`@std/log`](https://jsr.io/@std/log) 的日志记录器的项目：

```json, title="deno.json"
{
  "imports": {
    "@std/log": "jsr:@std/log@0.224.5"
  }
}
```

为了增加这个版本，您可以更新依赖项，然后重新加载缓存并在本地更新锁定文件：

```console
deno install --reload --frozen=false
```

您应该在运行此操作后看到锁定文件内容的变化。当这个更改被提交并通过管道运行时，您应该看到一个新的缓存，并在随后的任何运行中使用它。

默认情况下，缓存会自动根据以下内容生成键：

- github [job_id](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#jobsjob_id)
- 运行器的操作系统和架构
- 项目中 `deno.lock` 文件的哈希值

可以通过 `cache-hash` 输入自定义作为缓存键一部分的默认哈希（`${{ hashFiles('**/deno.lock') }}`）。

```yaml
- uses: denoland/setup-deno@v2
  with:
    # setting `cache-hash` implies `cache: true` and will replace
    # the default cache-hash of `${{ hashFiles('**/deno.lock') }}`
    cache-hash: ${{ hashFiles('**/deno.json') }}
```

---

# Deno 命名空间 API

> Deno 内置运行时 API 指南。了解通过全局 Deno 命名空间提供的文件系统操作、网络功能、权限管理及其他核心能力。

URL: https://docs.deno.com/runtime/reference/deno_namespace_apis


此页面已迁移至 [/api/deno/](/api/deno/)。

---

# Create working directory

> Complete guide to using Deno with Docker containers. Learn about official Deno images, writing Dockerfiles, multi-stage builds, workspace containerization, and Docker best practices for Deno applications.

URL: https://docs.deno.com/runtime/reference/docker


## Using Deno with Docker

Deno provides [official Docker files](https://github.com/denoland/deno_docker)
and [images](https://hub.docker.com/r/denoland/deno).

To use the official image, create a `Dockerfile` in your project directory:

```dockerfile
FROM denoland/deno:latest

# Create working directory
WORKDIR /app

# Copy source
COPY . .

# Compile the main app
RUN deno cache main.ts

# Run the app
CMD ["deno", "run", "--allow-net", "main.ts"]
```

### Best Practices

#### Use Multi-stage Builds

For smaller production images:

```dockerfile
# Build stage
FROM denoland/deno:latest AS builder
WORKDIR /app
COPY . .
RUN deno cache main.ts

# Production stage
FROM denoland/deno:latest
WORKDIR /app
COPY --from=builder /app .
CMD ["deno", "run", "--allow-net", "main.ts"]
```

#### Permission Flags

Specify required permissions explicitly:

```dockerfile
CMD ["deno", "run", "--allow-net=api.example.com", "--allow-read=/data", "main.ts"]
```

#### Development Container

For development with hot-reload:

```dockerfile
FROM denoland/deno:latest

WORKDIR /app
COPY . .

CMD ["deno", "run", "--watch", "--allow-net", "main.ts"]
```

### Common Issues and Solutions

1. **Permission Denied Errors**
   - Use `--allow-*` flags appropriately
   - Consider using `deno.json` permissions

2. **Large Image Sizes**
   - Use multi-stage builds
   - Include only necessary files
   - Add proper `.dockerignore`

3. **Cache Invalidation**
   - Separate dependency caching
   - Use proper layer ordering

### Example .dockerignore

```text
.git
.gitignore
Dockerfile
README.md
*.log
_build/
node_modules/
```

### Available Docker Tags

Deno provides several official tags:

- `denoland/deno:latest` - Latest stable release
- `denoland/deno:alpine` - Alpine-based smaller image
- `denoland/deno:distroless` - Google's distroless-based image
- `denoland/deno:ubuntu` - Ubuntu-based image
- `denoland/deno:1.x` - Specific version tags

### Environment Variables

Common environment variables for Deno in Docker:

```dockerfile
ENV DENO_DIR=/deno-dir/
ENV DENO_INSTALL_ROOT=/usr/local
ENV PATH=${DENO_INSTALL_ROOT}/bin:${PATH}

# Optional environment variables
ENV DENO_NO_UPDATE_CHECK=1
ENV DENO_NO_PROMPT=1
```

### Running Tests in Docker

```dockerfile
FROM denoland/deno:latest

WORKDIR /app
COPY . .

# Run tests
CMD ["deno", "test", "--allow-none"]
```

### Using Docker Compose

```yaml
// filepath: docker-compose.yml
version: "3.8"
services:
  deno-app:
    build: .
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    environment:
      - DENO_ENV=development
    command: ["deno", "run", "--watch", "--allow-net", "main.ts"]
```

### Health Checks

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s \
  CMD deno eval "try { await fetch('http://localhost:8000/health'); } catch { Deno.exit(1); }"
```

### Common Development Workflow

For local development:

1. Build the image: `docker build -t my-deno-app .`
2. Run with volume mount:

```bash
docker run -it --rm \
  -v ${PWD}:/app \
  -p 8000:8000 \
  my-deno-app
```

### Security Considerations

- Run as non-root user:

```dockerfile
# Create deno user
RUN addgroup --system deno && \
    adduser --system --ingroup deno deno

# Switch to deno user
USER deno

# Continue with rest of Dockerfile
```

- Use minimal permissions:

```dockerfile
CMD ["deno", "run", "--allow-net=api.example.com", "--allow-read=/app", "main.ts"]
```

- Consider using `--deny-*` flags for additional security

## Working with Workspaces in Docker

When working with Deno workspaces (monorepos) in Docker, there are two main
approaches:

### 1. Full Workspace Containerization

Include the entire workspace when you need all dependencies:

```dockerfile
FROM denoland/deno:latest

WORKDIR /app

# Copy entire workspace
COPY deno.json .
COPY project-a/ ./project-a/
COPY project-b/ ./project-b/

WORKDIR /app/project-a
CMD ["deno", "run", "-A", "mod.ts"]
```

### 2. Minimal Workspace Containerization

For smaller images, include only required workspace members:

1. Create a build context structure:

```sh
project-root/
├── docker/
│   └── project-a/
│       ├── Dockerfile
│       ├── .dockerignore
│       └── build-context.sh
├── deno.json
├── project-a/
└── project-b/
```

2. Create a `.dockerignore`:

```text
// filepath: docker/project-a/.dockerignore
*
!deno.json
!project-a/**
!project-b/**  # Only if needed
```

3. Create a build context script:

```bash
// filepath: docker/project-a/build-context.sh
#!/bin/bash

# Create temporary build context
BUILD_DIR="./tmp-build-context"
mkdir -p $BUILD_DIR

# Copy workspace configuration
cp ../../deno.json $BUILD_DIR/

# Copy main project
cp -r ../../project-a $BUILD_DIR/

# Copy only required dependencies
if grep -q "\"@scope/project-b\"" "../../project-a/mod.ts"; then
    cp -r ../../project-b $BUILD_DIR/
fi
```

4. Create a minimal Dockerfile:

```dockerfile
// filepath: docker/project-a/Dockerfile
FROM denoland/deno:latest

WORKDIR /app

# Copy only necessary files
COPY deno.json .
COPY project-a/ ./project-a/
# Copy dependencies only if required
COPY project-b/ ./project-b/

WORKDIR /app/project-a

CMD ["deno", "run", "-A", "mod.ts"]
```

5. Build the container:

```bash
cd docker/project-a
./build-context.sh
docker build -t project-a -f Dockerfile tmp-build-context
rm -rf tmp-build-context
```

### Best Practices

- Always include the root `deno.json` file
- Maintain the same directory structure as development
- Document workspace dependencies clearly
- Use build scripts to manage context
- Include only required workspace members
- Update `.dockerignore` when dependencies change


---

# Documentation Tests

> Learn how to write and run documentation tests in Deno. This guide covers how to create testable code examples in documentation comments, type-checking documentation, and running doc tests with the Deno test runner.

URL: https://docs.deno.com/runtime/reference/documentation


Deno 支持对文档示例进行类型检查和评估。

这确保了文档中的示例是最新的并且可以正常工作。

基本思想是这样的：

````ts
/**
 * # 示例
 *
 * ```ts
 * const x = 42;
 * ```
 */
````

三重反引号标记代码块的开始和结束，语言由语言标识符属性决定，该属性可以是以下任一项：

- `js`
- `javascript`
- `mjs`
- `cjs`
- `jsx`
- `ts`
- `typescript`
- `mts`
- `cts`
- `tsx`

如果未指定语言标识符，则语言从提取代码块的源文档的媒体类型推断。

另一个支持的属性是 `ignore`，它告诉测试运行器跳过对代码块的类型检查。

````ts
/**
 * # 不通过类型检查
 *
 * ```typescript ignore
 * const x: string = 42;
 * ```
 */
````

如果这个示例在一个名为 foo.ts 的文件中，运行 `deno test --doc foo.ts` 将提取这个示例，然后对其进行类型检查和评估，作为一个独立的模块，位于与正在文档化的模块相同的目录中。

要文档化你的导出，请使用相对路径说明符导入模块：

````ts
/**
 * # 示例
 *
 * ```ts
 * import { foo } from "./foo.ts";
 * ```
 */
export function foo(): string {
  return "foo";
}
````
有关 Deno 中测试的更多指南，请查看：

- [基本测试教程](/examples/testing_tutorial/)
- [测试中的数据模拟教程](/examples/mocking_tutorial/)
- [Web 应用程序测试教程](/examples/web_testing_tutorial/)


---

# 环境变量

> Deno 中使用环境变量的指南。了解 Deno.env API、.env 文件支持、CLI 配置以及控制 Deno 行为的特殊环境变量。

URL: https://docs.deno.com/runtime/reference/env_variables


在 Deno 中使用环境变量有几种方式：

## 内置 Deno.env 方法

Deno 运行时提供了对环境变量的内置支持，通过
[`Deno.env`](https://docs.deno.com/api/deno/~/Deno.env)。

`Deno.env` 具有获取和设置方法。以下是示例用法：

```ts
Deno.env.set("FIREBASE_API_KEY", "examplekey123");
Deno.env.set("FIREBASE_AUTH_DOMAIN", "firebasedomain.com");

console.log(Deno.env.get("FIREBASE_API_KEY")); // examplekey123
console.log(Deno.env.get("FIREBASE_AUTH_DOMAIN")); // firebasedomain.com
console.log(Deno.env.has("FIREBASE_AUTH_DOMAIN")); // true
```

## .env 文件

Deno 也支持 `.env` 文件。您可以通过 `--env-file` 标志告诉 Deno 从 `.env` 中读取环境变量，例如：

```sh
deno run --env-file main.ts
```

这将从当前工作目录或包含 `.env` 文件的第一个父目录中读取 `.env` 文件。如果要从不同的文件加载环境变量，可以将该文件作为标志参数指定。

您可以传递多个 `--env-file` 标志（例如，
`deno run --env-file=.env.one --env-file=.env.two --allow-env <script>`）以从多个文件加载变量。

:::note

当单个 `.env` 文件内存在多个相同环境变量的声明时，将应用第一个出现的声明。然而，如果同一变量在多个 `.env` 文件中定义（使用多个 `--env-file` 参数），则最后一个指定文件中的值将优先。这意味着在最后列出的 `.env` 文件中的第一个出现将被应用。

:::

另外，标准库中的 `dotenv` 包也将从 `.env` 加载环境变量。

假设您有一个 `.env` 文件，如下所示：

```sh
GREETING="Hello, world."
```

导入 `load` 模块以自动从 `.env` 文件导入到进程环境中。

```ts
import "jsr:@std/dotenv/load";

console.log(Deno.env.get("GREETING")); // "Hello, world."
```

有关 `.env` 处理的更多文档可以在
[@std/dotenv](https://jsr.io/@std/dotenv/doc) 文档中找到。

## 在运行命令时设置变量

与其他 CLI 命令一样，您可以在运行命令之前设置环境变量，如下所示：

```shell
MY_VAR="my value" deno run main.ts
```

当您想根据环境变量更改任务时，这可能是有用的，并且可以与
[`deno task`](/runtime/reference/cli/task/) 命令结合使用，如下所示：

```jsonc title="deno.json"
{

  ...
  
  "tasks": {
    "build:full": {
      "description": "Build the site with all features",
      "command": "BUILD_TYPE=FULL deno run main.ts"
    },
    "build:light": {
      "description": "Build the site without expensive operations",
      "command": "BUILD_TYPE=LIGHT deno run main.ts"
    }
  }
}
```

## `std/cli`

Deno 标准库具有 [`std/cli` 模块](https://jsr.io/@std/cli) 用于解析命令行参数。有关文档和示例，请参考该模块。

## 特殊环境变量

Deno 运行时具有以下特殊环境变量。

| 名称                 | 描述                                                                                                                                                                       |
| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DENO_AUTH_TOKENS     | 用于从私有存储库获取远程模块时要使用的以分号分隔的 bearer 令牌和主机名列表<br />(例如 `abcde12345@deno.land;54321edcba@github.com`) |
| DENO_TLS_CA_STORE    | 以逗号分隔的顺序相关证书存储列表.<br />可能的值：`system`，`mozilla`。默认为 `mozilla`。                                                                                     |
| DENO_CERT            | 从 PEM 编码文件加载证书颁发机构                                                                                                                                      |
| DENO_COVERAGE_DIR    | 设置收集覆盖率分析数据的目录。此选项仅适用于 [`deno test` 子命令](/runtime/reference/cli/test/)。                                        |
| DENO_DIR             | 设置缓存目录                                                                                                                                                           |
| DENO_INSTALL_ROOT    | 设置 deno 安装的输出目录（默认为 `$HOME/.deno/bin`）                                                                                                               |
| DENO_REPL_HISTORY    | 设置 REPL 历史文件路径，当值为空时禁用历史文件<br />(默认为 `$DENO_DIR/deno_history.txt`)                                                                         |
| DENO_NO_PACKAGE_JSON | 禁用 `package.json` 的自动解析                                                                                                                                     |
| DENO_NO_PROMPT       | 设置以禁用访问时的权限提示<br />(作为调用时传递 `--no-prompt` 的替代)                                                                                             |
| DENO_NO_UPDATE_CHECK | 设置以禁用检查是否有更新的 Deno 版本                                                                                                                                |
| DENO_V8_FLAGS        | 设置 V8 命令行选项                                                                                                                                                    |
| DENO_JOBS            | 用于 `--parallel` 标志与测试子命令的并行工作者数量.<br />默认为可用 CPU 的数量。                                                                                        |
| DENO_WEBGPU_TRACE    | 使用 WebGPU API 时输出 [WGPU 追踪](https://github.com/gfx-rs/wgpu/pull/619) 的目录路径                                                                                 |
| DENO_WEBGPU_BACKEND  | 选择 WebGPU 将使用的后端，或按优先顺序列出的逗号分隔的后端列表。可能的值为 `vulkan`，`dx12`，`metal` 或 `opengl`。                                                   |
| HTTP_PROXY           | HTTP 请求的代理地址（模块下载，提取）                                                                                                                                  |
| HTTPS_PROXY          | HTTPS 请求的代理地址（模块下载，提取）                                                                                                                                 |
| NPM_CONFIG_REGISTRY  | 用于 npm 注册表的 URL。                                                                                                                                                 |
| NO_COLOR             | 设置以禁用颜色                                                                                                                                                         |
| NO_PROXY             | 以逗号分隔的主机列表，表示不使用代理（模块下载，提取）                                                                                                                 |

---

# JSX

> Deno 中使用 JSX 的完整指南。了解 JSX 配置选项、自动运行时功能、开发转换，以及 Deno 为服务器端渲染优化的预编译转换。

URL: https://docs.deno.com/runtime/reference/jsx


Deno 内置支持 `.jsx` 文件和 `.tsx` 文件中的 JSX。Deno 中的 JSX 对于服务器端渲染或为浏览器生成代码非常有用。

## 默认配置

Deno CLI 对 JSX 有默认配置，这与 `tsc` 的默认配置不同。实际上，Deno 默认使用以下 [TypeScript 编译器](https://www.typescriptlang.org/docs/handbook/compiler-options.html) 选项：

```json title="deno.json"
{
  "compilerOptions": {
    "jsx": "react",
    "jsxFactory": "React.createElement",
    "jsxFragmentFactory": "React.Fragment"
  }
}
```

使用 `"react"` 选项时，将 JSX 转换为以下 JavaScript 代码：

```jsx
// 输入
const jsx = (
  <div className="foo">
    <MyComponent value={2} />
  </div>
);

// 输出:
const jsx = React.createElement(
  "div",
  { className: "foo" },
  React.createElement(MyComponent, { value: 2 }),
);
```

## JSX 自动运行时（推荐）

在 React 17 中，React 团队添加了他们所称之为 [新 JSX 转换](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)。这增强了 JSX 转换的 API，并提供了一种机制，可以自动添加相关的 JSX 导入，以便您无需手动添加。这是推荐使用 JSX 的方式。

要使用更新的 JSX 运行时转换，请在您的 `deno.json` 中更改编译器选项。

```json title="deno.json"
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  },
  "imports": {
    "react": "npm:react",
    "@types/react": "npm:@types/react"
  }
}
```

:::note install dependencies

当您手动向 `deno.json` 文件添加导入时，请记得运行
`deno install` 来下载安装和缓存依赖。

:::

幕后的 `jsxImportSource` 设置总是会向导入说明符追加一个
`/jsx-runtime`。

```js
// 此导入将被自动插入
import { jsx as _jsx } from "react/jsx-runtime";
```

使用 `"react-jsx"` 选项将 JSX 转换为以下 JavaScript 代码：

```jsx
// 输入
const jsx = (
  <div className="foo">
    <MyComponent value={2} />
  </div>
);

// 输出
import { jsx as _jsx } from "react/jsx-runtime";
const jsx = _jsx(
  "div",
  {
    className: "foo",
    children: _jsx(MyComponent, { value: 2 }),
  },
);
```

如果您希望使用 [Preact](https://preactjs.com/) 而不是 React，您可以相应地更新 `jsxImportSource` 值。

```diff title="deno.json"
  {
    "compilerOptions": {
      "jsx": "react-jsx",
-     "jsxImportSource": "react"
+     "jsxImportSource": "preact"
    },
    "imports": {
-     "react": "npm:react"
+     "preact": "npm:preact"
    }
  }
```

### 开发转换

将 `"jsx"` 选项设置为 `"react-jsxdev"` 而不是 `"react-jsx"` 将为每个 JSX 节点传递额外的调试信息。额外的信息包括每个 JSX 节点调用位置的文件路径、行号和列号。

这些信息通常在框架中用于增强开发期间的调试体验。在 React 中，这些信息用于增强堆栈跟踪，并显示组件在哪个位置被实例化，通常在 React 开发者工具浏览器扩展中显示。

使用 `"react-jsxdev"` 选项将 JSX 转换为以下 JavaScript 代码：

```jsx
// 输入
const jsx = (
  <div className="foo">
    <MyComponent value={2} />
  </div>
);

// 输出
import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
const _jsxFileName = "file:///input.tsx";
const jsx = _jsxDEV(
  "div",
  {
    className: "foo",
    children: _jsxDEV(
      MyComponent,
      {
        value: 2,
      },
      void 0,
      false,
      {
        fileName: _jsxFileName,
        lineNumber: 3,
        columnNumber: 5,
      },
      this,
    ),
  },
  void 0,
  false,
  {
    fileName: _jsxFileName,
    lineNumber: 1,
    columnNumber: 14,
  },
  this,
);
```

:::caution

仅在开发期间使用 `"react-jsxdev"`，不要在生产环境中使用。

:::

### 使用 JSX 导入源谕语

无论您是否为项目配置了 JSX 导入源，还是使用默认的“旧版”配置，您都可以向 `.jsx` 或 `.tsx` 模块添加 JSX 导入源谕语，并且 Deno 会尊重它。

`@jsxImportSource` 谕语需要位于模块的开头注释中。例如，要使用来自 esm.sh 的 Preact，您可以这样做：

```jsx
/** @jsxImportSource https://esm.sh/preact */

export function App() {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

### `jsxImportSourceTypes`

在某些情况下，库可能不提供类型。要指定类型，您可以使用 `@jsxImportSourceTypes` 谕语：

```jsx
/** @jsxImportSource npm:react@^18.3 */
/** @jsxImportSourceTypes npm:@types/react@^18.3 */

export function Hello() {
  return <div>Hello!</div>;
}
```

或者通过 _deno.json_ 中的 `jsxImportSourceTypes` 编译器选项进行指定：

```json title="deno.json"
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "npm:react@^18.3",
    "jsxImportSourceTypes": "npm:@types/react@^18.3"
  }
}
```

## JSX 预编译转换

Deno 附带了一种 [新 JSX 转换](https://deno.com/blog/v1.38#fastest-jsx-transform)，其针对服务器端渲染进行了优化。与其他 JSX 转换选项相比，它可能快 **7-20 倍**。区别在于，预编译转换静态分析您的 JSX，并在可能的情况下存储预编译的 HTML 字符串。这可以避免在创建 JSX 对象时消耗大量时间。

要使用预编译转换，请将 `jsx` 选项设置为 `"precompile"`。

```diff title="deno.json"
  {
    "compilerOptions": {
+     "jsx": "precompile",
      "jsxImportSource": "preact"
    },
    "imports": {
      "preact": "npm:preact"
    }
  }
```

为了防止代表 HTML 元素的 JSX 节点被预编译，您可以将它们添加到 `jsxPrecompileSkipElements` 设置中。

```diff title="deno.json"
  {
    "compilerOptions": {
      "jsx": "precompile",
      "jsxImportSource": "preact",
+     "jsxPrecompileSkipElements": ["a", "link"]
    },
    "imports": {
      "preact": "npm:preact"
    }
  }
```

:::note

`precompile` 转换与 [Preact](https://preactjs.com/) 或 [Hono](https://hono.dev/) 最为兼容。它在 React 中不支持。

:::

使用 `"precompile"` 选项将 JSX 转换为以下 JavaScript 代码：

```jsx
// 输入
const jsx = (
  <div className="foo">
    <MyComponent value={2} />
  </div>
);

// 输出:
import {
  jsx as _jsx,
  jsxTemplate as _jsxTemplate,
} from "npm:preact/jsx-runtime";
const $$_tpl_1 = [
  '<div class="foo">',
  "</div>",
];
function MyComponent() {
  return null;
}
const jsx = _jsxTemplate(
  $$_tpl_1,
  _jsx(MyComponent, {
    value: 2,
  }),
);
```
## 在服务器响应中渲染 JSX

在 Deno 中使用 JSX 进行服务器端渲染时，您需要将 JSX 组件转换为可以在响应中发送的 HTML 字符串。这在使用 Deno.serve 构建 Web 应用程序时特别有用。

### 使用 Preact 和 renderToString

对于 Preact 应用程序，您可以使用 `preact-render-to-string` 包：

```json title="deno.json"
{
  "compilerOptions": {
    "jsx": "precompile",
    "jsxImportSource": "preact"
  },
  "imports": {
    "preact": "npm:preact@^10.26.6",
    "preact-render-to-string": "npm:preact-render-to-string@^6.5.13"
  }
}
```

然后在你的服务器代码中：

```tsx title="server.tsx"
import { renderToString } from "preact-render-to-string";

const App = () => {
  return <h1>Hello world</h1>;
};

Deno.serve(() => {
  const html = `<!DOCTYPE html>${renderToString(<App />)}`;
  return new Response(html, {
    headers: { "Content-Type": "text/html; charset=utf-8" },
  });
});
```

这种方法与预编译转换配合良好，提供了最佳的服务器端渲染性能。

### 使用 React 的 renderToString

如果你使用 React 而不是 Preact，可以使用 React 自身的服务器渲染能力：

```json title="deno.json"
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react"
  },
  "imports": {
    "react": "npm:react@^18.2.0",
    "react-dom": "npm:react-dom@^18.2.0",
    "react-dom/server": "npm:react-dom@^18.2.0/server"
  }
}
```

在您的服务器代码中：

```tsx title="server.tsx"
import { renderToString } from "react-dom/server";

const App = () => {
  return <h1>Hello from React</h1>;
};

Deno.serve(() => {
  const html = `<!DOCTYPE html>${renderToString(<App />)}`;
  return new Response(html, {
    headers: { "Content-Type": "text/html; charset=utf-8" },
  });
});
```

使用这些配置，您的 Deno 服务器可以高效地将 JSX 组件渲染为 HTML 并将其提供给客户端。

---

# Lint Plugins

> Guide to creating and using custom lint plugins in Deno. Learn how to write custom lint rules, use selectors for AST matching, implement fixes, and test your plugins using Deno's lint plugin API.

URL: https://docs.deno.com/runtime/reference/lint_plugins


:::caution

这是一个实验性功能，要求 Deno 版本为 `2.2.0` 或更高。

插件 API 目前被标记为"不稳定"，因为它在未来可能会发生变化。

:::

内置的 linter 可以通过插件进行扩展，以添加自定义 lint 规则。

虽然 Deno 默认提供了[许多 lint 规则](/lint/)，但在某些情况下，您可能需要特别为您的项目量身定制的自定义规则——无论是为了捕捉特定上下文的问题，还是为了强制执行全公司的约定。

这就是 lint 插件 API 的用武之地。

lint 插件 API 有意模拟了
[ESLint API](https://eslint.org/docs/latest/extend/custom-rules)。虽然此 API
没有提供 100% 的兼容性，但如果您曾经编写过自定义
[ESLint](https://eslint.org/) 规则，那么现有的知识大部分可以重新利用。

插件通过 `deno.json` 中的 `lint.plugins` 设置加载。

该值是一个插件描述符数组。这些描述符可以是路径、`npm:`或
`jsr:` 描述符。

```json title="deno.json"
{
  "lint": {
    "plugins": ["./my-plugin.ts"]
  }
}
```

## 示例插件

插件始终具有相同的结构。它有一个默认导出，即您的插件对象。

:::info

Deno 为 lint 插件 API 提供了类型声明。

所有类型定义都在 `Deno.lint` 命名空间下可用。

:::

```ts title="my-plugin.ts"
const plugin: Deno.lint.Plugin = {
  // 您插件的名称。将在错误输出中显示
  name: "my-plugin",
  // 规则对象。属性名是规则名称，并且
  // 将在错误输出中显示。
  rules: {
    "my-rule": {
      // 在 `create(context)` 方法中放置您的逻辑。
      // 当文件被 lint 时会调用该方法。
      create(context) {
        // 返回一个 AST 访问者对象
        return {
          // 在这个示例中，我们禁止任何标识符被命名为 `_a`
          Identifier(node) {
            if (node.name === "_a") {
              // 报告一个 lint 错误，并附带自定义消息
              context.report({
                node,
                message: "应该是 _b",
                // 可选：提供一个修复，当用户运行 `deno lint --fix`
                // 时可以应用该修复
                fix(fixer) {
                  return fixer.replaceText(node, "_b");
                },
              });
            }
          },
        };
      },
    },
  },
};
export default plugin;
```

## 使用选择器匹配节点

如果您直接在普通 JavaScript 中编写代码来匹配特定节点，有时可能会变得有些乏味。有时，通过选择器表达此匹配逻辑会更容易，类似于 CSS 选择器。通过在返回的访问者对象中使用字符串作为属性名，我们可以指定一个自定义选择器。

```ts title="my-plugin.ts"
const plugin: Deno.lint.Plugin = {
  name: "my-plugin",
  rules: {
    "my-rule": {
      create(context) {
        return {
          // 选择器也可以使用。在这里我们检查
          // `require("...")` 调用。
          'CallExpression[callee.name="require"]'(node) {
            context.report({
              node,
              message: "请不要使用 require() 调用来加载模块",
            });
          },
        };
      },
    },
  },
};
export default plugin;
```

注意，如果匹配逻辑太复杂而无法仅用选择器表达，我们始终可以进一步在 JavaScript 中细化匹配。支持的选择器语法完整列表如下：

| 语法                       | 描述                                   |
| -------------------------- | ------------------------------------- |
| `Foo + Foo`                | 下一个兄弟选择器                      |
| `Foo > Bar`                | 子组合器                               |
| `Foo ~ Bar`                | 后续兄弟组合器                        |
| `Foo Bar`                  | 后代组合器                           |
| `Foo[attr]`                | 属性存在性                             |
| `Foo[attr.length < 2]`     | 属性值比较                             |
| `Foo[attr=/(foo\|bar)*/]` | 属性值正则检查                        |
| `:first-child`             | 第一个子元素伪类                     |
| `:last-child`              | 最后一个子元素伪类                   |
| `:nth-child(2n + 1)`       | 第 n 个子元素伪类                     |
| `:not(> Bar)`              | 非伪类                               |
| `:is(> Bar)`               | 是伪类                              |
| `:where(> Bar)`            | 位于伪类（与 `:is()` 相同）          |
| `:matches(> Bar)`          | 匹配伪类（与 `:is()` 相同）          |
| `:has(> Bar)`              | 有伪类                               |
| `IfStatement.test`         | 字段选择器 `.<field>`                |

还有一个 `:exit` 伪类，仅在整个选择器的末尾有效。当它存在时，Deno 会在向上遍历树时调用该函数，而不是向下遍历时。

:::tip

我们强烈建议在开发 lint 规则时使用
[typescript-eslint playground](https://typescript-eslint.io/play/)。它允许您检查代码和生成的 AST 格式。这使得更容易看到哪个选择器匹配哪个节点。

:::

## 应用修复

自定义 lint 规则可以提供一个函数，在报告问题时应用修复。可选的 `fix()` 方法在运行 `deno lint --fix` 或通过 Deno LSP 在编辑器内部应用修复时被调用。

`fix()` 方法接收一个包含辅助方法的 `fixer` 实例，以方便创建修复。修复由起始位置、结束位置和应放入该范围内的新文本组成。

```ts
context.report({
  node,
  message: "应该是 _b",
  fix(fixer) {
    return fixer.replaceText(node, "_b");
  },
});
```

`fixer` 对象具有以下方法：

- `insertTextAfter(node, text)`：在给定节点之后插入文本。
- `insertTextAfterRange(range, text)`：在给定范围之后插入文本。
- `insertTextBefore(node, text)`：在给定节点之前插入文本。
- `insertTextBeforeRange(range, text)`：在给定范围之前插入文本。
- `remove(node)`：移除给定节点。
- `removeRange(range)`：移除给定范围内的文本。
- `replaceText(node, text)`：替换给定节点中的文本。
- `replaceTextRange(range, text)`：替换给定范围内的文本。

`fix()` 方法还可以返回一个修复数组，或者如果是生成器函数，则可以 yield 多个修复。

有时需要节点的原始源文本来创建修复。要获取任何节点的源代码，请使用 `context.sourceCode.getText()`：

```ts
context.report({
  node,
  message: "应该是 _b",
  fix(fixer) {
    const original = context.sourceCode.getText(node);
    const newText = `{ ${original} }`;
    return fixer.replaceText(node, newText);
  },
});
```

## 运行清理代码

如果您的插件在文件被 lint 后需要运行清理代码，您可以通过 `destroy()` 钩子连接到 linter。它在文件被 lint 后以及插件上下文被销毁之前调用。

```ts title="my-plugin.ts"
const plugin: Deno.lint.Plugin = {
  name: "my-plugin",
  rules: {
    "my-rule": {
      create(context) {
        // ...
      },
      // 可选：在文件的 lint 完成后
      // 以及每个规则上下文被销毁后运行代码。
      destroy() {
        // 如果需要，做一些清理工作
      },
    },
  },
};
export default plugin;
```

:::caution

假设您的插件代码会在每个被 lint 的文件上再次执行并不安全。

最好不要保持全局状态，并在 `destroy` 钩子中进行清理，以防 `deno lint` 决定重用现有的插件实例。

:::

## 排除自定义规则

与内置规则类似，您可以禁用插件提供的自定义规则。为此，请将其添加到 `deno.json` 中的 `lint.rules.exclude` 键。自定义 lint 规则的格式始终为 `<plugin-name>/<rule-name>`。

```json title="deno.json"
{
  "lint": {
    "plugins": ["./my-plugin.ts"],
    "rules": {
      "exclude": ["my-plugin/my-rule"]
    }
  }
}
```

## 忽略自定义 lint 报告

有时您希望在代码的特定位置禁用报告的 lint 错误。您可以通过在该位置之前放置代码注释来禁用报告的位置，而不是完全禁用自定义 lint 规则。

```ts
// deno-lint-ignore my-custom-plugin/no-console
console.log("hey");
```

这将禁用特定行的 lint 插件中的 lint 规则。

忽略注释的语法是：

```ts
// deno-lint-ignore <my-plugin>/<my-rule>
```

## 测试插件

`Deno.lint.runPlugin` API 提供了一种方便的方式来测试您的插件。它允许您断言插件根据特定输入生成预期的诊断信息。

让我们使用上面定义的示例插件：

```ts title="my-plugin_test.ts"
import { assertEquals } from "jsr:@std/assert";
import myPlugin from "./my-plugin.ts";

Deno.test("my-plugin", () => {
  const diagnostics = Deno.lint.runPlugin(
    myPlugin,
    "main.ts", // 虚拟文件名，文件不需要存在。
    "const _a = 'a';",
  );

  assertEquals(diagnostics.length, 1);
  const d = diagnostics[0];
  assertEquals(d.id, "my-plugin/my-rule");
  assertEquals(d.message, "应该是 _b");
  assertEquals(d.fix, [{ range: [6, 8], text: "_b" }]);
});
```

:::info

`Deno.lint.runPlugin` API 仅在 `deno test` 和
`deno bench` 子命令中可用。

尝试在其他子命令中使用它将会抛出错误。

:::

请参考[API 参考文档](/api/deno/)以获取有关
[`Deno.lint.runPlugin`](/api/deno/~/Deno.lint.runPlugin) 和
[`Deno.lint.Diagnostic`](/api/deno/~/Deno.lint.Diagnostic) 的更多信息。


---

# Language Server Integration

> Technical guide to integrating Deno's Language Server Protocol (LSP). Learn about LSP implementation details, custom commands, requests, notifications, and testing API integration for editor and tool developers.

URL: https://docs.deno.com/runtime/reference/lsp_integration


:::tip

如果您在寻找如何使用 Deno 的 LSP 以及各种编辑器的信息，请访问
[设置您的环境页面](/runtime/getting_started/setup_your_environment/)。

:::

Deno CLI 内置一个语言服务器，可以提供智能的编辑体验，以及一种轻松访问 Deno 中内置的其他工具的方法。对于大多数用户而言，使用语言服务器将通过 [Visual Studio Code](/runtime/reference/vscode/) 或 [其他编辑器](/runtime/getting_started/setup_your_environment/) 来实现。

此页面针对的是创建语言服务器集成或提供与 Deno 智能集成的包注册表的开发者。

Deno 语言服务器提供了 [语言服务器协议](https://microsoft.github.io/language-server-protocol/) 的服务端实现，特别设计为提供代码的 _Deno_ 视图。它集成在命令行中，并可以通过 `lsp` 子命令启动。

## 结构

当语言服务器启动时，会创建一个 `LanguageServer` 实例，该实例持有语言服务器的所有状态。它还定义了客户端通过语言服务器 RPC 协议调用的所有方法。

## 设置

语言服务器支持一系列的工作区设置：

- `deno.enable`
- `deno.enablePaths`
- `deno.cache`
- `deno.certificateStores`
- `deno.config`
- `deno.importMap`
- `deno.internalDebug`
- `deno.codeLens.implementations`
- `deno.codeLens.references`
- `deno.codeLens.referencesAllFunctions`
- `deno.codeLens.test`
- `deno.suggest.completeFunctionCalls`
- `deno.suggest.names`
- `deno.suggest.paths`
- `deno.suggest.autoImports`
- `deno.suggest.imports.autoDiscover`
- `deno.suggest.imports.hosts`
- `deno.lint`
- `deno.tlsCertificate`
- `deno.unsafelyIgnoreCertificateErrors`
- `deno.unstable`

此外，语言服务器还支持按资源的设置：

- `deno.enable`
- `deno.enablePaths`
- `deno.codeLens.test`

Deno 在语言服务器进程的多个点分析这些设置。首先，当来自客户端的 `initialize` 请求到达时，`initializationOptions` 将被视为一个表示 `deno` 命名空间选项的对象。例如，以下值将为该实例的语言服务器启用不稳定 API：

```json
{
  "enable": true,
  "unstable": true
}
```

当语言服务器接收到 `workspace/didChangeConfiguration` 通知时，它将评估客户端是否指示是否具有 `workspaceConfiguration` 功能。如果有，它将发送一个 `workspace/configuration` 请求，其中将包括请求工作区配置以及语言服务器当前跟踪的所有 URI 的配置。

如果客户端具有 `workspaceConfiguration` 功能，语言服务器将在收到 `textDocument/didOpen` 通知时发送一个 URI 的配置请求，以获取特定于资源的设置。

如果客户端没有 `workspaceConfiguration` 功能，语言服务器将假设工作区设置适用于所有资源。

## 命令

语言服务器可能会向客户端发出几条命令，客户端预计将实现这些命令：

### .cache

`deno.cache` 作为解析代码操作发送，当有未缓存的模块说明被导入到模块时发送。它将以包含作为字符串的已解析说明符的参数发送。

### showReferences

`deno.showReferences` 作为某些代码透镜上的命令发送，以显示引用位置。参数包含该命令的主题说明符、目标的起始位置和要显示的引用的位置。

### test

`deno.test` 作为测试代码透镜的一部分发送，客户端应根据参数运行测试，这些参数是测试所在的说明符和用于过滤测试的测试名称。

## 请求

LSP 当前支持以下自定义请求。客户端应实现这些请求，以便拥有一个与 Deno 完美集成的完全功能的客户端：

### /cache

`deno/cache` 将指示 Deno 尝试缓存模块及其所有依赖项。如果仅传递一个 `referrer`，则将加载模块说明符的所有依赖项。如果 `uris` 中有值，则仅缓存那些 `uris`。

它期望参数为：

```ts
interface CacheParams {
  referrer: TextDocumentIdentifier;
  uris: TextDocumentIdentifier[];
}
```

### performance

`deno/performance` 请求返回 Deno 内部仪器化的平均时机。它不期望任何参数。

### reloadImportRegistries

`deno/reloadImportRegistries` 重新加载来自导入注册表的任何缓存响应。它不期望任何参数。

### virtualTextDocument

`deno/virtualTextDocument` 请求从 LSP 生成一个虚拟文本文档，这是一个只读文档，可以在客户端显示。这让客户端能够访问 Deno 缓存中的文档，如远程模块和内置于 Deno 的 TypeScript 库文件。Deno 语言服务器将在自定义架构 `deno:` 下编码所有内部文件，因此客户端应将所有针对 `deno:` 架构的请求路由回 `deno/virtualTextDocument` API。

它还支持一个特殊的 URL `deno:/status.md`，该 URL 提供一个 markdown 格式的文本文档，其中包含有关 LSP 状态的详细信息以供用户显示。

它期望参数为：

```ts
interface VirtualTextDocumentParams {
  textDocument: TextDocumentIdentifier;
}
```

### task

`deno/task` 请求返回可用的 Deno 任务，请参阅 [task_runner](/runtime/reference/cli/task_runner/)。它不期望任何参数。

## 通知

当前有一个自定义通知从服务器发送到客户端，`deno/registryState`。当 `deno.suggest.imports.autoDiscover` 为 `true`，且待添加到文档中的导入的源未在 `deno.suggest.imports.hosts` 中明确设置时，将检查源并向客户端发送状态通知。

接收到通知时，如果参数 `suggestion` 为 `true`，客户端应向用户提供选择，以启用该源并将其添加到 `deno.suggest.imports.hosts` 的配置中。如果 `suggestion` 为 `false`，客户端应将其添加到配置中作为 `false`，以阻止语言服务器尝试检测建议是否被支持。

通知的参数为：

```ts
interface RegistryStatusNotificationParams {
  origin: string;
  suggestions: boolean;
}
```

## 语言 ID

语言服务器支持以下 [文本文档语言 ID](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentItem) 的诊断和格式化：

- `"javascript"`
- `"javascriptreact"`
- `"jsx"` _非标准，与 `javascriptreact` 相同_
- `"typescript"`
- `"typescriptreact"`
- `"tsx"` _非标准，与 `typescriptreact` 相同_

语言服务器仅支持以下语言 ID 的格式化：

- `"json"`
- `"jsonc"`
- `"markdown"`

## 测试

Deno 语言服务器支持一组自定义 API 来启用测试。这些 API 基于提供信息以启用 [vscode 的测试 API](https://code.visualstudio.com/api/extension-guides/testing)，但其他语言服务器客户端也可以使用来提供类似的接口。

客户端与服务器都应支持实验性的 `testingApi` 功能：

```ts
interface ClientCapabilities {
  experimental?: {
    testingApi: boolean;
  };
}
```

```ts
interface ServerCapabilities {
  experimental?: {
    testingApi: boolean;
  };
}
```

当支持测试 API 的 Deno 版本遇到支持该功能的客户端时，它将初始化处理测试检测的代码，并开始提供启用它的通知。

还需要注意的是，当启用测试 API 功能时，测试代码透镜将不再发送到客户端。

### 测试设置

有特定的设置可以改变语言服务器的行为：

- `deno.testing.args` - 在执行测试时将提供的字符串数组作为参数。这与 `deno test` 子命令的作用相同。
- `deno.testing.enable` - 一个二进制标志，用于启用或禁用测试服务器

### 测试通知

服务器会在某些条件下向客户端发送通知。

#### deno/testModule

当服务器发现包含测试的模块时，它将通过发送 `deno/testModule` 通知以及 `TestModuleParams` 的有效载荷来通知客户端。

Deno 以这种方式构建：

- 一个模块可以包含 _n_ 个测试。
- 一个测试可以包含 _n_ 个步骤。
- 一个步骤可以包含 _n_ 个步骤。

当 Deno 进行测试模块的静态分析时，它会尝试识别任何测试和测试步骤。由于测试在 Deno 中的声明方式是动态的，因此不能总是静态识别，只有在模块执行时才能识别。当更新客户端时，该通知被设计为处理这两种情况。当静态发现测试时，通知 `kind` 将是 `"replace"`；当在执行时发现测试或步骤时，通知 `kind` 将是 `"insert"`。

当在编辑器中编辑测试文档，并从客户端接收到 `textDocument/didChange` 通知时，该变更的静态分析将在服务器端执行，如果测试已更改，客户端将接收到通知。

当客户端收到 `"replace"` 通知时，它可以安全地“替换”测试模块表示，当收到 `"insert"` 时，应递归尝试添加到现有表示中。

对于测试模块，`textDocument.uri` 应该用作所有表示的唯一 ID（因为它是唯一模块的字符串 URL）。`TestData` 项包含一个唯一的 `id` 字符串。此 `id` 字符串是服务器跟踪的识别信息的 SHA-256 哈希。

```ts
interface TestData {
  /** 此测试/步骤的唯一 ID。 */
  id: string;

  /** 测试/步骤的显示标签。 */
  label: string;

  /** 与此测试/步骤相关的任何测试步骤 */
  steps?: TestData[];

  /** 适用于测试的拥有文本文档的范围。 */
  range?: Range;
}

interface TestModuleParams {
  /** 与测试相关的文本文档标识符。 */
  textDocument: TextDocumentIdentifier;

  /** 如果描述的测试是 _新发现_ 的，并应 _插入_ 或如果相关的测试是现有测试的替代品的指示。 */
  kind: "insert" | "replace";

  /** 测试模块的文本标签。 */
  label: string;

  /** 由此测试模块拥有的一数组测试。 */
  tests: TestData[];
}
```

#### deno/testModuleDelete

当服务器观察到的测试模块被删除时，服务器将发出 `deno/testModuleDelete` 通知。接收到通知时，客户端应删除测试模块及其所有子测试和测试步骤的表示。

```ts
interface TestModuleDeleteParams {
  /** 已被移除的文本文档标识符。 */
  textDocument: TextDocumentIdentifier;
}
```

#### deno/testRunProgress

当从客户端请求 [`deno/testRun`](#denotestrun) 时，服务器将通过 `deno/testRunProgress` 通知支持该测试运行的进度。

客户端应处理这些消息并更新任何 UI 表示。

状态变化在 `TestRunProgressParams` 的 `.message.kind` 属性中表示。状态为：

- `"enqueued"` - 一个测试或测试步骤已经排队等待测试。
- `"skipped"` - 一个测试或测试步骤被跳过。这发生在 Deno 测试中设置了 `ignore` 选项为 `true`。
- `"started"` - 一个测试或测试步骤已开始。
- `"passed"` - 一个测试或测试步骤已通过。
- `"failed"` - 一个测试或测试步骤已失败。这旨在表明测试工具中的错误，而不是测试本身，但目前 Deno 不支持这种区分。
- `"errored"` - 测试或测试步骤出现错误。关于错误的额外信息将位于 `.message.messages` 属性中。
- `"end"` - 测试运行已结束。

```ts
interface TestIdentifier {
  /** 与消息相关的测试模块。 */
  textDocument: TextDocumentIdentifier;

  /** 测试的可选 ID。如果未提供，则消息适用于测试模块中的所有测试。 */
  id?: string;

  /** 步骤的可选 ID。如果未提供，则消息仅适用于测试。 */
  stepId?: string;
}

interface TestMessage {
  /** 消息的内容。 */
  message: MarkupContent;

  /** 表示预期输出的可选字符串。 */
  expectedOutput?: string;

  /** 表示实际输出的可选字符串。 */
  actualOutput?: string;

  /** 与消息相关的可选位置。 */
  location?: Location;
}

interface TestEnqueuedStartedSkipped {
  /** 某个特定测试或测试步骤发生的状态变化。
   *
   * - `"enqueued"` - 测试现在已排队待测试
   * - `"started"` - 测试已开始
   * - `"skipped"` - 测试被跳过
   */
  type: "enqueued" | "started" | "skipped";

  /** 与状态变化相关的测试或测试步骤。 */
  test: TestIdentifier;
}

interface TestFailedErrored {
  /** 某个特定测试或测试步骤发生的状态变化。
   *
   * - `"failed"` - 测试未能正常运行，而是测试出现错误。
   *   当前 Deno 语言服务器不支持此。
   * - `"errored"` - 测试出现错误。
   */
  type: "failed" | "errored";

  /** 与状态变化相关的测试或测试步骤。 */
  test: TestIdentifier;

  /** 与状态变化相关的消息。 */
  messages: TestMessage[];

  /** 从开始到当前状态的可选持续时间，以毫秒为单位。 */
  duration?: number;
}

interface TestPassed {
  /** 某个特定测试或测试步骤发生的状态变化。 */
  type: "passed";

  /** 与状态变化相关的测试或测试步骤。 */
  test: TestIdentifier;

  /** 从开始到当前状态的可选持续时间，以毫秒为单位。 */
  duration?: number;
}

interface TestOutput {
  /** 测试或测试步骤输出信息/记录信息。 */
  type: "output";

  /** 输出的值。 */
  value: string;

  /** 如果有，相关的测试或测试步骤。 */
  test?: TestIdentifier;

  /** 与输出相关的可选位置。 */
  location?: Location;
}

interface TestEnd {
  /** 测试运行已结束。 */
  type: "end";
}

type TestRunProgressMessage =
  | TestEnqueuedStartedSkipped
  | TestFailedErrored
  | TestPassed
  | TestOutput
  | TestEnd;

interface TestRunProgressParams {
  /** 适用的测试运行 ID 的进度消息。 */
  id: number;

  /** 消息 */
  message: TestRunProgressMessage;
}
```

### 测试请求

服务器处理两种不同的请求：

#### deno/testRun

要请求语言服务器执行一组测试，客户端发送 `deno/testRun` 请求，其中包括将用于将来对客户端的响应的测试运行 ID、测试运行的类型，以及要包含或排除的测试模块或测试。

当前 Deno 仅支持 `"run"` 类型的测试运行。`"debug"` 和 `"coverage"` 计划在未来支持。

当没有包含的测试模块或测试时，意味着应该执行所有发现的测试模块和测试。当一个测试模块被包含，但没有任何测试 ID 时，意味着应包含该测试模块中的所有测试。一旦识别出所有测试，将排除的测试将被移除，并在响应中作为 `"enqueued"` 返回解析的测试集。

通过此 API 无法包含或排除测试步骤，因为测试步骤的声明和运行方式是动态的。

```ts
interface TestRunRequestParams {
  /** 用于将来消息的测试运行 ID。 */
  id: number;

  /** 运行类型。目前 Deno 仅支持 `"run"` */
  kind: "run" | "coverage" | "debug";

  /** 要排除的测试模块或测试。 */
  exclude?: TestIdentifier[];

  /** 在测试运行中要包括的测试模块或测试。 */
  include?: TestIdentifier[];
}

interface EnqueuedTestModule {
  /** 与排队的测试 ID 相关的测试模块 */
  textDocument: TextDocumentIdentifier;

  /** 当前已排队等待测试的测试 ID */
  ids: string[];
}

interface TestRunResponseParams {
  /** 当前已排队等待测试的测试模块和测试 ID。 */
  enqueued: EnqueuedTestModule[];
}
```

#### deno/testRunCancel

如果客户端希望取消正在运行的测试运行，则发送 `deno/testRunCancel` 请求以取消测试 ID。返回的响应将是一个布尔值 `true`，表示测试已取消，或 `false`，表示无法取消。适当的测试进度通知仍会在测试取消时发送。

```ts
interface TestRunCancelParams {
  /** 要取消的测试 ID。 */
  id: number;
}
```

---

# Deno 1.x to 2.x Migration Guide

> Comprehensive guide to migrating from Deno 1.x to 2.x. Learn about breaking changes, API updates, Node.js compatibility features, and how to update your codebase to work with Deno 2.x.

URL: https://docs.deno.com/runtime/reference/migration_guide


尽管我们在 Deno 1.x 中取得了大量成就，下一个主要版本旨在
支持 Deno **大规模应用**。这意味着与 Node.js 和
npm JavaScript 基础设施的无缝互操作性，并支持更广泛的项目和
开发团队，所有这些都在不牺牲开发者所喜爱的简单性、安全性和
“内置电池”特性的情况下实现。

## 与 Node.js 和 npm 的向后兼容性

Deno 2 与 Node.js 和 npm 向后兼容。这不仅允许你在当前的 Node.js 项目中运行 Deno，还允许你逐步采用 Deno 的一体化工具链的各个部分。

例如，你可以在 Node.js 项目中使用 `deno install` 来安装
依赖项，运行 `deno fmt` 来格式化代码而无需使用 Prettier，或使用
`deno lint` 来检查常见问题，而不是使用 ESLint。

Deno 2 理解 `package.json`、`node_modules` 目录，甚至支持 npm
工作区，使你能够轻松迁移现有的使用 ESM 的项目。

为了更好地兼容 Node，默认情况下在存在 package.json 时不会自动安装 npm 包，而推荐运行 `deno install`。
要获取 Deno 1.x 中的自动安装行为，请将以下内容添加到你的
deno.json 中：

```json title="deno.json"
{
  "nodeModulesDir": "auto"
}
```

[在 `Node.js 支持` 页面上了解更多](/runtime/fundamentals/node/)

### 长期支持版本

从 Deno v2.1.0（预计在 2024 年 11 月发布）开始，Deno 将提供
LTS（长期支持）通道。

LTS 版本支持 6 个月，接收 bug 修复和关键性能修复，然后将新版本提升为 LTS。

[在 `稳定性和发布` 页面上了解更多](/runtime/fundamentals/stability_and_releases/#long-term-support-(lts))

## 管理依赖

Deno 2 大大改善了对 npm 和 JSR 包的依赖管理，提供了以下工具：

- [`deno install`](/runtime/reference/cli/install/)
- [`deno add`](/runtime/reference/cli/add/)
- [`deno remove`](/runtime/reference/cli/remove/)

你可以期待与 Deno 首先的项目（使用 `deno.json`）、Node.js 首先的项目（使用 `package.json`）以及混合项目（使用 `deno.json` 和 `package.json`）之间的无缝体验，从而实现易于迁移的路径。

## Monorepo、工作区和私有注册表支持

Deno 2 是针对在重要项目上工作的开发团队而构建的。这些团队处理复杂的代码库，共享内部代码，通常使用私有注册表。

使用 Deno 2，你的团队可以像使用 Node.js 和 npm 一样利用私有 npm 注册表，使用 `.npmrc` 文件：

```js title=".npmrc"
@mycompany:registry=http://mycompany.com:8111/
mycompany.com:8111/:_authToken=token
```

了解更多关于私有注册表配置
[在 `npm 包` 页面上](/runtime/fundamentals/node/#private-registries)。

Deno 2 具有工作区支持，允许你在同一个 monorepo 中混合 Deno 首先和 Node 首先的包，使增量采用变得快速且易于实现。

阅读更多
[在 `工作区和单一仓库` 页面上](/runtime/fundamentals/workspaces/)。

## 框架支持

随着 Node.js 和 npm 兼容性的提高，Deno 2 支持许多用户喜爱的框架，例如：

- Next.js
- SvelteKit
- Remix
- Nuxt
- TanStack
- Qwik
- 等等

大多数现有项目将需要最小或不需要更改；只需用 `deno task dev` 替换
`npm run dev`，便可以开始工作。

Deno 将提供有用的错误消息，附带建议，以引导你走向工作解决方案。

你还可以使用 `deno lint --fix` 自动修复常见的不兼容性。

---

以下部分概述了 Deno 1.x 与 Deno 2 之间的配置、CLI 和 API 变化。

## 配置更改

- `nodeModulesDir`

对于 `nodeModulesDir` 和 `--node-modules-dir` 配置选项使用布尔值已被弃用，取而代之的是选择多种行为选项。因此，当未设置该选项时，默认值已更改。

```diff
- "nodeModulesDir": false | true
+ "nodeModulesDir": "none" | "auto" | "manual"

- 默认值（无 package.json 时）：false（对应于 "none"）
+ 默认值（无 package.json 时）："none"

- 默认值（有 package.json 时）：true（对应于 "auto"）
+ 默认值（有 package.json 时）："manual"
```

如果你的项目中未包含 `package.json` 文件，则默认行为将保持不变。

如果你的项目中包含 `package.json` 文件且未指定 `nodeModulesDir` 选项，则必须将其设置为 `auto` 以保持 Deno 1.x 中的自动安装行为。Deno 2 中的新默认值为 `manual`，这意味着用户必须手动保持该目录的最新状态。

参见
[Node 模块目录](https://docs.deno.com/runtime/fundamentals/configuration/#node-modules-directory)
以供参考。

## CLI 更改

- `deno bundle`

`deno bundle` 命令已被删除。我们建议结合使用
[`esbuild`](https://esbuild.github.io/) 和
[`esbuild-deno-loader`](https://jsr.io/@luca/esbuild-deno-loader)。

```ts
import * as esbuild from "npm:esbuild";
import { denoPlugins } from "jsr:@luca/esbuild-deno-loader";

const result = await esbuild.build({
  plugins: [...denoPlugins()],
  entryPoints: ["https://deno.land/std@0.185.0/bytes/mod.ts"],
  outfile: "./dist/bytes.esm.js",
  bundle: true,
  format: "esm",
});

esbuild.stop();
```

- `deno cache`

`deno cache` 命令已合并到 `deno install` 命令中的 `--entrypoint` 选项下。

```diff
- deno cache main.ts
+ deno install --entrypoint main.ts
```

- `deno vendor`

`deno vendor` 命令已被 `deno.json` 中的 `"vendor": true` 配置选项所替代。

```json title="deno.json"
{
  "vendor": true
}
```

- `--allow-none`

请改用 `--permit-no-files` CLI 标志。

```diff
- deno test --allow-none
+ deno test --permit-no-files
```

- `--jobs`

请使用
[`DENO_JOBS`](https://docs.deno.com/runtime/manual/basics/env_variables/#special-environment-variables)
环境变量来替代。

```diff
- deno test --jobs=4 --parallel
+ DENO_JOBS=4 deno test --parallel
```

- `--ts`

请改用 `--ext=ts` CLI 标志。

```diff
- deno run --ts script.ts
+ deno run --ext=ts script.ts
```

```diff
- deno run -T script.ts
+ deno run --ext=ts script.ts
```

- `--trace-ops`

请改用 `--trace-leaks` CLI 标志。

```diff
- deno test --trace-ops
+ deno test --trace-leaks
```

- `--unstable`

请使用更细化的不稳定标志（`--unstable-*`）或配置选项。
参见
[不稳定特性标志](https://docs.deno.com/runtime/reference/cli/unstable_flags/)
以供参考。

```ts
// kv.ts
const kv = await Deno.openKv();

// ...
```

```diff
- deno run --unstable kv.ts
+ deno run --unstable-kv kv.ts
```

或

```diff
{
+ "unstable": ["kv"]
}
```

有关详细信息，请参见
[Deno 1.40 博客文章](https://deno.com/blog/v1.40#changes-to-how-we-handle-unstable-features)。

## 导入断言移除

导入断言已从 JavaScript 中移除，并在 Deno 2.0 中被弃用。请改用导入属性：

```diff
- import data from "./data.json" assert { type: "json" };
+ import data from "./data.json" with { type: "json" };
```

这是少数几个提案在达到第三阶段后被 [降级的情况之一](https://github.com/tc39/proposal-import-attributes?tab=readme-ov-file#history)。

## API 更改

- `Deno.Buffer`

请改用来自标准库的 [`Buffer`](https://jsr.io/@std/io/doc/buffer/~/Buffer)。

```diff
+ import { Buffer } from "jsr:@std/io/buffer";

- const buffer = new Deno.Buffer();
+ const buffer = new Buffer();

  // ...
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.Closer`

请改用来自标准库的 [`Closer`](https://jsr.io/@std/io/doc/types/~/Closer)。

```diff
+ import type { Closer } from "jsr:@std/io/types";

- function foo(closer: Deno.Closer) {
+ function foo(closer: Closer) {
  // ...
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.close()`

请改用资源的 `.close()` 方法。

<a href="#" id="rid">测试</a>

```diff
  const conn = await Deno.connect({ port: 80 });

  // ...

- Deno.close(conn.rid);
+ conn.close();
```

```diff
  const file = await Deno.open("/foo/bar.txt");

  // ...

- Deno.close(file.rid);
+ file.close();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.Conn.prototype.rid`

请改用 [`Deno.Conn`](https://docs.deno.com/api/deno/~/Deno.Conn) 实例方法。

```diff
  const conn = await Deno.connect({ port: 80 });

  const buffer = new Uint8Array(1_024);
- await Deno.read(conn.rid, buffer);
+ await conn.read(buffer);

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(conn.rid, data);
+ await conn.write(data);

- await Deno.shutdown(conn.rid);
+ await conn.closeWrite();

- Deno.close(conn.rid);
+ conn.close();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.ConnectTlsOptions.certChain`

请改用
[`cert`](https://docs.deno.com/api/deno/~/Deno.TlsCertifiedKeyPem#property_cert)
选项。

```diff
const caCert = await Deno.readTextFile("./certs/my_custom_root_CA.pem");
using conn = await Deno.connectTls({
  hostname: "192.0.2.1",
  port: 80,
  caCerts: [caCert],
- certChain: Deno.readTextFileSync("./server.crt"),
+ cert: Deno.readTextFileSync("./server.crt"),
  key: Deno.readTextFileSync("./server.key"),
});
```

有关详细信息，请参阅 [deno#22274](https://github.com/denoland/deno/pull/22274)。

- `Deno.ConnectTlsOptions.certFile`

请改用
[`cert`](https://docs.deno.com/api/deno/~/Deno.TlsCertifiedKeyPem#property_cert)
选项。

```diff
const caCert = await Deno.readTextFile("./certs/my_custom_root_CA.pem");
using conn = await Deno.connectTls({
  hostname: "192.0.2.1",
  port: 80,
  caCerts: [caCert],
- certFile: "./server.crt",
+ cert: Deno.readTextFileSync("./server.crt"),
  key: Deno.readTextFileSync("./server.key"),
});
```

有关详细信息，请参阅 [deno#22274](https://github.com/denoland/deno/pull/22274)。

- `Deno.ConnectTlsOptions.privateKey`

请改用
[`key`](https://docs.deno.com/api/deno/~/Deno.TlsCertifiedKeyPem#property_key)
选项。

```diff
const caCert = await Deno.readTextFile("./certs/my_custom_root_CA.pem");
using conn = await Deno.connectTls({
  hostname: "192.0.2.1",
  port: 80,
  caCerts: [caCert],
  cert: Deno.readTextFileSync("./server.crt"),
- keyFile: "./server.key",
+ key: Deno.readTextFileSync("./server.key"),
});
```

有关详细信息，请参阅 [deno#22274](https://github.com/denoland/deno/pull/22274)。

- `Deno.copy()`

请改用来自标准库的 [`copy()`](https://jsr.io/@std/io/doc/copy/~/copy)。

```diff
+ import { copy } from "jsr:@std/io/copy";

  using file = await Deno.open("/foo/bar.txt");

- await Deno.copy(file, Deno.stdout);
+ await copy(file, Deno.stdout);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.customInspect`

请改用 `Symbol.for("Deno.customInspect")`。

```diff
class Foo {
- [Deno.customInspect]() {
+ [Symbol.for("Deno.customInspect")] {
  }
}
```

有关更多详细信息，请参阅 [deno#9294](https://github.com/denoland/deno/issues/9294)。

- `Deno.fdatasync()`

请改用
[`Deno.FsFile.prototype.syncData()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.syncData)。

```diff
  using file = await Deno.open("/foo/bar.txt", { read: true, write: true });

  await file.write(new TextEncoder().encode("Hello, world!"));
- await Deno.fdatasync(file.rid);
+ await file.syncData();
```

- `Deno.fdatasyncSync()`

请改用
[`Deno.FsFile.prototype.syncDataSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.syncDataSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt", { read: true, write: true });

  file.writeSync(new TextEncoder().encode("Hello, world!"));
- Deno.fdatasyncSync(file.rid);
+ file.syncDataSync();
```

- `Deno.File`

请改用 [`Deno.FsFile`](https://docs.deno.com/api/deno/~/Deno.FsFile)。

```diff
- function foo(file: Deno.File) {
+ function foo(file: Deno.FsFile) {
  // ...
}
```

有关详细信息，请参阅 [deno#13661](https://github.com/denoland/deno/issues/13661)。

- `Deno.flock()`

请改用
[`Deno.FsFile.prototype.lock()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.lock)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- await Deno.flock(file.rid);
+ await file.lock();
```

有关详细信息，请参阅 [deno#22178](https://github.com/denoland/deno/issues/22178)。

- `Deno.flockSync()`

请改用
[`Deno.FsFile.prototype.lockSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.lockSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt");

- Deno.flockSync(file.rid);
+ file.lockSync();
```

有关详细信息，请参阅 [deno#22178](https://github.com/denoland/deno/issues/22178)。

- `Deno.FsFile.prototype.rid`

请改用 [`Deno.FsFile`](https://docs.deno.com/api/deno/~/Deno.FsFile) 实例方法。

```diff
  const file = await Deno.open("/foo/bar.txt");

  const buffer = new Uint8Array(1_024);
- await Deno.read(file.rid, buffer);
+ await file.read(buffer);

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(file.rid, data);
+ await file.write(data);

- Deno.close(file.rid);
+ file.close();
```

- `Deno.fstatSync()`

请改用
[`Deno.FsFile.prototype.statSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.statSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt");

- const fileInfo = Deno.fstatSync(file.rid);
+ const fileInfo = file.statSync();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.fstat()`

请改用
[`Deno.FsFile.prototype.stat()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.stat)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- const fileInfo = await Deno.fstat(file.rid);
+ const fileInfo = await file.stat();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.FsWatcher.prototype.rid`

请改用 [`Deno.FsWatcher`](https://docs.deno.com/api/deno/~/Deno.FsWatcher) 实例方法。

```diff
  using watcher = Deno.watchFs("/dir");

  // ...

- Deno.close(watcher.rid);
+ watcher.close();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.fsync()`

请改用
[`Deno.FsFile.prototype.sync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.sync)。

```diff
  using file = await Deno.open("/foo/bar.txt", { read: true, write: true });

  await file.write(new TextEncoder().encode("Hello, world!"));
  await file.truncate(1);
- await Deno.fsync(file.rid);
+ await file.sync();
```

- `Deno.fsyncSync()`

请改用
[`Deno.FsFile.prototype.syncSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.syncSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt", { read: true, write: true });

  file.writeSync(new TextEncoder().encode("Hello, world!"));
  file.truncateSync(1);
- Deno.fsyncSync(file.rid);
+ file.syncSync();
```

- `Deno.ftruncateSync()`

请改用
[`Deno.FsFile.prototype.truncateSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.truncateSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt");

- Deno.ftruncateSync(file.rid, 7);
+ file.truncateSync(7);
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.ftruncate()`

请改用
[`Deno.FsFile.prototype.truncate()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.truncate)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- await Deno.ftruncate(file.rid, 7);
+ await file.truncate(7);
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.funlock()`

请改用
[`Deno.FsFile.prototype.unlock()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.unlock)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- await Deno.funlock(file.rid);
+ await file.unlock();
```

有关详细信息，请参阅 [deno#22178](https://github.com/denoland/deno/issues/22178)。

- `Deno.funlockSync()`

请改用
[`Deno.FsFile.prototype.unlockSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.unlockSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt");

- Deno.funlockSync(file.rid);
+ file.unlockSync();
```

有关详细信息，请参阅 [deno#22178](https://github.com/denoland/deno/issues/22178)。

- `Deno.futimeSync()`

请改用
[`Deno.FsFile.prototype.utimeSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.utimeSync)。

```diff
  using file = Deno.openSync("/foo/bar.txt");

- Deno.futimeSync(file.rid, 1556495550, new Date());
+ file.utimeSync(1556495550, new Date());
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.futime()`

请改用
[`Deno.FsFile.prototype.utime()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.utime)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- await Deno.futime(file.rid, 1556495550, new Date());
+ await file.utime(1556495550, new Date());
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.isatty()`

请改用 `Deno.FsFile.prototype.isTerminal()`、`Deno.stdin.prototype.isTerminal()`、
`Deno.stdout.prototype.isTerminal()` 或 `Deno.stderr.prototype.isTerminal()`。

```diff
  using file = await Deno.open("/dev/tty6");

- Deno.isatty(file.rid);
+ file.isTerminal();
```

```diff
- Deno.isatty(Deno.stdin.rid);
+ Deno.stdin.isTerminal();
```

```diff
- Deno.isatty(Deno.stdout.rid);
+ Deno.stdout.isTerminal();
```

```diff
- Deno.isatty(Deno.stderr.rid);
+ Deno.stderr.isTerminal();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.iter()`

请改用来自标准库的
[`iterateReader()`](https://jsr.io/@std/io/doc/iterate-reader/~/iterateReader)。

```diff
+ import { iterateReader } from "jsr:@std/io/iterate-reader";

- for await (const chunk of Deno.iter(Deno.stdout)) {
+ for await (const chunk of iterateReader(Deno.stdout)) {
  // ...
}
```

```diff
+ import { iterateReaderSync } from "jsr:@std/io/iterate-reader";

  using file = await Deno.open("/foo/bar.txt");

- for await (const chunk of Deno.iter(file)) {
+ for await (const chunk of iterateReader(file)) {
  // ...
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.iterSync()`

请改用来自标准库的
[`iterateReaderSync()`](https://jsr.io/@std/io/doc/iterate-reader/~/iterateReaderSync)。

```diff
+ import { iterateReaderSync } from "jsr:@std/io/iterate-reader";

- for (const chunk of Deno.iterSync(Deno.stdout)) {
+ for (const chunk of iterateReaderSync(Deno.stdout)) {
  // ...
}
```

```diff
+ import { iterateReaderSync } from "jsr:@std/io/iterate-reader";

  using file = await Deno.open("/foo/bar.txt");

- for (const chunk of Deno.iterSync(file)) {
+ for (const chunk of iterateReaderSync(file)) {
  // ...
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.Listener.prototype.rid`

请改用 [`Deno.Listener`](https://docs.deno.com/api/deno/~/Deno.Listener) 实例方法。

```diff
  const listener = Deno.listen({ port: 80 })

- Deno.close(listener.rid);
+ listener.close();
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.ListenTlsOptions.certChain`

请改用
[`cert`](https://docs.deno.com/api/deno/~/Deno.ListenTlsOptions#property_cert)
选项。

```diff
using listener = Deno.listenTls({
  port: 443,
- certChain: Deno.readTextFile("./server.crt"),
+ cert: Deno.readTextFile("./server.crt"),
  key: Deno.readTextFileSync("./server.key"),
});
```

- `Deno.ListenTlsOptions.certFile`

将证书文件内容传递给
[`cert`](https://docs.deno.com/api/deno/~/Deno.ListenTlsOptions#property_cert)
选项。

```diff
using listener = Deno.listenTls({
  port: 443,
- certFile: "./server.crt",
+ cert: Deno.readTextFile("./server.crt"),
  key: Deno.readTextFileSync("./server.key"),
});
```

有关详细信息，请参阅 [deno#12639](https://github.com/denoland/deno/issues/12639)。

- `Deno.ListenTlsOptions.keyFile`

将密钥文件内容传递给
[`key`](https://docs.deno.com/api/deno/~/Deno.ListenTlsOptions#property_key)
选项。

```diff
using listener = Deno.listenTls({
  port: 443,
  cert: Deno.readTextFile("./server.crt"),
- keyFile: "./server.key",
+ key: Deno.readTextFileSync("./server.key"),
});
```

有关详细信息，请参阅 [deno#12639](https://github.com/denoland/deno/issues/12639)。

- `Deno.metrics()`

此符号没有替代 API。

- `Deno.readAllSync()`

请改用来自标准库的 [`readAllSync()`](https://jsr.io/@std/io/doc/read-all/~/readAllSync)。

```diff
+ import { readAllSync } from "jsr:@std/io/read-all";

- const data = Deno.readAllSync(Deno.stdin);
+ const data = readAllSync(Deno.stdin);
```

```diff
+ import { readAllSync } from "jsr:@std/io/read-all";

  using file = Deno.openSync("/foo/bar.txt", { read: true });

- const data = Deno.readAllSync(file);
+ const data = readAllSync(file);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.readAll()`

请改用来自标准库的 [`readAll()`](https://jsr.io/@std/io/doc/read-all/~/readAll)。

```diff
+ import { readAll } from "jsr:@std/io/read-all";

- const data = await Deno.readAll(Deno.stdin);
+ const data = await readAll(Deno.stdin);
```

```diff
+ import { readAll } from "jsr:@std/io/read-all";

  using file = await Deno.open("/foo/bar.txt", { read: true });

- const data = await Deno.readAll(file);
+ const data = await readAll(file);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.Reader`

请改用来自标准库的 [`Reader`](https://jsr.io/@std/io/doc/~/Reader)。

```diff
+ import type { Reader } from "jsr:@std/io/types";

- function foo(closer: Deno.Reader) {
+ function foo(closer: Reader) {
  // ...  
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.ReaderSync`

请改用来自标准库的 [`ReaderSync`](https://jsr.io/@std/io/doc/~/ReaderSync)。

```diff
+ import type { ReaderSync } from "jsr:@std/io/types";

- function foo(reader: Deno.ReaderSync) {
+ function foo(reader: ReaderSync) {
  // ...  
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.readSync()`

请改用资源的 `.readSync()` 方法。

```diff
  using conn = await Deno.connect({ port: 80 });
  const buffer = new Uint8Array(1_024);

- Deno.readSync(conn.rid, buffer);
+ conn.readSync(buffer);
```

```diff
  using file = Deno.openSync("/foo/bar.txt");
  const buffer = new Uint8Array(1_024);

- Deno.readSync(file.rid, buffer);
+ file.readSync(buffer);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.read()`

请改用资源的 `.read()` 方法。

```diff
  using conn = await Deno.connect({ port: 80 });
  const buffer = new Uint8Array(1_024);

- await Deno.read(conn.rid, buffer);
+ await conn.read(buffer);
```

```diff
  using file = await Deno.open("/foo/bar.txt");
  const buffer = new Uint8Array(1_024);

- await Deno.read(file.rid, buffer);
+ await file.read(buffer);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.resources()`

此符号没有替代 API，因为资源 ID（RID）正在逐渐被淘汰。

- `Deno.run()`

请改用 [`new Deno.Command()`](https://docs.deno.com/api/deno/~/Deno.Command)。

```diff
- const process = Deno.run({ cmd: [ "echo", "hello world" ], stdout: "piped" });
- const [{ success }, stdout] = await Promise.all([
-   process.status(),
-   process.output(),
- ]);
- process.close();
+ const command = new Deno.Command("echo", {
+   args: ["hello world"]
+ });
+ const { success, stdout } = await command.output();
  console.log(success);
  console.log(new TextDecoder().decode(stdout));
```

注意：这个符号在 Deno 2 中被软删除。它的类型已被删除，但其实现仍然存在以减少断裂性变化。你可以通过使用
[`@ts-ignore`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#suppress-errors-in-ts-files-using--ts-ignore-comments)
指令来忽略 “属性不存在” 的 TypeScript 错误。

```diff
+ // @ts-ignore `Deno.run()` is soft-removed as of Deno 2.
  const process = Deno.run({ cmd: [ "echo", "hello world" ], stdout: "piped" });
  const [{ success }, stdout] = await Promise.all([
    process.status(),
    process.output(),
  ]);
  process.close();
  console.log(success);
  console.log(new TextDecoder().decode(stdout));
```

有关详细信息，请参阅 [deno#16516](https://github.com/denoland/deno/pull/16516)。

- `Deno.Seeker`

请改用来自标准库的 [`Seeker`](https://jsr.io/@std/io/doc/types/~/Seeker)。

```diff
+ import type { Seeker } from "jsr:@std/io/types";

- function foo(seeker: Deno.Seeker) {
+ function foo(seeker: Seeker) {
  // ...  
}
```

- `Deno.SeekerSync`

请改用来自标准库的 [`SeekerSync`](https://jsr.io/@std/io/doc/types/~/SeekerSync)。

```diff
+ import type { SeekerSync } from "jsr:@std/io/types";

- function foo(seeker: Deno.SeekerSync) {
+ function foo(seeker: SeekerSync) {
  // ...  
}
```

- `Deno.seekSync()`

请改用
[`Deno.FsFile.prototype.seekSync()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.seekSync)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- Deno.seekSync(file.rid, 6, Deno.SeekMode.Start);
+ file.seekSync(6, Deno.SeekMode.Start);
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.seek()`

请改用
[`Deno.FsFile.prototype.seek()`](https://docs.deno.com/api/deno/~/Deno.FsFile.prototype.seek)。

```diff
  using file = await Deno.open("/foo/bar.txt");

- await Deno.seek(file.rid, 6, Deno.SeekMode.Start);
+ await file.seek(6, Deno.SeekMode.Start);
```

有关详细信息，请参阅 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.serveHttp()`

请改用 [`Deno.serve()`](https://docs.deno.com/api/deno/~/Deno.serve)。

```diff
- const conn = Deno.listen({ port: 80 });
- const httpConn = Deno.serveHttp(await conn.accept());
- const e = await httpConn.nextRequest();
- if (e) {
-  e.respondWith(new Response("Hello World"));
- }
+ Deno.serve({ port: 80 }, () => new Response("Hello World"));
```

注意：这个符号在 Deno 2 中被软删除。它的类型已被删除，但其实现仍然存在以减少断裂性变化。你可以通过使用
[`@ts-ignore`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#suppress-errors-in-ts-files-using--ts-ignore-comments)
指令来忽略 “属性不存在” 的 TypeScript 错误。

```diff
  const conn = Deno.listen({ port: 80 });
+ // @ts-ignore `Deno.serveHttp()` is soft-removed as of Deno 2.
  const httpConn = Deno.serveHttp(await conn.accept());
  const e = await httpConn.nextRequest();
  if (e) {
   e.respondWith(new Response("Hello World"));
  }
```

有关详细信息，请参见
[Deno 1.35 博客文章](https://deno.com/blog/v1.35#denoserve-is-now-stable)。

- `Deno.Server`

请改用 [`Deno.HttpServer`](https://docs.deno.com/api/deno/~/Deno.HttpServer)。

```diff
- function foo(server: Deno.Server) {
+ function foo(server: Deno.HttpServer) {
  // ...  
}
```

有关详细信息，请参阅 [deno#20840](https://github.com/denoland/deno/issues/20840)。

- `Deno.shutdown()`

请改用
[`Deno.Conn.closeWrite()`](https://docs.deno.com/api/deno/~/Deno.Conn#method_closeWrite_0)。

```diff
  using conn = await Deno.connect({ port: 80 });

- await Deno.shutdown(conn.rid);
+ await conn.closeWrite();
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.stderr.prototype.rid`

请改用 [`Deno.stderr`](https://docs.deno.com/api/deno/~/Deno.stderr) 实例方法。

```diff
- if (Deno.isatty(Deno.stderr.rid)) {
+ if (Deno.stderr.isTerminal()) {
    console.log("`Deno.stderr` is a terminal");
  }

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(Deno.stderr.rid, data);
+ await Deno.stderr.write(data);

- Deno.close(Deno.stderr.rid);
+ Deno.stderr.close();
```

注意：这个符号在 Deno 2 中被软删除。它的类型已被删除，但其实现仍然存在以减少断裂性变化。你可以通过使用
[`@ts-ignore`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#suppress-errors-in-ts-files-using--ts-ignore-comments)
指令来忽略 “属性不存在” 的 TypeScript 错误。

```diff
+ // @ts-ignore `Deno.stderr.rid` is soft-removed as of Deno 2.
  Deno.isatty(Deno.stderr.rid);
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.stdin.prototype.rid`

请改用 [`Deno.stdin`](https://docs.deno.com/api/deno/~/Deno.stdin) 实例方法。

```diff
- if (Deno.isatty(Deno.stdin.rid)) {
+ if (Deno.stdin.isTerminal()) {
    console.log("`Deno.stdout` is a terminal");
  }

  const buffer = new Uint8Array(1_024);
- await Deno.write(Deno.stdin.rid, buffer);
+ await Deno.stdin.write(buffer);

- Deno.close(Deno.stdin.rid);
+ Deno.stdin.close();
```

注意：这个符号在 Deno 2 中被软删除。它的类型已被删除，但其实现仍然存在以减少断裂性变化。你可以通过使用
[`@ts-ignore`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#suppress-errors-in-ts-files-using--ts-ignore-comments)
指令来忽略 “属性不存在” 的 TypeScript 错误。

```diff
+ // @ts-ignore `Deno.stdin.rid` is soft-removed as of Deno 2.
  Deno.isatty(Deno.stdin.rid);
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.stdout.prototype.rid`

请改用 [`Deno.stdout`](https://docs.deno.com/api/deno/~/Deno.stdout) 实例方法。

```diff
- if (Deno.isatty(Deno.stdout.rid)) {
+ if (Deno.stdout.isTerminal()) {
    console.log("`Deno.stdout` is a terminal");
  }

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(Deno.stdout.rid, data);
+ await Deno.stdout.write(data);

- Deno.close(Deno.stdout.rid);
+ Deno.stdout.close();
```

注意：这个符号在 Deno 2 中被软删除。它的类型已被删除，但其实现仍然存在以减少断裂性变化。你可以通过使用
[`@ts-ignore`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#suppress-errors-in-ts-files-using--ts-ignore-comments)
指令来忽略 “属性不存在” 的 TypeScript 错误。

```diff
+ // @ts-ignore `Deno.stdout.rid` is soft-removed as of Deno 2.
  Deno.isatty(Deno.stdout.rid);
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.TcpConn.prototype.rid`

请改用 [`Deno.TcpConn`](https://docs.deno.com/api/deno/~/Deno.TcpConn) 实例方法。

```diff
  using tcpConn = await Deno.connect({ port: 80 });

  const buffer = new Uint8Array(1_024);
- await Deno.read(tcpConn.rid, buffer);
+ await tcpConn.read(buffer);

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(tcpConn.rid, data);
+ await tcpConn.write(data);

- await Deno.shutdown(tcpConn.rid);
+ await tcpConn.closeWrite();

- Deno.close(tcpConn.rid);
+ tcpConn.close();
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.TlsConn.prototype.rid`

请改用 [`Deno.TlsConn`](https://docs.deno.com/api/deno/~/Deno.TlsConn) 实例方法。

```diff
  const caCert = await Deno.readTextFile("./certs/my_custom_root_CA.pem");
  using tlsConn = await Deno.connectTls({ caCerts: [caCert], hostname: "192.0.2.1", port: 80 });

  const buffer = new Uint8Array(1_024);
- await Deno.read(tlsConn.rid, buffer);
+ await tlsConn.read(buffer);

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(tlsConn.rid, data);
+ await tlsConn.write(data);

- await Deno.shutdown(tlsConn.rid);
+ await tlsConn.closeWrite();

- Deno.close(tlsConn.rid);
+ tlsConn.close();
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.TlsListener.prototype.rid`

请改用 [`Deno.TlsListener`](https://docs.deno.com/api/deno/~/Deno.TlsListener)
实例方法。

```diff
  const listener = Deno.listenTls({
    port: 443,
    cert: Deno.readTextFileSync("./server.crt"),
    key: Deno.readTextFileSync("./server.key"),
  });

  // ...

- Deno.close(listener.rid);
+ listener.close();
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.UnixConn.prototype.rid`

请改用 [`Deno.UnixConn`](https://docs.deno.com/api/deno/~/Deno.UnixConn) 实例方法。

```diff
  using unixConn = await Deno.connect({ path: "/foo/bar.sock", transport: "unix" });

  const buffer = new Uint8Array(1_024);
- await Deno.read(unixConn.rid, buffer);
+ await unixConn.read(buffer);

  const data = new TextEncoder().encode("Hello, world!");
- await Deno.write(unixConn.rid, data);
+ await unixConn.write(data);

- await Deno.shutdown(unixConn.rid);
+ await unixConn.closeWrite();

- Deno.close(unixConn.rid);
+ unixConn.close();
```

有关详细信息，请参见 [Deno 1.40 博客文章][Deno 1.40 博客文章]。

- `Deno.writeAllSync()`

请改用来自标准库的 [`writeAllSync()`](https://jsr.io/@std/io/doc/~/writeAllSync)。

```diff
+ import { writeAllSync } from "jsr:@std/io/write-all";

  const data = new TextEncoder().encode("Hello, world!");

- Deno.writeAllSync(Deno.stdout, data);
+ writeAllSync(Deno.stdout, data);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.writeAll()`

请改用来自标准库的 [`writeAll()`](https://jsr.io/@std/io/doc/~/writeAll)。

```diff
+ import { writeAll } from "jsr:@std/io/write-all";

  const data = new TextEncoder().encode("Hello, world!");

- await Deno.writeAll(Deno.stdout, data);
+ await writeAll(Deno.stdout, data);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.Writer`

请改用来自标准库的 [Writer](https://jsr.io/@std/io/doc/~/Writer)。

```diff
+ import type { Writer } from "jsr:@std/io/types";

- function foo(writer: Deno.Writer) {
+ function foo(writer: Writer) {
  // ...  
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.WriterSync`

请改用来自标准库的 [WriterSync](https://jsr.io/@std/io/doc/~/WriterSync)。

```diff
+ import type { WriterSync } from "jsr:@std/io/types";

- function foo(writer: Deno.WriterSync) {
+ function foo(writer: WriterSync) {
  // ...  
}
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.writeSync()`

请改用资源的 `.writeSync()` 方法。

```diff
  using conn = await Deno.connect({ port: 80 });
  const buffer = new TextEncoder().encode("My message");

- Deno.writeSync(conn.rid, buffer);
+ conn.writeSync(buffer);
```

```diff
  using file = Deno.openSync("/foo/bar.txt", { write: true });
  const buffer = new TextEncoder().encode("My message");

- Deno.writeSync(file.rid, buffer);
+ file.writeSync(buffer);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `Deno.write()`

请改用资源的 `.write()` 方法。

```diff
  using conn = await Deno.connect({ port: 80 });
  const buffer = new TextEncoder().encode("My message");

- await Deno.write(conn.rid, buffer);
+ await conn.write(buffer);
```

```diff
  using file = await Deno.open("/foo/bar.txt", { write: true });
  const buffer = new TextEncoder().encode("My message");

- await Deno.write(file.rid, buffer);
+ await file.write(buffer);
```

有关详细信息，请参阅 [deno#9795][deno#9795]。

- `new Deno.FsFile()`

请改用 [`Deno.openSync()`](https://docs.deno.com/api/deno/~/Deno.openSync) 或
[`Deno.open()`](https://docs.deno.com/api/deno/~/Deno.open)。

```diff
- const file = new Deno.FsFile(3);
+ using file = await Deno.open("/foo/bar.txt");
```

- `window`

请改用 `globalThis`。

```diff
  const messageBuffer = new TextEncoder().encode("Hello, world!");
  
- const hashBuffer = await window.crypto.subtle.digest("SHA-256", messageBuffer);
+ const hashBuffer = await globalThis.crypto.subtle.digest("SHA-256", messageBuffer);
```

请参见 [deno#9795][deno#9795]。

[deno#9795]: https://github.com/denoland/deno/issues/9795
[Deno 1.40 博客文章]: https://deno.com/blog/v1.40#deprecations-stabilizations-and-removals

---

# runtime/reference/node_apis.md

> A guide to Node.js compatibility in Deno. Learn about supported Node.js built-in modules, global objects, and how to use Node.js packages in Deno projects.

URL: https://docs.deno.com/runtime/reference/node_apis


Deno 为多个内置的 Node.js 模块和全局变量提供了填充。

<a href="/api/node/" class="docs-cta runtime-cta">探索内置 Node API</a>

Node 兼容性是一个正在进行的项目 - 帮助我们识别缺口，并告诉我们
您需要哪些模块，通过
[在 GitHub 上开一个问题](https://github.com/denoland/deno)。

{{ await generateNodeCompatibility() }}

## 全局变量

这是 Deno 支持的 Node 全局变量列表。这些全局变量仅在 `npm` 包范围内可用。在您自己的代码中，您可以通过从相关的 `node:` 模块导入它们来使用它们。

| 全局变量名                                                                                                            | 状态                               |
| ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------- |
| [`AbortController`](https://nodejs.org/api/globals.html#class-abortcontroller)                                        | ✅                                 |
| [`AbortSignal`](https://nodejs.org/api/globals.html#class-abortsignal)                                              | ✅                                 |
| [`Blob`](https://nodejs.org/api/globals.html#class-blob)                                                            | ✅                                 |
| [`Buffer`](https://nodejs.org/api/globals.html#class-buffer)                                                        | ✅                                 |
| [`ByteLengthQueuingStrategy`](https://nodejs.org/api/globals.html#class-bytelengthqueuingstrategy)                   | ✅                                 |
| [`__dirname`](https://nodejs.org/api/globals.html#__dirname)                                                        | ⚠️ [信息](#node.js-global-objects) |
| [`__filename`](https://nodejs.org/api/globals.html#__filename)                                                      | ⚠️ [信息](#nodejs-global-objects)  |
| [`atob`](https://nodejs.org/api/globals.html#atobdata)                                                              | ✅                                 |
| [`BroadcastChannel`](https://nodejs.org/api/globals.html#broadcastchannel)                                          | ✅                                 |
| [`btoa`](https://nodejs.org/api/globals.html#btoadata)                                                              | ✅                                 |
| [`clearImmediate`](https://nodejs.org/api/globals.html#clearimmediateimmediateobject)                                 | ✅                                 |
| [`clearInterval`](https://nodejs.org/api/globals.html#clearintervalintervalobject)                                   | ✅                                 |
| [`clearTimeout`](https://nodejs.org/api/globals.html#cleartimeouttimeoutobject)                                      | ✅                                 |
| [`CompressionStream`](https://nodejs.org/api/globals.html#class-compressionstream)                                   | ✅                                 |
| [`console`](https://nodejs.org/api/globals.html#console)                                                            | ✅                                 |
| [`CountQueuingStrategy`](https://nodejs.org/api/globals.html#class-countqueuingstrategy)                             | ✅                                 |
| [`Crypto`](https://nodejs.org/api/globals.html#crypto)                                                              | ✅                                 |
| [`CryptoKey`](https://nodejs.org/api/globals.html#cryptokey)                                                        | ✅                                 |
| [`CustomEvent`](https://nodejs.org/api/globals.html#customevent)                                                    | ✅                                 |
| [`CustomEvent`](https://nodejs.org/api/globals.html#customevent)                                                    | ✅                                 |
| [`DecompressionStream`](https://nodejs.org/api/globals.html#class-decompressionstream)                               | ✅                                 |
| [`Event`](https://nodejs.org/api/globals.html#event)                                                                | ✅                                 |
| [`EventTarget`](https://nodejs.org/api/globals.html#eventtarget)                                                    | ✅                                 |
| [`exports`](https://nodejs.org/api/globals.html#exports)                                                            | ✅                                 |
| [`fetch`](https://nodejs.org/api/globals.html#fetch)                                                                | ✅                                 |
| [`File`](https://nodejs.org/api/globals.html#class-file)                                                            | ✅                                 |
| [`FormData`](https://nodejs.org/api/globals.html#class-formdata)                                                    | ✅                                 |
| [`global`](https://nodejs.org/api/globals.html#global)                                                              | ✅                                 |
| [`Headers`](https://nodejs.org/api/globals.html#class-headers)                                                      | ✅                                 |
| [`MessageChannel`](https://nodejs.org/api/globals.html#messagechannel)                                              | ✅                                 |
| [`MessageEvent`](https://nodejs.org/api/globals.html#messageevent)                                                  | ✅                                 |
| [`MessagePort`](https://nodejs.org/api/globals.html#messageport)                                                    | ✅                                 |
| [`module`](https://nodejs.org/api/globals.html#module)                                                              | ✅                                 |
| [`PerformanceEntry`](https://nodejs.org/api/globals.html#performanceentry)                                          | ✅                                 |
| [`PerformanceMark`](https://nodejs.org/api/globals.html#performancemark)                                            | ✅                                 |
| [`PerformanceMeasure`](https://nodejs.org/api/globals.html#performancemeasure)                                      | ✅                                 |
| [`PerformanceObserver`](https://nodejs.org/api/globals.html#performanceobserver)                                     | ✅                                 |
| [`PerformanceObserverEntryList`](https://nodejs.org/api/globals.html#performanceobserverentrylist)                   | ❌                                 |
| [`PerformanceResourceTiming`](https://nodejs.org/api/globals.html#performanceresourcetiming)                         | ❌                                 |
| [`performance`](https://nodejs.org/api/globals.html#performance)                                                    | ✅                                 |
| [`process`](https://nodejs.org/api/globals.html#process)                                                            | ✅                                 |
| [`queueMicrotask`](https://nodejs.org/api/globals.html#queuemicrotaskcallback)                                      | ✅                                 |
| [`ReadableByteStreamController`](https://nodejs.org/api/globals.html#class-readablebytestreamcontroller)              | ✅                                 |
| [`ReadableStream`](https://nodejs.org/api/globals.html#class-readablestream)                                        | ✅                                 |
| [`ReadableStreamBYOBReader`](https://nodejs.org/api/globals.html#class-readablestreambyobreader)                    | ✅                                 |
| [`ReadableStreamBYOBRequest`](https://nodejs.org/api/globals.html#class-readablestreambyobrequest)                  | ✅                                 |
| [`ReadableStreamDefaultController`](https://nodejs.org/api/globals.html#class-readablestreamdefaultcontroller)      | ✅                                 |
| [`ReadableStreamDefaultReader`](https://nodejs.org/api/globals.html#class-readablestreamdefaultreader)              | ✅                                 |
| [`require`](https://nodejs.org/api/globals.html#require)                                                            | ✅                                 |
| [`Response`](https://nodejs.org/api/globals.html#response)                                                          | ✅                                 |
| [`Request`](https://nodejs.org/api/globals.html#request)                                                            | ✅                                 |
| [`setImmediate`](https://nodejs.org/api/globals.html#setimmediatecallback-args)                                     | ✅                                 |
| [`setInterval`](https://nodejs.org/api/globals.html#setintervalcallback-delay-args)                                  | ✅                                 |
| [`setTimeout`](https://nodejs.org/api/globals.html#settimeoutcallback-delay-args)                                    | ✅                                 |
| [`structuredClone`](https://nodejs.org/api/globals.html#structuredclonevalue-options)                                | ✅                                 |
| [`structuredClone`](https://nodejs.org/api/globals.html#structuredclonevalue-options)                                | ✅                                 |
| [`SubtleCrypto`](https://nodejs.org/api/globals.html#subtlecrypto)                                                  | ✅                                 |
| [`DOMException`](https://nodejs.org/api/globals.html#domexception)                                                  | ✅                                 |
| [`TextDecoder`](https://nodejs.org/api/globals.html#textdecoder)                                                    | ✅                                 |
| [`TextDecoderStream`](https://nodejs.org/api/globals.html#class-textdecoderstream)                                   | ✅                                 |
| [`TextEncoder`](https://nodejs.org/api/globals.html#textencoder)                                                    | ✅                                 |
| [`TextEncoderStream`](https://nodejs.org/api/globals.html#class-textencoderstream)                                   | ✅                                 |
| [`TransformStream`](https://nodejs.org/api/globals.html#class-transformstream)                                       | ✅                                 |
| [`TransformStreamDefaultController`](https://nodejs.org/api/globals.html#class-transformstreamdefaultcontroller)     | ✅                                 |
| [`URL`](https://nodejs.org/api/globals.html#url)                                                                    | ✅                                 |
| [`URLSearchParams`](https://nodejs.org/api/globals.html#urlsearchparams)                                           | ✅                                 |
| [`URLSearchParams`](https://nodejs.org/api/globals.html#urlsearchparams)                                           | ✅                                 |
| [`WebAssembly`](https://nodejs.org/api/globals.html#webassembly)                                                    | ✅                                 |
| [`WritableStream`](https://nodejs.org/api/globals.html#class-writablestream)                                        | ✅                                 |
| [`WritableStreamDefaultController`](https://nodejs.org/api/globals.html#class-writablestreamdefaultcontroller)      | ✅                                 |
| [`WritableStreamDefaultWriter`](https://nodejs.org/api/globals.html#class-writablestreamdefaultwriter)              | ✅                                 |

## Node 测试结果

如果您对逐个测试用例的兼容性有更详细的了解，您可以在 [此页面](https://node-test-viewer.deno.dev/) 上找到通过和未通过的 Node.js 测试用例列表。


---

# Configuring TypeScript

> A guide to TypeScript configuration in Deno. Learn about compiler options, type checking JavaScript, JSDoc support, type declarations, and configuring TypeScript for cross-platform compatibility.

URL: https://docs.deno.com/runtime/reference/ts_config_migration


Deno 的灵活性体现在对 TypeScript 和 JavaScript 的平等对待。
无论您是从 JavaScript 迁移到 TypeScript，还是反之，Deno
都提供了便利功能来帮助您顺利过渡。

## JavaScript 的类型检查

您可能希望使您的 JavaScript 更加符合类型，而不必在每个地方添加类型注解。Deno 支持使用 TypeScript 类型检查器来检查 JavaScript 的类型。您可以通过向文件添加检查 JavaScript 的 pragma 来标记单个文件：

```js
// @ts-check
```

这将导致类型检查器推断 JavaScript 代码的类型信息，并将任何问题作为诊断问题提出。

您可以通过提供配置文件并将 check JS 选项设置为 `true` 来为程序中的所有 JavaScript 文件启用此功能，如下所示。然后在命令行运行时使用 `--config` 选项。

```json
{
  "compilerOptions": {
    "checkJs": true
  }
}
```

## 在 JavaScript 中使用 JSDoc

在对 JavaScript 进行类型检查或将 JavaScript 导入到 TypeScript 时，JSDoc 注释可以提供超出代码本身可以推断的额外类型信息。如果您在代码中以支持的
[TypeScript JSDoc](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html) 进行内联注释，Deno 将无缝支持这一点。

例如，要设置数组的类型，可以使用以下 JSDoc 注释：

```js
/** @type {string[]} */
const a = [];
```

## 跳过类型检查

您可能有正在尝试的 TypeScript 代码，其中语法有效但并不完全安全。您可以通过传递 `--no-check` 标志来绕过整个程序的类型检查。

如果您已启用 check JS，还可以通过使用 `nocheck` pragma 跳过整个文件的类型检查，包括 JavaScript：

```js
// @ts-nocheck
```

## 将 JS 文件重命名为 TS 文件

TypeScript 文件受益于 TypeScript 编译器能够对您的代码进行更彻底的安全检查。这通常被称为 _严格模式_。
当您将 `.js` 文件重命名为 `.ts` 时，您可能会看到 TypeScript 之前无法检测到的新类型错误。

## 在 Deno 中配置 TypeScript

TypeScript 提供了许多配置选项，对于刚刚开始使用 TS 的人来说可能会觉得令人生畏。Deno 旨在简化 TypeScript 的使用，而不是让您淹没在无数设置中。Deno 配置 TypeScript 以 **开箱即用**。无需额外的配置麻烦！

但是，如果您确实想更改 TypeScript 编译器选项，Deno 允许您在 `deno.json` 文件中进行更改。在命令行中提供路径，或使用默认路径。例如：

```console
deno run --config ./deno.json main.ts
```

:::note

如果您正在创建需要配置文件的库，请记住，您的所有 TS 模块的消费者也需要该配置文件。此外，配置文件中可能有使其他 TypeScript 模块不兼容的设置。

:::

## TS 编译器选项

以下是可以更改的编译器选项的表格，它们在 Deno 中的默认值以及关于该选项的其他说明：

| 选项                           | 默认值                 | 备注                                                                                                                                     |
| ------------------------------ | ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `allowJs`                      | `true`                 | 这几乎永远不需要更改                                                                                                                   |
| `allowUnreachableCode`         | `false`                |                                                                                                                                           |
| `allowUnusedLabels`            | `false`                |                                                                                                                                           |
| `checkJs`                      | `false`                | 如果为 `true`，则会导致 TypeScript 对 JavaScript 进行类型检查                                                                              |
| `jsx`                          | `"react"`              |                                                                                                                                           |
| `jsxFactory`                   | `"React.createElement"` |                                                                                                                                           |
| `jsxFragmentFactory`           | `"React.Fragment"`      |                                                                                                                                           |
| `keyofStringsOnly`             | `false`                |                                                                                                                                           |
| `lib`                          | `[ "deno.window" ]`     | 该选项的默认值根据 Deno 中的其他设置而有所不同。如果提供，则会覆盖默认值。有关更多信息，请参见下文。                                             |
| `noErrorTruncation`            | `false`                |                                                                                                                                           |
| `noFallthroughCasesInSwitch`   | `false`                |                                                                                                                                           |
| `noImplicitAny`                | `true`                 |                                                                                                                                           |
| `noImplicitOverride`           | `true`                 |                                                                                                                                           |
| `noImplicitReturns`            | `false`                |                                                                                                                                           |
| `noImplicitThis`               | `true`                 |                                                                                                                                           |
| `noImplicitUseStrict`          | `true`                 |                                                                                                                                           |
| `noStrictGenericChecks`        | `false`                |                                                                                                                                           |
| `noUnusedLocals`               | `false`                |                                                                                                                                           |
| `noUnusedParameters`           | `false`                |                                                                                                                                           |
| `noUncheckedIndexedAccess`     | `false`                |                                                                                                                                           |
| `reactNamespace`               | `React`                |                                                                                                                                           |
| `strict`                       | `true`                 |                                                                                                                                           |
| `strictBindCallApply`          | `true`                 |                                                                                                                                           |
| `strictFunctionTypes`          | `true`                 |                                                                                                                                           |
| `strictPropertyInitialization`  | `true`                 |                                                                                                                                           |
| `strictNullChecks`             | `true`                 |                                                                                                                                           |
| `suppressExcessPropertyErrors` | `false`                |                                                                                                                                           |
| `suppressImplicitAnyIndexErrors` | `false`               |                                                                                                                                           |
| `useUnknownInCatchVariables`   | `true`                 |                                                                                                                                           |

有关全系列编译器选项及其如何影响 TypeScript 的信息，请参阅
[TypeScript 手册](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。

## 使用 "lib" 属性

如果您正在处理一个向多个运行时（如浏览器）发送代码的项目，您可以通过 `compilerOptions` 中的 "lib" 属性调整默认类型。

对用户感兴趣的内置库包括：

- `"deno.ns"` - 包含所有自定义的 `Deno` 全局命名空间 API 以及 Deno 对 `import.meta` 的扩展。通常这不会与其他库或全局类型冲突。
- `"deno.unstable"` - 包含额外的不稳定 `Deno` 全局命名空间 API。
- `"deno.window"` - 这是在检查 Deno 主运行时脚本时使用的 "默认" 库。它包括 `"deno.ns"` 以及用于内置的扩展的其他类型库。此库会与标准 TypeScript 库（如 `"dom"` 和 `"dom.iterable"`）冲突。
- `"deno.worker"` - 这是在检查 Deno 网络工作者脚本时使用的库。有关网络工作者的更多信息，请查阅
  [Web 工作者的类型检查](/runtime/reference/ts_config_migration/#type-checking-web-workers)。
- `"dom.asynciterable"` - TypeScript 当前不包括 Deno 实现的 DOM 异步可迭代对象（以及多个浏览器），因此我们自己实现了它，直到它在 TypeScript 中可用。

这些是不会默认启用但在编写计划在其他运行时中也能正常工作的代码时实用的公共库：

- `"dom"` - 包含 TypeScript 的主要浏览器全局库。类型定义在许多方面与 `"deno.window"` 冲突，因此如果使用了 `"dom"`，则考虑仅使用 `"deno.ns"` 来暴露 Deno 特定的 API。
- `"dom.iterable"` - 浏览器全局库的可迭代扩展。
- `"scripthost"` - Microsoft Windows 脚本主机的库。
- `"webworker"` - 浏览器中网络工作者的主要库。与 `"dom"` 一样，这会与 `"deno.window"` 或 `"deno.worker"` 冲突，因此考虑仅使用 `"deno.ns"` 来暴露 Deno 特定的 API。
- `"webworker.importscripts"` - 使 `importScripts()` API 在网络工作者中可用的库。
- `"webworker.iterable"` - 将可迭代添加到网络工作者中的对象的库。现代浏览器支持此功能。

## 针对 Deno 和浏览器

您可能希望编写可以无缝运行于 Deno 和浏览器中的代码。在这种情况下，您需要在使用任何独占于某一个环境的 API 之前有条件地检查执行环境。在这种情况下，典型的 `compilerOptions` 配置可能如下所示：

```json title="deno.json"
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "dom.asynciterable", "deno.ns"]
  }
}
```

这应该允许大多数代码在 Deno 中被正确地类型检查。

如果您预计将在使用 `--unstable` 标志的 Deno 中运行代码，那么您还应该将该库添加到配置中：

```json title="deno.json"
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "dom.asynciterable",
      "deno.ns",
      "deno.unstable"
    ]
  }
}
```

通常情况下，当您在 TypeScript 中使用 `"lib"` 选项时，您还需要包括一个 "es" 库。在 `"deno.ns"` 和 `"deno.unstable"` 的情况下，它们在引入时会自动包含 `"esnext"`。

:::note

如果您遇到类型错误，例如 **找不到 `document` 或 `HTMLElement`**，则可能您使用的库依赖于 DOM。这在设计为在浏览器内和服务器端运行的包中很常见。默认情况下，Deno 仅包括直接支持的库。假设该包正确识别其在运行时所处的环境，那么使用 DOM 库进行类型检查是 "安全" 的。

:::

## 类型和类型声明

Deno 运用 _无非标准模块解析_ 的设计原则。当 TypeScript 检查一个文件时，它只关注其类型。相比之下，`tsc` 编译器使用复杂的逻辑来解析这些类型。默认情况下，`tsc` 期望带有扩展名的模糊模块描述符（例如 `.ts`、`.d.ts` 或 `.js`）。然而，Deno 处理的是明确的描述符。

这里的有趣之处在于：假设您希望使用已经转译为 JavaScript 的 TypeScript 文件及其类型定义文件（`mod.js` 和 `mod.d.ts`）。如果您将 `mod.js` 导入到 Deno，它会严格遵循您的请求并导入 JavaScript 文件。但这里有个问题：您的代码不会像 TypeScript 考虑 `mod.d.ts` 文件和 `mod.js` 文件一样得到全面的类型检查。

为了解决这个问题，Deno 提供了两种解决方案，分别适用于特定场景：

**作为导入者：** 如果您知道应该应用于 JavaScript 模块的类型，可以通过显式指定类型来增强类型检查。

**作为提供者：** 如果您是模块的提供者或宿主，则所有使用该模块的人受益于不必担心类型解析。

## 导入时提供类型

如果您正在使用一个 JavaScript 模块，并且您已经创建了类型（`.d.ts` 文件）或以其他方式获取了您想要使用的类型，您可以指示 Deno 在类型检查时使用该文件，而不是 JavaScript 文件，使用 `@ts-types` 编译提示。

例如，如果您有一个 JavaScript 模块 `coolLib.js` 和一个单独的 `coolLib.d.ts` 文件，您可以这样导入它：

```ts
// @ts-types="./coolLib.d.ts"
import * as coolLib from "./coolLib.js";
```

在对 `coolLib` 进行类型检查并在文件中使用时，`coolLib.d.ts` 的 TypeScript 类型定义将优先于查看 JavaScript 文件。

:::note

在过去，`@ts-types` 指令被称为 `@deno-types`。这个别名仍然有效，但不再推荐使用。请使用 `@ts-types`。

:::

## 托管时提供类型

如果您控制模块的源代码或其在 Web 服务器上的文件托管方式，有两种方式可以让 Deno 知道特定模块的类型（这无需导入者采取任何特别操作）。

### @ts-self-types

如果您提供一个 JavaScript 文件，并希望提供一个声明文件来包含此文件的类型，您可以在 JS 文件中指定一个 `@ts-self-types` 指令，指向声明文件。

例如，如果您制作一个 `coolLib.js` 库，并在 `coolLib.d.ts` 中编写其类型定义，`ts-self-types` 指令将如下所示：

```js title="coolLib.js"
// @ts-self-types="./coolLib.d.ts"

// ... JavaScript 的其他部分 ...
```

### X-TypeScript-Types

Deno 支持用于远程模块的头部，它指示 Deno 在何处找到给定模块的类型。例如，对 `https://example.com/coolLib.js` 的响应可能如下所示：

```console
HTTP/1.1 200 OK
Content-Type: application/javascript; charset=UTF-8
Content-Length: 648
X-TypeScript-Types: ./coolLib.d.ts
```

当看到这个头部时，Deno 会尝试检索 `https://example.com/coolLib.d.ts` 并在对原始模块进行类型检查时使用它。

## 使用环境或全局类型

总体而言，最好在 Deno 中使用模块/UMD 类型定义，模块明确导入其依赖的类型。模块化类型定义可以通过类型定义中的 `declare global` 表达
[全局作用域的增强](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)。例如：

```ts
declare global {
  var AGlobalString: string;
}
```

这会使 `AGlobalString` 在导入类型定义时可用于全局命名空间。

在某些情况下，当利用其他现有类型库时，可能无法利用模块化类型定义。因此，在类型检查程序时，有一些方法可以包含任意类型定义。

### 三斜杠指令

此选项将类型定义与代码本身关联。通过在 TS 文件（非 JS 文件！）中的模块类型附近添加三斜杠的 `types` 指令，类型检查该文件将包括类型定义。例如：

```ts
/// <reference types="./types.d.ts" />
```

提供的描述符与 Deno 中的其他描述符一样进行解析，这意味着它需要一个扩展名，并且相对于引用它的模块。它也可以是一个完全合格的 URL：

```ts
/// <reference types="https://deno.land/x/pkg@1.0.0/types.d.ts" />
```

### 在 deno.json 中提供 "types"

另一种选择是在您的 `deno.json` 中为 `"compilerOptions"` 提供一个 `"types"` 值。例如：

```json title="deno.json"
{
  "compilerOptions": {
    "types": [
      "./types.d.ts",
      "https://deno.land/x/pkg@1.0.0/types.d.ts",
      "/Users/me/pkg/types.d.ts"
    ]
  }
}
```

与上面的三斜杠引用类似，提供的 `"types"` 数组中的描述符将像 Deno 中的其他描述符一样进行解析。在相对描述符的情况下，它将相对于配置文件的路径进行解析。通过指定 `--config=path/to/file` 标志确保 Deno 使用该文件。

## 对 Web 工作者进行类型检查

当 Deno 在 Web 工作者中加载 TypeScript 模块时，它将自动对模块及其依赖项进行类型检查，以确保符合 Deno 网络工作者库。这在其他上下文中（如 `deno check` 或编辑器中）可能会带来挑战。您可以通过几种方式指示 Deno 使用网络工作者库，而不是标准 Deno 库。

### 三斜杠指令

此选项将库设置与代码本身关联。通过在工作者脚本的入口文件顶部添加以下三斜杠指令，Deno 将会将其作为 Deno 网络工作者脚本进行类型检查，无论该模块如何分析：

```ts
/// <reference no-default-lib="true" />
/// <reference lib="deno.worker" />
```

第一个指令确保不使用其他默认库。如果省略此项，您将收到一些冲突的类型定义，因为 Deno 会尝试应用标准 Deno 库。第二个指令则告诉 Deno 应用内置的 Deno 网络工作者类型定义及相关依赖库（如 `"esnext"`）。

这种方法的一个缺点是，代码在其他非 Deno 平台（如 `tsc`）上的可移植性较差，因为只有 Deno 内置了 `"deno.worker"` 库。

### 在 deno.json 中提供 "lib" 设置

您可以在 `deno.json` 文件中提供 "lib" 选项来指示 Deno 使用库文件。例如：

```json title="deno.json"
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["deno.worker"]
  }
}
```

然后在运行 deno 子命令时，您需要传递 `--config path/to/file` 参数，或者如果您正在使用利用 Deno 语言服务器的 IDE，则设置 `deno.config` 设置。

如果您还有非工作者脚本，您要么需要省略 `--config` 参数，要么配置一个适合您的非工作者脚本的配置。

## 重要事项

### 类型声明语义

类型声明文件（`.d.ts` 文件）遵循与 Deno 中其他文件相同的语义。这意味着声明文件被假定为模块声明（_UMD 声明_），而不是环境/全局声明。Deno 将如何处理环境/全局声明是不可预测的。

此外，如果类型声明导入了其他内容，例如另一个 `.d.ts` 文件，它的解析遵循 Deno 的正常导入规则。对于许多生成的并可在网上获得的 `.d.ts` 文件，它们可能与 Deno 不兼容。

[esm.sh](https://esm.sh) 是一个提供默认类型声明的 CDN（通过 `X-TypeScript-Types` 头部）。通过在导入 URL 后附加 `?no-dts` 可以禁用它：

```ts
import React from "https://esm.sh/react?no-dts";
```

## JavaScript 在类型检查时的行为

当您在 Deno 中将 JavaScript 代码导入 TypeScript 时，即使您已将 `checkJs` 设置为 `false`（这是 Deno 的默认行为），TypeScript 编译器仍会分析 JavaScript 模块。它试图从该模块推断导出形状，以验证在您的 TypeScript 文件中的导入。

通常，这在导入标准 ES 模块时不会出现问题。然而，在某些情况下，TypeScript 的分析可能会失败，例如，在具有特殊打包或全局 UMD（通用模块定义）模块的情况下。面对这种情况，最好的方法是使用前面提到的某种形式的类型信息。

### 内部逻辑

虽然理解 Deno 如何在内部工作并不是使用 TypeScript 和 Deno 时的必要条件，但理解其工作原理是有帮助的。

在执行或编译任何代码之前，Deno 通过解析根模块生成一个模块图，然后检测其所有依赖，并递归检索和解析这些模块，直到获取所有依赖。

对于每个依赖项，有两个潜在的 "插槽" 被使用。一个是代码插槽，一个是类型插槽。随着模块图的填充，如果模块是可以发射到 JavaScript 的内容，则填充代码插槽，而类型依赖项，如 `.d.ts` 文件，则填充类型插槽。

当构建模块图并需要进行类型检查时，Deno 启动 TypeScript 编译器，并将需要作为 JavaScript 发射的模块的名称提供给它。在该过程中，TypeScript 编译器会请求额外的模块，而 Deno 将查看依赖的插槽，在填充类型插槽后再提供代码插槽。

这意味着当您导入一个 `.d.ts` 模块或使用上述某个解决方案为 JavaScript 代码提供替代类型模块时，提供给 TypeScript 的即是该类型模块，而不是解析模块时的代码。

---

# Deno & Visual Studio Code

> Complete guide to using Deno with Visual Studio Code. Learn about extension setup, workspace configuration, debugging, testing, task automation, and advanced IDE features for Deno development.

URL: https://docs.deno.com/runtime/reference/vscode


该页面介绍了如何使用 [Visual Studio Code](https://code.visualstudio.com/) 和官方的 [vscode_deno](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno) 扩展来开发 Deno 应用程序。

## 安装

Deno VS Code 扩展直接与 Deno CLI 集成，使用 [语言服务器协议](/runtime/reference/lsp_integration/)。这有助于确保您获取的有关代码的信息与您使用 Deno CLI 运行代码时的运行方式对齐。

Deno 扩展的安装方式与 VS Code 中的其他扩展相同。在 VS Code 的扩展选项卡中搜索 `Deno` 并单击 **安装** 按钮，或者 [这个链接](vscode:extension/denoland.vscode-deno) 将打开扩展页面，您可以选择安装。

首次安装扩展后，您应该会收到一条欢迎页面，欢迎您使用该扩展。（如果您错过了它，或者想再次查看，使用 <kbd>⌘</kbd> <kbd>⇧</kbd> <kbd>P</kbd> 打开命令面板，并运行 **Deno: Welcome** 命令。）

## 在 VS Code 工作区中启用 Deno

我们意识到，您在 VS Code 中工作的并非每个项目都是 Deno 项目。默认情况下，VS Code 配备了内置的 TypeScript/JavaScript 语言服务，当编辑 TypeScript 或 JavaScript 文件时将使用。

为了支持 Deno API，以及能够像 Deno CLI 一样解析模块，您需要在工作区中启用 Deno。最直接的方法是使用 VS Code 的 **Deno: Initialize Workspace Configuration** 命令从 [命令面板](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette)。

![带有 Deno: Initialize Workspace Configuration 的命令面板截图](./images/command_palette.png)

此命令会在工作区配置中添加 `"deno.enable": true`（即您的工作区根目录 `.vscode/settings.json`）。命令完成后，您将收到通知，表示 Deno 工作区已初始化。

![通知 'Deno workspace initialized' 的截图](./images/vscode_workspace_initialized.png)

这些设置（以及其他设置）可以通过 VS Code 的 [设置](https://code.visualstudio.com/docs/getstarted/userinterface#_settings) 面板获取。在面板中，该设置为 **Deno: Enable**。

:::note

VS Code 有用户和工作区设置。您可能不希望在 **用户** 设置中启用 Deno，而是将其设定在 **工作区** 设置中，否则每个工作区都将默认启用 Deno。

:::

### 工作区文件夹设置

这些是在工作区文件夹上可以设置的设置。其余设置当前仅适用于工作区：

- `deno.enable` - 控制是否启用 Deno 语言服务器。当启用时，扩展将禁用内置的 VS Code JavaScript 和 TypeScript 语言服务，并将使用 Deno 语言服务器。_布尔值，默认 `false`_
- `deno.enablePaths` - 控制是否仅对工作区文件夹的特定路径启用 Deno 语言服务器。默认为空列表。
- `deno.codeLens.test` - 控制测试代码透镜是否启用。_布尔值，默认 `true`_
- `deno.codeLens.testArgs` - 在激活测试代码透镜时传递给 `deno test` 的参数列表。_字符串数组，默认 `["--allow-all"]`_

启用项目后，扩展将直接从已安装的 Deno CLI 获取信息。扩展还将静音内置的 TypeScript/JavaScript 扩展。

## 在 VS Code 工作区中部分启用 Deno

在工作区（或工作区文件夹）中，子路径可以启用 Deno，而代码路径外的部分不会启用，VS Code 的内置 JavaScript/TypeScript 语言服务器将被使用。使用 **Deno: Enable Paths** 设置（或如果手动编辑则使用 `deno.enablePaths`）

例如，如果您有如下项目：

```console
project
├── worker
└── front_end
```

您只希望启用 `worker` 路径（及其子路径）为 Deno 启用，您将需要将 `./worker` 添加到配置中的 **Deno: Enable Paths** 列表中。

## 混合 Deno 项目

通过此功能，您可以拥有混合 Deno 项目，其中某些工作区文件夹已启用 Deno，而某些文件夹未启用。这在创建可能具有前端组件的项目时很有用，因为您希望该前端代码有不同的配置。

为了支持此操作，您可以创建一个新工作区（或向现有工作区添加文件夹），并在设置中将其中一个文件夹配置为 `deno.enable` 设置为 `true`，而其他一个设置为 `false`。保存工作区配置后，您会注意到 Deno 语言服务器仅对启用的文件夹应用诊断，而其他文件夹将使用 VS Code 的内置 TypeScript 编译器来提供 TypeScript 和 JavaScript 文件的诊断。

## 代码检查

使用 `deno lint` 时提供诊断的相同引擎也可以通过扩展使用。通过在设置面板中启用 **Deno: Lint** 设置（或如果在 JSON 中手动编辑，则使用 `deno.lint`），编辑器将开始在您的代码中显示 lint "警告"。有关如何使用 Deno lint 的更多信息，请参见 [Linter](/runtime/reference/cli/linter/) 部分。

## 使用配置文件

Deno 项目并不要求使用配置文件，但在某些场景下它可能很有用。如果您希望在命令行中指定 `--config` 选项时应用相同的设置，则可以使用 **Deno: Config** 选项（或如果手动编辑则使用 `deno.config`）。

Deno 扩展还会通过查找工作区根目录中的配置文件来自动识别并应用 `deno.jsonc` 或 `deno.json`。手动指定 **Deno: Config** 选项将覆盖此自动行为。

## 格式化

Deno CLI 提供了一个 [内置格式化工具](/runtime/reference/cli/formatter/)，可以通过 `deno fmt` 访问，但也可以配置为由 VS Code 使用。`Deno` 应该出现在 **编辑器: 默认格式化程序** 设置的下拉列表中（或者如果您手动编辑设置，它将是 `"editor.defaultFormatter": "denoland.vscode-deno"`）。

## 设置 Deno CLI 的路径

扩展在主机的 `PATH` 中查找 Deno CLI 可执行文件，但有时这并不理想，可以设置 **Deno: Path**（或如果手动编辑则使用 `deno.path`）以指向 Deno 可执行文件。如果提供的路径是相对路径，它将相对于工作区根目录解析。

## 导入建议

在尝试导入模块时，扩展将提供完整导入的建议。建议中将包含本地相对文件以及任何缓存的远程文件。

扩展支持注册表自动补全，远程注册表/模块网站可以选择性地提供元数据，以允许客户端发现模块。默认情况下，扩展将检查主机/源以查看它们是否支持建议，如果支持，扩展将提示您查看是否启用。此行为可以通过在设置中取消选中 **Deno > Suggest > Imports: Auto Discover** 选项改变。（或 `deno.suggest.imports.autoDiscover` 如果手动编辑）。

可以通过编辑 **Deno > Suggest > Imports: Hosts** 设置 - `deno.suggest.imports.hosts` 在适当的 `settings.json` 中启用或禁用单独的主机/源。

## 缓存远程模块

Deno 支持远程模块，并将提取远程模块并将其存储在本地缓存中。当您在命令行上执行 `deno run`、`deno test`、`deno info` 或 `deno install` 等操作时，Deno CLI 将获取任何远程模块及其依赖项并填充缓存。

在编辑器中开发代码时，如果模块不在缓存中，您将收到一条诊断信息，例如 `Uncached or missing remote URL: "https://deno.land/example/mod.ts"`，表示任何缺少远程模块。Deno 不会自动尝试缓存模块，除非它是来自注册表导入建议的补全（见上文）。

除了在命令行上运行命令外，扩展还提供了在编辑器中缓存依赖项的方法。缺少依赖项将具有一个 _快速修复_，让 Deno 尝试缓存该依赖项。修复可以通过在导入说明符上按 <kbd>CTRL</kbd> <kbd>.</kbd> 或 <kbd>⌘</kbd> <kbd>.</kbd> 来访问，或者悬停在说明符上并选择 **Quick Fix...**。

命令面板中还有 **Deno: Cache Dependencies** 命令，该命令将尝试缓存当前在编辑器中激活的模块的任何依赖项。

## 代码透镜

语言服务器当前支持若干代码透镜（可操作的上下文信息穿插在代码中），使您可以对代码获得更深入的洞察。大多数默认为禁用，但可以轻松启用：

### Deno > 代码透镜: 实现

`deno.codeLens.implementations` - 提供一个透镜，可以列出代码中任何其他位置的项目实现。

### Deno > 代码透镜: 引用

`deno.codeLens.references` - 提供一个透镜，可以列出代码中任何其他位置对项目的引用。

### Deno > 代码透镜: 所有函数的引用

`deno.codeLens.referencesAllFunctions` - 提供一个透镜，可以列出代码中所有函数的所有引用。所有函数都被排除在上面提到的 _References_ 设置之外。

### 测试代码透镜

Deno CLI 包含一个 [内置测试 API](/runtime/reference/lsp_integration/#testing)，可在 `Deno.test` 下可用。该扩展和语言服务器默认启用一个代码透镜，提供了从编辑器运行测试的能力。

当您有一个提供测试的代码块时：

```ts
import { assert } from "jsr:@std/assert@1";

Deno.test({
  name: "a test case",
  fn() {
    let someCondition = true;
    assert(someCondition);
  },
});
```

您将在测试上方看到一个代码透镜：

```console
▶ 运行测试
```

如果您单击代码透镜，扩展将启动 Deno CLI 为您运行测试并显示输出。根据您的其他设置，扩展将尝试以相同的设置运行您的测试。如果您需要调整在执行 `deno test` 时提供的参数，您可以通过设置 `deno.codeLens.testArgs` 设置来实现。

扩展还将尝试跟踪您在同一模块中是否解构了 `Deno.test` 函数或将其分配给变量。这样，您可以像这样做并仍然让代码透镜工作：

```ts
const { test: denoTest } = Deno;

denoTest({
  name: "example test",
  fn() {},
});
```

如果您想禁用该功能，可以通过取消设置 **Deno > 代码透镜: 测试** 设置 - `deno.codeLens.test` 来实现。

您可以通过测试资源管理器视图、代码透镜装饰或命令面板运行测试。您还可以在测试资源管理器视图中使用过滤功能以排除某些测试不参加测试运行。

当测试失败时，失败消息，包括堆栈跟踪，将在 VS Code 中检查测试结果时可用。

### 测试配置

默认情况下，测试的执行方式类似于您在命令行中使用 `deno test --allow-all`。可以通过在用户或工作区设置中设置 **Deno > Testing: Args** 选项（或 `deno.testing.args` 如果您手动配置）来更改这些默认参数。在这里添加您本来会使用 `deno test` 子命令的单独参数。

基于您拥有的其他设置，这些选项将自动合并到运行测试时使用的 "命令行" 中，除非在 **Deno > Testing: Args** 设置中明确提供。

## 使用调试器

该扩展提供与内置的 VS Code 调试器的集成。您可以通过以下方式生成配置：转到 `运行和调试` 面板，点击 `创建一个 launch.json 文件`，并从可用的调试器选项中选择 `Deno` 选项。（生成的配置 `type` 将是 `node`；这没问题。）

## 任务

尽管扩展与语言服务器直接通信，但有时您可能更希望通过 CLI 运行 Deno 命令。您可以在工作区根目录中的 `deno.json` 文件中定义任务，位于 [`tasks` 字段](/runtime/fundamentals/configuration/#tasks).

## 使用开发容器

使用 [开发容器](https://code.visualstudio.com/docs/remote/containers) 与 VS Code 是获得隔离开发环境的绝佳方式，而无需担心在本地系统上安装 Deno CLI。Deno 支持开发容器，Deno 扩展将与之配合使用。

如果您有一个现有的 Deno 项目，您希望添加开发容器支持，则在命令面板中执行 **Remote-Containers: Add Development Container Configuration Files...**，选择 **Show All Definitions...**，然后搜索 `Deno` 定义。这将设置一个基线的 `.devcontainer` 配置，将在容器中安装 Deno CLI 的最新版本。

添加后，VS Code 会提示您是否希望在开发容器中打开项目。如果您选择这样做，VS Code 将构建开发容器，并使用该开发容器重新打开工作区，其中将安装 Deno CLI 和 `vscode_deno` 扩展。

## 故障排除

以下部分涵盖使用扩展时可能遇到的挑战，并尝试提供可能的原因。

### 错误/诊断

`导入路径无法以 '.ts' 扩展名结束。` 或 `找不到名称 'Deno'.`

这通常是 Deno 没有在 Deno 项目中启用的情况。如果您查看诊断源，您可能会看到 `ts(2691)`。`ts` 表示它来自 VS Code 中内置的 TypeScript/JavaScript 引擎。您将需要检查您的配置是否正确设置以及 **Deno: Enable** 设置 - `deno.enable` 是否为 true。

您还可以通过使用命令面板中的 **Deno: Language Server Status** 查看 Deno 语言服务器认为您当前的活动配置。这将显示一个来自语言服务器的文档，其中包含名为 "Workspace Configuration" 的部分。这将给您提供 VS Code 报告给语言服务器的配置。

还要检查 VS Code 配置中 `enableProjectDiagnostics`，它位于 **TypeScript › Tsserver › Experimental: Enable Project Diagnostics** 是否为 **禁用**。此设置允许 TypeScript 语言服务器在后台一次检查整个项目，Deno 不能禁用其行为，因此错误会继续显示，即使所有其他设置都已正确设置。

如果 `"enable"` 在此处设置为 `true`，并且错误消息仍然存在，您可能想重启 VS Code，因为扩展中 "静音" 内置 TypeScript 诊断文件的部分没有按预期工作。如果在重启后问题仍然存在，您可能遇到了我们未预料到的错误，接下来的步骤是搜索问题并在 https://github.com/denoland/vscode_deno 上报告错误。


---

# WebAssembly

> 在 Deno 中使用 WebAssembly (Wasm) 的指南。了解模块导入、类型检查、流式 API、优化技术以及如何与编译为 Wasm 的各种编程语言进行协作。

URL: https://docs.deno.com/runtime/reference/wasm


WebAssembly（Wasm）旨在与 JavaScript 一起使用，以加快关键应用程序组件的速度，其执行速度可以比 JavaScript 高得多且更一致 - 类似于 C、C++ 或 Rust。Deno 可以使用与 [浏览器提供的](https://developer.mozilla.org/en-US/docs/WebAssembly) 相同的接口执行 WebAssembly 模块，并通过将其作为模块导入来使用它们。

## Wasm 模块

从 Deno 2.1 开始，可以导入 WebAssembly 模块并对其使用进行类型检查。

假设我们有一个 [WebAssembly 文本格式](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format) 文件，它导出一个 `add` 函数，该函数将两个数字相加并返回结果：

```wat title="add.wat"
(module
  (func (export "add") (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.add
  )
)
```

我们可以通过 [wat2wasm](https://github.com/webassembly/wabt) 将其编译为 `add.wasm`：

```sh
wat2wasm add.wat
```

然后通过导入语句使用此 WebAssembly 模块：

```ts title="main.ts"
import { add } from "./add.wasm";

console.log(add(1, 2));
```

```shellsession
> deno run main.ts
3
```

### 类型检查

Deno 理解 Wasm 模块的导出并对其使用进行类型检查。如果在前面的示例中，我们错误地调用 `add` 函数，则会看到类型检查错误。

```ts title="main.ts"
import { add } from "./add.wasm";

console.log(add(1, ""));
```

```shellsession
> deno check main.ts   
Check file:///.../main.ts
error: TS2345 [ERROR]: Argument of type 'string' is not assignable to parameter of type 'number'.
console.log(add(1, ""));
                   ~~
    at file:///.../main.ts:3:20
```

### 导入

与 JavaScript 类似，Wasm 模块也可以导入其他模块。

例如，我们可以创建一个 Wasm 模块，导入 `"./values.js"` 说明符并调用 `getValue` 导出：

```wat title="toolkit.wat"
(module
  (import "./time.ts" "getTimeInSeconds" (func $get_time (result i32)))

  (func (export "getValue") (result i32)
    call $get_time
  )
)
```

```js title="time.ts"
export function getTimeInSeconds() {
  return Date.now() / 1000;
}
```

```js title="main.ts"
import { getValue } from "./toolkit.wasm";

console.log(getValue());
```

现在运行：

```shellsession
> wat2wasm toolkit.wat
> deno run main.ts
1732147633
V:\scratch
> deno run main.ts
1732147637
```

#### 重写导入说明符

通常，Wasm 模块不会使用相对说明符来方便地导入另一个 JavaScript 模块。假设我们有以下与之前类似的设置，但注意 Wasm 模块通过 "env" 说明符进行导入。

```wat title="toolkit.wat"
(module
  (import "env" "get_time_in_seconds" (func $get_time (result i32)))

  (func (export "getValue") (result i32)
    call $get_time
  )
)
```

```js title="env.ts"
function getTimeInSeconds() {
  return Date.now() / 1000;
}

export { getTimeInSeconds as get_time_in_seconds };
```

```js title="main.ts"
import { getValue } from "./toolkit.wasm";

console.log(getValue());
```

```shellsession
> wat2wasm toolkit.wat
> deno run main.ts
error: Relative import path "env" not prefixed with / or ./ or ../
    at file:///.../toolkit.wasm
```

这并不是很方便，因为我们希望它导入 `"./env.ts"`。

幸运的是，通过在 _deno.json_ 中通过 [导入映射](https://github.com/WICG/import-maps) 将说明符映射，可以很简单地使其工作：

```json title="deno.json"
{
  "imports": {
    "env": "./env.ts"
  }
}
```

现在它可以正常工作：

```shellsession
> deno run main.ts
1732148355
```

## 通过 WebAssembly API 使用 WebAssembly

要在 Deno 中运行 WebAssembly，您只需要一个要运行的 Wasm 模块。以下模块导出一个 `main` 函数，该函数在调用时仅返回 `42`：

```ts
// deno-fmt-ignore
const wasmCode = new Uint8Array([
  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127,
  3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0,
  5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145,
  128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97,
  105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0,
  65, 42, 11
]);

const wasmModule = new WebAssembly.Module(wasmCode);

const wasmInstance = new WebAssembly.Instance(wasmModule);

const main = wasmInstance.exports.main as CallableFunction;
console.log(main().toString());
```

为了通过 WebAssembly API 加载 WebAssembly，需要执行以下步骤：

1. 获取二进制文件（通常为 `.wasm` 文件，尽管我们现在使用一个简单的字节数组）
2. 将二进制文件编译为 `WebAssembly.Module` 对象
3. 实例化 WebAssembly 模块

WebAssembly 是一种二进制数据格式，旨在不易于人类阅读，也不应手动编写。您的 `.wasm` 文件应由如 [Rust](https://www.rust-lang.org/)、[Go](https://golang.org/) 或 [AssemblyScript](https://www.assemblyscript.org/) 等语言的编译器生成。

例如，编译成上述字节的 Rust 程序可能看起来像这样：

```rust
#[no_mangle]
pub fn main() -> u32 { // u32 代表使用 32 位内存的无符号整数。
  42
}
```

## 使用流式 WebAssembly API

获取、编译和实例化 WebAssembly 模块的 [最有效](/api/web/~/WebAssembly.instantiateStreaming) 方法是使用 WebAssembly API 的流式变体。例如，您可以使用 `instantiateStreaming` 结合 `fetch` 一次性执行这三步：

```ts
const { instance, module } = await WebAssembly.instantiateStreaming(
  fetch("https://wpt.live/wasm/incrementer.wasm"),
);

const increment = instance.exports.increment as (input: number) => number;
console.log(increment(41));
```

请注意，`.wasm` 文件必须使用 `application/wasm` MIME 类型提供。如果您希望在实例化之前对模块执行其他操作，您可以改为使用 [`compileStreaming`](/api/web/~/WebAssembly.compileStreaming)：

```ts
const module = await WebAssembly.compileStreaming(
  fetch("https://wpt.live/wasm/incrementer.wasm"),
);

/* do some more stuff */

const instance = await WebAssembly.instantiate(module);
instance.exports.increment as (input: number) => number;
```

如果由于某种原因您无法使用流式方法，则可以回退到效率较低的 [`compile`](/api/web/~/WebAssembly.compile) 和 [`instantiate`](/api/web/~/WebAssembly.instantiate) 方法。

有关流式方法为何更高效的更深入了解，请 [查看这篇文章](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/)。

## WebAssembly API

有关 WebAssembly API 所有部分的更多信息，请参见
[Deno 参考指南](/api/web/~/WebAssembly) 和
[MDN](https://developer.mozilla.org/en-US/docs/WebAssembly)。

## 处理非数字类型

本文档中的代码示例仅使用了 WebAssembly 模块中的数字类型。要使用更复杂的类型（如字符串或类）运行 WebAssembly，您需要使用生成 JavaScript 和编译为 WebAssembly 的语言之间类型绑定的工具。

关于如何在 JavaScript 和 Rust 之间创建类型绑定、将其编译为二进制文件并从 JavaScript 程序调用的示例，可以在 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm) 上找到。

如果您计划在 Rust+WebAssembly 中进行大量 Web API 工作，您可能会发现 [web_sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) 和 [js_sys](https://rustwasm.github.io/wasm-bindgen/contributing/js-sys/index.html) Rust crates 很有用。`web_sys` 包含 Deno 中可用的大多数 Web API 的绑定，而 `js_sys` 提供 JavaScript 标准内置对象的绑定。

## 在 Deno 中使用 wasmbuild 进行 Rust WebAssembly 开发

[wasmbuild](https://github.com/denoland/wasmbuild) 是一个官方的 Deno 工具，简化了在 Deno 项目中使用 Rust 和 WebAssembly。它自动化了将 Rust 代码编译为 WebAssembly 和生成 TypeScript 绑定的过程，使从 JavaScript 调用 Rust 函数变得简单。

wasmbuild 为您的 Rust 函数生成 TypeScript 定义，提供完整的类型检查。生成的 JavaScript 可以与 esbuild 等打包器一起使用。生成的文件可以直接提交到源代码控制中，以便于部署。

## 优化

对于生产构建，您可以对 WebAssembly 二进制文件进行优化。如果您通过网络提供二进制文件，则优化大小可以产生真正的差异。如果您主要在服务器上执行 WebAssembly 以执行计算密集型任务，则优化速度可能是有益的。您可以在 [这里](https://rustwasm.github.io/docs/book/reference/code-size.html) 找到有关优化（生产）构建的良好指南。此外， [rust-wasm 小组](https://rustwasm.github.io/docs/book/reference/tools.html) 提供了一些用于优化和处理 WebAssembly 二进制文件的工具列表。

---

# Web Platform APIs

> A guide to the Web Platform APIs available in Deno. Learn about fetch, events, workers, storage, and other web standard APIs, including implementation details and deviations from browser specifications.

URL: https://docs.deno.com/runtime/reference/web_platform_apis


Deno 简化网络和云开发的一种方式是使用标准的 Web 平台 API（如 `fetch`、WebSockets 等）而不是专有 API。这意味着如果你曾经为浏览器开发过，你可能已经对 Deno 有了一定的熟悉；而如果你正在学习 Deno，你也在投资于对网络的了解。

<a href="/api/web/" class="docs-cta runtime-cta">Explore supported Web APIs</a>

下面我们将重点介绍一些 Deno 支持的标准 Web API。

要检查某个 Web 平台 API 是否在 Deno 中可用，你可以点击
[MDN 上的接口](https://developer.mozilla.org/en-US/docs/Web/API#interfaces)
并参考
[其浏览器兼容性表](https://developer.mozilla.org/en-US/docs/Web/API/AbortController#browser_compatibility)。

## fetch

[`fetch`](/api/web/~/fetch) API 可用于发起 HTTP 请求。它的实现符合
[WHATWG `fetch` 规范](https://fetch.spec.whatwg.org/)。

### 规范偏差

- Deno 用户代理没有 cookie 存储。因此，响应中的 `set-cookie` 头不会被处理，也不会从可见的响应头中过滤。
- Deno 不遵循同源策略，因为 Deno 用户代理当前没有原始的概念，也没有 cookie 存储。这意味着 Deno 不需要保护防止跨源泄露身份验证数据。因此 Deno 不实现 WHATWG `fetch` 规范的以下部分：
  - 第 `3.1.` 节：`'Origin'` 头。
  - 第 `3.2.` 节：CORS 协议。
  - 第 `3.5.` 节：CORB。
  - 第 `3.6.` 节：`'Cross-Origin-Resource-Policy'` 头。
  - `原子 HTTP 重定向处理`。
  - `opaqueredirect` 响应类型。
- 使用 `redirect` 模式为 `manual` 的 `fetch` 会返回 `basic` 响应，而不是 `opaqueredirect` 响应。
- 规范对于如何处理 [`file:` URLs](https://fetch.spec.whatwg.org/#scheme-fetch) 上并不明确。Firefox 是唯一实施 `file:` URLs 获取的主流浏览器，即使如此，默认情况下它不工作。从 Deno 1.16 开始，Deno 支持获取本地文件。请参阅下一节以获取详情。
- `request` 和 `response` 头保护已实现，但与浏览器不同，没有任何对允许哪些头名称的限制。
- `referrer`、`referrerPolicy`、`mode`、`credentials`、`cache`、`integrity`、`keepalive` 和 `window` 属性及其在 `RequestInit` 中的相关行为未实现。相关字段不存在于 `Request` 对象上。
- 支持请求体上传流（在 HTTP/1.1 和 HTTP/2 上）。与当前的 fetch 提案不同，实施方案支持双向流。
- 在迭代 `headers` 时，`set-cookie` 头不会被连接。此行为正在
  [进行规范](https://github.com/whatwg/fetch/pull/1346)。

### 获取本地文件

Deno 支持获取 `file:` URLs。这使得编写在服务器上和本地使用相同代码路径的代码变得更容易，同时也更容易编写可以在 Deno CLI 和 Deno Deploy 中工作的代码。

Deno 只支持绝对的文件 URL，这意味着 `fetch("./some.json")` 将不工作。然而需要注意的是，如果指定了 [`--location`](#location)，相对 URL 将使用 `--location` 作为基础，但 `file:` URL 不能作为 `--location` 传递。

要能够获取一个相对于当前模块的资源，该资源在本地或远程都能工作，应该使用 `import.meta.url` 作为基础。例如：

```js
const response = await fetch(new URL("./config.json", import.meta.url));
const config = await response.json();
```

关于获取本地文件的注意事项：

- 对读取资源施加权限，因此需要适当的 `--allow-read` 权限才能读取本地文件。
- 本地获取仅支持 `GET` 方法，对于其他任何方法都会拒绝 promise。
- 不存在的文件会简单地拒绝 promise，并抛出模糊的 `TypeError`。这是为了避免指纹识别攻击的潜在风险。
- 响应中没有设置任何头。因此由消费者决定内容类型或内容长度等。
- 响应体从 Rust 端流式传输，因此大文件是分块可用的，并且可以被取消。

## CustomEvent 和 EventTarget

[DOM 事件 API](/api/web/~/Event) 可用于在应用程序中分发和监听事件。它的实现符合
[WHATWG DOM 规范](https://dom.spec.whatwg.org/#events)。

### 规范偏差

- 事件不会冒泡，因为 Deno 没有 DOM 层次结构，因此没有事件可以冒泡/捕获的树。
- `timeStamp` 属性始终设置为 `0`。

## 类型定义

实现的 Web API 的 TypeScript 定义可以在
[`lib.deno.shared_globals.d.ts`](https://github.com/denoland/deno/blob/main/cli/tsc/dts/lib.deno.shared_globals.d.ts)
和
[`lib.deno.window.d.ts`](https://github.com/denoland/deno/blob/main/cli/tsc/dts/lib.deno.window.d.ts)
文件中找到。

特定于 worker 的定义可以在
[`lib.deno.worker.d.ts`](https://github.com/denoland/deno/blob/main/cli/tsc/dts/lib.deno.worker.d.ts)
文件中找到。

## Location

Deno 支持来自 Web 的 [`location`](/api/web/~/Location) 全局。

### Location 标志

在 Deno 进程中没有可以用于位置的“网页” URL。因此，我们允许用户通过 CLI 指定一个来模拟文档位置，使用 `--location` 标志。它可以是一个 `http` 或 `https` URL。

```ts
// deno run --location https://example.com/path main.ts

console.log(location.href);
// "https://example.com/path"
```

你必须传递 `--location <href>` 才能让这项工作正常。如果不这样做，任何对 `location` 全局的访问都将抛出错误。

```ts
// deno run main.ts

console.log(location.href);
// error: Uncaught ReferenceError: Access to "location", run again with --location <href>.
```

设置 `location` 或其任何字段通常会导致浏览器中的导航。在 Deno 中不适用，因此在这种情况下将抛出错误。

```ts
// deno run --location https://example.com/path main.ts

location.pathname = "./foo";
// error: Uncaught NotSupportedError: Cannot set "location.pathname".
```

### 扩展用法

在 Web 上，资源解析（不包括模块）通常使用 `location.href` 的值作为基础来处理任何相对 URL。这会影响一些被 Deno 采用的 Web API。

#### Fetch API

```ts
// deno run --location https://api.github.com/ --allow-net main.ts

const response = await fetch("./orgs/denoland");
// Fetches "https://api.github.com/orgs/denoland".
```

如果没有传递 `--location` 标志，上面的 `fetch()` 调用将抛出错误，因为没有可以基于的 Web 类似位置。

#### Worker 模块

```ts
// deno run --location https://example.com/index.html --allow-net main.ts

const worker = new Worker("./workers/hello.ts", { type: "module" });
// Fetches worker module at "https://example.com/workers/hello.ts".
```

:::note

对于上述用例，最好完整传递 URL 而不是依赖 `--location`。如有需要，你可以使用 `URL` 构造函数手动构建相对 URL。

:::

`--location` 标志适用于那些想要模拟文档位置并意识到这仅在应用层级有效的人。不过，你也可以使用它来消除依赖项中不必要访问 `location` 全局造成的错误。

## Web Storage

[Web Storage API](/api/web/storage) 提供了一个用于存储字符串键和值的 API。数据持久化的方式与浏览器相似，并且有 10MB 的存储限制。全局 `sessionStorage` 对象只对当前执行上下文持久化数据，而 `localStorage` 则从一次执行到下一次执行持久化数据。

在浏览器中，`localStorage` 每个 origin 唯一持久化数据（有效的协议加主机名加端口）。从 Deno 1.16 开始，Deno 有一套规则来确定什么是唯一的存储位置：

- 当使用 `--location` 标志时，位置的 origin 用于唯一存储数据。这意味着 `http://example.com/a.ts` 和 `http://example.com/b.ts` 以及 `http://example.com:80/` 将共享相同的存储，但 `https://example.com/` 将是不同的。
- 如果没有位置说明符，但指定了 `--config` 配置文件，则使用该配置文件的绝对路径。这意味着 `deno run --config deno.jsonc a.ts` 和 `deno run --config deno.jsonc b.ts` 将共享相同的存储，但 `deno run --config tsconfig.json a.ts` 将是不同的。
- 如果没有配置或位置说明符，Deno 使用主模块的绝对路径来确定共享的存储。Deno REPL 会生成一个基于 `deno` 启动的当前工作目录的“合成”主模块。这意味着从同一路径多次调用 REPL 将共享持久化的 `localStorage` 数据。

要设置、获取和移除 `localStorage` 中的项，可以使用以下方法：

```ts
// 在 localStorage 中设置一个项
localStorage.setItem("myDemo", "Deno App");

// 从 localStorage 中读取一个项
const cat = localStorage.getItem("myDemo");

// 从 localStorage 中移除一个项
localStorage.removeItem("myDemo");

// 从 localStorage 中移除所有项
localStorage.clear();
```

## Web Workers

Deno 支持 [`Web Worker API`](/api/web/workers)。

Worker 可用于在多个线程上运行代码。每个 `Worker` 实例在单独的线程上运行，仅用于该 worker。

当前 Deno 仅支持 `module` 类型的 workers；因此在创建新 worker 时务必传递 `type: "module"` 选项。

在主 worker 中使用相对模块说明符仅在 CLI 传递 `--location <href>` 时受支持。这不推荐用于可移植性。你可以使用 `URL` 构造函数和 `import.meta.url` 来轻松创建某个附近脚本的说明符。然而，专用 worker 默认具有位置及此能力。

```ts
// 好
new Worker(import.meta.resolve("./worker.js"), { type: "module" });

// 坏
new Worker(import.meta.resolve("./worker.js"));
new Worker(import.meta.resolve("./worker.js"), { type: "classic" });
new Worker("./worker.js", { type: "module" });
```

与常规模块一样，你可以在 worker 模块中使用顶层 `await`。然而，你应该小心始终在第一个 `await` 之前注册消息处理程序，因为否则消息可能会丢失。这不是 Deno 的错误，而是一种特性的遗憾交互，并且在所有支持模块 worker 的浏览器中也会发生。

```ts
import { delay } from "jsr:@std/async@1/delay";

// 第一个 await：等待一秒，然后继续运行模块。
await delay(1000);

// 消息处理程序仅在那 1 秒延迟后设置，因此在那一秒内到达 worker 的一些消息可能在没有注册处理程序时被触发。
self.onmessage = (evt) => {
  console.log(evt.data);
};
```

### 实例权限

创建新的 `Worker` 实例类似于动态导入；因此 Deno 对此操作要求适当的权限。

对于使用本地模块的 worker；需要 `--allow-read` 权限：

```ts title="main.ts"
new Worker(import.meta.resolve("./worker.ts"), { type: "module" });
```

```ts title="worker.ts"
console.log("hello world");
self.close();
```

```shell
$ deno run main.ts
error: Uncaught PermissionDenied: read access to "./worker.ts", run again with the --allow-read flag

$ deno run --allow-read main.ts
hello world
```

对于使用远程模块的 worker；需要 `--allow-net` 权限：

```ts title="main.ts"
new Worker("https://example.com/worker.ts", { type: "module" });
```

```ts title="worker.ts"
// 此文件托管在 https://example.com/worker.ts
console.log("hello world");
self.close();
```

```shell
$ deno run main.ts
error: Uncaught PermissionDenied: net access to "https://example.com/worker.ts", run again with the --allow-net flag

$ deno run --allow-net main.ts
hello world
```

### 在 worker 中使用 Deno

```js title="main.js"
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
});

worker.postMessage({ filename: "./log.txt" });
```

```js title="worker.js"
self.onmessage = async (e) => {
  const { filename } = e.data;
  const text = await Deno.readTextFile(filename);
  console.log(text);
  self.close();
};
```

```text title="log.txt"
hello world
```

```shell
$ deno run --allow-read main.js
hello world
```

### 指定 worker 权限

:::caution

这是一个不稳定的 Deno 特性。了解更多关于
[不稳定特性](/runtime/fundamentals/stability_and_releases/#unstable-apis)。

:::

worker 的权限与 CLI 权限标志类似，这意味着在那里启用的每个权限都可以在 Worker API 级别禁用。你可以在这里找到每个权限选项的更详细描述 [here](/runtime/fundamentals/security/)。

默认情况下，worker 将继承其创建所在线程的权限，但是为了允许用户限制此 worker 的访问，我们在 worker API 中提供了 `deno.permissions` 选项。

对于支持细粒度访问的权限，你可以传入 worker 将访问的所需资源的列表，而对于仅具有开/关选项的权限，你可以分别传递 true/false：

```ts
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
  deno: {
    permissions: {
      net: [
        "deno.land",
      ],
      read: [
        new URL("./file_1.txt", import.meta.url),
        new URL("./file_2.txt", import.meta.url),
      ],
      write: false,
    },
  },
});
```

细粒度访问权限同时支持绝对路径和相对路径作为参数，但请注意相对路径将相对于实例化 worker 的文件进行解析，而不是 worker 文件当前所在的路径：

```ts
const worker = new Worker(
  new URL("./worker/worker.js", import.meta.url).href,
  {
    type: "module",
    deno: {
      permissions: {
        read: [
          "/home/user/Documents/deno/worker/file_1.txt",
          "./worker/file_2.txt",
        ],
      },
    },
  },
);
```

`deno.permissions` 及其子项都支持选项 `"inherit"`，这意味着它将借用其父权限：

```ts
// 此 worker 将继承其父权限
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
  deno: {
    permissions: "inherit",
  },
});
```

```ts
// 此 worker 将仅继承其父的网络权限
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
  deno: {
    permissions: {
      env: false,
      hrtime: false,
      net: "inherit",
      ffi: false,
      read: false,
      run: false,
      write: false,
    },
  },
});
```

不指定 `deno.permissions` 选项或其子项将导致 worker 默认继承：

```ts
// 此 worker 将继承其父权限
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
});
```

```ts
// 此 worker 将继承其父的所有权限，但不包括网络
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
  deno: {
    permissions: {
      net: false,
    },
  },
});
```

通过将 `"none"` 传递给 `deno.permissions` 选项，可以完全禁用 worker 的权限：

```ts
// 此 worker 将不启用任何权限
const worker = new Worker(import.meta.resolve("./worker.js"), {
  type: "module",
  deno: {
    permissions: "none",
  },
});
```

## 其他 API 从规范的偏差

### 缓存 API

仅实现以下 API：

- [CacheStorage::open()](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open)
- [CacheStorage::has()](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/has)
- [CacheStorage::delete()](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/delete)
- [Cache::match()](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
- [Cache::put()](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put)
- [Cache::delete()](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete)

与浏览器相比，几个地方有所不同：

1. 你不能将相对路径传递给 API。请求可以是 Request、URL 的实例或 URL 字符串。
2. `match()` 和 `delete()` 尚不支持查询选项。

---

# subhosting/api/authentication.md

URL: https://docs.deno.com/subhosting/api/authentication


开发者可以使用 Subhosting REST API 配置项目、域、KV 数据库和其他资源。

## 端点和认证

Subhosting REST API v1 的基本 URL 如下。

```console
https://api.deno.com/v1/
```

v1 API 使用
[HTTP 令牌认证](https://swagger.io/docs/specification/authentication/bearer-authentication/)。
您可以在仪表盘 [这里](https://dash.deno.com/account#access-tokens) 创建一个访问令牌以使用 API。大多数 API 请求还需要您的组织 ID。您可以从 Deno Deploy 仪表盘中获取您的组织 ID。

![在这里找到您的组织 ID](./images/org-id.png)

使用您的组织 ID 和访问令牌，您可以通过列出与您的组织相关联的所有项目来测试您的 API 访问。以下是一个可以用于访问 API 的 Deno 脚本示例。

```typescript
// 将这些替换为您自己的！
const organizationId = "a75a9caa-b8ac-47b3-a423-3f2077c58731";
const token = "ddo_u7mo08lBNHm8GMGLhtrEVfcgBsCuSp36dumX";

const res = await fetch(
  `https://api.deno.com/v1/organizations/${organizationId}/projects`,
  {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
    },
  },
);

const response = await res.json();
console.log(response);
```

---

# subhosting/api/index.md

URL: https://docs.deno.com/subhosting/api/


要构建 Deno Deploy 的子托管，了解系统内的一些关键资源是很有帮助的。这些资源在
[REST API](../api/index.md) 中也有体现。

![子托管资源概述](./images/subhosting-org-structure.svg)

## 组织

[**组织**](https://apidocs.deno.com/#get-/organizations/-organizationId-) 是与子托管实现相关的所有数据的容器。你的组织将有一个名称和一个 ID。每个组织都有一个分析端点，可以用来获取整个组织的指标（例如请求次数和使用的带宽）。

其他 Deploy 用户可以被邀请与组织协作，并且
[访问令牌](https://dash.deno.com/account#access-tokens) 可以让具有组织访问权限的开发人员通过 API 修改组织中的资源。可以在
[Deploy 控制面板](https://dash.deno.com/orgs/new) 中创建新组织。

## 项目

[**项目**](https://apidocs.deno.com/#get-/organizations/-organizationId-/projects) 是部署的组织容器。一个项目包含它的部署及其分析和使用信息。

项目是免费的，可以根据需要设置。

为了跟踪单个用户的用量以进行计费，有一个 API 端点可以报告每个项目的分析（带宽使用、请求次数等），并具有 15 分钟的颗粒度。

> 所有部署（无论是在同一个项目内还是不同项目之间）默认情况下不共享任何内容。项目是一种组织你的部署的方式，并且不收取任何费用。然而，分析是按项目进行报告的，如果你有多个租户，我们建议为每个租户设置一个项目。特别是如果你预计会根据他们的使用情况向你的用户收费。

## 部署

[**部署**](https://apidocs.deno.com/#get-/projects/-projectId-/deployments)：部署是一组配置、可运行代码和可在 Deno Deploy 中的隔离环境中运行的静态文件。部署有一个可以启动服务器的入口文件，可以与一个 [Deno KV](/deploy/kv/manual) 数据库相关联，并可以设置为运行在自定义域名上。

部署是一个不可变对象，包含：

- 要运行的源代码
- 静态资产
- 环境变量
- 数据库绑定
- 其他设置

我们提供查询或流式传输构建日志以及查询或流式传输执行日志的端点。

如果需要阻止或解锁一个部署，可以通过删除需要阻止的部署或解除分配其域名来完成。这将使部署不可达。

子托管系统构建得如此，使得一个部署的行为或负载不会影响其他部署。这同样适用于一个组织内的不同部署。容量按需自动扩展。如果你想限制特定部署或应用程序的资源，可以使用分析 API 为你提供详细的指标（请求次数、带宽等），以项目级粒度呈现。你可以利用这些信息决定是否关闭部署并使其不可达。

> 注意：**部署是不可变的**，但是，你可以创建一个新部署，然后将其域名重新映射到新部署。重新部署端点可以从现有部署创建一个新的部署，并使用不同的设置。

## 自定义域名

[**自定义域名**](https://apidocs.deno.com/#get-/organizations/-organizationId-/domains) 可以动态映射到部署，为其提供一个唯一的 URL（例如 `mycompany.com`）。

在使用域名之前，你需要
[验证所有权并提供或上传 TLS 证书](https://github.com/denoland/deploy-api/blob/main/samples.ipynb)。

如果你处于 [Builder 层级](https://deno.com/deploy/pricing?subhosting)，你可以使用通配符域名。一旦注册了通配符域名，你可以以两种方式使用它：

- 将所有 `*.mycompany.com` 的请求发送到特定的部署
- （即将推出）将不同的子域（例如 `foo.mycompany.com` 和 `bar.mycompany.com`）分配给不同的部署。

### 预发布环境与生产环境

当开发人员打开 Github 拉取请求时，Deno Deploy 终端用户平台会自动创建预览部署，而对“main”分支的提交则会自动转换为生产部署。虽然子托管并不提供开箱即用的 Github 集成，但它拥有定义创建预览和生产部署的所有必要原语。

## 连接 KV 数据库

(KV) 数据库存储键值对。当你创建部署时，可以使数据库对该部署可访问。KV 数据库可以被多个部署同时使用。

要在子托管中使用 KV：

- [使用 API 创建数据库](https://docs.deno.com/deploy/kv/manual)
- 使用子托管 API 创建部署时，指定你创建的数据库。

> 注意：Deno Cron 和队列目前不适用于子托管。

## OpenAPI 规范和工具

Deploy API 的 [OpenAPI 规范](https://www.openapis.org/) 可以在此找到：

```console
https://api.deno.com/v1/openapi.json
```

该规范文档可与
[大量 OpenAPI 兼容工具](https://openapi.tools/) 一起使用。除了这里维护的 REST API 文档外，您还可以在 [这里](https://apidocs.deno.com/) 找到自动生成的 API 文档（包括基于浏览器的测试工具）。

---

# subhosting/index.md

URL: https://docs.deno.com/subhosting/



---

# subhosting/manual/acceptable_use_policy.md

URL: https://docs.deno.com/subhosting/manual/acceptable_use_policy


Deno 子托管服务包括受此可接受使用政策约束的资源（CPU 时间，请求计数）。本文件可以大致估计我们认为的“可接受使用”，以及我们不认可的内容。

### 可接受使用示例

- ✅ 服务器端渲染的网站
- ✅ Jamstack 网站和应用
- ✅ 单页应用
- ✅ 查询数据库或外部 API 的 API
- ✅ 个人博客
- ✅ 公司网站
- ✅ 电子商务网站

### 不可接受使用

- ❌ 加密货币挖矿
- ❌ 高 CPU 强度负载（例如：机器学习）
- ❌ 外部网站的媒体托管
- ❌ 爬虫
- ❌ 代理或 VPN

## 指导方针

我们期望大多数项目的使用量都在合理范围内。若您的项目使用情况显著偏离正常范围，我们会通知您。在采取任何措施以解决我们基础设施上不合理负担的情况下，我们会尽可能提前与您联系。

---

# subhosting/manual/events.md

URL: https://docs.deno.com/subhosting/manual/events


在部署执行的生命周期中，多个事件被记录到其执行日志中。通过使用
[部署日志 API](https://apidocs.deno.com/#get-/deployments/-deploymentId-/app_logs)，这些事件日志可以用来理解和监控您的部署行为。

## 启动

```json
"isolate start time: 96.67 ms (user time: 6.13 ms)"
```

`boot` 事件在部署成功启动并运行后被触发。它记录了自接收促使部署启动的初始请求以来，经过的时间，直到部署准备好开始处理该请求。除了整体启动时间之外，该事件还记录了在执行部署的 JavaScript 代码时花费的时间（称为“用户时间”）。

## 内存限制

```json
"Memory limit exceeded, terminated"
```

当部署因超过
[每次部署执行允许的内存限制](https://deno.com/deploy/pricing?subhosting)而被终止时，`memory-limit` 事件被触发。在某些情况下，它后面会跟随一个事件 URN，以便与由于此事件生成的任何可观察性文档进行交叉引用：

```json
"Memory limit exceeded, terminated (urn:dd-hard-memory-limit:deno:pcx8pcbpc34b:048730b1-0e1f-4df7-8f92-e64233415322)"
```

在部署被终止时，所有正在处理的请求都会收到一个 502 响应，代码为 `"MEMORY_LIMIT"`。

## CPU 时间限制

```json
"CPU time limit exceeded, see https://deno.com/deploy/docs/pricing-and-limit (urn:dd-time-limit:deno:pcx8pcbpc34b:b8c729c0-e17a-4ce1-a6df-4267cbeb6d5c)"
```

当部署因超过
[每个请求允许的 CPU 时间限制](https://deno.com/deploy/pricing?subhosting)而被终止时，`time-limit` 事件被触发。日志中包含的事件 URN 可用于与由于此事件生成的任何可观察性文档进行交叉引用。

在部署被终止时，所有正在处理的请求都会收到一个 502 响应，代码为 `"TIME_LIMIT"`。

---

# subhosting/manual/index.md

URL: https://docs.deno.com/subhosting/manual/


Deno 子托管是一个强大的平台，旨在允许软件即服务（SaaS）提供商安全地运行客户编写的代码。子托管 API 允许您以编程方式和规模化地部署不受信任的代码。

## 主要特点

- **易用性：** 开发者可以用通用的 JavaScript 或 TypeScript 编写代码，无需具备特定的 Deno 知识。
- **标准合规性：** Deno 支持标准的 JavaScript 和 TypeScript，并广泛集成了常用的 Web API，如 `fetch` 和 `web cache`。
- **Deno 特定高级功能：** 提供了超出典型浏览器能力的高级功能，如 `KV`（键值存储）。
- **快速部署：** Deno 的云产品旨在支持极短的部署时间，从简单应用的不到一秒，到具有众多依赖关系的复杂网站约十秒。
- **改善开发者体验：** 子托管将为您管理设置安全基础设施以在公共云中运行不受信任代码的广泛工作。

## Deno 云服务概述 - Deno Deploy 和 Deno 子托管

Deno 提供了两个不同的云服务，Deno Deploy 和 Deno 子托管，旨在利用相同的基础设施支持特定用例。

### Deno Deploy

Deno Deploy 针对个人开发者和专注于开发和迭代有限一组第一方项目的小团队进行了优化。此解决方案非常适合托管网站或应用程序，部署过程通常通过 GitHub 集成进行管理。

- 目标受众：个人开发者和小型开发团队。
- 部署集成：主要通过 GitHub 进行持续集成和交付。
- 使用案例：托管网站和应用程序。

### Deno 子托管

相比之下，Deno 子托管旨在安全管理大规模的项目和部署。它通过 API 支持不受信任的代码或函数的部署，使其适用于涉及多个最终用户贡献代码的场景。

- 目标受众：需要安全托管客户生成的、不受信任代码的 SaaS 平台。
- 部署机制：通过设计用于可扩展性和安全性的强大 API。
- 使用案例：大规模项目托管，最终用户贡献代码。

实施子托管的步骤大致如下：

1. [创建组织](./quick_start.md)并获取 REST API 的访问令牌
1. [创建项目](./planning_your_implementation.md)，然后为该项目创建您的首次部署

使用这些技术，您可以将用户代码打包为“部署”，并在 Deno 提供的 URL 或您可以自行配置的
[自定义 URL](../api/#custom-domains)上执行该代码。

## REST API 参考和 OpenAPI 规范

有关实现子托管所使用的 REST API 的完整参考，您可以
[在这里查看文档](https://apidocs.deno.com)。Deno Deploy REST API 还提供了一个
[OpenAPI 规范](https://api.deno.com/v1/openapi.json)，可以与
[多个 OpenAPI 兼容工具](https://openapi.tools/)一起使用。

我们还提供了 [JavaScript](https://www.npmjs.com/package/subhosting)、[Python](https://pypi.org/project/subhosting/0.0.1a0/) 和 [Go](https://github.com/denoland/subhosting-go) 的 SDK。

---

# subhosting/manual/planning_your_implementation.md

URL: https://docs.deno.com/subhosting/manual/planning_your_implementation


假设你正在构建一个类似于 Salesforce 的 SaaS CRM 平台。你希望让你的客户能够编写 JavaScript 代码，以便在每次捕获新客户时执行。

如果你打算使用 Deno Deploy 实现这个功能，以下是你可能会考虑的构建方式：

- 创建一个 **项目**，并将该项目与数据库中的客户账户关联。这将允许你跟踪每个客户产生的使用情况，并可能基于该使用情况通过项目的分析信息向他们收费。
- 创建一个 **部署**，其中包含最终用户提供的代码，该代码应该在创建新客户时运行。
- 使用同一项目中的多个部署，你可以实现事件处理逻辑的“预发布”或“生产”版本。
- 你的 CRM 软件将通过向部署发送 HTTP 请求并等待响应与最终用户的代码进行通信。
- 将来，如果你想支持为 CRM 中的其他事件编写代码（例如创建新联系人或每晚发送自动报告），你可以为这些事件创建一个项目，并对每个事件使用上述描述的流程。

让我们看一个实现此操作所需的 API 端点的示例。

## 为项目创建部署

在[上一章](./quick_start.md)中，你创建了一个新项目并记录了它的 `id` 属性。在上一章的示例中，ID 是：

```console
f084712a-b23b-4aba-accc-3c2de0bfa26a
```

你可以使用项目标识符来[为该项目创建部署](https://apidocs.deno.com/#get-/projects/-projectId-/deployments)。创建一个名为 `create_deployment.ts` 的新文件，并包含以下代码以为你的项目创建一个新的“Hello World”部署。

```ts title="create_deployment.ts"
const accessToken = Deno.env.get("DEPLOY_ACCESS_TOKEN");
const API = "https://api.deno.com/v1";

// 用你所需的项目 ID 替换
const projectId = "your-project-id-here";

// 创建一个新的部署
const res = await fetch(`${API}/projects/${projectId}/deployments`, {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    entryPointUrl: "main.ts",
    assets: {
      "main.ts": {
        "kind": "file",
        "content":
          `export default { async fetch(req) { return new Response("Hello, World!"); } }`,
        "encoding": "utf-8",
      },
    },
    envVars: {},
  }),
});

const deployment = await res.json();

console.log(res.status);
console.log(
  "访问你的站点：",
  `https://${project.name}-${deployment.id}.deno.dev`,
);
```

如果你使用以下命令运行此脚本：

```bash
deno run -A --env create_deployment.ts
```

你应该很快会在公共 URL 上拥有一个简单的“Hello World！”服务器，可以从你的 Deno Deploy 仪表板上查看。

## 部署的组成部分

上面的示例展示了一个非常简单的部署。一个更复杂的部署可能包含以下某些或全部组件，详细描述见[这里的 API 文档](https://apidocs.deno.com/#get-/projects/-projectId-/deployments)。

- **资产：** TypeScript 或 JavaScript 源文件、图像、JSON 文档 - 使你的部署运行的代码和静态文件。这些文件可以使用 `utf-8`（用于纯源文件）或 `base64` 编码上传到服务器的 JSON 中。除了实际文件外，你还可以包含指向其他文件的符号链接。
- **入口点 URL：** 从上面的集合中执行的资产（TypeScript 或 JavaScript 文件）的文件路径，应该在你的部署中启动服务器时执行。
- **环境变量：** 你可以指定应存在于系统环境中的值，以便通过 `Deno.env.get` 获取。
- **数据库 ID：** 应该可以在此部署中使用的 Deno KV 数据库的标识符。
- **编译器选项：** 应用于解析 TypeScript 代码的一组选项。

## 自定义域名

部署创建后，将分配一个生成的 URL。这在某些场景下可能是可以的，但通常你会想要将自定义域名与部署关联起来。
[查看域的 API 参考](https://apidocs.deno.com/#get-/organizations/-organizationId-/domains)。

---

# subhosting/manual/pricing_and_limits.md

URL: https://docs.deno.com/subhosting/manual/pricing_and_limits


您可以在 Deno 网站上查看
[可用定价计划和功能的概述](https://deno.com/deploy/pricing?subhosting)。如果您有超出这些限制的使用案例， [请联系](mailto:deploy@deno.com)。

## 部署大小

每次部署的所有源代码和资产加起来应少于 1GB。

## 部署频率

一个 subhosting 用户每小时的最大部署次数为 60 次（免费套餐）或 300 次（构建者套餐）。对于企业计划的组织，提供更高的限制。

## 每次请求的 CPU 时间

- 根据套餐，限制为 50ms 或 200ms。
- 每次请求的 CPU 时间限制是基于多个请求的平均值来设定的，并不是严格按每个请求 enforced。
- 不包括部署等待 I/O 的时间（例如，在进行 fetch() 请求时等待远程服务器的时间）

## 阻塞事件循环

程序不应阻塞事件循环超过 1 秒。

## 可用内存

最大可用内存为 512MB。

---

# 在 git 中忽略此文件

URL: https://docs.deno.com/subhosting/manual/quick_start


想要寻找一个尽可能小的示例，展示如何将代码部署到 Deno 的隔离云吗？我们在下面为您提供了相关信息，或者您可以跳到[更详细的入门指南](#getting-started-with-subhosting)。

```ts
// 1.) 准备 API 访问信息
const accessToken = Deno.env.get("DEPLOY_ACCESS_TOKEN");
const orgId = Deno.env.get("DEPLOY_ORG_ID");
const API = "https://api.deno.com/v1";
const headers = {
  Authorization: `Bearer ${accessToken}`,
  "Content-Type": "application/json",
};

// 2.) 创建一个新项目
const pr = await fetch(`${API}/organizations/${orgId}/projects`, {
  method: "POST",
  headers,
  body: JSON.stringify({
    name: null, // 随机生成项目名称
  }),
});

const project = await pr.json();

// 3.) 将 "hello world" 服务器部署到新项目
const dr = await fetch(`${API}/projects/${project.id}/deployments`, {
  method: "POST",
  headers,
  body: JSON.stringify({
    entryPointUrl: "main.ts",
    assets: {
      "main.ts": {
        "kind": "file",
        "content":
          `export default { async fetch(req) { return new Response("Hello, World!"); } }`,
        "encoding": "utf-8",
      },
    },
    envVars: {},
  }),
});

const deployment = await dr.json();

console.log(dr.status);
console.log(
  "访问您的网站：",
  `https://${project.name}-${deployment.id}.deno.dev`,
);
```

## 子托管入门

要开始使用子托管，您需要在[Deno Deploy 控制台](https://dash.deno.com/orgs/new)中创建一个组织。请按照屏幕上的说明为子托管创建一个新组织。

在完成入职流程时，您可能还会生成一个**访问令牌**，您将用它来访问[REST API](../api/index.md)。如果您没有这样做（或您的令牌已过期），您可以[在这里生成一个新令牌](https://dash.deno.com/account#access-tokens)。

:::caution 将您的令牌保存在安全的地方

一旦您生成了访问令牌，**它将不会再在 Deploy 控制台 UI 中显示**。请确保将此令牌存储在安全的地方。

:::

## 设置测试环境

在接下来的教程页面中，我们将假设您通过 Deno 脚本（TypeScript 代码）与 Deploy REST API 进行交互，并将以这种方式展示与 API 交互的示例。然而，这里展示的技术在任何能够执行 HTTP 请求的环境中同样适用。

这里以及后续章节中的示例代码假设您已经安装了[Deno 1.38 或更高版本](/runtime/getting_started/installation)。

在与 REST API 配合使用时，最好将身份验证凭据存储在[系统环境](/runtime/reference/env_variables)中，以防止您意外地将其提交到源代码管理中。

在本教程中，我们将使用在 Deno 1.38 中引入的新 `--env` 标志来管理环境变量。请在本地计算机上创建一个新目录以存储我们的管理脚本，并创建三个文件：

- `.env` - 存放我们的 API 访问信息
- `.gitignore` - 忽略我们的 `.env` 文件，以免我们意外地将其放入源代码管理中
- `create_project.ts` - 我们稍后将用于第一次请求 REST API 的文件

### 配置 `.env` 文件和 `.gitignore` 文件

首先，将您的[访问令牌](https://dash.deno.com/account#access-tokens)和组织 ID 存储在您之前创建的 `.env` 文件中。

```bash title=".env"
DEPLOY_ACCESS_TOKEN=your_token_here
DEPLOY_ORG_ID=your_org_id_here
```

用您自己 Deploy 账户中的值替换文件中的值。

接下来，创建一个 `.gitignore` 文件，以确保我们不会意外地将 `.env` 文件提交到源代码管理中：

```bash title=".gitignore"
# 在 git 中忽略此文件
.env

# 可选：忽略在 mac OS 上常常生成的这个垃圾文件
.DS_Store
```

现在我们已经设置好凭据，接下来我们来写一些代码以访问 REST API。

## 创建我们的第一个项目

为了在子托管或 REST API 上进行任何有趣的操作，我们需要[创建一个项目](https://apidocs.deno.com/#get-/projects/-projectId-/deployments)。将以下代码复制到与 `.env` 和 `.gitignore` 文件在同一目录中的 `create_project.ts` 文件中。

```ts title="create_project.ts"
const accessToken = Deno.env.get("DEPLOY_ACCESS_TOKEN");
const orgId = Deno.env.get("DEPLOY_ORG_ID");
const API = "https://api.deno.com/v1";

// 创建一个新项目
const res = await fetch(`${API}/organizations/${orgId}/projects`, {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: null, // 随机生成项目名称
  }),
});

const project = await res.json();
console.log(project);
```

在终端中使用以下命令执行此代码：

```bash
deno run -A --env create_project.ts
```

如果一切顺利，您应该会看到类似于以下内容的输出：

```console
{
  id: "f084712a-b23b-4aba-accc-3c2de0bfa26a",
  name: "strong-fox-44",
  createdAt: "2023-11-07T01:01:14.078730Z",
  updatedAt: "2023-11-07T01:01:14.078730Z"
}
```

请注意返回的项目 `id` - 这是我们在下一步将使用的项目 ID。

现在我们已经配置好 REST API 访问并设置好了项目，我们可以继续[创建我们的第一个部署](./planning_your_implementation)。

---

