---
title: "@std/cbor"
description: "解析和序列化简明二进制对象表示法（CBOR）的实用工具"
jsr: jsr:@std/cbor
pkg: cbor
version: 0.1.8
generated: true
stability: unstable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

:::info 不稳定

此 @std 包处于实验阶段，其 API 可能会在没有主版本号变更的情况下更改。

:::

## 概览

<h2 id="overview">
概览</h2>
<p>简明二进制对象表示法（CBOR）是一种优化了紧凑性和效率的二进制数据序列化格式。它设计用以编码各种数据类型，包括整数、字符串、数组和映射，且空间效率高。
<a href="https://datatracker.ietf.org/doc/html/rfc8949" rel="nofollow">RFC 8949 - 简明二进制对象表示法 (CBOR)</a>
规范。</p>
<h2 id="limitations">
限制</h2>
<ul>
<li>此实现仅支持对“文本字符串”键的编码和解码。</li>
<li>此实现采用 64 位编码十进制数，不会尝试判定十进制数是否可用 32 位或 16 位编码。</li>
<li>解码时，值小于 2 ** 32 的整数将为 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="nofollow">number</a> 类型，所有更大的整数将为 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="nofollow">bigint</a> 类型。</li>
</ul>
<p>函数和类可能还会列出更具体的限制。</p>

```js
import { assert, assertEquals } from "@std/assert";
import { decodeCbor, encodeCbor } from "@std/cbor";

const rawMessage = "I am a raw Message!";

const encodedMessage = encodeCbor(rawMessage);
const decodedMessage = decodeCbor(encodedMessage);

assert(typeof decodedMessage === "string");
assertEquals(decodedMessage, rawMessage);
```

### 添加到你的项目

```sh
deno add jsr:@std/cbor
```

<a href="https://jsr.io/@std/cbor/doc" class="docs-cta jsr-cta">查看 @std/cbor 中的全部符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 CBOR？

CBOR（简明二进制对象表示法）类似于 JSON 的二进制版本。它将数据存储为紧凑的二进制格式，而非文本，从而减少体积并加速解析。

它支持所有常见类型（数字、字符串、布尔值、null、数组、映射），还支持二进制数据和大整数。CBOR 通常用于网络传输数据（非常适合带宽有限的物联网或移动设备）、存储紧凑负载和语言之间的互操作性。

## 为什么使用 @std/cbor？

此包提供简单的函数，将 JavaScript 对象编码为 CBOR 二进制格式，并将 CBOR 二进制解码回 JavaScript 对象。

## 示例

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const obj = { t: "temp", v: 21.5, ts: Date.now() };
const bin = encodeCbor(obj);
const back = decodeCbor(bin);
```

### 二进制数据 (Uint8Array)

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const bytes = new TextEncoder().encode("hello");
const encoded = encodeCbor(bytes);
const decoded = decodeCbor(encoded);

if (!(decoded instanceof Uint8Array)) throw new Error("expected bytes");
console.log(new TextDecoder().decode(decoded)); // "hello"
```

### 大整数行为

大于 2**32 的整数解码为 bigint：

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const bigNumber = 5_000_000_000; // > 2**32
const bigBytes = encodeCbor(bigNumber);
const bigValue = decodeCbor(bigBytes);

console.log(typeof bigValue); // "bigint"
console.log(bigValue === 5_000_000_000n); // true

const smallValue = decodeCbor(encodeCbor(42));
console.log(typeof smallValue); // "number"
```

### 序列（多个值）

```ts
import { decodeCborSequence, encodeCborSequence } from "@std/cbor";

const packet = encodeCborSequence([{ id: 1 }, { id: 2 }, "done" as const]);
const values = decodeCborSequence(packet);
// values: [{ id: 1 }, { id: 2 }, "done"]
```

### 标记值（日期）

使用 CBOR 标签 1 表示基于纪元的时间（自 Unix 纪元以来的秒数）。如何在解码时解释标签由你的应用决定。

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";
import { CborTag } from "@std/cbor/tag";

const nowSeconds = Math.floor(Date.now() / 1000);
const tagged = new CborTag(1, nowSeconds);
const buf = encodeCbor(tagged);

const out = decodeCbor(buf) as CborTag;
console.log(out.tagNumber); // 1
console.log(out.tagContent); // 纪元秒数
```

### 解码守护模式

处理不受信任的字节时，解码后检查数据结构。

```ts
import { decodeCbor } from "@std/cbor";

function isRecord(x: unknown): x is Record<string, unknown> {
  return typeof x === "object" && x !== null && !Array.isArray(x);
}

const bytesFromNetwork = new Uint8Array(/* ... */);
const value = decodeCbor(bytesFromNetwork);

if (!isRecord(value) || typeof value.type !== "string") {
  throw new Error("Unexpected payload");
}

// 使用安全
console.log(value.type);
```

<!-- custom:end -->