---
title: "@std/streams"
description: "用于处理 Web Streams API 的工具"
jsr: jsr:@std/streams
pkg: streams
version: 1.0.14
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>用于处理
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" rel="nofollow">Streams API</a>的工具。</p>
<p>包括缓冲和转换功能。</p>

```js
import { toText } from "@std/streams";
import { assertEquals } from "@std/assert";

const stream = ReadableStream.from(["Hello, world!"]);
const text = await toText(stream);

assertEquals(text, "Hello, world!");
```

### 添加到你的项目

```sh
deno add jsr:@std/streams
```

<a href="https://jsr.io/@std/streams/doc" class="docs-cta jsr-cta">查看 @std/streams 中的全部符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 Web Streams？

Web Streams 提供了一种在 JavaScript 中处理流式数据的标准方式。它们允许你在数据陆续到达时逐块处理，而不必等待整个数据集全部可用。这对于处理大文件、网络请求或任何随着时间产生数据的场景特别有用。

## 为什么使用 @std/streams？

用于高效地缓冲、转换和组合 Web Streams。

### 示例

```ts
import { copy, readerFromStreamReader, writeAll } from "@std/streams";

// 通过流将一个文件复制到另一个文件
const r = await Deno.open("input.txt");
const w = await Deno.open("output.txt", {
  create: true,
  write: true,
  truncate: true,
});
await copy(r, w);
r.close();
w.close();

// 将 ReadableStreamDefaultReader 转换为 Deno.Reader
const res = await fetch("https://deno.land");
const denoReader = readerFromStreamReader(res.body!.getReader());
await writeAll(
  Deno.stdout,
  new Uint8Array(await new Response(denoReader).arrayBuffer()),
);
```

## 小贴士

- 对于大数据负载，优先使用流式处理，以减少内存压力。
- 使用诸如 `toText`、`toArrayBuffer` 和 `iterateReader` 等辅助函数进行转换。

<!-- custom:end -->