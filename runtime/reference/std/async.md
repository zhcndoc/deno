---
title: "@std/async"
description: "用于异步操作的工具，如延迟、防抖或池化"
jsr: jsr:@std/async
pkg: async
version: 1.1.0
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>提供一些异步任务的辅助函数，比如 <a href="https://jsr.io/@std/async@1.1.0/doc/~/delay" rel="nofollow"><code>延迟（delay）</code></a>，
<a href="https://jsr.io/@std/async@1.1.0/doc/~/debounce" rel="nofollow"><code>防抖（debounce）</code></a>，<a href="https://jsr.io/@std/async@1.1.0/doc/~/retry" rel="nofollow"><code>重试（retry）</code></a>，或者
<a href="https://jsr.io/@std/async@1.1.0/doc/~/pooledMap" rel="nofollow"><code>池化（pooledMap）</code></a>。</p>

```js
import { delay } from "@std/async/delay";

await delay(100); // 等待 100 毫秒
```

### 添加到你的项目

```sh
deno add jsr:@std/async
```

<a href="https://jsr.io/@std/async/doc" class="docs-cta jsr-cta">查看 @std/async 中所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 async？

异步编程允许你的程序现在开始执行任务，稍后完成，而不会阻塞主线程。在 JavaScript 中，这通常表示 Promise、`async`/`await`、定时器和异步迭代器。异步代码通过交叉处理 I/O（网络、磁盘、定时器）并控制并发，提高响应性和吞吐量。

## 为什么使用 @std/async？

这个包为你提供小巧且专注的工具，解决常见的异步问题，避免你重新实现它们：

- 用于调度和超时的 `delay` 和 `deadline`（支持通过 `AbortSignal` 取消）。
- 控制调用频率的 `debounce`（和不稳定的 `throttle`），适用于 UI/命令行事件。
- 带退避和抖动的 `retry`，用于不稳定的操作比如 HTTP 请求。
- 用于转换任务流时限制并发的 `pooledMap`。
- 用于分支或合并异步迭代器的 `tee`/`MuxAsyncIterator`。

这些辅助工具体积小、行为可预测，且支持 Deno、Node.js、Bun、Workers 和浏览器。

## 示例

防抖快速触发的事件（例如自动补全）：

```ts
import { debounce } from "@std/async/debounce";

const search = debounce(async (q: string) => {
  // 用户停止输入后获取结果
}, 200);

// 多次调用；只有最后一次调用在 200 毫秒后执行
search("d");
search("de");
search("deno");
```

带指数退避和抖动的重试：

```ts
import { retry } from "@std/async/retry";

const data = await retry(() =>
  fetch("/api").then((r) => {
    if (!r.ok) throw new Error("bad status");
    return r.json();
  }), {
  maxAttempts: 5,
  minTimeout: 100,
  multiplier: 2,
  jitter: 0.2,
});
```

用 pooledMap 限制并发：

```ts
import { pooledMap } from "@std/async/pool";

const urls = ["/a", "/b", "/c", "/d"]; // 实际中可能更多
for await (const res of pooledMap(3, urls, (u) => fetch(u))) {
  // 最多同时进行 3 个请求；结果按完成顺序返回
}
```

截止时间和取消：

```ts
import { deadline } from "@std/async/deadline";

await deadline(fetch("/slow"), 1_000); // 1 秒后抛出 DOMException("TimeoutError")
```

<!-- custom:end -->