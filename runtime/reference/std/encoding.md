---
title: "@std/encoding"
description: "用于编码和解码常见格式（如 hex、base64 和 varint）的工具"
jsr: jsr:@std/encoding
pkg: encoding
version: 1.0.10
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概述

<p>用于编码和解码常见格式（如 hex、base64 和 varint）的工具。</p>
<h2 id="basic-usage">
基本用法</h2>

```js
import { decodeBase64, encodeBase64 } from "@std/encoding";
import { assertEquals } from "@std/assert";

const foobar = new TextEncoder().encode("foobar");
assertEquals(encodeBase64(foobar), "Zm9vYmFy");
assertEquals(decodeBase64("Zm9vYmFy"), foobar);
```

<h2 id="various-encoding-formats">
多种编码格式</h2>

```js
import {
  decodeAscii85,
  decodeBase32,
  decodeBase58,
  decodeBase64,
  decodeHex,
  encodeAscii85,
  encodeBase32,
  encodeBase58,
  encodeBase64,
  encodeHex,
} from "@std/encoding";
import { assertEquals } from "@std/assert";

// 针对不同字符集的多种编码
assertEquals(encodeHex("Hello world!"), "48656c6c6f20776f726c6421");
assertEquals(encodeBase32("Hello world!"), "JBSWY3DPEB3W64TMMQQQ====");
assertEquals(encodeBase58("Hello world!"), "2NEpo7TZRhna7vSvL");
assertEquals(encodeBase64("Hello world!"), "SGVsbG8gd29ybGQh");
assertEquals(encodeAscii85("Hello world!"), "87cURD]j7BEbo80");

// 解码
assertEquals(
  new TextDecoder().decode(decodeHex("48656c6c6f20776f726c6421")),
  "Hello world!",
);
assertEquals(
  new TextDecoder().decode(decodeBase32("JBSWY3DPEB3W64TMMQQQ====")),
  "Hello world!",
);
assertEquals(
  new TextDecoder().decode(decodeBase58("2NEpo7TZRhna7vSvL")),
  "Hello world!",
);
assertEquals(
  new TextDecoder().decode(decodeBase64("SGVsbG8gd29ybGQh")),
  "Hello world!",
);
assertEquals(
  new TextDecoder().decode(decodeAscii85("87cURD]j7BEbo80")),
  "Hello world!",
);
```

<h2 id="url-safe-base64">
URL 安全的 Base64</h2>

```js
import { encodeBase64, encodeBase64Url } from "@std/encoding";
import { assertEquals } from "@std/assert";

assertEquals(encodeBase64("ice creams"), "aWNlIGNyZWFtcw=="); // 不安全，因为有 `=`
assertEquals(encodeBase64Url("ice creams"), "aWNlIGNyZWFtcw"); // URL 安全！

// Base64Url 用 - 替代 +，用 _ 替代 /
assertEquals(encodeBase64("subjects?"), "c3ViamVjdHM/"); // 斜杠 / 不安全
assertEquals(encodeBase64Url("subjects?"), "c3ViamVjdHM_"); // _ 是安全的
```

<h2 id="binary-data-encoding">
二进制数据编码</h2>

```js
import { encodeBase64, encodeHex } from "@std/encoding";
import { assertEquals } from "@std/assert";

// 处理二进制数据
const binaryData = new Uint8Array([0xDE, 0xAD, 0xBE, 0xEF]);
assertEquals(encodeHex(binaryData), "deadbeef");
assertEquals(encodeBase64(binaryData), "3q2+7w==");
```

<h2 id="varint-encoding">
Varint 编码</h2>
<p>更多内容请参考 <a href="https://protobuf.dev/programming-guides/encoding/#varints" rel="nofollow">protobuf Varint 编码文档</a>。</p>

```js
import { decodeVarint, encodeVarint } from "@std/encoding";
import { assertEquals } from "@std/assert";

// Varint 编码支持
assertEquals(encodeVarint(9601n), [new Uint8Array([129, 75]), 2]);

// 解码 varint
const bytes = new Uint8Array([129, 75]);
assertEquals(decodeVarint(bytes), [9601n, 2]);
```

### 添加到你的项目

```sh
deno add jsr:@std/encoding
```

<a href="https://jsr.io/@std/encoding/doc" class="docs-cta jsr-cta">查看 @std/encoding 中的所有
符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是编码？

编码是将数据从一种格式转换到另一种格式的过程，通常用于使数据适合传输或存储。常见的编码格式包括 Base64、Hex 和 Varint。

## 为什么使用 @std/encoding？

该包提供简单、可靠的函数，用于以多种格式编码和解码数据。你将使用编码来：

- 互操作性：以人类可读/可传输的形式（URL、JSON、命令行、日志）交换二进制数据。
- 安全性：解码助手在输入格式错误时（例如 hex）抛出错误，而不是默默截断。
- 可移植性：跨运行时提供统一的 API。
- 控制性：选择 URL 安全的 Base64 避免 URL 中出现 +、/、=。

## 示例

```ts
import {
  decodeBase64Url,
  decodeHex,
  encodeBase64Url,
  encodeHex,
} from "@std/encoding";

// 字符串 ↔ 字节
const bytes = new TextEncoder().encode("hello");
const text = new TextDecoder().decode(bytes);

// URL 安全的 token
const token = encodeBase64Url(bytes); // aGVsbG8
const roundtrip = new TextDecoder().decode(decodeBase64Url(token));

// Hex 工具
const hex = encodeHex(bytes); // 68656c6c6f
const fromHex = decodeHex(hex);
```

```ts
// 其他支持的编码
import {
  decodeAscii85,
  decodeBase32,
  decodeBase58,
  decodeBase64,
  encodeAscii85,
  encodeBase32,
  encodeBase58,
  encodeBase64,
} from "@std/encoding";

encodeBase64("Hello world!"); // "SGVsbG8gd29ybGQh"
encodeBase32("Hello world!"); // "JBSWY3DPEB3W64TMMQQQ===="
encodeBase58("Hello world!"); // "2NEpo7TZRhna7vSvL"
encodeAscii85("Hello world!"); // "87cURD]j7BEbo80"

new TextDecoder().decode(decodeBase64("SGVsbG8gd29ybGQh")); // "Hello world!"
```

```ts
// Varint（紧凑型整数编码）
import { decodeVarint, encodeVarint } from "@std/encoding";

const [buf, end] = encodeVarint(9601n);
const [num, next] = decodeVarint(buf);
```

## 小贴士

- 所有编码器/解码器均使用 `Uint8Array`。使用 `TextEncoder`/`TextDecoder` 进行字符串 ↔ 字节转换。
- token 和查询参数建议使用 Base64URL；标准 Base64 可能包含需要转义的字符。
- Hex 工具默认返回小写字母。
- Varint 紧凑编码整数；不适用于任意二进制负载。

<!-- custom:end -->