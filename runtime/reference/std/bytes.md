---
title: "@std/bytes"
description: "操作 Uint8Arrays 的实用工具，这些工具不是 JavaScript 内置的"
jsr: jsr:@std/bytes
pkg: bytes
version: 1.0.6
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>用于操作
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="nofollow"><code>Uint8Array</code></a>
字节切片的辅助函数。</p>

```js
import { concat, endsWith, indexOfNeedle } from "@std/bytes";
import { assertEquals } from "@std/assert";

const a = new Uint8Array([0, 1, 2]);
const b = new Uint8Array([3, 4, 5]);

const c = concat([a, b]);

assertEquals(c, new Uint8Array([0, 1, 2, 3, 4, 5]));

assertEquals(indexOfNeedle(c, new Uint8Array([2, 3])), 2);

assertEquals(endsWith(c, b), true);
```

### 添加到你的项目

```sh
deno add jsr:@std/bytes
```

<a href="https://jsr.io/@std/bytes/doc" class="docs-cta jsr-cta">查看 @std/bytes 中的所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

### 什么是 Uint8Array？

`Uint8Array` 是一个基于 `ArrayBuffer` 的类型化数组视图，表示原始字节。每个元素是一个无符号的 8 位整数（0–255）。类型化数组长度固定，效率高，非常适合处理文件、网络、加密、图像、WASM 内存等二进制数据。

## 何时使用 @std/bytes

如果你正在操作原始二进制数据（`Uint8Array`），例如搜索、切片、比较或拼接。此包提供了 JavaScript 中没有的有用辅助函数。

## 示例

```ts
import { concat, equals, indexOfNeedle } from "@std/bytes";

const a = new Uint8Array([1, 2]);
const b = new Uint8Array([3, 4]);
const all = concat([a, b]); // Uint8Array [1,2,3,4]

console.log(equals(all, new Uint8Array([1, 2, 3, 4])));
console.log(indexOfNeedle(all, new Uint8Array([2, 3]))); // 1
```

## 小贴士

- 为了清晰和正确，优先使用这些辅助函数，而不是手写循环。
- 使用 `TextEncoder`/`TextDecoder` 进行文本 ↔ 字节转换。

<!-- custom:end -->
