---
title: "@std/media-types"
description: "媒体类型（MIME 类型）的实用函数"
jsr: jsr:@std/media-types
pkg: media-types
version: 1.1.0
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>媒体类型（MIME 类型）的实用函数。</p>
<p>该 API 灵感来源于 GoLang 的 <a href="https://pkg.go.dev/mime" rel="nofollow"><code>mime</code></a> 包和 <a href="https://github.com/jshttp/mime-types" rel="nofollow">jshttp/mime-types</a>，并设计用于整合和改进 <a href="https://deno.land/x/media_types" rel="nofollow">x/media_types</a> 的 API。</p>
<p><code>vendor</code> 文件夹包含 <a href="https://github.com/jshttp/mime-types" rel="nofollow">jshttp/mime-db</a> 的 <code>db.json</code> 文件副本及其许可证。</p>

```js
import { allExtensions, contentType, getCharset } from "@std/media-types";
import { assertEquals } from "@std/assert";

assertEquals(allExtensions("application/json"), ["json", "map"]);

assertEquals(contentType(".json"), "application/json; charset=UTF-8");

assertEquals(getCharset("text/plain"), "UTF-8");
```

### 添加到您的项目

```sh
deno add jsr:@std/media-types
```

<a href="https://jsr.io/@std/media-types/doc" class="docs-cta jsr-cta">在 @std/media-types 中查看所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是媒体类型？

媒体类型，也称为 MIME 类型，是用于标识文件或数据格式与性质的标准化标识符。它们通常用于 HTTP 头中，用以指定发送或接收内容的类型。

## 为什么使用 @std/media-types？

在处理文件上传、下载或提供网页内容时，您可能需要基于文件扩展名确定正确的 MIME 类型，或反之亦然。此包提供实用函数，方便地在扩展名和 MIME 类型之间相互映射，并获取字符集提示。

## 示例

### 快速查找

```ts
import { allExtensions, extension, typeByExtension } from "@std/media-types";

console.log(typeByExtension(".png")); // "image/png"
console.log(extension("text/html")); // "html"
console.log(allExtensions("application/json")); // ["json", "map"]
```

### 构建响应头

```ts
import { contentType } from "@std/media-types";

// 在合适时生成带有字符集的完整头部值
const ct = contentType(".css"); // "text/css; charset=UTF-8"

return new Response("body", {
  headers: {
    "Content-Type": ct ?? "application/octet-stream",
  },
});
```

### 解析并规范化 Content-Type 头部

```ts
import { formatMediaType, parseMediaType } from "@std/media-types";

const header = "text/HTML; charset=UTF-8";
const [type, params] = parseMediaType(header)!; // ["text/html", { charset: "UTF-8" }]

// 重新序列化，得到规范化的类型和参数（小写键）
const normalized = formatMediaType(type, params);
// "text/html; charset=UTF-8"
```

### 从请求中提取 multipart/form-data 边界

```ts
import { parseMediaType } from "@std/media-types";

function getBoundary(headers: Headers): string | undefined {
  const value = headers.get("content-type");
  if (!value) return undefined;
  const parsed = parseMediaType(value);
  return parsed?.[1]?.boundary;
}
```

### 从接收到的请求检测字符集

```ts
import { getCharset } from "@std/media-types";

async function readText(req: Request): Promise<string> {
  const charset = getCharset(req.headers.get("content-type") ?? "") ?? "UTF-8";
  const bytes = new Uint8Array(await req.arrayBuffer());
  const decoder = new TextDecoder(charset);
  return decoder.decode(bytes);
}
```

## 小贴士

- 构建 HTTP 响应时，优选使用 `contentType(extOrType)`。
- 使用 `allExtensions(type)` 来支持多种可能的扩展名。
- `parseMediaType` 在无效输入时会抛出异常；解析用户输入时请使用 try/catch 包裹。
- 当 `contentType()` 对未知扩展名或类型返回 `undefined`，请回退使用 `application/octet-stream`。

<!-- custom:end -->