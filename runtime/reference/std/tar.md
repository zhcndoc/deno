---
title: "@std/tar"
description: "用于处理 tar 归档文件的流式工具。"
jsr: jsr:@std/tar
pkg: tar
version: 0.1.9
generated: true
stability: unstable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

:::info 不稳定

此 @std 包为实验性质，其 API 可能会在不进行主版本升级的情况下发生改变。

:::

## 概述

<p>用于处理 tar 归档文件的流式工具。</p>
<p>文件不会被压缩，仅被收集到归档中。</p>

```js
import { UntarStream } from "@std/tar/untar-stream";
import { dirname, normalize } from "@std/path";

for await (
  const entry of (await Deno.open("./out.tar.gz"))
    .readable
    .pipeThrough(new DecompressionStream("gzip"))
    .pipeThrough(new UntarStream())
) {
  const path = normalize(entry.path);
  await Deno.mkdir(dirname(path), { recursive: true });
  await entry.readable?.pipeTo((await Deno.create(path)).writable);
}
```

### 添加到你的项目

```sh
deno add jsr:@std/tar
```

<a href="https://jsr.io/@std/tar/doc" class="docs-cta jsr-cta">查看 @std/tar 中所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 tar？

Tar（磁带归档）是一种广泛使用的文件格式，用于将多个文件收集到单个归档文件中，通常方便分发或备份。它保留文件的元数据，如权限和时间戳，使其适用于系统备份和软件发布。

## 为什么使用 @std/tar？

使用此包可以以流式方式创建或提取 tar 归档，这对于大型数据集效率更高，且避免了大量内存使用。

- 本模块以流为先：使用 Web Streams 来读取/写入条目，无需缓冲整个归档。
- 安全性：在写入磁盘前会清理条目路径，防止路径遍历（".." 段）。
- Tar 是归档格式，不是压缩格式。可叠加使用 `CompressionStream`/`DecompressionStream` 来处理 gzip。
- 提取时如果头部包含权限或修改时间，则会保留，确保文件信息的准确性。

## 示例

```ts
import { UntarStream } from "@std/tar/untar-stream";
import { dirname, isAbsolute, normalize } from "@std/path";

const outDir = "/safe/root";

for await (const entry of file.readable.pipeThrough(new UntarStream())) {
  const normalized = normalize(entry.path);
  // 防止写出到 outDir 之外
  if (normalized.includes("..") || isAbsolute(normalized)) continue;
  const dest = `${outDir}/${normalized}`;
  await Deno.mkdir(dirname(dest), { recursive: true });
  if (entry.readable) {
    await entry.readable.pipeTo((await Deno.create(dest)).writable);
  }
}
```

<!-- custom:end -->