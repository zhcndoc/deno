---
title: "@std/msgpack"
description: "msgpack 格式的编码和解码"
jsr: jsr:@std/msgpack
pkg: msgpack
version: 1.0.3
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>此模块提供用于编码和解码 MessagePack 的函数。</p>
<p>MessagePack 是一种高效的二进制序列化格式，语言无关。它类似于 JSON，但通常生成的有效载荷更小。<a href="https://msgpack.org/" rel="nofollow">了解更多关于 MessagePack 的信息</a>。</p>

```js
import { decode, encode } from "@std/msgpack";
import { assertEquals } from "@std/assert";

const obj = {
  str: "deno",
  arr: [1, 2, 3],
  bool: true,
  nil: null,
  map: {
    foo: "bar",
  },
};

const encoded = encode(obj);
assertEquals(encoded.length, 42);

const decoded = decode(encoded);
assertEquals(decoded, obj);
```

<p>MessagePack 支持对以下类型进行编码和解码：</p>
<ul>
<li><code>number</code> 数值类型</li>
<li><code>bigint</code> 大整数</li>
<li><code>string</code> 字符串</li>
<li><code>boolean</code> 布尔值</li>
<li><code>null</code> 空值</li>
<li><code>Uint8Array</code> 无符号 8 位整型数组</li>
<li>这些类型值的数组</li>
<li>键为字符串或数字，值为这些类型的对象</li>
</ul>

### 添加到你的项目

```sh
deno add jsr:@std/msgpack
```

<a href="https://jsr.io/@std/msgpack/doc" class="docs-cta jsr-cta">查看 @std/msgpack 中的全部符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 MessagePack？

MessagePack 是一种紧凑、高速且无模式的二进制序列化格式。它设计上注重尺寸和速度的高效，适用于高性能应用以及不同编程语言之间的数据交换。

## 为什么使用 @std/msgpack？

- MessagePack 非常适合在受信任服务之间传输紧凑、高速、无模式的数据。当你需要比 JSON 更高效的替代方案时，它非常有用。
- 二进制安全：`Uint8Array` 可以在不增加 base64 开销的情况下完成往返转换。

## 示例

```ts
import { decode, encode } from "@std/msgpack";

const payload = { id: 1, items: ["a", "b"], data: new Uint8Array([1, 2, 3]) };
const bin = encode(payload);
const back = decode(bin);
```

自定义扩展类型

```ts
import { Decoder, Encoder, ExtData } from "@std/msgpack";

// 为 Date 使用 tag 1
const enc = new Encoder({
  extensionCodec: {
    tryToEncode(object) {
      if (object instanceof Date) {
        return new ExtData(
          1,
          new Uint8Array(new BigInt64Array([BigInt(object.getTime())]).buffer),
        );
      }
    },
  },
});

const dec = new Decoder({
  extensionCodec: {
    decode(data) {
      if (data.type === 1) {
        return new Date(Number(new BigInt64Array(data.data.buffer)[0]));
      }
    },
  },
});
```

## 提示

- 注意 bigint 和 number 的区别：非常大的整数会被解码为 `bigint` 类型。
- 为了与其他语言互操作，建议使用常见类型（number、string、boolean、null、数组、映射、字节数组）。

<!-- custom:end -->
