---
title: "@std/datetime"
description: "处理 Date 对象的工具"
jsr: jsr:@std/datetime
pkg: datetime
version: 0.225.5
generated: true
stability: unstable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

:::info 不稳定

此 @std 包是实验性的，其 API 可能在不增加主版本号的情况下发生变化。

:::

## 概述

<p>处理 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="nofollow"><code>Date</code></a> 对象的实用工具。</p>

```js
import {
  dayOfYear,
  difference,
  HOUR,
  isLeap,
  MINUTE,
  SECOND,
} from "@std/datetime";
import { assertEquals } from "@std/assert";

assertEquals(dayOfYear(new Date("2019-03-11T03:24:00")), 70);
assertEquals(isLeap(1970), false);

const date0 = new Date("2018-05-14");
const date1 = new Date("2020-05-13");
assertEquals(difference(date0, date1).years, 1);

assertEquals(HOUR / MINUTE, 60);
assertEquals(MINUTE / SECOND, 60);
```

### 添加到项目中

```sh
deno add jsr:@std/datetime
```

<a href="https://jsr.io/@std/datetime/doc" class="docs-cta jsr-cta">查看 @std/datetime 中的所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 datetime？

在 JavaScript 中，日期和时间围绕内置的 `Date` 对象：

- `Date` 存储自 Unix 纪元时间点（1970‑01‑01T00:00:00Z）起的毫秒数。其内部值始终为 UTC。
- 渲染和许多 getter 方法可采用本地时间（例如 `getHours`）或 UTC 时间（例如 `getUTCHours`）。请明确指定所需的时间类型。
- 对非 ISO 字符串使用 `Date` 构造函数进行解析时，结果依赖于本地环境和实现细节，建议使用 ISO-8601 格式（`YYYY‑MM‑DDTHH:mm:ssZ`）或其他库/解析器。

`@std/datetime` 包基于此提供简单的解析、格式化和日期运算，并支持显式的模式和选项。

它旨在涵盖常见需求，无需引入大型依赖，并兼容 Deno、Node.js、Bun、浏览器和 Workers。

## 何时使用 @std/datetime

如果你需要格式化和解析日期/时间，以及进行小规模计算，同时不想引入大型库，典型用例包括：

- 为日志、文件名或界面显示生成可读的时间戳。
- 使用显式格式安全地解析用户输入，替代 Date 的猜测式解析。
- 显示相对持续时间（例如“剩余 X 天”）。
- 获取日历字段，比如年中的周数或天数。
- 生成符合标准的字符串（例如 ISO-8601）以供接口使用。

## 示例

```ts
import {
  dayOfYear,
  dayOfYearUtc,
  difference,
  format,
  isLeap,
  isUtcLeap,
  parse,
  weekOfYear,
} from "@std/datetime";

// 带时区的格式化
const nowTokyo = format(
  new Date("2025-01-02T12:34:56Z"),
  "yyyy-MM-dd HH:mm XXX",
  { timeZone: "Asia/Tokyo" },
);

// 按明确模式解析（本地时间，除非模式或偏移另有指定）
const parsed = parse("2025-01-02 09:30", "yyyy-MM-dd HH:mm");
parsed instanceof Date; // true

// 在特定单位上的差异
const a = new Date("2024-01-01T00:00:00Z");
const b = new Date("2025-06-01T00:00:00Z");
difference(a, b, { units: ["years", "months", "days"] });
// -> { years: 1, months: 5, days: 0 }

// 年周和年内天数
weekOfYear(new Date("2025-01-05")); // ISO 年周号 (1-53)
dayOfYear(new Date("2025-03-01")); // 本地时区
dayOfYearUtc(new Date(Date.UTC(2025, 2, 1))); // UTC

// 闰年检查
isLeap(2024); // 根据本地规则为 true
isUtcLeap(2024); // 时区无关，为 true
```

```ts
// UTC vs 指定时区格式化
import { format } from "@std/datetime";

const d = new Date("2025-01-02T00:00:00Z");
format(d, "yyyy-MM-dd HH:mm XXX", { timeZone: "UTC" }); // 2025-01-02 00:00 +00:00
format(d, "yyyy-MM-dd HH:mm XXX", { timeZone: "Asia/Tokyo" }); // 2025-01-02 09:00 +09:00
```

```ts
// 解析带数字偏移的 ISO 字符串
import { parse } from "@std/datetime";

const withOffset = parse(
  "2025-01-02T09:30:00+09:00",
  "yyyy-MM-dd'T'HH:mm:ssXXX",
);
withOffset.toISOString(); // 2025-01-02T00:30:00.000Z
```

```ts
// 使用提供的常量添加时间长度
import { HOUR, MINUTE, SECOND } from "@std/datetime";

const start = new Date("2025-01-01T00:00:00Z");
const plus90m = new Date(start.getTime() + 90 * MINUTE);
const plus1h5s = new Date(start.getTime() + HOUR + 5 * SECOND);
```

```ts
// 到期限的剩余天数（倒计时）
import { difference } from "@std/datetime";

const now = new Date("2025-01-01T00:00:00Z");
const launch = new Date("2025-02-15T00:00:00Z");
difference(now, launch, { units: ["days"] }); // { days: 45 }
```

```ts
// 年界限附近的 ISO 年周
import { weekOfYear } from "@std/datetime";

weekOfYear(new Date("2020-12-31")); // 53
weekOfYear(new Date("2021-01-01")); // 53 （仍是 2020 年最后一周）
weekOfYear(new Date("2021-01-04")); // 1
```

```ts
// 使用 Date 输入的闰年检测
import { isLeap } from "@std/datetime";

isLeap(new Date("2000-01-01")); // true（能被400整除）
isLeap(new Date("1900-01-01")); // false（世纪年不能被400整除）
```

## 提示

- 在格式化时明确时区（例如包含 `XXX` 偏移符号）。
- 交换和存储时优先使用 ISO 8601 格式。

<!-- custom:end -->