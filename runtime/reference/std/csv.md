---
title: "@std/csv"
description: "读写逗号分隔值（CSV）文件"
jsr: jsr:@std/csv
pkg: csv
version: 1.0.6
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## 概览

<p>读写逗号分隔值（CSV）文件。</p>
<h2 id="parsing-csv">
解析 CSV</h2>

```js
import { parse } from "@std/csv/parse";
import { assertEquals } from "@std/assert";

const string = "a,b,c\nd,e,f";

// 解析为二维数组（默认）
assertEquals(parse(string, { skipFirstRow: false }), [["a", "b", "c"], [
  "d",
  "e",
  "f",
]]);

// 将含有表头的 csv 文件解析为对象数组
assertEquals(parse(string, { skipFirstRow: true }), [{
  a: "d",
  b: "e",
  c: "f",
}]);

// 使用自定义列名解析
assertEquals(parse(string, { columns: ["x", "y", "z"] }), [
  { x: "a", y: "b", z: "c" },
  { x: "d", y: "e", z: "f" },
]);

// 解析制表符分隔的值
const tsvString = "name\tage\tcity\njohn\t30\tnew york\nmary\t25\tlos angeles";
assertEquals(parse(tsvString, { separator: "\t", skipFirstRow: true }), [
  { name: "john", age: "30", city: "new york" },
  { name: "mary", age: "25", city: "los angeles" },
]);

// 解析带有注释的 CSV 文件
const csvWithComments =
  "# 这是注释\nname,age,city\n# 另一条注释\njohn,30,new york\nmary,25,los angeles";
assertEquals(parse(csvWithComments, { comment: "#", skipFirstRow: true }), [
  { name: "john", age: "30", city: "new york" },
  { name: "mary", age: "25", city: "los angeles" },
]);
```

<h2 id="parsing-csv-from-a-stream">
从流中解析 CSV</h2>

```js
import { CsvParseStream } from "@std/csv/parse-stream";
import { assertEquals } from "@std/assert";

// 从流中解析（适用于大文件）
const source = ReadableStream.from([
  "name,age,city\n",
  "john,30,new york\n",
  "mary,25,los angeles\n",
]);

const csvStream = source
  .pipeThrough(new CsvParseStream({ skipFirstRow: true }));

const records = await Array.fromAsync(csvStream);
assertEquals(records, [
  { name: "john", age: "30", city: "new york" },
  { name: "mary", age: "25", city: "los angeles" },
]);

// 或者逐条处理记录
// for await (const record of csvStream) {
//   console.log(record);
// }
```

<h2 id="stringifying-data-to-csv">
将数据转换为 CSV 字符串</h2>

```js
import { stringify } from "@std/csv/stringify";
import { assertEquals } from "@std/assert";

// 将二维数组转换为 CSV
const arrayData = [["name", "age", "city"], ["john", "30", "new york"], [
  "mary",
  "25",
  "los angeles",
]];
const csvString = stringify(arrayData);
assertEquals(
  csvString,
  "name,age,city\r\njohn,30,new york\r\nmary,25,los angeles\r\n",
);

// 将对象数组转换为 CSV
const objectData = [
  { name: "john", age: "30", city: "new york" },
  { name: "mary", age: "25", city: "los angeles" },
];

// 使用对象数组时，必须指定要使用的列
const customColumns = stringify(objectData, {
  columns: ["city", "name", "age"],
});
assertEquals(
  customColumns,
  "city,name,age\r\nnew york,john,30\r\nlos angeles,mary,25\r\n",
);
```

<h2 id="streaming-stringify-data-to-csv">
流式将数据转换为 CSV</h2>

```js
import { CsvStringifyStream } from "@std/csv/stringify-stream";
import { assertEquals } from "@std/assert";

async function writeCsvToTempFile(): Promise<string> {
  const path = await Deno.makeTempFile();
  using file = await Deno.open(path, { write: true });

  const readable = ReadableStream.from([
    { id: 1, name: "one" },
    { id: 2, name: "two" },
    { id: 3, name: "three" },
  ]);

  await readable
    .pipeThrough(new CsvStringifyStream({ columns: ["id", "name"] }))
    .pipeThrough(new TextEncoderStream())
    .pipeTo(file.writable);

  return path;
}

const path = await writeCsvToTempFile();
const content = await Deno.readTextFile(path);
assertEquals(content, "id,name\r\n1,one\r\n2,two\r\n3,three\r\n");
```

<h2 id="csv-format-information">
CSV 格式信息</h2>
<p>CSV 文件有多种格式；本模块支持 <a href="https://www.rfc-editor.org/rfc/rfc4180.html" rel="nofollow">RFC 4180</a> 中描述的格式。</p>
<p>一个 CSV 文件包含零个或多个记录，每条记录包含一个或多个字段。每条记录由换行符分隔。最后一条记录后可以有也可以没有换行符。</p>

```js
field1, field2, field3;
```

<p>空白符被视为字段的一部分。</p>
<p>回车符紧跟在换行符前面时会被自动移除。</p>
<p>空行会被忽略。仅包含空白字符（不包括结尾换行符）的一行不被视为空行。</p>
<p>以引号字符 " 开头和结尾的字段称为带引号字段。开始和结束的引号不属于字段内容。</p>
<p>示例：</p>

```js
normal string,"quoted-field"
```

<p>解析为字段：</p>

```js
[`normal string`, `quoted-field`];
```

<p>在带引号字段内，两个连续的引号字符被视为一个引号字符。</p>

```js
"the ""word"" is true","a ""quoted-field"""
```

<p>解析为：</p>

```js
[`the "word" is true`, `a "quoted-field"`];
```

<p>带引号字段中可以包含换行符和逗号</p>

```js
"Multi-line
field","comma is ,"
```

<p>解析为</p>

```js
[
  `Multi-line
field`,
  `comma is ,`,
];
```

### 添加到你的项目

```sh
deno add jsr:@std/csv
```

<a href="https://jsr.io/@std/csv/doc" class="docs-cta jsr-cta">查看 @std/csv 中的所有符号
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## 什么是 CSV？

CSV（逗号分隔值）是一种简单的文本格式，用于存储表格数据，其中每一行代表一行数据，每个值通过逗号分隔。它被广泛用于不同应用之间的数据交换，尤其是在电子表格和数据库之间。

## 何时使用 @std/csv

此包非常适合在应用中读写 CSV 文件。它支持将 CSV 解析为数组或对象，将数据转换回 CSV，以及用于处理大型文件的流式处理。

## 提示

- 使用 `skipFirstRow: true` 将第一行作为表头处理。
- 对于对象数组，字符串化时需要指定 `columns`。
- 对于超过数GB的数据集，优先使用流式解析器。

<!-- custom:end -->